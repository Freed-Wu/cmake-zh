# guide
msgid ""
msgstr ""
"Project-Id-Version: CMake 3.26.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-01 00:02+0800\n"
"PO-Revision-Date: 2023-06-01 20:35+0800\n"
"Last-Translator: Wu Zhenyu <wuzhenyu@ustc.edu>\n"
"Language-Team: Wu Zhenyu <wuzhenyu@ustc.edu>\n"
"Language: zh-CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.12.1\n"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:2
msgid "IDE Integration Guide"
msgstr "集成开发环境集成指南"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:5
#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:5
#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:5
#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:5
msgid "Contents"
msgstr "内容"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:9
#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:9
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/index.rst:5
#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:9
#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:9
msgid "Introduction"
msgstr "介绍"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:11
msgid ""
"Integrated development environments (IDEs) may want to integrate with "
"CMake to improve the development experience for CMake users. This document"
" lays out the recommended best practices for such integration."
msgstr "集成开发环境 (IDE) 可能希望与 CMake 集成以改善 CMake 用户的开发体验。本文档列出了此类集成的推荐最佳实践。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:16
msgid "Bundling"
msgstr "捆绑"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:18
msgid ""
"Many IDE vendors will want to bundle a copy of CMake with their IDE. IDEs "
"that bundle CMake should present the user with the option of using an "
"external CMake installation instead of the bundled one, in case the "
"bundled copy becomes outdated and the user wants to use a newer version."
msgstr ""
"许多集成开发环境供应商希望将 CMake 的副本与他们的集成开发环境捆绑在一起。捆绑 CMake 的集成开发环境应该向用户提供使用外部 CMake "
"安装而不是捆绑的选项，以防捆绑的副本过时并且用户想要使用更新的版本。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:23
msgid ""
"While IDE vendors may be tempted to bundle different versions of CMake "
"with their application, such practice is not recommended. CMake has strong"
" guarantees of backwards compatibility, and there is no reason not to use "
"a newer version of CMake than what a project requires, or indeed, the very"
" latest version. Therefore, it is recommended that IDE vendors that bundle"
" CMake with their application always include the very latest patch version"
" of CMake available at the time of release."
msgstr ""
"虽然集成开发环境供应商可能会尝试将不同版本的 CMake 与他们的应用程序捆绑在一起，但不推荐这种做法。 CMake "
"具有很强的向后兼容性保证，没有理由不使用比项目所需的更新版本的 CMake，或者实际上是最新版本。因此，建议将 CMake 与其应用程序捆绑在一起的"
"集成开发环境供应商始终包含在发布时可用的最新补丁版本的 CMake。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:31
msgid ""
"As a suggestion, IDEs may also ship a copy of the Ninja buildsystem "
"alongside CMake. Ninja is highly performant and well-supported on all "
"platforms that support CMake. IDEs that bundle Ninja should use Ninja 1.10"
" or later, which contains features needed to support Fortran builds."
msgstr ""
"作为建议，集成开发环境还可以随 CMake 一起提供 Ninja 构建系统的副本。 Ninja 在支持 CMake "
"的所有平台上都具有高性能和良好的支持。捆绑 Ninja 的集成开发环境应该使用 Ninja 1.10 或更高版本，其中包含支持 Fortran "
"构建所需的功能。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:37
#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:416
msgid "Presets"
msgstr "预设"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:39
msgid ""
"CMake supports a file format called ``CMakePresets.json``, and its user-"
"specific counterpart, ``CMakeUserPresets.json``. This file contains "
"information on the various configure presets that a user may want. Each "
"preset may have a different compiler, build flags, etc. The details of "
"this format are explained in the :manual:`cmake(1)` manual."
msgstr ""
"CMake "
"支持一种名为“CMakePresets.json”的文件格式，以及它的用户特定对应格式“CMakeUserPresets.json”。该文件包含有关用户可能需要的各种配置预设的信息。每个预设可能有不同的编译器、构建标志等。此格式的详细信息在"
" :manual:`cmake(1)` 手册中进行了解释。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:45
msgid ""
"IDE vendors are encouraged to read and evaluate this file the same way "
"CMake does, and present the user with the presets listed in the file. "
"Users should be able to see (and possibly edit) the CMake cache variables,"
" environment variables, and command line options that are defined for a "
"given preset. The IDE should then construct the list of appropriate "
":manual:`cmake(1)` command line arguments based on these settings, rather "
"than using the :option:`--preset= <cmake --preset>` option directly. The "
":option:`--preset= <cmake --preset>` option is intended only as a "
"convenient frontend for command line users, and should not be used by the "
"IDE."
msgstr ""
"鼓励集成开发环境供应商以与 CMake 相同的方式阅读和评估此文件，并向用户提供文件中列出的预设。用户应该能够看到（并可能编辑）为给定预设定义的 "
"CMake 缓存变量、环境变量和命令行选项。然后，集成开发环境应该根据这些设置构建适当的 cmake(1) 命令行参数列表，而不是直接使用 "
":option:`--preset= <cmake --preset>` 选项。 :option:`--preset= <cmake "
"--preset>` 选项仅用作命令行用户的方便前端，不应由集成开发环境使用。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:55
msgid ""
"For example, if a preset named ``ninja`` specifies ``Ninja`` as the "
"generator and ``${sourceDir}/build`` as the build directory, instead of "
"running:"
msgstr "例如，如果名为“ninja”的预设指定“Ninja”作为生成器，“${sourceDir}/build”作为构建目录，而不是运行："

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:62
msgid ""
"the IDE should instead calculate the settings of the ``ninja`` preset, and"
" then run:"
msgstr "集成开发环境应该计算 ``ninja`` 预设的设置，然后运行："

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:69
msgid ""
"In cases where a preset contains lots of cache variables, and passing all "
"of them as :option:`-D <cmake -D>` flags would cause the command line "
"length limit of the platform to be exceeded, the IDE should instead "
"construct a temporary cache script and pass it with the :option:`-C <cmake"
" -C>` flag."
msgstr ""
"如果预设包含大量缓存变量，并且将它们全部作为 :option:`-D <cmake -D>` 标志传递会导致超过平台的命令行长度限制，集成开发环境"
"应该构造一个临时缓存脚本并使用 :option:`-C <cmake -C>` 标志传递它。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:74
msgid ""
"While reading, parsing, and evaluating the contents of "
"``CMakePresets.json`` is straightforward, it is not trivial. In addition "
"to the documentation, IDE vendors may also wish to refer to the CMake "
"source code and test cases for a better understanding of how to implement "
"the format. :download:`This file <../../manual/presets/schema.json>` "
"provides a machine-readable JSON schema for the ``CMakePresets.json`` "
"format that IDE vendors may find useful for validation and providing "
"editing assistance."
msgstr ""
"虽然读取、解析和评估 CMakePresets.json 的内容很简单，但并不简单。除了文档之外，集成开发环境供应商还可能希望参考 CMake "
"源代码和测试用例，以便更好地了解如何实现该格式。 :download:`此文件 "
"<../../manual/presets/schema.json>` 为 ``CMakePresets.json`` 格式提供机器可读的 JSON"
" 模式，集成开发环境供应商可能会发现它对验证和提供编辑很有用协助。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:83
msgid "Configuring"
msgstr "配置"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:85
msgid ""
"IDEs that invoke :manual:`cmake(1)` to run the configure step may wish to "
"receive information about the artifacts that the build will produce, as "
"well as the include directories, compile definitions, etc. used to build "
"the artifacts. Such information can be obtained by using the :manual:`File"
" API <cmake-file-api(7)>`. The manual page for the File API contains more "
"information about the API and how to invoke it. :manual:`Server mode "
"<cmake-server(7)>` was removed as of CMake 3.20 and should not be used on "
"CMake 3.14 or later."
msgstr ""
"调用 cmake(1) 来运行配置步骤的集成开发环境"
"可能希望接收有关构建将产生的工件的信息，以及用于构建工件的包含目录、编译定义等。此类信息可以通过使用 :manual:`文件应用编程接口 "
"<cmake-file-api(7)>` 获得。文件 API 的手册页包含有关 API 以及如何调用它的更多信息。 :manual:`服务器模式 "
"<cmake-server(7)>` 已从 CMake 3.20 中删除，不应在 CMake 3.14 或更高版本上使用。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:94
msgid ""
"IDEs should avoid creating more build trees than necessary, and only "
"create multiple build trees if the user wishes to switch to a different "
"compiler, use different compile flags, etc. In particular, IDEs should NOT"
" create multiple single-config build trees which all have the same "
"properties except for a differing :variable:`CMAKE_BUILD_TYPE`, "
"effectively creating a multi-config environment. Instead, the "
":generator:`Ninja Multi-Config` generator, in conjunction with the "
":manual:`File API <cmake-file-api(7)>` to get the list of build "
"configurations, should be used for this purpose."
msgstr ""
"集成开发环境应避免创建不必要的构建树，并且仅在用户希望切换到不同的编译器、使用不同的编译标志等时才创建多个构建树。特别是，集成开发环境"
"不应创建多个单一配置的构建树，这些构建树都具有除了不同的 CMAKE_BUILD_TYPE "
"之外，它们具有相同的属性，有效地创建了一个多配置环境。相反， :generator:`Ninja Multi-Config` 生成器，结合 "
":manual:`文件应用编程接口 <cmake-file-api(7)>` 来获取构建配置列表，应该用于此目的。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:103
msgid ""
"IDEs should not use the \"extra generators\" with Makefile or Ninja "
"generators, which generate IDE project files in addition to the Makefile "
"or Ninja files. Instead the :manual:`File API <cmake-file-api(7)>` should "
"be used to get the list of build artifacts."
msgstr ""
"集成开发环境不应将“额外生成器”与 Makefile 或 Ninja 生成器一起使用，它们会生成集成开发环境项目文件以及 Makefile 或 Ninja"
" 文件。相反，应该使用 :manual:`文件应用编程接口 <cmake-file-api(7)>` 来获取构建工件列表。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:109
msgid "Building"
msgstr "构建"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:111
msgid ""
"If a Makefile or Ninja generator is used to generate the build tree, it is"
" not recommended to invoke ``make`` or ``ninja`` directly. Instead, it is "
"recommended that the IDE invoke :manual:`cmake(1)` with the "
":option:`--build <cmake --build>` argument, which will in turn invoke the "
"appropriate build tool."
msgstr ""
"如果使用 Makefile 或 Ninja 生成器生成构建树，不建议直接调用 ``make`` 或 ``ninja`` 。相反，建议集成开发环境使用 "
":option:`--build <cmake --build>` 参数调用 :manual:`cmake(1)` ，这将依次调用适当的构建工具。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:117
msgid ""
"If an IDE project generator is used, such as :generator:`Xcode` or one of "
"the Visual Studio generators, and the IDE understands the project format "
"used, the IDE should read the project file and build it the same way it "
"would otherwise."
msgstr ""
"如果使用集成开发环境项目生成器，例如 :generator:`Xcode` 或虚拟实验室生成器之一，并且集成开发环境"
"理解所使用的项目格式，则集成开发环境应该读取项目文件并按照与其他方式相同的方式构建它。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:121
msgid ""
"The :manual:`File API <cmake-file-api(7)>` can be used to obtain a list of"
" build configurations from the build tree, and the IDE should present this"
" list to the user to select a build configuration."
msgstr ""
":manual:`文件应用编程接口 <cmake-file-api(7)>` 可用于从构建树中获取构建配置列表，集成开发环境"
"应将此列表呈现给用户以选择构建配置。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:126
msgid "Testing"
msgstr "测试"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:128
msgid ""
":manual:`ctest(1)` supports outputting a JSON format with information "
"about the available tests and test configurations. IDEs which want to run "
"CTest should obtain this information and use it to present the user with a"
" list of tests."
msgstr ""
":manual:`ctest(1)` 支持输出包含可用测试和测试配置信息的 JSON 格式。想要运行 CTest 的集成开发环境"
"应该获取此信息并使用它向用户提供测试列表。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:132
msgid ""
"IDEs should not invoke the ``test`` target of the generated buildsystem. "
"Instead, they should invoke :manual:`ctest(1)` directly."
msgstr "集成开发环境不应调用生成的构建系统的“测试”目标。相反，他们应该直接调用 :manual:`ctest(1)` 。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:136
msgid "IDEs with CMake integration"
msgstr "集成 CMake 的集成开发环境"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:138
msgid "The following IDEs support CMake natively:"
msgstr "以下集成开发环境原生支持 CMake："

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:140
msgid "`CLion`_"
msgstr "`CLion`_"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:141
msgid "`KDevelop`_"
msgstr "`KDevelop`_"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:142
msgid "`QtCreator`_"
msgstr "`QtCreator`_"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:143
msgid "`Vim`_ (via a plugin)"
msgstr "`Vim`_ （通过插件）"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:144
msgid "`Visual Studio`_"
msgstr "`视觉工作室`_"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:145
msgid "`VSCode`_ (via a plugin)"
msgstr "`VSCode`_ （通过插件）"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:154
msgid "Additionally, CMake has builtin support for some IDEs:"
msgstr "此外，CMake 内置了对某些集成开发环境的支持："

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:156
msgid ""
":ref:`IDE Build Tool Generators`: Generate IDE native build systems such "
"as Visual Studio or Xcode."
msgstr ":ref:`集成开发环境构建工具生成器`：生成集成开发环境本机构建系统，例如虚拟实验室或 Xcode。"

#: ../../cmake-prefix/src/cmake/Help/guide/ide-integration/index.rst:158
msgid ""
":ref:`Extra Generators`: Extend :ref:`Command-Line Build Tool Generators` "
"to generate IDE project files that hook into the command-line build "
"system. Superseded by the :manual:`File API <cmake-file-api(7)>`."
msgstr ""
":ref:`Extra Generators`：扩展 :ref:`Command-Line Build Tool Generators` "
"以生成挂接到命令行构建系统的集成开发环境项目文件。被 :manual:`文件应用编程接口 <cmake-file-api(7)>` 取代。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:2
msgid "Importing and Exporting Guide"
msgstr "导入导出指南"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:11
msgid ""
"In this guide, we will present the concept of :prop_tgt:`IMPORTED` targets"
" and demonstrate how to import existing executable or library files from "
"disk into a CMake project. We will then show how CMake supports exporting "
"targets from one CMake-based project and importing them into another. "
"Finally, we will demonstrate how to package a project with a configuration"
" file to allow for easy integration into other CMake projects. This guide "
"and the complete example source code can be found in the "
"``Help/guide/importing-exporting`` directory of the CMake source code "
"tree."
msgstr ""
"在本指南中，我们将介绍 :prop_tgt:`IMPORTED` 目标的概念，并演示如何将现有的可执行文件或库文件从磁盘导入到 CMake "
"项目中。然后，我们将展示 CMake 如何支持从一个基于 CMake "
"的项目中导出目标并将其导入到另一个项目中。最后，我们将演示如何使用配置文件打包项目，以便轻松集成到其他 CMake "
"项目中。本指南和完整的示例源代码可以在 CMake 源代码树的 ``Help/guide/importing-exporting`` 目录中找到。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:22
msgid "Importing Targets"
msgstr "导入目标"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:24
msgid ""
":prop_tgt:`IMPORTED` targets are used to convert files outside of a CMake "
"project into logical targets inside of the project. :prop_tgt:`IMPORTED` "
"targets are created using the ``IMPORTED`` option of the "
":command:`add_executable` and :command:`add_library` commands. No build "
"files are generated for :prop_tgt:`IMPORTED` targets. Once imported, "
":prop_tgt:`IMPORTED` targets may be referenced like any other target "
"within the project and provide a convenient, flexible reference to outside"
" executables and libraries."
msgstr ""
":prop_tgt:`IMPORTED` 目标用于将 CMake 项目外的文件转换为项目内的逻辑目标。 :prop_tgt:`IMPORTED` "
"目标是使用 :command:`add_executable` 和 :command:`add_library` 命令的 ``IMPORTED`` "
"选项创建的。没有为 :prop_tgt:`IMPORTED` 目标生成构建文件。导入后， :prop_tgt:`IMPORTED` "
"目标可以像项目中的任何其他目标一样被引用，并提供对外部可执行文件和库的方便、灵活的引用。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:33
msgid ""
"By default, the :prop_tgt:`IMPORTED` target name has scope in the "
"directory in which it is created and below. We can use the ``GLOBAL`` "
"option to extended visibility so that the target is accessible globally in"
" the build system."
msgstr ""
"默认情况下， :prop_tgt:`IMPORTED` 目标名称在其创建目录及以下目录中具有作用域。我们可以使用 ``GLOBAL`` "
"选项来扩展可见性，以便目标可以在构建系统中全局访问。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:37
msgid ""
"Details about the :prop_tgt:`IMPORTED` target are specified by setting "
"properties whose names begin in ``IMPORTED_`` and ``INTERFACE_``. For "
"example, :prop_tgt:`IMPORTED_LOCATION` contains the full path to the "
"target on disk."
msgstr ""
"有关 :prop_tgt:`IMPORTED` 目标的详细信息是通过设置名称以 ``IMPORTED_`` 和 ``INTERFACE_`` "
"开头的属性来指定的。例如， :prop_tgt:`IMPORTED_LOCATION` 包含磁盘上目标的完整路径。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:43
msgid "Importing Executables"
msgstr "导入可执行文件"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:45
msgid ""
"To start, we will walk through a simple example that creates an "
":prop_tgt:`IMPORTED` executable target and then references it from the "
":command:`add_custom_command` command."
msgstr ""
"首先，我们将通过一个简单的示例来创建一个 :prop_tgt:`IMPORTED` 可执行目标，然后从 "
":command:`add_custom_command` 命令中引用它。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:49
msgid ""
"We'll need to do some setup to get started. We want to create an "
"executable that when run creates a basic ``main.cc`` file in the current "
"directory. The details of this project are not important. Navigate to "
"``Help/guide/importing-exporting/MyExe``, create a build directory, run "
":manual:`cmake <cmake(1)>` and build and install the project."
msgstr ""
"我们需要做一些设置才能开始。我们想要创建一个可执行文件，它在运行时会在当前目录中创建一个基本的 ``main.cc`` "
"文件。这个项目的细节并不重要。导航至 ``Help/guide/importing-exporting/MyExe``，创建构建目录，运行 "
":manual:`cmake <cmake(1)>` 并构建和安装项目。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:67
msgid ""
"Now we can import this executable into another CMake project. The source "
"code for this section is available in ``Help/guide/importing-"
"exporting/Importing``. In the CMakeLists file, use the "
":command:`add_executable` command to create a new target called ``myexe``."
" Use the ``IMPORTED`` option to tell CMake that this target references an "
"executable file located outside of the project. No rules will be generated"
" to build it and the :prop_tgt:`IMPORTED` target property will be set  to "
"``true``."
msgstr ""
"现在我们可以将这个可执行文件导入到另一个 CMake 项目中。本节的源代码可在 ``Help/guide/importing-"
"exporting/Importing`` 中找到。在 CMakeLists 文件中，使用 :command:`add_executable` "
"命令创建一个名为 ``myexe`` 的新目标。使用 ``IMPORTED`` 选项告诉 CMake "
"此目标引用位于项目外部的可执行文件。不会生成任何规则来构建它，并且 :prop_tgt:`IMPORTED` 目标属性将设置为 ``true``。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:80
msgid ""
"Next, set the :prop_tgt:`IMPORTED_LOCATION` property of the target using "
"the :command:`set_property` command. This will tell CMake the location of "
"the target on disk. The location may need to be adjusted to the ``<install"
" location>`` specified in the previous step."
msgstr ""
"接下来，使用 :command:`set_property` 命令设置目标的 :prop_tgt:`IMPORTED_LOCATION` "
"属性。这将告诉 CMake 目标在磁盘上的位置。该位置可能需要调整为上一步中指定的``<安装位置>``。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:90
msgid ""
"We can now reference this :prop_tgt:`IMPORTED` target just like any target"
" built within the project. In this instance, let's imagine that we want to"
" use the generated source file in our project. Use the "
":prop_tgt:`IMPORTED` target in the :command:`add_custom_command` command:"
msgstr ""
"我们现在可以引用这个 :prop_tgt:`IMPORTED` "
"目标，就像在项目中构建的任何目标一样。在这种情况下，假设我们要在我们的项目中使用生成的源文件。在 "
":command:`add_custom_command` 命令中使用 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:100
msgid ""
"As ``COMMAND`` specifies an executable target name, it will automatically "
"be replaced by the location of the executable given by the "
":prop_tgt:`IMPORTED_LOCATION` property above."
msgstr ""
"由于 ``COMMAND`` 指定了一个可执行目标名称，它将自动替换为上面 :prop_tgt:`IMPORTED_LOCATION` "
"属性给出的可执行文件的位置。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:104
msgid "Finally, use the output from :command:`add_custom_command`:"
msgstr "最后，使用 :command:`add_custom_command` 的输出："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:111
msgid "Importing Libraries"
msgstr "导入库"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:113
msgid ""
"In a similar manner, libraries from other projects may be accessed through"
" :prop_tgt:`IMPORTED` targets."
msgstr "以类似的方式，可以通过 :prop_tgt:`IMPORTED` 目标访问来自其他项目的库。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:116
msgid ""
"Note: The full source code for the examples in this section is not "
"provided and is left as an exercise for the reader."
msgstr "注意：本节中示例的完整源代码未提供，留作读者练习。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:119
msgid ""
"In the CMakeLists file, add an :prop_tgt:`IMPORTED` library and specify "
"its location on disk:"
msgstr "在 CMakeLists 文件中，添加一个 :prop_tgt:`IMPORTED` 库并指定其在磁盘上的位置："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:128
msgid "Then use the :prop_tgt:`IMPORTED` library inside of our project:"
msgstr "然后在我们的项目中使用 :prop_tgt:`IMPORTED` 库："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:136
msgid ""
"On Windows, a .dll and its .lib import library may be imported together:"
msgstr "在 Windows 上，可以将 .dll 及其 .lib 导入库一起导入："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:148
msgid ""
"A library with multiple configurations may be imported with a single "
"target:"
msgstr "可以使用单个目标导入具有多个配置的库："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:163
msgid ""
"The generated build system will link ``myexe`` to ``m.lib`` when built in "
"the release configuration, and ``md.lib`` when built in the debug "
"configuration."
msgstr ""
"生成的构建系统将在发布配置中构建时将 ``myexe`` 链接到 ``m.lib``，在调试配置中构建时将链接到 ``md.lib``。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:167
msgid "Exporting Targets"
msgstr "导出目标"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:169
msgid ""
"While :prop_tgt:`IMPORTED` targets on their own are useful, they still "
"require that the project that imports them knows the locations of the "
"target files on disk. The real power of :prop_tgt:`IMPORTED`  targets is "
"when the project providing the target files also provides a CMake file to "
"help import them. A project can be setup to produce the necessary "
"information so that it can easily be used by other CMake projects be it "
"from a build directory, a local install or when packaged."
msgstr ""
"虽然 :prop_tgt:`IMPORTED` 目标本身很有用，但它们仍然需要导入它们的项目知道目标文件在磁盘上的位置。 "
":prop_tgt:`IMPORTED` 目标的真正强大之处在于，当提供目标文件的项目还提供一个 CMake "
"文件来帮助导入它们时。可以设置项目以生成必要的信息，以便其他 CMake 项目可以轻松地使用它，无论是来自构建目录、本地安装还是打包时。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:177
msgid ""
"In the remaining sections, we will walk through a set of example projects "
"step-by-step. The first project will create and install a library and "
"corresponding CMake configuration and package files. The second project "
"will use the generated package."
msgstr "在其余部分中，我们将逐步完成一组示例项目。第一个项目将创建并安装一个库以及相应的 CMake 配置和包文件。第二个项目将使用生成的包。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:182
msgid ""
"Let's start by looking at the ``MathFunctions`` project in the "
"``Help/guide/importing-exporting/MathFunctions`` directory. Here we have a"
" header file ``MathFunctions.h`` that declares a ``sqrt`` function:"
msgstr ""
"让我们首先查看 ``Help/guide/importing-exporting/MathFunctions`` 目录中的 "
"``MathFunctions`` 项目。这里我们有一个头文件“MathFunctions.h”，它声明了一个“sqrt”函数："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:189
msgid "And a corresponding source file ``MathFunctions.cxx``:"
msgstr "以及相应的源文件``MathFunctions.cxx``："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:194
msgid ""
"Don't worry too much about the specifics of the C++ files, they are just "
"meant to be a simple example that will compile and run on many build "
"systems."
msgstr "不要太担心 C++ 文件的细节，它们只是一个简单的示例，可以在许多构建系统上编译和运行。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:197
msgid ""
"Now we can create a ``CMakeLists.txt`` file for the ``MathFunctions`` "
"project. Start by specifying the :command:`cmake_minimum_required` version"
" and :command:`project` name:"
msgstr ""
"现在我们可以为“MathFunctions”项目创建一个“CMakeLists.txt”文件。首先指定 "
":command:`cmake_minimum_required` 版本和 :command:`project` 名称："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:205
msgid ""
"The :module:`GNUInstallDirs` module is included in order to provide the "
"project with the flexibility to install into different platform layouts by"
" making the directories available as cache variables."
msgstr "包含 :module:`GNUInstallDirs` 模块是为了通过使目录可用作缓存变量来为项目提供安装到不同平台布局的灵活性。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:209
msgid ""
"Create a library called ``MathFunctions`` with the :command:`add_library` "
"command:"
msgstr "使用 :command:`add_library` 命令创建一个名为 ``MathFunctions`` 的库："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:217
msgid ""
"And then use the :command:`target_include_directories` command to specify "
"the include directories for the target:"
msgstr "然后使用 :command:`target_include_directories` 命令为目标指定包含目录："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:225
msgid ""
"We need to tell CMake that we want to use different include directories "
"depending on if we're building the library or using it from an installed "
"location. If we don't do this, when CMake creates the export information "
"it will export a path that is specific to the current build directory and "
"will not be valid for other projects. We can use :manual:`generator "
"expressions <cmake-generator-expressions(7)>` to specify that if we're "
"building the library include the current source directory. Otherwise, when"
" installed, include the ``include`` directory. See the `Creating "
"Relocatable Packages`_ section for more details."
msgstr ""
"我们需要告诉 CMake 我们想要使用不同的包含目录，具体取决于我们是在构建库还是从已安装的位置使用它。如果我们不这样做，当 CMake "
"创建导出信息时，它将导出一个特定于当前构建目录的路径，并且对其他项目无效。我们可以使用 :manual:`generator expressions"
" <cmake-generator-expressions(7)>` 来指定如果我们正在构建库包括当前源目录。否则，在安装时，包含 "
"``include`` 目录。有关更多详细信息，请参阅“创建可重定位包”部分。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:235
msgid ""
"The :command:`install(TARGETS)` and :command:`install(EXPORT)` commands "
"work together to install both targets (a library in our case) and a CMake "
"file designed to make it easy to import the targets into another CMake "
"project."
msgstr ""
":command:`install(TARGETS)` 和 :command:`install(EXPORT)` "
"命令共同安装两个目标（在我们的例子中是一个库）和一个 CMake 文件，旨在使将目标导入另一个 CMake 变得容易项目。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:239
msgid ""
"First, in the :command:`install(TARGETS)` command we will specify the "
"target, the ``EXPORT`` name and the destinations that tell CMake where to "
"install the targets."
msgstr ""
"首先，在 :command:`install(TARGETS)` 命令中，我们将指定目标、``EXPORT`` 名称和告诉 CMake "
"在何处安装目标的目的地。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:248
msgid ""
"Here, the ``EXPORT`` option tells CMake to create an export called "
"``MathFunctionsTargets``. The generated :prop_tgt:`IMPORTED` targets have "
"appropriate properties set to define their :ref:`usage requirements "
"<Target Usage Requirements>`, such as "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES`, "
":prop_tgt:`INTERFACE_COMPILE_DEFINITIONS` and other relevant built-in "
"``INTERFACE_`` properties.  The ``INTERFACE`` variant of user-defined "
"properties listed in :prop_tgt:`COMPATIBLE_INTERFACE_STRING` and other "
":ref:`Compatible Interface Properties` are also propagated to the "
"generated :prop_tgt:`IMPORTED` targets. For example, in this case, the "
":prop_tgt:`IMPORTED` target will have its "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` property populated with the "
"directory specified by the ``INCLUDES DESTINATION`` property. As a "
"relative path was given, it is treated as relative to the "
":variable:`CMAKE_INSTALL_PREFIX`."
msgstr ""
"在这里，“EXPORT”选项告诉 CMake 创建一个名为“MathFunctionsTargets”的导出。生成的 "
":prop_tgt:`IMPORTED` 目标具有适当的属性集来定义它们的 :ref:`使用要求 <Target Usage "
"Requirements>` ，例如 "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` 、 :prop_tgt:`INTERFACE_COMPILE_DEFINITIONS`"
" 和其他相关的内置``INTERFACE_`` 属性。 COMPATIBLE_INTERFACE_STRING 和其他 Compatible "
"Interface Properties 中列出的用户定义属性的 INTERFACE 变体也传播到生成的 IMPORTED "
"目标。例如，在这种情况下，IMPORTED 目标的 INTERFACE_INCLUDE_DIRECTORIES 属性将填充由 INCLUDES "
"DESTINATION 属性指定的目录。由于给出了相对路径，它被视为相对于 :variable:`CMAKE_INSTALL_PREFIX`。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:264
msgid "Note, we have *not* asked CMake to install the export yet."
msgstr "请注意，我们*没有*要求 CMake 安装导出。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:266
msgid ""
"We don't want to forget to install the ``MathFunctions.h`` header file "
"with the :command:`install(FILES)` command. The header file should be "
"installed to the ``include`` directory, as specified by the "
":command:`target_include_directories` command above."
msgstr ""
"我们不想忘记使用 :command:`install(FILES)` 命令安装 ``MathFunctions.h`` 头文件。头文件应安装到 "
"``include`` 目录，如上面的 :command:`target_include_directories` 命令所指定的。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:276
msgid ""
"Now that the ``MathFunctions`` library and header file are installed, we "
"also need to explicitly install the ``MathFunctionsTargets``  export "
"details. Use the :command:`install(EXPORT)` command to export the targets "
"in ``MathFunctionsTargets``, as defined by the  "
":command:`install(TARGETS)` command."
msgstr ""
"现在安装了``MathFunctions`` 库和头文件，我们还需要显式安装``MathFunctionsTargets`` 导出细节。使用 "
":command:`install(EXPORT)` 命令导出 ``MathFunctionsTargets`` 中的目标，如 "
":command:`install(TARGETS)` 命令所定义。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:287
msgid ""
"This command generates the ``MathFunctionsTargets.cmake`` file and "
"arranges to install it to ``lib/cmake``. The file contains code suitable "
"for use by downstreams to import all targets listed in the install command"
" from the installation tree."
msgstr ""
"此命令生成“MathFunctionsTargets.cmake”文件并安排将其安装到“lib/cmake”。该文件包含适合下游使用的代码，用于从安装树导入安装命令中列出的所有目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:292
msgid ""
"The ``NAMESPACE`` option will prepend ``MathFunctions::`` to  the target "
"names as they are written to the export file. This convention of double-"
"colons gives CMake a hint that the name is an  :prop_tgt:`IMPORTED` target"
" when it is used by downstream projects. This way, CMake can issue a "
"diagnostic message if the package providing it was not found."
msgstr ""
"``NAMESPACE`` 选项将在写入导出文件时将 ``MathFunctions::`` 添加到目标名称之前。这种双冒号的约定给 CMake "
"一个提示，即当下游项目使用该名称时，它是一个 :prop_tgt:`IMPORTED` 目标。这样，如果找不到提供它的包，CMake "
"可以发出诊断消息。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:298
msgid ""
"The generated export file contains code that creates an "
":prop_tgt:`IMPORTED` library."
msgstr "生成的导出文件包含创建 :prop_tgt:`IMPORTED` 库的代码。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:309
msgid ""
"This code is very similar to the example we created by hand in the "
"`Importing Libraries`_ section. Note that ``${_IMPORT_PREFIX}`` is "
"computed relative to the file location."
msgstr "此代码与我们在“导入库”部分中手动创建的示例非常相似。请注意，``${_IMPORT_PREFIX}`` 是相对于文件位置计算的。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:313
msgid ""
"An outside project may load this file with the :command:`include` command "
"and reference the ``MathFunctions`` library from the installation tree as "
"if it were built in its own tree. For example:"
msgstr ""
"外部项目可以使用 :command:`include` 命令加载此文件，并从安装树中引用 ``MathFunctions`` "
"库，就好像它是在自己的树中构建的一样。例如："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:324
msgid ""
"Line 1 loads the target CMake file. Although we only exported a single "
"target, this file may import any number of targets. Their locations are "
"computed relative to the file location so that the install tree may be "
"easily moved. Line 3 references the imported ``MathFunctions`` library. "
"The resulting build system will link to the library from its installed "
"location."
msgstr ""
"第 1 行加载目标 CMake "
"文件。虽然我们只导出了一个目标，但这个文件可以导入任意数量的目标。它们的位置是相对于文件位置计算的，因此可以轻松移动安装树。第 3 "
"行引用导入的“MathFunctions”库。生成的构建系统将从其安装位置链接到库。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:330
msgid ""
"Executables may also be exported and imported using the same process."
msgstr "也可以使用相同的过程导出和导入可执行文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:332
msgid ""
"Any number of target installations may be associated with the same export "
"name. Export names are considered global so any directory may contribute a"
" target installation. The :command:`install(EXPORT)` command only needs to"
" be called once to install a file that references all targets. Below is an"
" example of how multiple exports may be combined into a single export "
"file, even if they are in different subdirectories of the project."
msgstr ""
"任意数量的目标安装都可以与相同的导出名称相关联。导出名称被认为是全局的，因此任何目录都可以提供目标安装。 "
":command:`install(EXPORT)` "
"命令只需调用一次即可安装引用所有目标的文件。下面是一个示例，说明如何将多个导出合并到一个导出文件中，即使它们位于项目的不同子目录中。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:356
msgid "Creating Packages"
msgstr "创建包"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:358
msgid ""
"At this point, the ``MathFunctions`` project is exporting the target "
"information required to be used by other projects. We can make this "
"project even easier for other projects to use by generating a "
"configuration file so that the CMake :command:`find_package` command can "
"find our project."
msgstr ""
"此时，``MathFunctions`` 项目正在导出其他项目需要使用的目标信息。我们可以通过生成一个配置文件使这个项目更容易被其他项目使用，这样 "
"CMake :command:`find_package` 命令就可以找到我们的项目。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:363
msgid ""
"To start, we will need to make a few additions to the ``CMakeLists.txt`` "
"file. First, include the :module:`CMakePackageConfigHelpers` module to get"
" access to some helper functions for creating config files."
msgstr ""
"首先，我们需要向 ``CMakeLists.txt`` 文件添加一些内容。首先，包含 "
":module:`CMakePackageConfigHelpers` 模块以访问一些用于创建配置文件的辅助函数。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:372
msgid ""
"Then we will create a package configuration file and a package version "
"file."
msgstr "然后我们将创建一个包配置文件和一个包版本文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:375
msgid "Creating a Package Configuration File"
msgstr "创建包配置文件"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:377
msgid ""
"Use the :command:`configure_package_config_file` command provided by the "
":module:`CMakePackageConfigHelpers` to generate the package configuration "
"file. Note that this command should be used instead of the plain "
":command:`configure_file` command. It helps to ensure that the resulting "
"package is relocatable by avoiding hardcoded paths in the installed "
"configuration file. The path given to ``INSTALL_DESTINATION`` must  be the"
" destination where the ``MathFunctionsConfig.cmake`` file will be "
"installed. We will examine the contents of the package configuration file "
"in the next section."
msgstr ""
"使用 CMakePackageConfigHelpers 提供的 configure_package_config_file "
"命令生成包配置文件。请注意，应该使用此命令而不是普通的 :command:`configure_file` "
"命令。通过避免在已安装的配置文件中使用硬编码路径，它有助于确保生成的包是可重定位的。给 ``INSTALL_DESTINATION`` "
"的路径必须是安装 ``MathFunctionsConfig.cmake`` 文件的目的地。我们将在下一节中检查包配置文件的内容。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:392
msgid ""
"Install the generated configuration files with the "
":command:`INSTALL(files)` command. Both "
"``MathFunctionsConfigVersion.cmake`` and ``MathFunctionsConfig.cmake`` are"
" installed to the same location, completing the package."
msgstr ""
"使用 :command:`INSTALL(files)` 命令安装生成的配置文件。 "
"``MathFunctionsConfigVersion.cmake`` 和 ``MathFunctionsConfig.cmake`` "
"都安装到相同的位置，完成了包。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:402
msgid ""
"Now we need to create the package configuration file itself. In this case,"
" the ``Config.cmake.in`` file is very simple but sufficient to allow "
"downstreams to use the :prop_tgt:`IMPORTED` targets."
msgstr ""
"现在我们需要自己创建包配置文件。在这种情况下，``Config.cmake.in`` 文件非常简单，但足以让下游使用 "
":prop_tgt:`IMPORTED` 目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:408
msgid ""
"The first line of the file contains only the string ``@PACKAGE_INIT@``. "
"This expands when the file is configured and allows the use of relocatable"
" paths prefixed with ``PACKAGE_``. It also provides the "
"``set_and_check()`` and ``check_required_components()`` macros."
msgstr ""
"该文件的第一行仅包含字符串“@PACKAGE_INIT@”。这会在配置文件时扩展，并允许使用以“PACKAGE_”为前缀的可重定位路径。它还提供了``set_and_check()``"
" 和``check_required_components()`` 宏。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:413
msgid ""
"The ``check_required_components`` helper macro ensures that all requested,"
" non-optional components have been found by checking the "
"``<Package>_<Component>_FOUND`` variables for all required components. "
"This macro should be called at the end of the package configuration file "
"even if the package does not have any components. This way, CMake can make"
" sure that the downstream project hasn't specified any non-existent "
"components. If ``check_required_components`` fails, the "
"``<Package>_FOUND`` variable is set to FALSE, and the package is "
"considered to be not found."
msgstr ""
"``check_required_components`` 辅助宏通过检查所有必需组件的 "
"``<Package>_<Component>_FOUND`` "
"变量确保找到所有请求的非可选组件。即使包没有任何组件，也应在包配置文件的末尾调用此宏。这样，CMake "
"可以确保下游项目没有指定任何不存在的组件。如果 ``check_required_components`` 失败，则 "
"``<Package>_FOUND`` 变量设置为 FALSE，并认为未找到包。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:422
msgid ""
"The ``set_and_check()`` macro should be used in configuration files "
"instead of the normal ``set()`` command for setting directories and file "
"locations. If a referenced file or directory does not exist, the macro "
"will fail."
msgstr ""
"``set_and_check()`` 宏应该在配置文件中使用，而不是用于设置目录和文件位置的普通 ``set()`` "
"命令。如果引用的文件或目录不存在，宏将失败。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:426
msgid ""
"If any macros should be provided by the ``MathFunctions`` package, they "
"should be in a separate file which is installed to the same location as "
"the ``MathFunctionsConfig.cmake`` file, and included from there."
msgstr ""
"如果“MathFunctions”包应该提供任何宏，它们应该在一个单独的文件中，该文件安装到与“MathFunctionsConfig.cmake”文件相同的位置，并从那里包含。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:430
msgid ""
"**All required dependencies of a package must also be found in the package"
" configuration file.** Let's imagine that we require the ``Stats`` library"
" in our project. In the CMakeLists file, we would add:"
msgstr ""
"**包的所有必需依赖项也必须在包配置文件中找到。**让我们假设我们在我们的项目中需要 ``Stats`` 库。在 CMakeLists "
"文件中，我们将添加："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:439
msgid ""
"As the ``Stats::Types`` target is a ``PUBLIC`` dependency of "
"``MathFunctions``, downstreams must also find the ``Stats`` package and "
"link to the ``Stats::Types`` library.  The ``Stats`` package should be "
"found in the configuration file to ensure this."
msgstr ""
"由于 ``Stats::Types`` 目标是 ``MathFunctions`` 的 ``PUBLIC`` 依赖项，下游还必须找到 "
"``Stats`` 包并链接到 ``Stats::Types`` 库. ``Stats`` 包应该在配置文件中找到以确保这一点。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:449
msgid ""
"The ``find_dependency`` macro from the :module:`CMakeFindDependencyMacro` "
"module helps by propagating  whether the package is ``REQUIRED``, or "
"``QUIET``, etc. The ``find_dependency`` macro also sets "
"``MathFunctions_FOUND`` to ``False`` if the dependency is not found, along"
" with a diagnostic that the ``MathFunctions`` package cannot be used "
"without the ``Stats`` package."
msgstr ""
":module:`CMakeFindDependencyMacro` 模块中的``find_dependency`` "
"宏有助于传播包是``REQUIRED`` 还是``QUIET`` 等。``find_dependency`` "
"宏还设置``MathFunctions_FOUND如果未找到依赖项，则为 `False``，同时诊断为没有``Stats`` "
"包就无法使用``MathFunctions`` 包。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:456
msgid ""
"**Exercise:** Add a required library to the ``MathFunctions`` project."
msgstr "**练习：** 将所需的库添加到“MathFunctions”项目。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:459
msgid "Creating a Package Version File"
msgstr "创建包版本文件"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:461
msgid ""
"The :module:`CMakePackageConfigHelpers` module provides the "
":command:`write_basic_package_version_file` command for creating a simple "
"package version file.  This file is read by CMake when "
":command:`find_package` is called to determine the compatibility with the "
"requested version, and to set some version-specific variables such as "
"``<PackageName>_VERSION``, ``<PackageName>_VERSION_MAJOR``, "
"``<PackageName>_VERSION_MINOR``, etc. See :manual:`cmake-packages <cmake-"
"packages(7)>` documentation for more details."
msgstr ""
":module:`CMakePackageConfigHelpers` "
"模块提供了 :command:`write_basic_package_version_file` 命令来创建一个简单的包版本文件。当 "
":command:`find_package` 被调用以确定与请求版本的兼容性，并设置一些特定于版本的变量，例如 "
"``<PackageName>_VERSION``、``<PackageName>_VERSION_MAJOR` 时，CMake "
"会读取此文件`、``<PackageName>_VERSION_MINOR`` 等。有关详细信息，请参阅 :manual:`cmake-packages "
"<cmake-packages(7)>` 文档。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:474
msgid ""
"In our example, ``MathFunctions_MAJOR_VERSION`` is defined as a "
":prop_tgt:`COMPATIBLE_INTERFACE_STRING` which means that it must be "
"compatible among the dependencies of any depender. By setting this custom "
"defined user property in this version and in the next version of "
"``MathFunctions``, :manual:`cmake <cmake(1)>` will issue a diagnostic if "
"there is an attempt to use version 3 together with version 4.  Packages "
"can choose to employ such a pattern if different major versions of the "
"package are designed to be incompatible."
msgstr ""
"在我们的示例中，``MathFunctions_MAJOR_VERSION`` 被定义为 "
":prop_tgt:`COMPATIBLE_INTERFACE_STRING` "
"这意味着它必须与任何依赖项的依赖项兼容。通过在此版本和下一版本的“MathFunctions”中设置此自定义用户属性，如果尝试将版本 3 "
"与版本一起使用，cmake <cmake(1)>` 将发出诊断4. 如果包的不同主要版本被设计为不兼容，则包可以选择采用这种模式。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:485
msgid "Exporting Targets from the Build Tree"
msgstr "从构建树中导出目标"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:487
msgid ""
"Typically, projects are built and installed before being used by an "
"outside project. However, in some cases, it is desirable to export targets"
" directly from a build tree. The targets may then be used by an outside "
"project that references the build tree with no installation involved. The "
":command:`export` command is used to generate a file exporting targets "
"from a project build tree."
msgstr ""
"通常，项目是在被外部项目使用之前构建和安装的。但是，在某些情况下，希望直接从构建树中导出目标。然后，这些目标可能会被引用构建树的外部项目使用，而不涉及安装。"
" :command:`export` 命令用于生成从项目构建树中导出目标的文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:493
msgid ""
"If we want our example project to also be used from a build directory we "
"only have to add the following to ``CMakeLists.txt``:"
msgstr "如果我们希望我们的示例项目也可以从构建目录中使用，我们只需将以下内容添加到“CMakeLists.txt”："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:500
msgid ""
"Here we use the :command:`export` command to generate the export targets "
"for the build tree. In this case, we'll create a file called "
"``MathFunctionsTargets.cmake`` in the ``cmake`` subdirectory of the build "
"directory. The generated file contains the required code to import the "
"target and may be loaded by an outside project that is aware of the "
"project build tree. This file is specific to the build-tree, and **is not "
"relocatable**."
msgstr ""
"这里我们使用 :command:`export` "
"命令为构建树生成导出目标。在这种情况下，我们将在构建目录的“cmake”子目录中创建一个名为“MathFunctionsTargets.cmake”的文件。生成的文件包含导入目标所需的代码，并且可以由了解项目构建树的外部项目加载。此文件特定于构建树，并且**不可重定位**。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:507
msgid ""
"It is possible to create a suitable package configuration file and package"
" version file to define a package for the build tree which may be used "
"without installation.  Consumers of the build tree can simply ensure that "
"the :variable:`CMAKE_PREFIX_PATH` contains the build directory, or set the"
" ``MathFunctions_DIR`` to ``<build_dir>/MathFunctions`` in the cache."
msgstr ""
"可以创建合适的包配置文件和包版本文件来定义构建树的包，无需安装即可使用。构建树的消费者只需确保 :variable:`CMAKE_PREFIX_PATH` "
"包含构建目录，或在缓存中将``MathFunctions_DIR`` 设置为``<build_dir>/MathFunctions``。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:513
msgid ""
"An example application of this feature is for building an executable on a "
"host platform when cross-compiling. The project containing the executable "
"may be built on the host platform and then the project that is being "
"cross-compiled for another platform may load it."
msgstr ""
"此功能的一个示例应用程序是在交叉编译时在主机平台上构建可执行文件。包含可执行文件的项目可以在主机平台上构建，然后正在为另一个平台交叉编译的项目可以加载它。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:519
msgid "Building and Installing a Package"
msgstr "构建和安装包"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:521
msgid ""
"At this point, we have generated a relocatable CMake configuration for our"
" project that can be used after the project has been installed. Let's try "
"to build the ``MathFunctions`` project:"
msgstr "至此，我们已经为我们的项目生成了一个可重定位的CMake配置，可以在项目安装后使用。让我们尝试构建“MathFunctions”项目："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:532
msgid ""
"In the build directory, notice that the file "
"``MathFunctionsTargets.cmake`` has been created in the ``cmake`` "
"subdirectory."
msgstr "在构建目录中，请注意文件“MathFunctionsTargets.cmake”已在“cmake”子目录中创建。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:535
msgid "Now install the project:"
msgstr "现在安装项目："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:542
msgid "Creating Relocatable Packages"
msgstr "创建可重定位包"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:544
msgid ""
"Packages created by :command:`install(EXPORT)` are designed to be "
"relocatable, using paths relative to the location of the package itself. "
"They must not reference absolute paths of files on the machine where the "
"package is built that will not exist on the machines where the package may"
" be installed."
msgstr ""
"由 :command:`install(EXPORT)` "
"创建的包被设计为可重定位，使用相对于包本身位置的路径。它们不得引用在构建包的机器上的文件的绝对路径，这些文件在可能安装包的机器上不存在。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:549
msgid ""
"When defining the interface of a target for ``EXPORT``, keep in mind that "
"the include directories should be specified as relative paths to the "
":variable:`CMAKE_INSTALL_PREFIX` but should not explicitly include the "
":variable:`CMAKE_INSTALL_PREFIX`:"
msgstr ""
"在为 EXPORT 定义目标接口时，请记住，包含目录应指定为 CMAKE_INSTALL_PREFIX 的相对路径，但不应显式包含 "
"CMAKE_INSTALL_PREFIX ："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:566
msgid ""
"The :genex:`$<INSTALL_PREFIX>` generator expression may be used as a "
"placeholder for the install prefix without resulting in a non-relocatable "
"package.  This is necessary if complex generator expressions are used:"
msgstr ""
":genex:`$<INSTALL_PREFIX>` "
"生成器表达式可以用作安装前缀的占位符，而不会产生不可重定位的包。如果使用复杂的生成器表达式，这是必需的："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:577
msgid ""
"This also applies to paths referencing external dependencies. It is not "
"advisable to populate any properties which may contain paths, such as "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` or "
":prop_tgt:`INTERFACE_LINK_LIBRARIES`, with paths relevant to dependencies."
" For example, this code may not work well for a relocatable package:"
msgstr ""
"这也适用于引用外部依赖项的路径。不建议使用与依赖项相关的路径填充任何可能包含路径的属性，例如:prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES`"
" 或 :prop_tgt:`INTERFACE_LINK_LIBRARIES`。例如，此代码可能不适用于可重定位包："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:592
msgid ""
"The referenced variables may contain the absolute paths to libraries and "
"include directories **as found on the machine the package was made on**. "
"This would create a package with hard-coded paths to dependencies not "
"suitable for relocation."
msgstr "引用的变量可能包含库的绝对路径，并包含目录**在创建包的机器上找到的**。这将创建一个包含不适合重定位的依赖项的硬编码路径的包。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:597
msgid ""
"Ideally such dependencies should be used through their own :ref:`IMPORTED "
"targets <Imported Targets>` that have their own "
":prop_tgt:`IMPORTED_LOCATION` and usage requirement properties such as "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` populated appropriately.  Those "
"imported targets may then be used with the "
":command:`target_link_libraries` command for ``MathFunctions``:"
msgstr ""
"理想情况下，此类依赖项应通过它们自己的 :ref:`IMPORTED 目标 <Imported Targets>` 使用，这些目标具有自己的 "
":prop_tgt:`IMPORTED_LOCATION` 和使用要求属性，例如 INTERFACE_INCLUDE_DIRECTORIES` "
"适当填充。这些导入的目标然后可以与 :command:`target_link_libraries` 命令一起用于 "
"``MathFunctions``："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:608
msgid ""
"With this approach the package references its external dependencies only "
"through the names of :ref:`IMPORTED targets <Imported Targets>`. When a "
"consumer uses the installed package, the consumer will run the appropriate"
" :command:`find_package` commands (via the ``find_dependency`` macro "
"described above) to find the dependencies and populate the imported "
"targets with appropriate paths on their own machine."
msgstr ""
"使用这种方法，包仅通过 :ref:`IMPORTED targets <Imported Targets>` "
"的名称引用其外部依赖项。当消费者使用已安装的包时，消费者将运行适当的 :command:`find_package` 命令（通过上述的 "
"``find_dependency`` 宏）来查找依赖项并在自己的机器上使用适当的路径填充导入的目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:616
msgid "Using the Package Configuration File"
msgstr "使用包配置文件"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:618
msgid ""
"Now we're ready to create a project to use the installed ``MathFunctions``"
" library. In this section we will be using source code from "
"``Help\\guide\\importing-exporting\\Downstream``. In this directory, there"
" is a source file called ``main.cc`` that uses the ``MathFunctions`` "
"library to calculate the square root of a given number and then prints the"
" results:"
msgstr ""
"现在我们准备创建一个项目来使用已安装的“MathFunctions”库。在本节中，我们将使用来自 ``Help\\guide\\importing-"
"exporting\\Downstream`` 的源代码。在这个目录中，有一个名为 ``main.cc`` 的源文件，它使用 "
"``MathFunctions`` 库计算给定数字的平方根，然后打印结果："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:627
msgid ""
"As before, we'll start with the :command:`cmake_minimum_required` and "
":command:`project` commands in the ``CMakeLists.txt`` file. For this "
"project, we'll also specify the C++ standard."
msgstr ""
"和以前一样，我们将从 CMakeLists.txt 文件中的 :command:`cmake_minimum_required` 和 "
":command:`project` 命令开始。对于这个项目，我们还将指定 C++ 标准。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:635
msgid "We can use the :command:`find_package` command:"
msgstr "我们可以使用 :command:`find_package` 命令："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:642
msgid "Create an executable:"
msgstr "创建一个可执行文件："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:649
msgid "And link to the ``MathFunctions`` library:"
msgstr "并链接到“MathFunctions”库："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:655
msgid "That's it! Now let's try to build the ``Downstream`` project."
msgstr "就是这样！现在让我们尝试构建“下游”项目。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:664
msgid "A warning may have appeared during CMake configuration:"
msgstr "CMake配置时可能出现警告："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:684
msgid ""
"Set the ``CMAKE_PREFIX_PATH`` to where MathFunctions was installed "
"previously and try again. Ensure that the newly created executable runs as"
" expected."
msgstr ""
"将 CMAKE_PREFIX_PATH 设置为之前安装 MathFunctions 的位置，然后重试。确保新创建的可执行文件按预期运行。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:688
msgid "Adding Components"
msgstr "添加组件"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:690
msgid ""
"Let's edit the ``MathFunctions`` project to use components. The source "
"code for this section can be found in ``Help\\guide\\importing-"
"exporting\\MathFunctionsComponents``. The CMakeLists file for this project"
" adds two subdirectories: ``Addition`` and ``SquareRoot``."
msgstr ""
"让我们编辑“MathFunctions”项目以使用组件。本节的源代码可以在 ``Help\\guide\\importing-"
"exporting\\MathFunctionsComponents`` 中找到。该项目的 CMakeLists "
"文件添加了两个子目录：``Addition`` 和 ``SquareRoot``。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:699
msgid ""
"Generate and install the package configuration and package version files:"
msgstr "生成并安装包配置和包版本文件："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:705
msgid ""
"If ``COMPONENTS`` are specified when the downstream uses "
":command:`find_package`, they are listed in the "
"``<PackageName>_FIND_COMPONENTS`` variable. We can use this variable to "
"verify that all necessary component targets are included in "
"``Config.cmake.in``. At the same time, this function will act as a custom "
"``check_required_components`` macro to ensure that the downstream only "
"attempts to use supported components."
msgstr ""
"如果在下游使用 :command:`find_package` 时指定了 "
"``COMPONENTS``，它们将列在``<PackageName>_FIND_COMPONENTS`` "
"变量中。我们可以使用这个变量来验证所有必要的组件目标都包含在 ``Config.cmake.in`` 中。同时，该函数将充当自定义的 "
"``check_required_components`` 宏，以确保下游仅尝试使用受支持的组件。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:714
msgid ""
"Here, the ``MathFunctions_NOT_FOUND_MESSAGE`` is set to a diagnosis that "
"the package could not be found because an invalid component was specified."
" This message variable can be set for any case where the ``_FOUND`` "
"variable is set to ``False``, and will be displayed to the user."
msgstr ""
"在这里，``MathFunctions_NOT_FOUND_MESSAGE`` "
"被设置为无法找到包的诊断，因为指定了无效的组件。这个消息变量可以在任何情况下设置 `_FOUND`` 变量设置为 "
"``False``，并将显示给用户。"

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:719
msgid ""
"The ``Addition`` and ``SquareRoot`` directories are similar. Let's look at"
" one of the CMakeLists files:"
msgstr "``Addition`` 和 ``SquareRoot`` 目录是相似的。让我们看一下其中一个 CMakeLists 文件："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:725
msgid ""
"Now we can build the project as described in earlier sections. To test "
"using this package, we can use the project in ``Help\\guide\\importing-"
"exporting\\DownstreamComponents``. There's two differences from the "
"previous ``Downstream`` project. First, we need to find the package "
"components. Change the ``find_package`` line from:"
msgstr ""
"现在我们可以按照前面部分中的描述构建项目。要测试使用这个包，我们可以使用 ``Help\\guide\\importing-"
"exporting\\DownstreamComponents`` 中的项目。与之前的“下游”项目有两个不同之处。首先，我们需要找到包组件。更改 "
"``find_package`` 行："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:736
#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:749
msgid "To:"
msgstr "到："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:743
msgid "and the ``target_link_libraries`` line from:"
msgstr "和 ``target_link_libraries`` 行来自："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:756
msgid "In ``main.cc``, replace ``#include MathFunctions.h`` with:"
msgstr "在 ``main.cc`` 中，将 ``#include MathFunctions.h`` 替换为："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:763
msgid "Finally, use the ``Addition`` library:"
msgstr "最后，使用 ``Addition`` 库："

#: ../../cmake-prefix/src/cmake/Help/guide/importing-exporting/index.rst:770
msgid ""
"Build the ``Downstream`` project and confirm that it can find and use the "
"package components."
msgstr "构建 ``Downstream`` 项目并确认它可以找到并使用包组件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:2
#: Starting
msgid "Step 1: A Basic Starting Point"
msgstr "第 1 步：基本起点"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:4
#: Starting
msgid ""
"Where do I start with CMake? This step will provide an introduction to "
"some of CMake's basic syntax, commands, and variables. As these concepts "
"are introduced, we will work through three exercises and create a simple "
"CMake project."
msgstr ""
"我从哪里开始使用 CMake？此步骤将介绍 CMake 的一些基本语法、命令和变量。在介绍这些概念时，我们将完成三个练习并创建一个简单的 CMake"
" 项目。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:9
#: Starting
msgid ""
"Each exercise in this step will start with some background information. "
"Then, a goal and list of helpful resources are provided. Each file in the "
"``Files to Edit`` section is in the ``Step1`` directory and contains one "
"or more ``TODO`` comments. Each ``TODO`` represents a line or two of code "
"to change or add. The ``TODO`` s are intended to be completed in numerical"
" order, first complete  ``TODO 1`` then ``TODO 2``, etc. The ``Getting "
"Started`` section will give some helpful hints and guide you through the "
"exercise. Then the ``Build and Run`` section will walk step-by-step "
"through how to build and test the exercise. Finally, at the end of each "
"exercise the intended solution is discussed."
msgstr ""
"此步骤中的每个练习都将从一些背景信息开始。然后，提供目标和有用资源列表。 ``Files to Edit`` 部分中的每个文件都位于 "
"``Step1`` 目录中，并包含一个或多个 ``TODO`` 注释。每个 ``TODO`` 代表要更改或添加的一两行代码。 ``TODO`` "
"旨在按数字顺序完成，首先完成 ``TODO 1`` 然后是 ``TODO 2`` 等。``Getting Started`` "
"部分将提供一些有用的提示并指导您通过练习。然后“构建和运行”部分将逐步介绍如何构建和测试练习。最后，在每个练习结束时讨论预期的解决方案。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:20
#: Starting
msgid ""
"Also note that each step in the tutorial builds on the next. So, for "
"example, the starting code for ``Step2`` is the complete solution to "
"``Step1``."
msgstr "另请注意，本教程中的每个步骤都建立在下一步之上。因此，例如，“Step2”的起始代码是“Step1”的完整解决方案。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:24
#: Starting
msgid "Exercise 1 - Building a Basic Project"
msgstr "练习 1 - 构建一个基本项目"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:26
#: Starting
msgid ""
"The most basic CMake project is an executable built from a single source "
"code file. For simple projects like this, a ``CMakeLists.txt`` file with "
"three commands is all that is required."
msgstr ""
"最基本的 CMake 项目是从单个源代码文件构建的可执行文件。对于像这样的简单项目，只需要一个包含三个命令的“CMakeLists.txt”文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:30
#: Starting
msgid ""
"**Note:** Although upper, lower and mixed case commands are supported by "
"CMake, lower case commands are preferred and will be used throughout the "
"tutorial."
msgstr "**注意：** 虽然 CMake 支持大写、小写和混合大小写命令，但首选小写命令，并将在整个教程中使用。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:33
#: Starting
msgid ""
"Any project's top most CMakeLists.txt must start by specifying a minimum "
"CMake version using the :command:`cmake_minimum_required` command. This "
"establishes policy settings and ensures that the following CMake functions"
" are run with a compatible version of CMake."
msgstr ""
"任何项目的最顶层 CMakeLists.txt 必须首先使用 :command:`cmake_minimum_required` 命令指定最低 "
"CMake 版本。这会建立策略设置并确保以下 CMake 函数使用兼容版本的 CMake 运行。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:38
#: Starting
msgid ""
"To start a project, we use the :command:`project` command to set the "
"project name. This call is required with every project and should be "
"called soon after :command:`cmake_minimum_required`. As we will see later,"
" this command can also be used to specify other project level information "
"such as the language or version number."
msgstr ""
"要启动一个项目，我们使用 :command:`project` 命令来设置项目名称。每个项目都需要此调用，并且应在 "
"cmake_minimum_required 之后立即调用。正如我们稍后将看到的，此命令还可用于指定其他项目级别的信息，例如语言或版本号。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:44
#: Starting
msgid ""
"Finally, the :command:`add_executable` command tells CMake to create an "
"executable using the specified source code files."
msgstr "最后， :command:`add_executable` 命令告诉 CMake 使用指定的源代码文件创建可执行文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Dashboard.rst:14 Expressions.rst:39 Expressions.rst:182 Generator
#: Introspection.rst:14 Library.rst:23 Library.rst:25 Library.rst:213
#: Point.rst:48 Point.rst:181 Point.rst:293 Requirements Starting Support
#: System Testing Testing.rst:14 Testing.rst:166 Usage a and for
msgid "Goal"
msgstr "目标"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:50
#: Starting
msgid "Understand how to create a simple CMake project."
msgstr "了解如何创建简单的 CMake 项目。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Dashboard.rst:19 Expressions.rst:44 Expressions.rst:187 Generator
#: Introspection.rst:19 Library.rst:30 Library.rst:219 Point.rst:53
#: Point.rst:186 Point.rst:298 Starting Support System Testing a for
msgid "Helpful Resources"
msgstr "有用的资源"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:55
#: Starting
msgid ":command:`add_executable`"
msgstr ":command:`add_executable`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Expressions.rst:190 Generator Point.rst:56 Starting
msgid ":command:`cmake_minimum_required`"
msgstr ":command:`cmake_minimum_required`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:57
#: Starting
msgid ":command:`project`"
msgstr ":command:`project`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Dashboard.rst:26 Expressions.rst:51 Expressions.rst:195 Generator
#: Introspection.rst:25 Library.rst:33 Library.rst:39 Library.rst:227
#: Point.rst:60 Point.rst:193 Point.rst:306 Requirements Starting Support
#: System Testing Testing.rst:24 Testing.rst:180 Usage a and for
msgid "Files to Edit"
msgstr "要编辑的文件"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Dashboard.rst:28 Expressions.rst:53 Expressions.rst:197 Generator
#: Library.rst:36 Library.rst:41 Library.rst:229 Point.rst:62 Point.rst:195
#: Point.rst:308 Requirements Starting Support Testing Testing.rst:27
#: Testing.rst:182 Usage a and for
msgid "``CMakeLists.txt``"
msgstr "``CMakeLists.txt``"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Dashboard.rst:31 Expressions.rst:57 Expressions.rst:200 Generator
#: Introspection.rst:31 Library.rst:39 Library.rst:46 Library.rst:234
#: Point.rst:65 Point.rst:199 Point.rst:312 Requirements Starting Support
#: System Testing Testing.rst:30 Testing.rst:185 Usage a and for
msgid "Getting Started"
msgstr "入门"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:67
#: Starting
msgid ""
"The source code for ``tutorial.cxx`` is provided in the "
"``Help/guide/tutorial/Step1`` directory and can be used to compute the "
"square root of a number. This file does not need to be edited in this "
"step."
msgstr ""
"``tutorial.cxx`` 的源代码在``Help/guide/tutorial/Step1`` "
"目录中提供，可用于计算数字的平方根。此文件不需要在此步骤中进行编辑。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:71
#: Starting
msgid ""
"In the same directory is a ``CMakeLists.txt`` file which you will "
"complete. Start with ``TODO 1`` and work through ``TODO 3``."
msgstr ""
"在同一目录中有一个 ``CMakeLists.txt`` 文件，您将完成该文件。从 ``TODO 1`` 开始，完成 ``TODO 3``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Dashboard.rst:64 Expressions.rst:74 Expressions.rst:215 Generator
#: Introspection.rst:47 Library.rst:61 Library.rst:71 Library.rst:247
#: Point.rst:75 Point.rst:208 Point.rst:326 Requirements Starting Support
#: System Testing Testing.rst:46 Testing.rst:195 Usage a and for
msgid "Build and Run"
msgstr "构建并运行"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:77
#: Starting
msgid ""
"Once ``TODO 1`` through ``TODO 3`` have been completed, we are ready to "
"build and run our project! First, run the :manual:`cmake <cmake(1)>` "
"executable or the :manual:`cmake-gui <cmake-gui(1)>` to configure the "
"project and then build it with your chosen build tool."
msgstr ""
"一旦“TODO 1”到“TODO 3”完成，我们就可以构建和运行我们的项目了！首先，运行 :manual:`cmake <cmake(1)>` "
"可执行文件或 :manual:`cmake-gui <cmake-gui(1)>` 来配置项目，然后使用您选择的构建工具构建它。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:82
#: Starting
msgid ""
"For example, from the command line we could navigate to the "
"``Help/guide/tutorial`` directory of the CMake source code tree and create"
" a build directory:"
msgstr "例如，从命令行我们可以导航到 CMake 源代码树的 ``Help/guide/tutorial`` 目录并创建一个构建目录："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:90
#: Starting
msgid ""
"Next, navigate to that build directory and run :manual:`cmake <cmake(1)>` "
"to configure the project and generate a native build system:"
msgstr "接下来，导航到该构建目录并运行 :manual:`cmake <cmake(1)>` 来配置项目并生成本机构建系统："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:99
#: Starting
msgid "Then call that build system to actually compile/link the project:"
msgstr "然后调用该构建系统来实际编译/链接项目："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:105
#: Starting
msgid ""
"Finally, try to use the newly built ``Tutorial`` with these commands:"
msgstr "最后，尝试通过这些命令使用新构建的 ``Tutorial``："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Dashboard.rst:91 Expressions.rst:94 Expressions.rst:226 Generator
#: Introspection.rst:66 Library.rst:80 Library.rst:90 Library.rst:280
#: Point.rst:114 Point.rst:228 Point.rst:340 Requirements Starting Support
#: System Testing Testing.rst:90 Testing.rst:207 Usage a and for
msgid "Solution"
msgstr "解决方案"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:116
#: Starting
msgid ""
"As mentioned above, a three line ``CMakeLists.txt`` is all that we need to"
" get up and running. The first line is to use "
":command:`cmake_minimum_required` to set the CMake version as follows:"
msgstr ""
"如上所述，我们需要启动和运行三行“CMakeLists.txt”。第一行是使用 :command:`cmake_minimum_required` 设置 CMake 版本，如下："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Dashboard.rst:101 Expressions.rst:119 Generator Point.rst:124 Starting
#: Support Testing a for
msgid "TODO 1: CMakeLists.txt"
msgstr "TODO 1：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:134
#: Starting
msgid ""
"The next step to make a basic project is to use the :command:`project` "
"command as follows to set the project name:"
msgstr "制作基本项目的下一步是使用 :command:`project` 命令，如下所示设置项目名称："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Expressions.rst:139 Generator Library.rst:117 Library.rst:119
#: Point.rst:141 Requirements Starting Usage a for
msgid "TODO 2: CMakeLists.txt"
msgstr "TODO 2：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:151
#: Starting
msgid ""
"The last command to call for a basic project is :command:`add_executable`."
" We call it as follows:"
msgstr "调用基本项目的最后一个命令是 :command:`add_executable`。我们这样称呼它："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Library.rst:134 Library.rst:136 Point.rst:158 Requirements Starting Usage
#: a for
msgid "TODO 3: CMakeLists.txt"
msgstr "TODO 3：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:170
#: Starting
msgid "Exercise 2 - Specifying the C++ Standard"
msgstr "练习 2 - 指定 C++ 标准"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:172
#: Starting
msgid ""
"CMake has some special variables that are either created behind the scenes"
" or have meaning to CMake when set by project code. Many of these "
"variables start with ``CMAKE_``. Avoid this naming convention when "
"creating variables for your projects. Two of these special user settable "
"variables are :variable:`CMAKE_CXX_STANDARD` and "
":variable:`CMAKE_CXX_STANDARD_REQUIRED`. These may be used together to "
"specify the C++ standard needed to build the project."
msgstr ""
"CMake 有一些特殊变量，这些变量要么在幕后创建，要么在项目代码设置时对 CMake 有意义。许多这些变量以 ``CMAKE_`` "
"开头。在为您的项目创建变量时避免这种命名约定。其中两个特殊的用户可设置变量是 :variable:`CMAKE_CXX_STANDARD` "
"和 :variable:`CMAKE_CXX_STANDARD_REQUIRED`。这些可以一起使用来指定构建项目所需的 C++ 标准。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:183
#: Starting
msgid "Add a feature that requires C++11."
msgstr "添加需要 C++11 的功能。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:188
#: Starting
msgid ":variable:`CMAKE_CXX_STANDARD`"
msgstr ":variable:`CMAKE_CXX_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:189
#: Starting
msgid ":variable:`CMAKE_CXX_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_CXX_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Expressions.rst:191 Generator Point.rst:190 Starting
msgid ":command:`set`"
msgstr ":command:`set`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Library.rst:42 Library.rst:230 Point.rst:196 Point.rst:309 Starting a
msgid "``tutorial.cxx``"
msgstr "``tutorial.cxx``"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:201
#: Starting
msgid ""
"Continue editing files in the ``Step1`` directory. Start with ``TODO 4`` "
"and complete through ``TODO 6``."
msgstr "继续编辑 ``Step1`` 目录中的文件。从“TODO 4”开始，通过“TODO 6”完成。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:204
#: Starting
msgid ""
"First, edit ``tutorial.cxx`` by adding a feature that requires C++11. Then"
" update ``CMakeLists.txt`` to require C++11."
msgstr ""
"首先，通过添加需要 C++11 的功能来编辑 tutorial.cxx。然后更新 ``CMakeLists.txt`` 以要求 C++11。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:210
#: Starting
msgid ""
"Let's build our project again. Since we already created a build directory "
"and ran CMake for Exercise 1, we can skip to the build step:"
msgstr "让我们再次构建我们的项目。由于我们已经为练习 1 创建了构建目录并运行了 CMake，因此我们可以跳到构建步骤："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:218
#: Starting
msgid ""
"Now we can try to use the newly built ``Tutorial`` with same commands as "
"before:"
msgstr "现在我们可以尝试使用新构建的 ``Tutorial`` 和以前一样的命令："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:230
#: Starting
msgid ""
"We start by adding some C++11 features to our project by replacing "
"``atof`` with ``std::stod`` in ``tutorial.cxx``. This looks like the "
"following:"
msgstr ""
"我们首先通过在 ``tutorial.cxx`` 中将 ``atof`` 替换为 ``std::stod`` 来向我们的项目添加一些 C++11 "
"特性。这看起来像下面这样："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:238
#: Starting
msgid "TODO 4: tutorial.cxx"
msgstr "TODO 4：tutorial.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:249
#: Starting
msgid "To complete ``TODO 5``, simply remove ``#include <cstdlib>``."
msgstr "要完成“TODO 5”，只需删除“#include <cstdlib>”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:251
#: Starting
msgid ""
"We will need to explicitly state in the CMake code that it should use the "
"correct flags. One way to enable support for a specific C++ standard in "
"CMake is by using the :variable:`CMAKE_CXX_STANDARD` variable. For this "
"tutorial, set the :variable:`CMAKE_CXX_STANDARD` variable in the "
"``CMakeLists.txt`` file to ``11`` and "
":variable:`CMAKE_CXX_STANDARD_REQUIRED` to ``True``. Make sure to add the "
":variable:`CMAKE_CXX_STANDARD` declarations above the call to "
":command:`add_executable`."
msgstr ""
"我们需要在 CMake 代码中明确声明它应该使用正确的标志。在 CMake 中启用对特定 C++ 标准的支持的一种方法是使用 "
":variable:`CMAKE_CXX_STANDARD` 变量。对于本教程，将 CMakeLists.txt 文件中的 "
"CMAKE_CXX_STANDARD 变量设置为 11 并将 CMAKE_CXX_STANDARD_REQUIRED 变量设置为 True。确保在对"
" :command:`add_executable` 的调用上方添加 :variable:`CMAKE_CXX_STANDARD` 声明。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Expressions.rst:275 Generator Point.rst:263 Starting Testing.rst:240 and
msgid "TODO 6: CMakeLists.txt"
msgstr "TODO 6：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:275
#: Starting
msgid "Exercise 3 - Adding a Version Number and Configured Header File"
msgstr "练习 3 - 添加版本号和配置的头文件"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:277
#: Starting
msgid ""
"Sometimes it may be useful to have a variable that is defined in your "
"``CMakelists.txt`` file also be available in your source code. In this "
"case, we would like to print the project version."
msgstr "有时，在您的“CMakelists.txt”文件中定义的变量在您的源代码中也可用可能会很有用。在这种情况下，我们想打印项目版本。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:281
#: Starting
msgid ""
"One way to accomplish this is by using a configured header file. We create"
" an input file with one or more variables to replace. These variables have"
" special syntax which looks like ``@VAR@``. Then, we use the "
":command:`configure_file` command to copy the input file to a given output"
" file and replace these variables with the current value of ``VAR`` in the"
" ``CMakelists.txt`` file."
msgstr ""
"实现此目的的一种方法是使用已配置的头文件。我们创建一个输入文件，其中包含一个或多个要替换的变量。这些变量有特殊的语法，看起来像“@VAR@”。然后，我们使用"
" :command:`configure_file` 命令将输入文件复制到给定的输出文件，并用 ``CMakelists.txt`` 文件中的 "
"``VAR`` 的当前值替换这些变量。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:288
#: Starting
msgid ""
"While we could edit the version directly in the source code, using this "
"feature is preferred since it creates a single source of truth and avoids "
"duplication."
msgstr "虽然我们可以直接在源代码中编辑版本，但首选使用此功能，因为它创建了单一的真实来源并避免了重复。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:295
#: Starting
msgid "Define and report the project's version number."
msgstr "定义并报告项目的版本号。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:300
#: Starting
msgid ":variable:`<PROJECT-NAME>_VERSION_MAJOR`"
msgstr ":variable:`<PROJECT-NAME>_VERSION_MAJOR`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:301
#: Starting
msgid ":variable:`<PROJECT-NAME>_VERSION_MINOR`"
msgstr ":variable:`<PROJECT-NAME>_VERSION_MINOR`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:302
#: Starting
msgid ":command:`configure_file`"
msgstr ":command:`configure_file`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Library.rst:15 Library.rst:34 Point.rst:303 Requirements Starting Usage a
#: for
msgid ":command:`target_include_directories`"
msgstr ":command:`target_include_directories`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:314
#: Starting
msgid ""
"Continue to edit files from ``Step1``. Start on ``TODO 7`` and complete "
"through ``TODO 12``. In this exercise, we start by adding a project "
"version number in ``CMakeLists.txt``. In that same file, use "
":command:`configure_file` to copy a given input file to an output file and"
" substitute some variable values in the input file content."
msgstr ""
"继续编辑“Step1”中的文件。从“TODO 7”开始，完成“TODO 12”。在本练习中，我们首先在 CMakeLists.txt "
"中添加项目版本号。在同一个文件中，使用 :command:`configure_file` "
"将给定的输入文件复制到输出文件，并替换输入文件内容中的一些变量值。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:320
#: Starting
msgid ""
"Next, create an input header file ``TutorialConfig.h.in`` defining version"
" numbers which will accept variables passed from "
":command:`configure_file`."
msgstr ""
"接下来，创建一个输入头文件 ``TutorialConfig.h.in`` 定义版本号，它将接受从 "
":command:`configure_file` 传递的变量。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:323
#: Starting
msgid "Finally, update ``tutorial.cxx`` to print out its version number."
msgstr "最后，更新 ``tutorial.cxx`` 以打印出它的版本号。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:328
#: Starting
msgid ""
"Let's build our project again. As before, we already created a build "
"directory and ran CMake so we can skip to the build step:"
msgstr "让我们再次构建我们的项目。和以前一样，我们已经创建了一个构建目录并运行了 CMake，因此我们可以跳到构建步骤："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:336
#: Starting
msgid ""
"Verify that the version number is now reported when running the executable"
" without any arguments."
msgstr "验证在不带任何参数运行可执行文件时现在是否报告了版本号。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:342
#: Starting
msgid ""
"In this exercise, we improve our executable by printing a version number. "
"While we could do this exclusively in the source code, using "
"``CMakeLists.txt`` lets us maintain a single source of data for the "
"version number."
msgstr ""
"在本练习中，我们通过打印版本号来改进我们的可执行文件。虽然我们可以在源代码中专门执行此操作，但使用 CMakeLists.txt "
"可以让我们维护版本号的单一数据源。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:346
#: Starting
msgid ""
"First, we modify the ``CMakeLists.txt`` file to use the :command:`project`"
" command to set both the project name and version number. When the "
":command:`project` command is called, CMake defines "
"``Tutorial_VERSION_MAJOR`` and ``Tutorial_VERSION_MINOR`` behind the "
"scenes."
msgstr ""
"首先，我们修改 ``CMakeLists.txt`` 文件以使用 :command:`project` 命令设置项目名称和版本号。当 "
":command:`project` 命令被调用时，CMake 在幕后定义了 ``Tutorial_VERSION_MAJOR`` 和 "
"``Tutorial_VERSION_MINOR``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Expressions.rst:297 Generator Library.rst:291 Point.rst:355 Starting
#: Testing.rst:260 a and
msgid "TODO 7: CMakeLists.txt"
msgstr "TODO 7：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:366
#: Starting
msgid ""
"Then we used :command:`configure_file` to copy the input file with the "
"specified CMake variables replaced:"
msgstr "然后我们使用 :command:`configure_file` 复制输入文件并替换指定的 CMake 变量："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Library.rst:329 Point.rst:373 Starting Testing.rst:278 a and
msgid "TODO 8: CMakeLists.txt"
msgstr "TODO 8：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:384
#: Starting
msgid ""
"Since the configured file will be written into the project binary "
"directory, we must add that directory to the list of paths to search for "
"include files."
msgstr "由于配置文件将写入项目二进制目录，我们必须将该目录添加到路径列表中以搜索包含文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:388
#: Starting
msgid ""
"**Note:** Throughout this tutorial, we will refer to the project build and"
" the project binary directory interchangeably. These are the same and are "
"not meant to refer to a `bin/` directory."
msgstr "**注意：** 在本教程中，我们将交替引用项目构建和项目二进制目录。这些是相同的，并不意味着引用 `bin/` 目录。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:392
#: Starting
msgid ""
"We used :command:`target_include_directories` to specify where the "
"executable target should look for include files."
msgstr "我们使用 :command:`target_include_directories` 来指定可执行目标应该在哪里寻找包含文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Basic
#: Library.rst:351 Point.rst:399 Starting Testing.rst:303 a and
msgid "TODO 9: CMakeLists.txt"
msgstr "TODO 9：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:409
#: Starting
msgid ""
"``TutorialConfig.h.in`` is the input header file to be configured. When "
":command:`configure_file` is called from our ``CMakeLists.txt``, the "
"values for ``@Tutorial_VERSION_MAJOR@`` and ``@Tutorial_VERSION_MINOR@`` "
"will be replaced with the corresponding version numbers from the project "
"in ``TutorialConfig.h``."
msgstr ""
"``TutorialConfig.h.in`` 是要配置的输入头文件。当从我们的 CMakeLists.txt "
"调用 :command:`configure_file` 时， ``@Tutorial_VERSION_MAJOR@`` 和 "
"``@Tutorial_VERSION_MINOR@`` 的值将被替换为 ` `TutorialConfig.h``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:419
#: Starting
msgid "TODO 10: TutorialConfig.h.in"
msgstr "TODO 10：TutorialConfig.h.in"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:429
#: Starting
msgid ""
"Next, we need to modify ``tutorial.cxx`` to include the configured header "
"file, ``TutorialConfig.h``."
msgstr "接下来，我们需要修改 ``tutorial.cxx`` 以包含配置的头文件 ``TutorialConfig.h``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:436
#: Starting
msgid "TODO 11: tutorial.cxx"
msgstr "TODO 11：tutorial.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A Basic Point.rst:445
#: Starting
msgid ""
"Finally, we print out the executable name and version number by updating "
"``tutorial.cxx`` as follows:"
msgstr "最后，我们通过更新 ``tutorial.cxx`` 打印出可执行文件名称和版本号，如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/A
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Basic
#: Library.rst:408 Point.rst:452 Starting a
msgid "TODO 12 : tutorial.cxx"
msgstr "TODO 12：教程.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:2 Export
msgid "Step 11: Adding Export Configuration"
msgstr "步骤 11：添加导出配置"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:4 Export
msgid ""
"During :guide:`tutorial/Installing and Testing` of the tutorial we added "
"the ability for CMake to install the library and headers of the project. "
"During :guide:`tutorial/Packaging an Installer` we added the ability to "
"package up this information so it could be distributed to other people."
msgstr ""
"在本教程的 :guide:`tutorial/Installing and Testing` 期间，我们为 CMake "
"添加了安装项目库和标头的功能。在 :guide:`tutorial/Packaging an Installer` "
"期间，我们添加了打包此信息的功能，以便可以将其分发给其他人。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:9 Export
msgid ""
"The next step is to add the necessary information so that other CMake "
"projects can use our project, be it from a build directory, a local "
"install or when packaged."
msgstr "下一步是添加必要的信息，以便其他 CMake 项目可以使用我们的项目，无论是从构建目录、本地安装还是打包时。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:13 Export
msgid ""
"The first step is to update our :command:`install(TARGETS)` commands to "
"not only specify a ``DESTINATION`` but also an ``EXPORT``. The ``EXPORT`` "
"keyword generates a CMake file containing code to import all targets "
"listed in the install command from the installation tree. So let's go "
"ahead and explicitly ``EXPORT`` the ``MathFunctions`` library by updating "
"the ``install`` command in ``MathFunctions/CMakeLists.txt`` to look like:"
msgstr ""
"第一步是更新我们的 :command:`install(TARGETS)` 命令以不仅指定一个 ``DESTINATION`` 还指定一个 "
"``EXPORT``。 ``EXPORT`` 关键字生成一个 CMake "
"文件，其中包含用于从安装树导入安装命令中列出的所有目标的代码。因此，让我们继续并通过更新 "
"``MathFunctions/CMakeLists.txt`` 中的 ``install`` 命令来明确地 ``EXPORT`` "
"``MathFunctions`` 库，如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting Command
#: Configuration.rst:20 Configuration.rst:57 Custom Debug Export File.rst:29
#: File.rst:39 File.rst:50 File.rst:60 Generated Libraries.rst:36
#: Libraries.rst:70 Release.rst:39 Shared Static a and or
msgid "MathFunctions/CMakeLists.txt"
msgstr "数学函数/CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:26 Export
msgid ""
"Now that we have ``MathFunctions`` being exported, we also need to "
"explicitly install the generated ``MathFunctionsTargets.cmake`` file. This"
" is done by adding the following to the bottom of the top-level "
"``CMakeLists.txt``:"
msgstr ""
"现在我们已经导出了``MathFunctions``，我们还需要明确安装生成的``MathFunctionsTargets.cmake``文件。这是通过将以下内容添加到顶级“CMakeLists.txt”的底部来完成的："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Configuration.rst:30 Configuration.rst:80 Configuration.rst:97
#: Configuration.rst:111 Configuration.rst:120 Configuration.rst:132 Debug
#: Export Expressions.rst:103 Generator Installer.rst:14 Libraries.rst:22
#: Release.rst:19 Release.rst:28 Shared Static Testing.rst:141 an and or
msgid "CMakeLists.txt"
msgstr "CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:37 Export
msgid ""
"At this point you should try and run CMake. If everything is setup "
"properly you will see that CMake will generate an error that looks like:"
msgstr "此时您应该尝试运行 CMake。如果一切设置正确，您将看到 CMake 将生成如下所示的错误："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:49 Export
msgid ""
"What CMake is trying to say is that during generating the export "
"information it will export a path that is intrinsically tied to the "
"current machine and will not be valid on other machines. The solution to "
"this is to update the ``MathFunctions`` "
":command:`target_include_directories` to understand that it needs "
"different ``INTERFACE`` locations when being used from within the build "
"directory and from an install / package. This means converting the "
":command:`target_include_directories` call for ``MathFunctions`` to look "
"like:"
msgstr ""
"CMake "
"试图说明的是，在生成导出信息期间，它将导出一条与当前机器本质上相关的路径，并且在其他机器上无效。解决方案是更新``MathFunctions`` "
":command:`target_include_directories` 以了解它在构建目录和安装/包中使用时需要不同的``INTERFACE``"
" 位置。这意味着将对 `MathFunctions` 的 :command:`target_include_directories` "
"调用转换为如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:64 Export
msgid ""
"Once this has been updated, we can re-run CMake and verify that it doesn't"
" warn anymore."
msgstr "更新后，我们可以重新运行 CMake 并验证它不再发出警告。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:67 Export
msgid ""
"At this point, we have CMake properly packaging the target information "
"that is required but we will still need to generate a "
"``MathFunctionsConfig.cmake`` so that the CMake :command:`find_package` "
"command can find our project. So let's go ahead and add a new file to the "
"top-level of the project called ``Config.cmake.in`` with the following "
"contents:"
msgstr ""
"此时，我们已经让 CMake 正确打包了所需的目标信息，但我们仍需要生成一个 ``MathFunctionsConfig.cmake`` ，以便 "
"CMake:command:`find_package` "
"命令可以找到我们的项目。因此，让我们继续并在项目的顶层添加一个名为“Config.cmake.in”的新文件，其内容如下："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:73 Export
msgid "Config.cmake.in"
msgstr "Config.cmake.in"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:77 Export
msgid ""
"Then, to properly configure and install that file, add the following to "
"the bottom of the top-level ``CMakeLists.txt``:"
msgstr "然后，要正确配置和安装该文件，请将以下内容添加到顶层“CMakeLists.txt”的底部："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:88 Export
msgid ""
"Next, we execute the :command:`configure_package_config_file`.  This "
"command will configure a provided file but with a few specific differences"
" from the standard :command:`configure_file` way. To properly utilize this"
" function, the input file should have a single line with the text "
"``@PACKAGE_INIT@`` in addition to the content that is desired. That "
"variable will be replaced with a block of code which turns set values into"
" relative paths.  These values which are new can be referenced by the same"
" name but prepended with a ``PACKAGE_`` prefix."
msgstr ""
"接下来，我们执行 :command:`configure_package_config_file`。此命令将配置提供的文件，但与标准的 "
"configure_file "
"方式有一些具体差异。为了正确使用这个函数，输入文件除了需要的内容外，还应该有一行包含文本“@PACKAGE_INIT@”。该变量将替换为将设置值转换为相对路径的代码块。这些新值可以用相同的名称引用，但要加上“PACKAGE_”前缀。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:104 Export
msgid ""
"The :command:`write_basic_package_version_file` is next.  This command "
"writes a file which is used by :command:`find_package`, documenting the "
"version and compatibility of the desired package.  Here, we use the "
"``Tutorial_VERSION_*`` variables and say that it is compatible with "
"``AnyNewerVersion``, which denotes that this version or any higher one are"
" compatible with the requested version."
msgstr ""
":command:`write_basic_package_version_file` 是下一个。此命令写入一个由 "
":command:`find_package` 使用的文件，记录所需包的版本和兼容性。在这里，我们使用 ``Tutorial_VERSION_*``"
" 变量并表示它与 ``AnyNewerVersion`` 兼容，表示此版本或任何更高版本与请求的版本兼容。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:118 Export
msgid "Finally, set both generated files to be installed:"
msgstr "最后，设置要安装的两个生成的文件："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:127 Export
msgid ""
"At this point, we have generated a relocatable CMake Configuration for our"
" project that can be used after the project has been installed or "
"packaged. If we want our project to also be used from a build directory we"
" only have to add the following to the bottom of the top level "
"``CMakeLists.txt``:"
msgstr ""
"至此，我们已经为我们的项目生成了一个可重定位的CMake "
"Configuration，可以在项目安装或打包后使用。如果我们希望我们的项目也可以从构建目录中使用，我们只需将以下内容添加到顶层“CMakeLists.txt”的底部："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Configuration.rst:138 Export
msgid ""
"With this export call we now generate a ``MathFunctionsTargets.cmake``, "
"allowing the configured ``MathFunctionsConfig.cmake`` in the build "
"directory to be used by other projects, without needing it to be "
"installed."
msgstr ""
"通过这个导出调用，我们现在生成一个``MathFunctionsTargets.cmake``，允许其他项目使用构建目录中配置的``MathFunctionsConfig.cmake``，而无需安装它。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Expressions.rst:2
#: Generator
msgid "Step 4: Adding Generator Expressions"
msgstr "第 4 步：添加生成器表达式"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Expressions.rst:4
#: Generator
msgid ""
":manual:`Generator expressions <cmake-generator-expressions(7)>` are "
"evaluated during build system generation to produce information specific "
"to each build configuration."
msgstr ""
":manual:`生成器表达式 <cmake-generator-expressions(7)>` "
"在构建系统生成期间进行评估，以生成特定于每个构建配置的信息。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Expressions.rst:8
#: Generator
msgid ""
":manual:`Generator expressions <cmake-generator-expressions(7)>` are "
"allowed in the context of many target properties, such as "
":prop_tgt:`LINK_LIBRARIES`, :prop_tgt:`INCLUDE_DIRECTORIES`, "
":prop_tgt:`COMPILE_DEFINITIONS` and others. They may also be used when "
"using commands to populate those properties, such as "
":command:`target_link_libraries`, :command:`target_include_directories`, "
":command:`target_compile_definitions` and others."
msgstr ""
":manual:`生成器表达式 <cmake-generator-expressions(7)>` "
"在许多目标属性的上下文中是允许的，例如 :prop_tgt:`LINK_LIBRARIES` 、 :prop_tgt:`INCLUDE_DIRECTORIES` 、 :prop_tgt:`COMPILE_DEFINITIONS`"
" "
"和其他的。它们也可以在使用命令填充这些属性时使用，例如 :command:`target_link_libraries` 、 :command:`target_include_directories` 、 :command:`target_compile_definitions`"
" 等。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:15 Generator
msgid ""
":manual:`Generator expressions <cmake-generator-expressions(7)>`  may be "
"used to enable conditional linking, conditional definitions used when "
"compiling, conditional include directories and more. The conditions may be"
" based on the build configuration, target properties, platform information"
" or any other queryable information."
msgstr ""
":manual:`生成器表达式 <cmake-generator-expressions(7)>` "
"可用于启用条件链接、编译时使用的条件定义、条件包含目录等。这些条件可能基于构建配置、目标属性、平台信息或任何其他可查询信息。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:21 Generator
msgid ""
"There are different types of :manual:`generator expressions <cmake-"
"generator-expressions(7)>` including Logical, Informational, and Output "
"expressions."
msgstr ""
"有不同类型的 :manual:`generator expressions <cmake-generator-expressions(7)>` "
"包括逻辑、信息和输出表达式。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:25 Generator
msgid ""
"Logical expressions are used to create conditional output. The basic "
"expressions are the ``0`` and ``1`` expressions. A ``$<0:...>`` results in"
" the empty string, and ``<1:...>`` results in the content of ``...``.  "
"They can also be nested."
msgstr ""
"逻辑表达式用于创建条件输出。基本表达式是“0”和“1”表达式。 ``$<0:...>`` 导致空字符串，``<1:...>`` 导致``...`` "
"的内容。它们也可以嵌套。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:31 Generator
msgid "Exercise 1 - Setting the C++ Standard with Interface Libraries"
msgstr "练习 1 - 使用接口库设置 C++ 标准"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:33 Generator
msgid ""
"Before we use :manual:`generator expressions <cmake-generator-"
"expressions(7)>` let's refactor our existing code to use an ``INTERFACE`` "
"library. We will use that library in the next step to demonstrate a common"
" use for :manual:`generator expressions <cmake-generator-expressions(7)>`."
msgstr ""
"在我们使用 :manual:`generator expressions <cmake-generator-expressions(7)>` "
"之前，让我们重构我们现有的代码以使用 ``INTERFACE`` 库。我们将在下一步中使用该库来演示 :manual:`generator "
"expressions <cmake-generator-expressions(7)>` 的常见用法。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:41 Generator
msgid ""
"Add an ``INTERFACE`` library target to specify the required C++ standard."
msgstr "添加一个 ``INTERFACE`` 库目标来指定所需的 C++ 标准。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:46 Generator Library.rst:32 a
msgid ":command:`add_library`"
msgstr ":command:`add_library`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:47 Generator
msgid ":command:`target_compile_features`"
msgstr ":command:`target_compile_features`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:48 Generator Library.rst:35 a
msgid ":command:`target_link_libraries`"
msgstr ":command:`target_link_libraries`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Expressions.rst:54 Generator Introspection.rst:27 Library.rst:35
#: Library.rst:43 Requirements System Testing.rst:26 Usage a and for
msgid "``MathFunctions/CMakeLists.txt``"
msgstr "``MathFunctions/CMakeLists.txt``"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:59 Generator
msgid ""
"In this exercise, we will refactor our code to use an ``INTERFACE`` "
"library to specify the C++ standard."
msgstr "在本练习中，我们将重构我们的代码以使用 ``INTERFACE`` 库来指定 C++ 标准。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:62 Generator
msgid ""
"The starting source code is provided in the ``Step4`` directory. In this "
"exercise, complete ``TODO 1`` through ``TODO 3``."
msgstr "起始源代码在“Step4”目录中提供。在本练习中，完成“TODO 1”到“TODO 3”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:65 Generator
msgid ""
"Start by editing the top level ``CMakeLists.txt`` file. Construct an "
"``INTERFACE`` library target called ``tutorial_compiler_flags`` and "
"specify ``cxx_std_11`` as a target compiler feature."
msgstr ""
"首先编辑顶级“CMakeLists.txt”文件。构造一个名为“tutorial_compiler_flags”的“INTERFACE”库目标，并将“cxx_std_11”指定为目标编译器功能。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:69 Generator
msgid ""
"Modify ``CMakeLists.txt`` and ``MathFunctions/CMakeLists.txt`` so that all"
" targets have a :command:`target_link_libraries` call to "
"``tutorial_compiler_flags``."
msgstr ""
"修改 ``CMakeLists.txt`` 和 ``MathFunctions/CMakeLists.txt`` 以便所有目标都有一个 "
":command:`target_link_libraries` 调用 ``tutorial_compiler_flags`` 。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:76 Generator
msgid ""
"Make a new directory called ``Step4_build``, run the :manual:`cmake "
"<cmake(1)>` executable or the :manual:`cmake-gui <cmake-gui(1)>` to "
"configure the project and then build it with your chosen build tool or by "
"using ``cmake --build .`` from the build directory."
msgstr ""
"创建一个名为 ``Step4_build`` 的新目录，运行 :manual:`cmake <cmake(1)>` 可执行文件或 "
":manual:`cmake-gui <cmake-gui(1)>` 来配置项目，然后使用您选择的构建工具或使用构建目录中的 cmake "
"--build . 构建它。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:81 Generator
msgid "Here's a refresher of what that looks like from the command line:"
msgstr "这是看起来像来自命令行的复习："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:90 Generator Library.rst:76 Requirements Usage a for
msgid ""
"Next, use the newly built ``Tutorial`` and verify that it is working as "
"expected."
msgstr "接下来，使用新构建的 ``Tutorial`` 并验证它是否按预期工作。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:96 Generator
msgid ""
"Let's update our code from the previous step to use interface libraries to"
" set our C++ requirements."
msgstr "让我们更新上一步中的代码，以使用接口库来设置我们的 C++ 要求。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:99 Generator
msgid ""
"To start, we need to remove the two :command:`set` calls on the variables "
":variable:`CMAKE_CXX_STANDARD` and "
":variable:`CMAKE_CXX_STANDARD_REQUIRED`. The specific lines to remove are "
"as follows:"
msgstr ""
"首先，我们需要删除对变量 CMAKE_CXX_STANDARD 和 CMAKE_CXX_STANDARD_REQUIRED 的两个 "
":command:`set` 调用。具体删除的行如下："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:110 Generator
msgid ""
"Next, we need to create an interface library, ``tutorial_compiler_flags``."
" And then use :command:`target_compile_features` to add the compiler "
"feature ``cxx_std_11``."
msgstr ""
"接下来，我们需要创建一个接口库， ``tutorial_compiler_flags`` 。然后使用 :command:`target_compile_features`"
" 添加编译器特性 ``cxx_std_11`` 。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:130 Generator
msgid ""
"Finally, with our interface library set up, we need to link our executable"
" ``Target`` and our ``MathFunctions`` library to our new "
"``tutorial_compiler_flags`` library. Respectively, the code will look like"
" this:"
msgstr ""
"最后，设置好接口库后，我们需要将可执行的“Target”和“MathFunctions”库链接到新的“tutorial_compiler_flags”库。相应地，代码将如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:150 Generator
msgid "and this:"
msgstr "和这个："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:156 Generator Introspection.rst:117 System
msgid "TODO 3: MathFunctions/CMakeLists.txt"
msgstr "TODO 3：MathFunctions/CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:167 Generator
msgid ""
"With this, all of our code still requires C++ 11 to build. Notice though "
"that with this method, it gives us the ability to be specific about which "
"targets get specific requirements. In addition, we create a single source "
"of truth in our interface library."
msgstr ""
"有了这个，我们所有的代码仍然需要 C++ 11 "
"来构建。请注意，尽管使用此方法，它使我们能够确定哪些目标获得特定要求。此外，我们在界面库中创建了单一事实来源。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:173 Generator
msgid ""
"Exercise 2 - Adding Compiler Warning Flags with Generator Expressions"
msgstr "练习 2 - 使用生成器表达式添加编译器警告标志"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:175 Generator
msgid ""
"A common usage of :manual:`generator expressions <cmake-generator-"
"expressions(7)>` is to conditionally add compiler flags, such as those for"
" language levels or warnings. A nice pattern is to associate this "
"information to an ``INTERFACE`` target allowing this information to "
"propagate."
msgstr ""
":manual:`generator expressions <cmake-generator-expressions(7)>` "
"的一个常见用法是有条件地添加编译器标志，例如用于语言级别或警告的标志。一个很好的模式是将此信息关联到允许此信息传播的“接口”目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:184 Generator
msgid ""
"Add compiler warning flags when building but not for installed versions."
msgstr "在构建时添加编译器警告标志，但不为已安装的版本添加。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:189 Generator
msgid ":manual:`cmake-generator-expressions(7)`"
msgstr ":manual:`cmake-generator-expressions(7)`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:192 Generator Library.rst:14 Requirements Usage a for
msgid ":command:`target_compile_options`"
msgstr ":command:`target_compile_options`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:202 Generator
msgid ""
"Start with the resulting files from Exercise 1. Complete ``TODO 4`` "
"through ``TODO 7``."
msgstr "从练习 1 的结果文件开始。完成“TODO 4”到“TODO 7”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:205 Generator
msgid ""
"First, in the top level ``CMakeLists.txt`` file, we need to set the "
":command:`cmake_minimum_required` to ``3.15``. In this exercise we are "
"going to use a generator expression which was introduced in CMake 3.15."
msgstr ""
"首先，在顶层 CMakeLists.txt 文件中，我们需要将 :command:`cmake_minimum_required` 设置为 "
"``3.15``。在本练习中，我们将使用 CMake 3.15 中引入的生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:209 Generator
msgid ""
"Next we add the desired compiler warning flags that we want for our "
"project. As warning flags vary based on the compiler, we use the "
"``COMPILE_LANG_AND_ID`` generator expression to control which flags to "
"apply given a language and a set of compiler ids."
msgstr ""
"接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器而异，我们使用 ``COMPILE_LANG_AND_ID`` "
"生成器表达式来控制给定语言和一组编译器 ID 应用哪些标志。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:217 Generator
msgid ""
"Since we have our build directory already configured from Exercise 1, "
"simply rebuild our code by calling the following:"
msgstr "由于我们已经从练习 1 中配置了构建目录，因此只需调用以下命令来重建我们的代码："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:228 Generator
msgid ""
"Update the :command:`cmake_minimum_required` to require at least CMake "
"version ``3.15``:"
msgstr "更新 :command:`cmake_minimum_required` 至少需要 CMake 版本 ``3.15``："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:235 Generator Library.rst:155 a
msgid "TODO 4: CMakeLists.txt"
msgstr "待办事项 4：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:245 Generator
msgid ""
"Next we determine which compiler our system is currently using to build "
"since warning flags vary based on the compiler we use. This is done with "
"the ``COMPILE_LANG_AND_ID`` generator expression. We set the result in the"
" variables ``gcc_like_cxx`` and ``msvc_cxx`` as follows:"
msgstr ""
"接下来我们确定我们的系统当前使用哪个编译器来构建，因为警告标志因我们使用的编译器而异。这是通过 ``COMPILE_LANG_AND_ID`` "
"生成器表达式完成的。我们将结果设置在变量“gcc_like_cxx”和“msvc_cxx”中，如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Expressions.rst:254 Generator Testing.rst:217 and
msgid "TODO 5: CMakeLists.txt"
msgstr "TODO 5：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:265 Generator
msgid ""
"Next we add the desired compiler warning flags that we want for our "
"project. Using our variables ``gcc_like_cxx`` and ``msvc_cxx``, we can use"
" another generator expression to apply the respective flags only when the "
"variables are true. We use :command:`target_compile_options` to apply "
"these flags to our interface library."
msgstr ""
"接下来，我们为项目添加所需的编译器警告标志。使用我们的变量``gcc_like_cxx`` "
"和``msvc_cxx``，我们可以使用另一个生成器表达式仅在变量为真时应用相应的标志。我们使用 "
":command:`target_compile_options` 将这些标志应用到我们的界面库中。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Expressions.rst:288 Generator
msgid ""
"Lastly, we only want these warning flags to be used during builds. "
"Consumers of our installed project should not inherit our warning flags. "
"To specify this, we wrap our flags in a generator expression using the "
"``BUILD_INTERFACE`` condition. The resulting full code looks like the "
"following:"
msgstr ""
"最后，我们只希望在构建期间使用这些警告标志。我们已安装项目的消费者不应继承我们的警告标志。为了指定这一点，我们使用 "
"``BUILD_INTERFACE`` 条件将标志包装在生成器表达式中。生成的完整代码如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:2
#: Support Testing a for
msgid "Step 6: Adding Support for a Testing Dashboard"
msgstr "第 6 步：添加对测试仪表板的支持"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:4
#: Support Testing a for
msgid ""
"Adding support for submitting our test results to a dashboard is simple. "
"We already defined a number of tests for our project in :ref:`Testing "
"Support <Tutorial Testing Support>`. Now we just have to run those tests "
"and submit them to CDash."
msgstr ""
"添加对将我们的测试结果提交到仪表板的支持很简单。我们已经在 :ref:`Testing Support <Tutorial Testing "
"Support>` 中为我们的项目定义了一些测试。现在我们只需运行这些测试并将它们提交给 CDash。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:11
#: Support Testing a for
msgid "Exercise 1 - Send Results to a Testing Dashboard"
msgstr "练习 1 - 将结果发送到测试仪表板"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:16
#: Support Testing a for
msgid "Display our CTest results with CDash."
msgstr "使用 CDash 显示我们的 CTest 结果。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:21
#: Support Testing a for
msgid ":manual:`ctest(1)`"
msgstr ":manual:`ctest(1)`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:22
#: Support Testing a for
msgid ":command:`include`"
msgstr ":command:`include`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:23
#: Support Testing a for
msgid ":module:`CTest`"
msgstr ":module:`CTest`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:33
#: Support Testing a for
msgid ""
"For this exercise, complete ``TODO 1`` in the top-level ``CMakeLists.txt``"
" by including the :module:`CTest` module. This will enable testing with "
"CTest as well as dashboard submissions to CDash, so we can safely remove "
"the call to :command:`enable_testing`."
msgstr ""
"对于本练习，通过包含 CTest 模块来完成顶层 CMakeLists.txt 中的 TODO 1。这将启用使用 CTest 进行测试以及向 "
"CDash 提交仪表板，因此我们可以安全地删除对 :command:`enable_testing` 的调用。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:38
#: Support Testing a for
msgid ""
"We will also need to acquire a ``CTestConfig.cmake`` file to be placed in "
"the top-level directory. When run, the :manual:`ctest <ctest(1)>` "
"executable will read this file to gather information about the testing "
"dashboard. It contains:"
msgstr ""
"我们还需要获取一个 ``CTestConfig.cmake`` 文件放置在顶级目录中。运行时， :manual:`ctest <ctest(1)>` "
"可执行文件将读取此文件以收集有关测试仪表板的信息。它包含了："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:42
#: Support Testing a for
msgid "The project name"
msgstr "项目名称"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:44
#: Support Testing a for
msgid "The project \"Nightly\" start time"
msgstr "项目“每晚”开始时间"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:46
#: Support Testing a for
msgid "The time when a 24 hour \"day\" starts for this project."
msgstr "此项目的 24 小时“一天”开始的时间。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:48
#: Support Testing a for
msgid ""
"The URL of the CDash instance where the submission's generated documents "
"will be sent"
msgstr "提交生成的文档将发送到的 CDash 实例的 URL"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:51
#: Support Testing a for
msgid ""
"For this tutorial, a public dashboard server is used and its corresponding"
" ``CTestConfig.cmake`` file is provided for you in this step's root "
"directory. In practice, this file would be downloaded from a project's "
"``Settings`` page on the CDash instance intended to host the test results."
" Once downloaded from CDash, the file should not be modified locally."
msgstr ""
"对于本教程，使用了一个公共仪表板服务器，并在此步骤的根目录中为您提供了相应的“CTestConfig.cmake”文件。实际上，该文件将从旨在托管测试结果的"
" CDash 实例上的项目“设置”页面下载。从 CDash 下载后，不应在本地修改该文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:57
#: Support Testing a for
msgid "CTestConfig.cmake"
msgstr "CTestConfig.cmake"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:66
#: Support Testing a for
msgid ""
"Note that as part of the CDash submission some information about your "
"development system (e.g. site name or full pathnames) may displayed "
"publicly."
msgstr "请注意，作为 CDash 提交的一部分，有关您的开发系统的一些信息（例如站点名称或完整路径名）可能会公开显示。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:69
#: Support Testing a for
msgid ""
"To create a simple test dashboard, run the :manual:`cmake <cmake(1)>` "
"executable or the :manual:`cmake-gui <cmake-gui(1)>` to configure the "
"project but do not build it yet. Instead, navigate to the build directory "
"and run:"
msgstr ""
"要创建一个简单的测试仪表板，请运行 :manual:`cmake <cmake(1)>` 可执行文件或 :manual:`cmake-gui "
"<cmake-gui(1)>` 来配置项目，但先不要构建它.相反，导航到构建目录并运行："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:77
#: Support Testing a for
msgid ""
"Remember, for multi-config generators (e.g. Visual Studio), the "
"configuration type must be specified:"
msgstr "请记住，对于多配置生成器（例如虚拟实验室），必须指定配置类型："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:84
#: Support Testing a for
msgid "Or, from an IDE, build the ``Experimental`` target."
msgstr "或者，从集成开发环境构建“实验”目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:86
#: Support Testing a for
msgid ""
"The :manual:`ctest <ctest(1)>` executable will build the project, run any "
"tests, and submit the results to Kitware's public dashboard: "
"https://my.cdash.org/index.php?project=CMakeTutorial."
msgstr ""
":manual:`ctest <ctest(1)>` 可执行文件将构建项目，运行任何测试，并将结果提交到 Kitware "
"的公共仪表板:https://my.cdash.org/index.php?project=CMakeTutorial。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Dashboard.rst:93
#: Support Testing a for
msgid ""
"The only CMake code changed needed in this step was to enable dashboard "
"submissions to CDash by including the :module:`CTest` module in our top-"
"level ``CMakeLists.txt``:"
msgstr ""
"此步骤中唯一需要更改的 CMake 代码是通过在我们的顶级 ``CMakeLists.txt`` 中包含:module:`CTest` 模块来启用向"
" CDash 的仪表板提交："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:2 System
msgid "Step 7: Adding System Introspection"
msgstr "第 7 步：添加系统自检"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:4 System
msgid ""
"Let us consider adding some code to our project that depends on features "
"the target platform may not have. For this example, we will add some code "
"that depends on whether or not the target platform has the ``log`` and "
"``exp`` functions. Of course almost every platform has these functions but"
" for this tutorial assume that they are not common."
msgstr ""
"让我们考虑向我们的项目添加一些代码，这些代码取决于目标平台可能没有的功能。对于这个例子，我们将添加一些代码，这取决于目标平台是否有 ``log`` "
"和 ``exp`` 函数。当然几乎每个平台都有这些功能，但在本教程中假设它们并不常见。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:11 System
msgid "Exercise 1 - Assessing Dependency Availability"
msgstr "练习 1 - 评估依赖可用性"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:16 System
msgid "Change implementation based on available system dependencies."
msgstr "根据可用的系统依赖项更改实现。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:21 System
msgid ":module:`CheckCXXSourceCompiles`"
msgstr ":module:`CheckCXXSourceCompiles`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:22 Library.rst:13 Requirements System Usage a for
msgid ":command:`target_compile_definitions`"
msgstr ":command:`target_compile_definitions`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:28 System
msgid "``MathFunctions/mysqrt.cxx``"
msgstr "``MathFunctions/mysqrt.cxx``"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:33 System
msgid ""
"The starting source code is provided in the ``Step7`` directory. In this "
"exercise, complete ``TODO 1`` through ``TODO 5``."
msgstr "起始源代码在“Step7”目录中提供。在本练习中，完成“TODO 1”到“TODO 5”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:36 System
msgid ""
"Start by editing ``MathFunctions/CMakeLists.txt``. Include the "
":module:`CheckCXXSourceCompiles` module. Then, use "
"``check_cxx_source_compiles`` to determine whether ``log`` and ``exp`` are"
" available from ``cmath``. If they are available, use "
":command:`target_compile_definitions` to specify ``HAVE_LOG`` and "
"``HAVE_EXP`` as compile definitions."
msgstr ""
"首先编辑``MathFunctions/CMakeLists.txt``。包括 :module:`CheckCXXSourceCompiles` "
"模块。然后，使用 ``check_cxx_source_compiles`` 确定 ``log`` 和 ``exp`` 是否可从 ``cmath``"
" 获得。如果它们可用，请使用 :command:`target_compile_definitions` 指定 ``HAVE_LOG`` 和 "
"``HAVE_EXP`` 作为编译定义。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:43 System
msgid ""
"In the ``MathFunctions/mysqrt.cxx``, include ``cmath``. Then, if the "
"system has ``log`` and ``exp``, use them to compute the square root."
msgstr ""
"在“MathFunctions/mysqrt.cxx”中，包含“cmath”。然后，如果系统有 ``log`` 和 "
"``exp``，用它们来计算平方根。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:49 System
msgid ""
"Make a new directory called ``Step7_build``. Run the :manual:`cmake  "
"<cmake(1)>` executable or the :manual:`cmake-gui <cmake-gui(1)>` to "
"configure the project and then build it with your chosen build tool and "
"run the ``Tutorial`` executable."
msgstr ""
"创建一个名为“Step7_build”的新目录。运行 :manual:`cmake <cmake(1)>` 可执行文件或 "
":manual:`cmake-gui <cmake-gui(1)>` 来配置项目，然后使用您选择的构建工具构建它并运行 ` `教程``可执行文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:54 System
msgid "This can look like the following:"
msgstr "这可能类似于以下内容："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:63 System
msgid "Which function gives better results now, ``sqrt`` or ``mysqrt``?"
msgstr "现在哪个函数给出更好的结果，``sqrt`` 或 ``mysqrt``？"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:68 System
msgid ""
"In this exercise we will use functions from the "
":module:`CheckCXXSourceCompiles` module so first we must include it in "
"``MathFunctions/CMakeLists.txt``."
msgstr ""
"在本练习中，我们将使用 CheckCXXSourceCompiles 模块中的函数，因此首先我们必须将其包含在 "
"MathFunctions/CMakeLists.txt 中。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Introspection.rst:76 Library.rst:98 Library.rst:101 Requirements System
#: Testing.rst:107 Usage a and for
msgid "TODO 1: MathFunctions/CMakeLists.txt"
msgstr "TODO 1：MathFunctions/CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:87 System
msgid ""
"Then test for the availability of ``log`` and ``exp`` using "
"``check_cxx_compiles_source``. This function lets us try compiling simple "
"code with the required dependency prior to the true source code "
"compilation. The resulting variables ``HAVE_LOG`` and ``HAVE_EXP`` "
"represent whether those dependencies are available."
msgstr ""
"然后使用 ``check_cxx_compiles_source`` 测试 ``log`` 和 ``exp`` "
"的可用性。这个函数让我们在真正的源代码编译之前尝试编译具有所需依赖关系的简单代码。结果变量 ``HAVE_LOG`` 和 ``HAVE_EXP`` "
"表示这些依赖项是否可用。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Introspection.rst:97 System Testing.rst:124 and
msgid "TODO 2: MathFunctions/CMakeLists.txt"
msgstr "TODO 2：MathFunctions/CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:108 System
msgid ""
"Next, we need to pass these CMake variables to our source code. This way, "
"our source code can tell what resources are available. If both ``log`` and"
" ``exp`` are available, use :command:`target_compile_definitions` to "
"specify ``HAVE_LOG`` and ``HAVE_EXP`` as ``PRIVATE`` compile definitions."
msgstr ""
"接下来，我们需要将这些 CMake 变量传递给我们的源代码。这样，我们的源代码就可以知道哪些资源可用。如果 ``log`` 和 ``exp`` "
"都可用，请使用 :command:`target_compile_definitions` 将 ``HAVE_LOG`` 和 ``HAVE_EXP`` 指定为 "
"``PRIVATE`` 编译定义。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:128 System
msgid ""
"Since we may be using ``log`` and ``exp``, we need to modify "
"``mysqrt.cxx`` to include ``cmath``."
msgstr "由于我们可能会使用 ``log`` 和 ``exp``，因此我们需要修改 ``mysqrt.cxx`` 以包含 ``cmath``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:135 System
msgid "TODO 4: MathFunctions/mysqrt.cxx"
msgstr "TODO 4：MathFunctions/mysqrt.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:145 System
msgid ""
"If ``log`` and ``exp`` are available on the system, then use them to "
"compute the square root in the ``mysqrt`` function. The ``mysqrt`` "
"function in ``MathFunctions/mysqrt.cxx`` will look as follows:"
msgstr ""
"如果 ``log`` 和 ``exp`` 在系统上可用，则使用它们在 ``mysqrt`` 函数中计算平方根。 "
"``MathFunctions/mysqrt.cxx`` 中的``mysqrt`` 函数如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: Introspection.rst:153 System
msgid "TODO 5: MathFunctions/mysqrt.cxx"
msgstr "TODO 5：MathFunctions/mysqrt.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:2
#: Requirements Usage a for
msgid "Step 3: Adding Usage Requirements for a Library"
msgstr "第 3 步：添加库的使用要求"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:5
#: Requirements Usage a for
msgid "Exercise 1 - Adding Usage Requirements for a Library"
msgstr "练习 1 - 添加库的使用要求"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:7
#: Requirements Usage a for
msgid ""
":ref:`Usage requirements <Target Usage Requirements>` of a target "
"parameters allow for far better control over a library or executable's "
"link and include line while also giving more control over the transitive "
"property of targets inside CMake. The primary commands that leverage usage"
" requirements are:"
msgstr ""
":ref:`Usage requirements <Target Usage Requirements>` "
"目标参数允许更好地控制库或可执行文件的链接和包含行，同时还可以更好地控制 CMake 内部目标的传递属性。利用使用要求的主要命令是："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:16
#: Requirements Usage a for
msgid ":command:`target_link_directories`"
msgstr ":command:`target_link_directories`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:17
#: Requirements Usage a for
msgid ":command:`target_link_options`"
msgstr ":command:`target_link_options`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:18
#: Requirements Usage a for
msgid ":command:`target_precompile_headers`"
msgstr ":command:`target_precompile_headers`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:19
#: Requirements Usage a for
msgid ":command:`target_sources`"
msgstr ":command:`target_sources`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:25
#: Requirements Usage a for
msgid "Add usage requirements for a library."
msgstr "添加库的使用要求。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Library.rst:28 Requirements Testing.rst:19 Testing.rst:171 Usage a and
#: for
msgid "Helpful Materials"
msgstr "有用的材料"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:30
#: Requirements Usage a for
msgid ":variable:`CMAKE_CURRENT_SOURCE_DIR`"
msgstr ":variable:`CMAKE_CURRENT_SOURCE_DIR`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:41
#: Requirements Usage a for
msgid ""
"In this exercise, we will refactor our code from :guide:`tutorial/Adding a"
" Library` to use the modern CMake approach. We will let our library define"
" its own usage requirements so they are passed transitively to other "
"targets as necessary. In this case, ``MathFunctions`` will specify any "
"needed include directories itself. Then, the consuming target ``Tutorial``"
" simply needs to link to ``MathFunctions`` and not worry about any "
"additional include directories."
msgstr ""
"在本练习中，我们将重构来自 :guide:`tutorial/Adding a Library` 的代码以使用现代 CMake "
"方法。我们将让我们的库定义自己的使用要求，以便根据需要将它们传递给其他目标。在这种情况下，``MathFunctions`` "
"将自己指定任何需要的包含目录。然后，消费目标 ``Tutorial`` 只需要链接到 ``MathFunctions`` "
"而不必担心任何额外的包含目录。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:49
#: Requirements Usage a for
msgid ""
"The starting source code is provided in the ``Step3`` directory. In this "
"exercise, complete ``TODO 1`` through ``TODO 3``."
msgstr "起始源代码在“Step3”目录中提供。在本练习中，完成“TODO 1”到“TODO 3”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:52
#: Requirements Usage a for
msgid ""
"First, add a call to :command:`target_include_directories` in "
"``MathFunctions/CMakeLists``. Remember that "
":variable:`CMAKE_CURRENT_SOURCE_DIR` is the path to the source directory "
"currently being processed."
msgstr ""
"首先，在``MathFunctions/CMakeLists`` 中添加对 :command:`target_include_directories`"
" 的调用。请记住 :variable:`CMAKE_CURRENT_SOURCE_DIR` 是当前正在处理的源目录的路径。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:57
#: Requirements Usage a for
msgid ""
"Then, update (and simplify!) the call to "
":command:`target_include_directories` in the top-level ``CMakeLists.txt``."
msgstr "然后，更新（并简化！）对顶层 CMakeLists.txt 中的 target_include_directories 的调用。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:63
#: Requirements Usage a for
msgid ""
"Make a new directory called ``Step3_build``, run the :manual:`cmake "
"<cmake(1)>` executable or the :manual:`cmake-gui <cmake-gui(1)>` to "
"configure the project and then build it with your chosen build tool or by "
"using :option:`cmake --build . <cmake --build>` from the build directory. "
"Here's a refresher of what that looks like from the command line:"
msgstr ""
"创建一个名为 ``Step3_build`` 的新目录，运行 :manual:`cmake <cmake(1)>` 可执行文件或 "
":manual:`cmake-gui <cmake-gui(1)>` 来配置项目，然后使用您选择的构建工具或使用 :option:`cmake "
"--build 构建它。 <cmake --build>` 来自构建目录。这是从命令行看起来像的复习："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:82
#: Requirements Usage a for
msgid ""
"Let's update the code from the previous step to use the modern CMake "
"approach of usage requirements."
msgstr "让我们更新上一步中的代码，以使用现代 CMake 的使用要求方法。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:85
#: Requirements Usage a for
msgid ""
"We want to state that anybody linking to ``MathFunctions`` needs to "
"include the current source directory, while ``MathFunctions`` itself "
"doesn't. This can be expressed with an ``INTERFACE`` usage requirement. "
"Remember ``INTERFACE`` means things that consumers require but the "
"producer doesn't."
msgstr ""
"我们想声明任何链接到“MathFunctions”的人都需要包含当前源目录，而“MathFunctions”本身不需要。这可以用“接口”使用要求来表达。请记住“接口”意味着消费者需要但生产者不需要的东西。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:90
#: Requirements Usage a for
msgid ""
"At the end of ``MathFunctions/CMakeLists.txt``, use "
":command:`target_include_directories` with the ``INTERFACE`` keyword, as "
"follows:"
msgstr ""
"在``MathFunctions/CMakeLists.txt`` 的末尾，使用带有``INTERFACE`` "
"关键字的 :command:`target_include_directories`，如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:109
#: Requirements Usage a for
msgid ""
"Now that we've specified usage requirements for ``MathFunctions`` we can "
"safely remove our uses of the ``EXTRA_INCLUDES`` variable from the top-"
"level ``CMakeLists.txt``, here:"
msgstr ""
"现在我们已经为``MathFunctions``指定了使用要求，我们可以安全地从顶级``CMakeLists.txt``中删除我们对``EXTRA_INCLUDES``变量的使用，在这里："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:128
#: Requirements Usage a for
msgid "And here:"
msgstr "和这里："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:144
#: Requirements Usage a for
msgid ""
"Notice that with this technique, the only thing our executable target does"
" to use our library is call :command:`target_link_libraries` with the name"
" of the library target. In larger projects, the classic method of "
"specifying library dependencies manually becomes very complicated very "
"quickly."
msgstr ""
"请注意，使用这种技术，我们的可执行目标为使用我们的库所做的唯一事情就是使用库目标的名称调用 :command:`target_link_libraries`。在较大的项目中，手动指定库依赖项的经典方法很快就会变得非常复杂。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:2 Generated a and
msgid "Step 8: Adding a Custom Command and Generated File"
msgstr "步骤 8：添加自定义命令和生成的文件"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:4 Generated a and
msgid ""
"Suppose, for the purpose of this tutorial, we decide that we never want to"
" use the platform ``log`` and ``exp`` functions and instead would like to "
"generate a table of precomputed values to use in the ``mysqrt`` function. "
"In this section, we will create the table as part of the build process, "
"and then compile that table into our application."
msgstr ""
"假设，出于本教程的目的，我们决定永远不想使用平台“log”和“exp”函数，而是想生成一个预先计算的值表以在“mysqrt”中使用`功能。在本节中，我们将创建表作为构建过程的一部分，然后将该表编译到我们的应用程序中。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:10 Generated a and
msgid ""
"First, let's remove the check for the ``log`` and ``exp`` functions in "
"``MathFunctions/CMakeLists.txt``. Then remove the check for ``HAVE_LOG`` "
"and ``HAVE_EXP`` from ``mysqrt.cxx``. At the same time, we can remove "
":code:`#include <cmath>`."
msgstr ""
"首先，让我们删除对``MathFunctions/CMakeLists.txt`` 中的``log`` 和``exp`` 函数的检查。然后从 "
"mysqrt.cxx 中删除对 HAVE_LOG 和 HAVE_EXP 的检查。同时，我们可以删除 :code:`#include <cmath>`。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:15 Generated a and
msgid ""
"In the ``MathFunctions`` subdirectory, a new source file named "
"``MakeTable.cxx`` has been provided to generate the table."
msgstr "在“MathFunctions”子目录中，提供了一个名为“MakeTable.cxx”的新源文件来生成表格。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:18 Generated a and
msgid ""
"After reviewing the file, we can see that the table is produced as valid "
"C++ code and that the output filename is passed in as an argument."
msgstr "查看文件后，我们可以看到该表是作为有效的 C++ 代码生成的，并且输出文件名作为参数传入。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:21 Generated a and
msgid ""
"The next step is to add the appropriate commands to the "
"``MathFunctions/CMakeLists.txt`` file to build the MakeTable executable "
"and then run it as part of the build process. A few commands are needed to"
" accomplish this."
msgstr ""
"下一步是将适当的命令添加到“MathFunctions/CMakeLists.txt”文件以构建 MakeTable "
"可执行文件，然后将其作为构建过程的一部分运行。需要一些命令来完成此操作。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:26 Generated a and
msgid ""
"First, at the top of ``MathFunctions/CMakeLists.txt``, the executable for "
"``MakeTable`` is added as any other executable would be added."
msgstr ""
"首先，在``MathFunctions/CMakeLists.txt`` 的顶部，添加``MakeTable`` "
"的可执行文件，就像添加任何其他可执行文件一样。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:36 Generated a and
msgid ""
"Then we add a custom command that specifies how to produce ``Table.h`` by "
"running MakeTable."
msgstr "然后我们添加一个自定义命令，指定如何通过运行 MakeTable 来生成 ``Table.h``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:46 Generated a and
msgid ""
"Next we have to let CMake know that ``mysqrt.cxx`` depends on the "
"generated file ``Table.h``. This is done by adding the generated "
"``Table.h`` to the list of sources for the library MathFunctions."
msgstr ""
"接下来我们必须让 CMake 知道 ``mysqrt.cxx`` 依赖于生成的文件 ``Table.h``。这是通过将生成的 ``Table.h``"
" 添加到库 MathFunctions 的源列表中来完成的。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:57 Generated a and
msgid ""
"We also have to add the current binary directory to the list of include "
"directories so that ``Table.h`` can be found and included by "
"``mysqrt.cxx``."
msgstr "我们还必须将当前二进制目录添加到包含目录列表中，以便 ``table.h`` 可以被 ``mysqrt.cxx`` 找到并包含。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:67 Generated a and
msgid ""
"Now let's use the generated table. First, modify ``mysqrt.cxx`` to include"
" ``Table.h``. Next, we can rewrite the ``mysqrt`` function to use the "
"table:"
msgstr ""
"现在让我们使用生成的表。首先，修改 ``mysqrt.cxx`` 以包含 ``Table.h``。接下来，我们可以重写 ``mysqrt`` "
"函数来使用该表："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding
#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting Command Custom
#: File.rst:70 Generated Libraries.rst:45 Shared Static a and or
msgid "MathFunctions/mysqrt.cxx"
msgstr "MathFunctions/mysqrt.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:76 Generated Library.rst:73 a and
msgid ""
"Run the :manual:`cmake  <cmake(1)>` executable or the :manual:`cmake-gui "
"<cmake-gui(1)>` to configure the project and then build it with your "
"chosen build tool."
msgstr ""
"运行 :manual:`cmake <cmake(1)>` 可执行文件或 :manual:`cmake-gui <cmake-gui(1)>` "
"来配置项目，然后使用您选择的构建工具构建它。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:80 Generated a and
msgid ""
"When this project is built it will first build the ``MakeTable`` "
"executable. It will then run ``MakeTable`` to produce ``Table.h``. "
"Finally, it will compile ``mysqrt.cxx`` which includes ``Table.h`` to "
"produce the ``MathFunctions`` library."
msgstr ""
"构建此项目时，它将首先构建“MakeTable”可执行文件。然后它将运行“MakeTable”以生成“Table.h”。最后，它将编译包含 "
"Table.h 的 mysqrt.cxx 以生成 MathFunctions 库。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Command Custom
#: File.rst:85 Generated a and
msgid "Run the Tutorial executable and verify that it is using the table."
msgstr "运行 Tutorial 可执行文件并验证它是否正在使用该表。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:2 a
msgid "Step 2: Adding a Library"
msgstr "第 2 步：添加库"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:4 a
msgid ""
"At this point, we have seen how to create a basic project using CMake. In "
"this step, we will learn how to create and use a library in our project. "
"We will also see how to make the use of our library optional."
msgstr ""
"至此，我们已经了解了如何使用 CMake "
"创建一个基本项目。在这一步中，我们将学习如何在我们的项目中创建和使用库。我们还将看到如何使我们的库的使用成为可选的。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:9 a
msgid "Exercise 1 - Creating a Library"
msgstr "练习 1 - 创建库"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:11 a
msgid ""
"To add a library in CMake, use the :command:`add_library` command and "
"specify which source files should make up the library."
msgstr "要在 CMake 中添加库，请使用 :command:`add_library` 命令并指定应由哪些源文件组成库。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:14 a
msgid ""
"Rather than placing all of the source files in one directory, we can "
"organize our project with one or more subdirectories. In this case, we "
"will create a subdirectory specifically for our library. Here, we can add "
"a new ``CMakeLists.txt`` file and one or more source files. In the top "
"level ``CMakeLists.txt`` file, we will use the :command:`add_subdirectory`"
" command to add the subdirectory to the build."
msgstr ""
"我们可以用一个或多个子目录来组织我们的项目，而不是将所有源文件放在一个目录中。在这种情况下，我们将专门为我们的库创建一个子目录。在这里，我们可以添加一个新的"
" ``CMakeLists.txt`` 文件和一个或多个源文件。在顶层 ``CMakeLists.txt`` 文件中，我们将使用 "
":command:`add_subdirectory` 命令将子目录添加到构建中。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:21 a
msgid ""
"Once the library is created, it is connected to our executable target with"
" :command:`target_include_directories` and "
":command:`target_link_libraries`."
msgstr ""
"创建库后，它会通过 :command:`target_include_directories` 和 "
":command:`target_link_libraries` 连接到我们的可执行目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:27 a
msgid "Add and use a library."
msgstr "添加和使用库。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:33 a
msgid ":command:`add_subdirectory`"
msgstr ":command:`添加子目录`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:36 a
msgid ":variable:`PROJECT_SOURCE_DIR`"
msgstr ":variable:`PROJECT_SOURCE_DIR`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:48 a
msgid ""
"In this exercise, we will add a library to our project that contains our "
"own implementation for computing the square root of a number. The "
"executable can then use this library instead of the standard square root "
"function provided by the compiler."
msgstr ""
"在本练习中，我们将向我们的项目添加一个库，其中包含我们自己用于计算数字平方根的实现。然后可执行文件可以使用这个库而不是编译器提供的标准平方根函数。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:53 a
msgid ""
"For this tutorial we will put the library into a subdirectory called "
"``MathFunctions``. This directory already contains a header file, "
"``MathFunctions.h``, and a source file ``mysqrt.cxx``. We will not need to"
" modify either of these files. The source file has one function called "
"``mysqrt`` that provides similar functionality to the compiler's ``sqrt`` "
"function."
msgstr ""
"对于本教程，我们会将库放入名为“MathFunctions”的子目录中。该目录已经包含一个头文件“MathFunctions.h”和一个源文件“mysqrt.cxx”。我们不需要修改这些文件中的任何一个。源文件有一个名为“mysqrt”的函数，它提供与编译器的“sqrt”函数类似的功能。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:60 a
msgid ""
"From the ``Help/guide/tutorial/Step2`` directory, start with ``TODO 1`` "
"and complete through ``TODO 6``."
msgstr "在 ``Help/guide/tutorial/Step2`` 目录中，从 ``TODO 1`` 开始，完成 ``TODO 6``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:63 a
msgid ""
"First, fill in the one line ``CMakeLists.txt`` in the ``MathFunctions`` "
"subdirectory."
msgstr "首先，填写``MathFunctions`` 子目录中的一行``CMakeLists.txt``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:66 a
msgid "Next, edit the top level ``CMakeLists.txt``."
msgstr "接下来，编辑顶层“CMakeLists.txt”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:68 a
msgid ""
"Finally, use the newly created ``MathFunctions`` library in "
"``tutorial.cxx``"
msgstr "最后，在 ``tutorial.cxx`` 中使用新创建的 ``MathFunctions`` 库"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:77 a
msgid "Below is a refresher of what that looks like from the command line:"
msgstr "下面是从命令行看起来像什么的复习："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:86 a
msgid ""
"Try to use the newly built ``Tutorial`` and ensure that it is still "
"producing accurate square root values."
msgstr "尝试使用新建的 ``Tutorial`` 并确保它仍然生成准确的平方根值。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:92 a
msgid ""
"In the ``CMakeLists.txt`` file in the ``MathFunctions`` directory, we "
"create a library target called ``MathFunctions`` with "
":command:`add_library`. The source file for the library is passed as an "
"argument to :command:`add_library`. This looks like the following line:"
msgstr ""
"在 ``MathFunctions`` 目录下的 ``CMakeLists.txt`` 文件中，我们使用 "
":command:`add_library` 创建了一个名为 ``MathFunctions`` 的库目标。库的源文件作为参数传递给 "
":command:`add_library`。这看起来像下面一行："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:111 a
msgid ""
"To make use of the new library we will add an :command:`add_subdirectory` "
"call in the top-level ``CMakeLists.txt`` file so that the library will get"
" built."
msgstr "为了使用新库，我们将在顶级 CMakeLists.txt 文件中添加一个 add_subdirectory 调用，以便构建库。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:129 a
msgid ""
"Next, the new library target is linked to the executable target using "
":command:`target_link_libraries`."
msgstr "接下来，使用 target_link_libraries 将新库目标链接到可执行目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:146 a
msgid ""
"Finally we need to specify the library's header file location. Modify "
":command:`target_include_directories` to add the ``MathFunctions`` "
"subdirectory as an include directory so that the ``MathFunctions.h`` "
"header file can be found."
msgstr ""
"最后我们需要指定库的头文件位置。修改 :command:`target_include_directories` "
"以将 ``MathFunctions`` 子目录添加为包含目录，以便可以找到 ``MathFunctions.h`` 头文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:168 a
msgid ""
"Now let's use our library. In ``tutorial.cxx``, include "
"``MathFunctions.h``:"
msgstr "现在让我们使用我们的库。在 ``tutorial.cxx`` 中，包含 ``MathFunctions.h``："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:174 a
msgid "TODO 5 : tutorial.cxx"
msgstr "TODO 5：tutorial.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:184 a
msgid "Lastly, replace ``sqrt`` with our library function ``mysqrt``."
msgstr "最后，将 ``sqrt`` 替换为我们的库函数 ``mysqrt``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:190 a
msgid "TODO 6 : tutorial.cxx"
msgstr "TODO 6：tutorial.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:201 a
msgid "Exercise 2 - Making Our Library Optional"
msgstr "练习 2 - 让我们的图书馆成为可选的"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:203 a
msgid ""
"Now let us make the MathFunctions library optional. While for the tutorial"
" there really isn't any need to do so, for larger projects this is a "
"common occurrence."
msgstr "现在让我们将 MathFunctions 库设为可选。虽然对于教程来说确实没有必要这样做，但对于较大的项目来说这是很常见的事情。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:207 a
msgid ""
"CMake can do this using the :command:`option` command. This gives users a "
"variable which they can change when configuring their cmake build. This "
"setting will be stored in the cache so that the user does not need to set "
"the value each time they run CMake on a build directory."
msgstr ""
"CMake 可以使用 :command:`option` 命令来做到这一点。这为用户提供了一个变量，他们可以在配置他们的 cmake "
"构建时更改该变量。此设置将存储在缓存中，因此用户无需在每次在构建目录上运行 CMake 时都设置该值。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:215 a
msgid "Add the option to build without ``MathFunctions``."
msgstr "添加选项以在没有“MathFunctions”的情况下构建。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:221 a
msgid ":command:`if`"
msgstr ":command:`如果`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:222 a
msgid ":command:`list`"
msgstr ":command:`列表`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:223 a
msgid ":command:`option`"
msgstr ":command:`选项`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:224 a
msgid ":command:`cmakedefine <configure_file>`"
msgstr ":command:`cmakedefine <配置文件>`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:231 a
msgid "``TutorialConfig.h.in``"
msgstr "``TutorialConfig.h.in``"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:236 a
msgid ""
"Start with the resulting files from Exercise 1. Complete ``TODO 7`` "
"through ``TODO 13``."
msgstr "从练习 1 的结果文件开始。完成“TODO 7”到“TODO 13”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:239 a
msgid ""
"First create a variable ``USE_MYMATH`` using the :command:`option` command"
" in the top-level ``CMakeLists.txt`` file. In that same file, use that "
"option to determine whether to build and use the ``MathFunctions`` "
"library."
msgstr ""
"首先在顶层 ``CMakeLists.txt`` 文件中使用 :command:`option` 命令创建一个变量 "
"``USE_MYMATH``。在同一个文件中，使用该选项来确定是否构建和使用“MathFunctions”库。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:243 a
msgid ""
"Then, update ``tutorial.cxx`` and ``TutorialConfig.h.in`` to use "
"``USE_MYMATH``."
msgstr ""
"然后，更新 ``tutorial.cxx`` 和 ``TutorialConfig.h.in`` 以使用 ``USE_MYMATH``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:249 a
msgid ""
"Since we have our build directory already configured from Exercise 1, we "
"can rebuild by simply calling the following:"
msgstr "由于我们已经从练习 1 中配置了构建目录，我们可以通过简单地调用以下命令来重建："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:257 a
msgid ""
"Next, run the ``Tutorial`` executable on a few numbers to verify that it's"
" still correct."
msgstr "接下来，对几个数字运行“教程”可执行文件以验证它是否仍然正确。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:260 a
msgid ""
"Now let's update the value of ``USE_MYMATH`` to ``OFF``. The easiest way "
"is to use the :manual:`cmake-gui <cmake-gui(1)>` or  :manual:`ccmake "
"<ccmake(1)>` if you're in the terminal. Or, alternatively, if you want to "
"change the option from the command-line, try:"
msgstr ""
"现在让我们将 ``USE_MYMATH`` 的值更新为 ``OFF``。最简单的方法是使用 :manual:`cmake-gui <cmake-"
"gui(1)>` 或 :manual:`ccmake <ccmake(1)>` 如果您在终端中。或者，如果您想从命令行更改选项，请尝试："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:269 a
msgid "Now, rebuild the code with the following:"
msgstr "现在，使用以下内容重建代码："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:275 a
msgid ""
"Then, run the executable again to ensure that it still works with "
"``USE_MYMATH`` set to ``OFF``. Which function gives better results, "
"``sqrt`` or ``mysqrt``?"
msgstr ""
"然后，再次运行可执行文件以确保它仍然可以在“USE_MYMATH”设置为“OFF”的情况下工作。哪个函数给出更好的结果，``sqrt`` 或 "
"``mysqrt``？"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:282 a
msgid ""
"The first step is to add an option to the top-level ``CMakeLists.txt`` "
"file. This option will be displayed in the :manual:`cmake-gui <cmake-"
"gui(1)>` and :manual:`ccmake <ccmake(1)>` with a default value of ``ON`` "
"that can be changed by the user."
msgstr ""
"第一步是向顶级“CMakeLists.txt”文件添加一个选项。此选项将显示在 :manual:`cmake-gui <cmake-gui(1)>`"
" 和 :manual:`ccmake <ccmake(1)>` 中，默认值为 ``ON`` 可以更改由用户。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:302 a
msgid ""
"Next, make building and linking the ``MathFunctions`` library conditional."
msgstr "接下来，使构建和链接“MathFunctions”库成为条件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:305 a
msgid ""
"Start by creating a :command:`list` of the optional library targets for "
"our project. At the moment, it is just ``MathFunctions``. Let's name our "
"list ``EXTRA_LIBS``."
msgstr ""
"首先为我们的项目创建可选库目标的 "
":command:`list`。目前，它只是``MathFunctions``。让我们将列表命名为“EXTRA_LIBS”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:309 a
msgid ""
"Similarly, we need to make a :command:`list` for the optional includes "
"which we will call ``EXTRA_INCLUDES``. In this list, we will ``APPEND`` "
"the path of the header file needed for our library."
msgstr ""
"同样，我们需要为可选的包含创建一个 :command:`list`，我们将其称为 "
"EXTRA_INCLUDES。在此列表中，我们将“附加”我们的库所需的头文件的路径。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:313 a
msgid ""
"Next, create an :command:`if` statement which checks the value of "
"``USE_MYMATH``. Inside the :command:`if` block, put the "
":command:`add_subdirectory` command from Exercise 1 with the additional "
":command:`list` commands."
msgstr ""
"接下来，创建一个 :command:`if` 语句来检查 ``USE_MYMATH`` 的值。在 :command:`if` 块内，将练习 1 中的"
" :command:`add_subdirectory` 命令与其他 :command:`list` 命令放在一起。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:318 a
msgid ""
"When ``USE_MYMATH`` is ``ON``, the lists will be generated and will be "
"added to our project. When ``USE_MYMATH`` is ``OFF``, the lists stay "
"empty. With this strategy, we allow users to toggle ``USE_MYMATH`` to "
"manipulate what library is used in the build."
msgstr ""
"当“USE_MYMATH”为“ON”时，将生成列表并将其添加到我们的项目中。当“USE_MYMATH”为“OFF”时，列表保持为空。通过这种策略，我们允许用户切换“USE_MYMATH”来操纵构建中使用的库。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:323 a
msgid "The top-level CMakeLists.txt file will now look like the following:"
msgstr "顶级 CMakeLists.txt 文件现在如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:340 a
msgid ""
"Now that we have these two lists, we need to update "
":command:`target_link_libraries` and :command:`target_include_directories`"
" to use them. Changing them is fairly straightforward."
msgstr ""
"现在我们有了这两个列表，我们需要更新 :command:`target_link_libraries` 和 "
":command:`target_include_directories` 来使用它们。更改它们非常简单。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:344 a
msgid ""
"For :command:`target_link_libraries`, we replace the written out library "
"names with ``EXTRA_LIBS``. This looks like the following:"
msgstr ""
"对于 :command:`target_link_libraries`，我们将写出的库名称替换为 ``EXTRA_LIBS``。这看起来像下面这样："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:362 a
msgid ""
"Then, we do the same thing with :command:`target_include_directories` and "
"``EXTRA_INCLUDES``."
msgstr ""
"然后，我们对 :command:`target_include_directories` 和 ``EXTRA_INCLUDES`` 做同样的事情。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:369 a
msgid "TODO 10 : CMakeLists.txt"
msgstr "TODO 10：CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:379 a
msgid ""
"Note that this is a classic approach when dealing with many components. We"
" will cover the modern approach in the Step 3 of the tutorial."
msgstr "请注意，这是处理许多组件时的经典方法。我们将在本教程的第 3 步中介绍现代方法。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:382 a
msgid ""
"The corresponding changes to the source code are fairly straightforward. "
"First, in ``tutorial.cxx``, we include the ``MathFunctions.h`` header if "
"``USE_MYMATH`` is defined."
msgstr ""
"对源代码的相应更改非常简单。首先，在 ``tutorial.cxx`` 中，如果定义了 ``USE_MYMATH``，我们会包含 "
"``MathFunctions.h`` 头文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:390 a
msgid "TODO 11 : tutorial.cxx"
msgstr "TODO 11：教程.cxx"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:401 a
msgid ""
"Then, in the same file, we make ``USE_MYMATH`` control which square root "
"function is used:"
msgstr "然后，在同一个文件中，我们让 ``USE_MYMATH`` 控制使用哪个平方根函数："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:419 a
msgid ""
"Since the source code now requires ``USE_MYMATH`` we can add it to "
"``TutorialConfig.h.in`` with the following line:"
msgstr "由于源代码现在需要``USE_MYMATH``，我们可以使用以下行将其添加到``TutorialConfig.h.in``："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:426 a
msgid "TODO 13 : TutorialConfig.h.in"
msgstr "TODO 13：TutorialConfig.h.in"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:436 a
msgid ""
"With these changes, our library is now completely optional to whoever is "
"building and using it."
msgstr "通过这些更改，我们的库现在对于构建和使用它的任何人来说都是完全可选的。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:440 a
msgid "Bonus Question"
msgstr "奖金问题"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:442 a
msgid ""
"Why is it important that we configure ``TutorialConfig.h.in`` after the "
"option for ``USE_MYMATH``? What would happen if we inverted the two?"
msgstr "为什么在“USE_MYMATH”选项之后配置“TutorialConfig.h.in”很重要？如果我们将两者倒置会发生什么？"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:446 a
msgid "Answer"
msgstr "回答"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Adding Library.rst:452 a
msgid ""
"We configure after because ``TutorialConfig.h.in`` uses the value of "
"``USE_MYMATH``. If we configure the file before calling :command:`option`,"
" we won't be using the expected value of ``USE_MYMATH``."
msgstr ""
"我们在之后进行配置，因为 ``TutorialConfig.h.in`` 使用了 ``USE_MYMATH`` 的值。如果我们在调用 "
":command:`option` 之前配置文件，我们将不会使用 ``USE_MYMATH`` 的预期值。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Testing.rst:2
#: and
msgid "Step 5: Installing and Testing"
msgstr "第 5 步：安装和测试"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Testing.rst:5
#: and
msgid "Exercise 1 - Install Rules"
msgstr "练习 1 - 安装规则"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing Testing.rst:7
#: and
msgid ""
"Often, it is not enough to only build an executable, it should also be "
"installable. With CMake, we can specify install rules using the "
":command:`install` command. Supporting local installations for your builds"
" in CMake is often as simple as specifying an install location and the "
"targets and files to be installed."
msgstr ""
"通常，仅仅构建一个可执行文件是不够的，它还应该是可安装的。使用 CMake，我们可以使用 :command:`install` 命令指定安装规则。在"
" CMake 中为您的构建支持本地安装通常与指定安装位置以及要安装的目标和文件一样简单。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:16 and
msgid ""
"Install the ``Tutorial`` executable and the ``MathFunctions`` library."
msgstr "安装 ``Tutorial`` 可执行文件和 ``MathFunctions`` 库。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:21 and
msgid ":command:`install`"
msgstr ":command:`安装`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:32 and
msgid ""
"The starting code is provided in the ``Step5`` directory. In this "
"exercise, complete ``TODO 1`` through ``TODO 4``."
msgstr "起始代码在“Step5”目录中提供。在本练习中，完成“TODO 1”到“TODO 4”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:35 and
msgid ""
"First, update ``MathFunctions/CMakeLists.txt`` to install the "
"``MathFunctions`` and ``tutorial_compiler_flags`` libraries to the ``lib``"
" directory. In that same file, specify the install rules needed to install"
" ``MathFunctions.h`` to the ``include`` directory."
msgstr ""
"首先，更新``MathFunctions/CMakeLists.txt`` 以将``MathFunctions`` "
"和``tutorial_compiler_flags`` 库安装到``lib`` "
"目录。在同一文件中，指定将“MathFunctions.h”安装到“include”目录所需的安装规则。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:40 and
msgid ""
"Then, update the top level ``CMakeLists.txt`` to install the ``Tutorial`` "
"executable to the ``bin`` directory. Lastly, any header files should be "
"installed to the ``include`` directory. Remember that ``TutorialConfig.h``"
" is in the :variable:`PROJECT_BINARY_DIR`."
msgstr ""
"然后，更新顶层 ``CMakeLists.txt`` 以将 ``Tutorial`` 可执行文件安装到 ``bin`` "
"目录。最后，任何头文件都应该安装到 ``include`` 目录中。请记住，``TutorialConfig.h`` 在 "
":variable:`PROJECT_BINARY_DIR` 中。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:48 and
msgid ""
"Make a new directory called ``Step5_build``. Run the :manual:`cmake "
"<cmake(1)>` executable or the :manual:`cmake-gui <cmake-gui(1)>` to "
"configure the project and then build it with your chosen build tool."
msgstr ""
"创建一个名为“Step5_build”的新目录。运行 :manual:`cmake <cmake(1)>` 可执行文件或 "
":manual:`cmake-gui <cmake-gui(1)>` 来配置项目，然后使用您选择的构建工具构建它。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:53 and
msgid ""
"Then, run the install step by using the :option:`--install <cmake "
"--install>` option of the :manual:`cmake  <cmake(1)>` command (introduced "
"in 3.15, older versions of CMake must use ``make install``) from the "
"command line. This step will install the appropriate header files, "
"libraries, and executables. For example:"
msgstr ""
"然后，使用 :option:`--install <cmake --install>` 命令的 :option:`cmake <cmake(1)>`"
" 选项运行安装步骤（在 3.15 中引入，旧版本的 CMake 必须使用``make install``) "
"从命令行。此步骤将安装适当的头文件、库和可执行文件。例如："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:63 and
msgid ""
"For multi-configuration tools, don't forget to use the :option:`--config "
"<cmake--build --config>` argument to specify the configuration."
msgstr "对于多配置工具，不要忘记使用 :option:`--config <cmake--build --config>` 参数来指定配置。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:70 and
msgid ""
"If using an IDE, simply build the ``INSTALL`` target. You can build the "
"same install target from the command line like the following:"
msgstr "如果使用集成开发环境，只需构建 ``INSTALL`` 目标。您可以从命令行构建相同的安装目标，如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:77 and
msgid ""
"The CMake variable :variable:`CMAKE_INSTALL_PREFIX` is used to determine "
"the root of where the files will be installed. If using the :option:`cmake"
" --install` command, the installation prefix can be overridden via the "
":option:`--prefix <cmake--install --prefix>` argument. For example:"
msgstr ""
"CMake 变量 :variable:`CMAKE_INSTALL_PREFIX` 用于确定将安装文件的根目录。如果使用 "
":option:`cmake --install` 命令，可以通过 :option:`--prefix <cmake--install "
"--prefix>` 参数覆盖安装前缀。例如："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:86 and
msgid ""
"Navigate to the install directory and verify that the installed "
"``Tutorial`` runs."
msgstr "导航到安装目录并验证安装的“教程”是否运行。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:92 and
msgid "The install rules for our project are fairly simple:"
msgstr "我们项目的安装规则非常简单："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:94 and
msgid ""
"For ``MathFunctions``, we want to install the libraries and header file to"
" the ``lib`` and ``include`` directories respectively."
msgstr "对于``MathFunctions``，我们要将库和头文件分别安装到``lib`` 和``include`` 目录。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:97 and
msgid ""
"For the ``Tutorial`` executable, we want to install the executable and "
"configured header file to the ``bin`` and ``include`` directories "
"respectively."
msgstr ""
"对于 ``Tutorial`` 可执行文件，我们要将可执行文件和配置的头文件分别安装到 ``bin`` 和 ``include`` 目录。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:101 and
msgid "So to the end of ``MathFunctions/CMakeLists.txt`` we add:"
msgstr "所以在``MathFunctions/CMakeLists.txt`` 的末尾我们添加："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:118 and
msgid "and"
msgstr "和"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:134 and
msgid ""
"The install rules for the ``Tutorial`` executable and configured header "
"file are similar. To the end of the top-level ``CMakeLists.txt`` we add:"
msgstr "``Tutorial`` 可执行文件和配置的头文件的安装规则是相似的。在顶层“CMakeLists.txt”的末尾，我们添加："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:152 and
msgid ""
"That is all that is needed to create a basic local install of the "
"tutorial."
msgstr "这就是创建本教程的基本本地安装所需的全部内容。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:158 and
msgid "Exercise 2 - Testing Support"
msgstr "练习 2 - 测试支持"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:160 and
msgid ""
"CTest offers a way to easily manage tests for your project. Tests can be "
"added through the :command:`add_test` command. Although it is not "
"explicitly covered in this tutorial, there is a lot of compatibility "
"between CTest and other testing frameworks such as :module:`GoogleTest`."
msgstr ""
"CTest 提供了一种轻松管理项目测试的方法。可以通过 :command:`add_test` 命令添加测试。尽管本教程中没有明确涵盖，但 "
"CTest 与其他测试框架（例如:module:`GoogleTest`）之间存在很多兼容性。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:168 and
msgid "Create unit tests for our executable using CTest."
msgstr "使用 CTest 为我们的可执行文件创建单元测试。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:173 and
msgid ":command:`enable_testing`"
msgstr ":command:`enable_testing`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:174 and
msgid ":command:`add_test`"
msgstr ":command:`add_test`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:175 and
msgid ":command:`function`"
msgstr ":command:`功能`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:176 and
msgid ":command:`set_tests_properties`"
msgstr ":command:`set_tests_properties`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:177 and
msgid ":manual:`ctest <ctest(1)>`"
msgstr ":manual:`ctest <ctest(1)>`"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:187 and
msgid ""
"The starting source code is provided in the ``Step5`` directory. In this "
"exercise, complete ``TODO 5`` through ``TODO 9``."
msgstr "起始源代码在“Step5”目录中提供。在本练习中，完成“TODO 5”到“TODO 9”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:190 and
msgid ""
"First, we need to enable testing. Next, begin adding tests to our project "
"using :command:`add_test`. We will work through adding 3 simple tests and "
"then you can add additional testing as you see fit."
msgstr ""
"首先，我们需要启用测试。接下来，开始使用 :command:`add_test` 向我们的项目添加测试。我们将通过添加 3 "
"个简单测试来工作，然后您可以根据需要添加其他测试。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:197 and
msgid ""
"Navigate to the build directory and rebuild the application. Then, run the"
" :program:`ctest` executable: :option:`ctest -N` and :option:`ctest -VV`. "
"For multi-config generators (e.g. Visual Studio), the configuration type "
"must be specified with the :option:`-C \\<mode\\> <ctest -C>` flag.  For "
"example, to run tests in Debug mode use ``ctest -C Debug -VV`` from the "
"build directory (not the Debug subdirectory!). Release mode would be "
"executed from the same location but with a ``-C Release``. Alternatively, "
"build the ``RUN_TESTS`` target from the IDE."
msgstr ""
"导航到构建目录并重建应用程序。然后，运行 :program:`ctest` 可执行文件：:option:`ctest -N` 和:option:`ctest "
"-VV`。对于多配置生成器（例如虚拟实验室），必须使用 :option:`-C \\<mode\\> <ctest -C>` "
"标志指定配置类型。例如，要在调试模式下运行测试，请使用构建目录（不是调试子目录！）中的“ctest -C Debug "
"-VV”。发布模式将从相同的位置执行，但使用“-C Release”。或者，从集成开发环境构建“RUN_TESTS”目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:209 and
msgid ""
"Let's test our application. At the end of the top-level ``CMakeLists.txt``"
" file we first need to enable testing with the :command:`enable_testing` "
"command."
msgstr ""
"让我们测试我们的应用程序。在顶级``CMakeLists.txt`` 文件的末尾，我们首先需要使用 "
":command:`enable_testing` 命令启用测试。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:228 and
msgid ""
"With testing enabled, we will add a number of basic tests to verify that "
"the application is working correctly. First, we create a test using "
":command:`add_test` which runs the ``Tutorial`` executable with the "
"parameter 25 passed in. For this test, we are not going to check the "
"executable's computed answer. This test will verify that application runs,"
" does not segfault or otherwise crash, and has a zero return value. This "
"is the basic form of a CTest test."
msgstr ""
"启用测试后，我们将添加一些基本测试来验证应用程序是否正常工作。首先，我们使用 :command:`add_test` 创建一个测试，它运行传入参数 "
"25 的 ``Tutorial`` "
"可执行文件。对于此测试，我们不打算检查可执行文件的计算结果。此测试将验证应用程序是否运行、没有出现段错误或以其他方式崩溃，并且返回值为零。这是 "
"CTest 测试的基本形式。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:251 and
msgid ""
"Next, let's use the :prop_test:`PASS_REGULAR_EXPRESSION` test property to "
"verify that the output of the test contains certain strings. In this case,"
" verifying that the usage message is printed when an incorrect number of "
"arguments are provided."
msgstr ""
"接下来，让我们使用 :prop_test:`PASS_REGULAR_EXPRESSION` "
"测试属性来验证测试的输出是否包含某些字符串。在这种情况下，验证在提供的参数数量不正确时是否打印了用法消息。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:271 and
msgid ""
"The next test we will add verifies the computed value is truly the square "
"root."
msgstr "我们将添加的下一个测试将验证计算值是否真的是平方根。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Installing
#: Testing.rst:291 and
msgid ""
"This one test is not enough to give us confidence that it will work for "
"all values passed in. We should add more tests to verify this. To easily "
"add more tests, we make a function called ``do_test`` that runs the "
"application and verifies that the computed square root is correct for "
"given input. For each invocation of ``do_test``, another test is added to "
"the project with a name, input, and expected results based on the passed "
"arguments."
msgstr ""
"这个测试不足以让我们相信它适用于所有传入的值。我们应该添加更多测试来验证这一点。为了轻松添加更多测试，我们制作了一个名为“do_test”的函数来运行应用程序并验证计算的平方根对于给定输入是否正确。对于“do_test”的每次调用，都会将另一个测试添加到项目中，并根据传递的参数添加名称、输入和预期结果。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:2 and
msgid "Step 12: Packaging Debug and Release"
msgstr "第十二步：打包调试发布"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:4 and
msgid ""
"**Note:** This example is valid for single-configuration generators and "
"will not work for multi-configuration generators (e.g. Visual Studio)."
msgstr "**注意：**此示例对单配置生成器有效，不适用于多配置生成器（例如虚拟实验室）。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:7 and
msgid ""
"By default, CMake's model is that a build directory only contains a single"
" configuration, be it Debug, Release, MinSizeRel, or RelWithDebInfo. It is"
" possible, however, to setup CPack to bundle multiple build directories "
"and construct a package that contains multiple configurations of the same "
"project."
msgstr ""
"默认情况下，CMake 的模型是一个构建目录只包含一个配置，可以是 Debug、Release、MinSizeRel 或 "
"RelWithDebInfo。但是，可以将 CPack 设置为捆绑多个构建目录并构建一个包含同一项目的多个配置的包。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:12 and
msgid ""
"First, we want to ensure that the debug and release builds use different "
"names for the libraries that will be installed. Let's use `d` as the "
"postfix for the debug libraries."
msgstr "首先，我们要确保调试和发布版本对将要安装的库使用不同的名称。让我们使用`d` 作为调试库的后缀。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:16 and
msgid ""
"Set :variable:`CMAKE_DEBUG_POSTFIX` near the beginning of the top-level "
"``CMakeLists.txt`` file:"
msgstr "在顶级 CMakeLists.txt 文件的开头附近设置 :variable:`CMAKE_DEBUG_POSTFIX`："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:26 and
msgid ""
"And the :prop_tgt:`DEBUG_POSTFIX` property on the tutorial executable:"
msgstr "教程可执行文件的 :prop_tgt:`DEBUG_POSTFIX` 属性："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:35 and
msgid ""
"Let's also add version numbering to the ``MathFunctions`` library. In "
"``MathFunctions/CMakeLists.txt``, set the :prop_tgt:`VERSION` and "
":prop_tgt:`SOVERSION` properties:"
msgstr ""
"我们还可以将版本编号添加到“MathFunctions”库中。在``MathFunctions/CMakeLists.txt`` 中，设置 "
":prop_tgt:`VERSION` 和 :prop_tgt:`SOVERSION` 属性："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:46 and
msgid ""
"From the ``Step12`` directory, create ``debug`` and ``release`` "
"subdirectories. The layout will look like:"
msgstr "在 ``Step12`` 目录中，创建 ``debug`` 和 ``release`` 子目录。布局将如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:55 and
msgid ""
"Now we need to setup debug and release builds. We can use "
":variable:`CMAKE_BUILD_TYPE` to set the configuration type:"
msgstr "现在我们需要设置调试和发布版本。我们可以使用 :variable:`CMAKE_BUILD_TYPE` 来设置配置类型："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:67 and
msgid ""
"Now that both the debug and release builds are complete, we can use a "
"custom configuration file to package both builds into a single release. In"
" the ``Step12`` directory, create a file called "
"``MultiCPackConfig.cmake``. In this file, first include the default "
"configuration file that was created by the :manual:`cmake  <cmake(1)>` "
"executable."
msgstr ""
"现在调试和发布版本都已完成，我们可以使用自定义配置文件将两个版本打包到一个版本中。在 ``Step12`` 目录中，创建一个名为 "
"``MultiCPackConfig.cmake`` 的文件。在此文件中，首先包含由 :manual:`cmake <cmake(1)>` "
"可执行文件创建的默认配置文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:73 and
msgid ""
"Next, use the ``CPACK_INSTALL_CMAKE_PROJECTS`` variable to specify which "
"projects to install. In this case, we want to install both debug and "
"release."
msgstr ""
"接下来，使用 ``CPACK_INSTALL_CMAKE_PROJECTS`` 变量指定要安装的项目。在这种情况下，我们要安装调试和发布。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:76 and
msgid "MultiCPackConfig.cmake"
msgstr "MultiCPackConfig.cmake"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging Debug
#: Release.rst:81 and
msgid ""
"From the ``Step12`` directory, run :manual:`cpack <cpack(1)>` specifying "
"our custom configuration file with the ``config`` option:"
msgstr ""
"从 ``Step12`` 目录，运行 :manual:`cpack <cpack(1)>` 使用 ``config`` "
"选项指定我们的自定义配置文件："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:2 an
msgid "Step 9: Packaging an Installer"
msgstr "第 9 步：打包安装程序"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:4 an
msgid ""
"Next suppose that we want to distribute our project to other people so "
"that they can use it. We want to provide both binary and source "
"distributions on a variety of platforms. This is a little different from "
"the install we did previously in :guide:`tutorial/Installing and Testing`,"
" where we were installing the binaries that we had built from the source "
"code. In this example we will be building installation packages that "
"support binary installations and package management features. To "
"accomplish this we will use CPack to create platform specific installers. "
"Specifically we need to add a few lines to the bottom of our top-level "
"``CMakeLists.txt`` file."
msgstr ""
"接下来假设我们想要将我们的项目分发给其他人，以便他们可以使用它。我们希望在各种平台上提供二进制和源代码分发。这与我们之前在 "
":guide:`tutorial/Installing and Testing` "
"中进行的安装略有不同，我们在其中安装从源代码构建的二进制文件。在此示例中，我们将构建支持二进制安装和包管理功能的安装包。为此，我们将使用 CPack"
" 创建特定于平台的安装程序。具体来说，我们需要在顶级“CMakeLists.txt”文件的底部添加几行。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:20 an
msgid ""
"That is all there is to it. We start by including "
":module:`InstallRequiredSystemLibraries`. This module will include any "
"runtime libraries that are needed by the project for the current platform."
" Next we set some CPack variables to where we have stored the license and "
"version information for this project. The version information was set "
"earlier in this tutorial and the ``License.txt`` has been included in the "
"top-level source directory for this step.  The "
":variable:`CPACK_SOURCE_GENERATOR` variable selects a file format for the "
"source package."
msgstr ""
"这就是它的全部。我们首先包括:module:`InstallRequiredSystemLibraries`。该模块将包含当前平台项目所需的任何运行时库。接下来，我们将一些"
" CPack 变量设置为我们存储该项目的许可证和版本信息的位置。版本信息已在本教程前面部分设置，并且 ``License.txt`` "
"已包含在该步骤的顶级源目录中。 :variable:`CPACK_SOURCE_GENERATOR` 变量选择源包的文件格式。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:29 an
msgid ""
"Finally we include the :module:`CPack module <CPack>` which will use these"
" variables and some other properties of the current system to setup an "
"installer."
msgstr "最后，我们包括 :module:`CPack 模块 <CPack>`，它将使用这些变量和当前系统的一些其他属性来设置安装程序。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:33 an
msgid ""
"The next step is to build the project in the usual manner and then run the"
" :manual:`cpack <cpack(1)>` executable. To build a binary distribution, "
"from the binary directory run:"
msgstr ""
"下一步是以通常的方式构建项目，然后运行 ​​ :manual:`cpack <cpack(1)>` "
"可执行文件。要构建二进制分发版，请从二进制目录运行："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:41 an
msgid ""
"To specify the generator, use the :option:`-G <cpack -G>` option. For "
"multi-config builds, use :option:`-C <cpack -C>` to specify the "
"configuration. For example:"
msgstr ""
"要指定生成器，请使用 :option:`-G <cpack -G>` 选项。对于多配置构建，使用:option:`-C <cpack -C>` "
"指定配置。例如："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:48 an
msgid ""
"For a list of available generators, see :manual:`cpack-generators(7)` or "
"call :option:`cpack --help`. An :cpack_gen:`archive generator <CPack "
"Archive Generator>` like ZIP creates a compressed archive of all "
"*installed* files."
msgstr ""
"有关可用生成器的列表，请参阅 :manual:`cpack-generators(7)` 或调用:option:`cpack --help`。像 ZIP 这样的 "
":cpack_gen:`archive generator <CPack Archive Generator>` 创建所有 *installed* "
"文件的压缩存档。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:52 an
msgid "To create an archive of the *full* source tree you would type:"
msgstr "要创建*完整*源代码树的存档，您可以键入："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:58 an
msgid ""
"Alternatively, run ``make package`` or right click the ``Package`` target "
"and ``Build Project`` from an IDE."
msgstr "或者，从集成开发环境运行“make package”或右键单击“Package”目标和“Build Project”。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Packaging
#: Installer.rst:61 an
msgid ""
"Run the installer found in the binary directory. Then run the installed "
"executable and verify that it works."
msgstr "运行在二进制目录中找到的安装程序。然后运行安装的可执行文件并验证它是否有效。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:2 Shared Static or
msgid "Step 10: Selecting Static or Shared Libraries"
msgstr "第 10 步：选择静态或共享库"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:4 Shared Static or
msgid ""
"In this section we will show how the :variable:`BUILD_SHARED_LIBS` "
"variable can be used to control the default behavior of "
":command:`add_library`, and allow control over how libraries without an "
"explicit type (``STATIC``, ``SHARED``, ``MODULE`` or ``OBJECT``) are "
"built."
msgstr ""
"在本节中，我们将展示 :variable:`BUILD_SHARED_LIBS` 变量如何用于控制 :command:`add_library` "
"的默认行为，并允许控制没有显式类型的库（``STATIC``，`` SHARED``、``MODULE`` 或 ``OBJECT``) 被构建。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:9 Shared Static or
msgid ""
"To accomplish this we need to add :variable:`BUILD_SHARED_LIBS` to the "
"top-level ``CMakeLists.txt``. We use the :command:`option` command as it "
"allows users to optionally select if the value should be ``ON`` or "
"``OFF``."
msgstr ""
"为此，我们需要将 BUILD_SHARED_LIBS 添加到顶级 CMakeLists.txt 中。我们使用 :command:`option` "
"命令，因为它允许用户有选择地选择值应该是 ``ON`` 还是 ``OFF``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:13 Shared Static or
msgid ""
"Next we are going to refactor ``MathFunctions`` to become a real library "
"that encapsulates using ``mysqrt`` or ``sqrt``, instead of requiring the "
"calling code to do this logic. This will also mean that ``USE_MYMATH`` "
"will not control building ``MathFunctions``, but instead will control the "
"behavior of this library."
msgstr ""
"接下来我们将重构``MathFunctions``，使其成为一个真正的库，使用``mysqrt`` 或``sqrt`` "
"进行封装，而不是要求调用代码执行此逻辑。这也意味着 ``USE_MYMATH`` 不会控制构建 "
"``MathFunctions``，而是控制这个库的行为。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:19 Shared Static or
msgid ""
"The first step is to update the starting section of the top-level "
"``CMakeLists.txt`` to look like:"
msgstr "第一步是将顶层“CMakeLists.txt”的起始部分更新为如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:28 Shared Static or
msgid ""
"Now that we have made ``MathFunctions`` always be used, we will need to "
"update the logic of that library. So, in ``MathFunctions/CMakeLists.txt`` "
"we need to create a SqrtLibrary that will conditionally be built and "
"installed when ``USE_MYMATH`` is enabled. Now, since this is a tutorial, "
"we are going to explicitly require that SqrtLibrary is built statically."
msgstr ""
"现在我们已经让“MathFunctions”始终被使用，我们需要更新那个库的逻辑。因此，在``MathFunctions/CMakeLists.txt``"
" 中，我们需要创建一个 SqrtLibrary，当启用``USE_MYMATH`` "
"时，它将有条件地构建和安装。现在，由于这是一个教程，我们将明确要求 SqrtLibrary 是静态构建的。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:34 Shared Static or
msgid ""
"The end result is that ``MathFunctions/CMakeLists.txt`` should look like:"
msgstr "最终结果是``MathFunctions/CMakeLists.txt``应该是这样的："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:42 Shared Static or
msgid ""
"Next, update ``MathFunctions/mysqrt.cxx`` to use the ``mathfunctions`` and"
" ``detail`` namespaces:"
msgstr "接下来，更新“MathFunctions/mysqrt.cxx”以使用“mathfunctions”和“detail”命名空间："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:50 Shared Static or
msgid ""
"We also need to make some changes in ``tutorial.cxx``, so that it no "
"longer uses ``USE_MYMATH``:"
msgstr "我们还需要对 ``tutorial.cxx`` 进行一些更改，使其不再使用 ``USE_MYMATH``："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:53 Shared Static or
msgid "Always include ``MathFunctions.h``"
msgstr "始终包含``MathFunctions.h``"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:54 Shared Static or
msgid "Always use ``mathfunctions::sqrt``"
msgstr "总是使用``mathfunctions::sqrt``"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:55 Shared Static or
msgid "Don't include ``cmath``"
msgstr "不要包括``cmath``"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:57 Shared Static or
msgid ""
"Finally, update ``MathFunctions/MathFunctions.h`` to use dll export "
"defines:"
msgstr "最后，更新“MathFunctions/MathFunctions.h”以使用 dll 导出定义："

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:59 Shared Static or
msgid "MathFunctions/MathFunctions.h"
msgstr "MathFunctions/MathFunctions.h"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:64 Shared Static or
msgid ""
"At this point, if you build everything, you may notice that linking fails "
"as we are combining a static library without position independent code "
"with a library that has position independent code. The solution to this is"
" to explicitly set the :prop_tgt:`POSITION_INDEPENDENT_CODE` target "
"property of SqrtLibrary to be ``True`` when building shared libraries."
msgstr ""
"在这一点上，如果您构建所有内容，您可能会注意到链接失败，因为我们将没有位置独立代码的静态库与具有位置独立代码的库组合在一起。解决方案是在构建共享库时将"
" SqrtLibrary 的 :prop_tgt:`POSITION_INDEPENDENT_CODE` 目标属性显式设置为 ``True``。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/Selecting
#: Libraries.rst:76 Shared Static or
msgid ""
"**Exercise**: We modified ``MathFunctions.h`` to use dll export defines. "
"Using CMake documentation can you find a helper module to simplify this?"
msgstr ""
"**练习**：我们修改了“MathFunctions.h”以使用 dll 导出定义。使用 CMake 文档，你能找到一个帮助模块来简化这个吗？"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/index.rst:2
msgid "CMake Tutorial"
msgstr "教程"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/index.rst:7
msgid ""
"The CMake tutorial provides a step-by-step guide that covers common build "
"system issues that CMake helps address. Seeing how various topics all work"
" together in an example project can be very helpful."
msgstr ""
"CMake 教程提供了一个分步指南，涵盖了 CMake 帮助解决的常见构建系统问题。了解各种主题如何在一个示例项目中一起工作会很有帮助。"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/index.rst:12
msgid "Steps"
msgstr "步骤"

#: ../../cmake-prefix/src/cmake/Help/guide/tutorial/index.rst:16
msgid ""
"|tutorial_source| Each step has its own subdirectory containing code that "
"may be used as a starting point. The tutorial examples are progressive so "
"that each step provides the complete solution for the previous step."
msgstr ""
"|tutorial_source|每个步骤都有自己的子目录，其中包含可用作起点的代码。教程示例是渐进的，因此每个步骤都为上一步提供完整的解决方案。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:2
msgid "User Interaction Guide"
msgstr "用户交互指南"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:11
msgid ""
"Where a software package supplies a CMake-based buildsystem with the "
"source of their software, the consumer of the software is required to run "
"a CMake user interaction tool in order to build it."
msgstr "如果软件包为基于 CMake 的构建系统提供其软件源，则软件的消费者需要运行 CMake 用户交互工具才能构建它。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:16
msgid ""
"Well-behaved CMake-based buildsystems do not create any output in the "
"source directory, so typically, the user performs an out-of-source build "
"and performs the build there.  First, CMake must be instructed to generate"
" a suitable buildsystem, then the user invokes a build tool to process "
"that generated buildsystem.  The generated buildsystem is specific to the "
"machine used to generate it and is not redistributable.  Each consumer of "
"a provided source software package is required to use CMake to generate a "
"buildsystem specific to their system."
msgstr ""
"行为良好的基于​​ CMake 的构建系统不会在源目录中创建任何输出，因此通常，用户执行源外构建并在那里执行构建。首先，必须指示 CMake "
"生成合适的构建系统，然后用户调用构建工具来处理生成的构建系统。生成的构建系统特定于用于生成它的机器，并且不可再分发。所提供的源软件包的每个消费者都需要使用"
" CMake 来生成特定于其系统的构建系统。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:27
msgid ""
"Generated buildsystems should generally be treated as read-only. The CMake"
" files as a primary artifact should completely specify the buildsystem and"
" there should be no reason to populate properties manually in an IDE for "
"example after generating the buildsystem.  CMake will periodically rewrite"
" the generated buildsystem, so modifications by users will be overwritten."
msgstr ""
"生成的构建系统通常应被视为只读的。作为主要工件的 CMake 文件应该完全指定构建系统，并且没有理由在集成开发环境"
"中手动填充属性，例如在生成构建系统之后。 CMake 会定期重写生成的构建系统，因此用户的修改将被覆盖。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:35
msgid ""
"The features and user interfaces described in this manual are available "
"for all CMake-based build systems by virtue of providing CMake files."
msgstr "通过提供 CMake 文件，本手册中描述的功能和用户界面可用于所有基于 CMake 的构建系统。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:39
msgid ""
"The CMake tooling may report errors to the user when processing provided "
"CMake files, such as reporting that the compiler is not supported, or the "
"compiler does not support a required compile option, or a dependency can "
"not be found.  These errors must be resolved by the user by choosing a "
"different compiler, :guide:`installing dependencies <Using Dependencies "
"Guide>`, or instructing CMake where to find them, etc."
msgstr ""
"CMake 工具在处理提供的 CMake "
"文件时可能会向用户报告错误，例如报告不支持编译器，或者编译器不支持所需的编译选项，或者找不到依赖项。这些错误必须由用户通过选择不同的编译器、 :guide:`安装依赖项"
" <使用依赖项指南>` 或指示 CMake 在哪里找到它们等来解决。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:49
msgid "Command Line cmake tool"
msgstr "命令行 cmake 工具"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:51
msgid ""
"A simple but typical use of :manual:`cmake(1)` with a fresh copy of "
"software source code is to create a build directory and invoke cmake "
"there:"
msgstr ":manual:`cmake(1)` 与软件源代码的新副本的一个简单但典型的用法是创建一个构建目录并在其中调用 cmake："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:64
msgid ""
"It is recommended to build in a separate directory to the source because "
"that keeps the source directory pristine, allows for building a single "
"source with multiple toolchains, and allows easy clearing of build "
"artifacts by simply deleting the build directory."
msgstr ""
"建议在源代码的单独目录中构建，因为这样可以保持源目录的原始状态，允许使用多个工具链构建单个源代码，并允许通过简单地删除构建目录来轻松清除构建工件。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:70
msgid ""
"The CMake tooling may report warnings which are intended for the provider "
"of the software, not intended for the consumer of the software.  Such "
"warnings end with \"This warning is for project developers\".  Users may "
"disable such warnings by passing the :option:`-Wno-dev <cmake -Wno-dev>` "
"flag to :manual:`cmake(1)`."
msgstr ""
"CMake 工具可能会报告针对软件提供者而非软件消费者的警告。此类警告以“This warning is for project "
"developers”结尾。用户可以通过将 :option:`-Wno-dev <cmake -Wno-dev>` 标志传递给 "
":manual:`cmake(1)` 来禁用此类警告。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:78
msgid "cmake-gui tool"
msgstr "cmake-gui 工具"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:80
msgid ""
"Users more accustomed to GUI interfaces may use the :manual:`cmake-gui(1)`"
" tool to invoke CMake and generate a buildsystem."
msgstr "更习惯于 GUI 界面的用户可以使用 :manual:`cmake-gui(1)` 工具来调用 CMake 并生成构建系统。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:84
msgid ""
"The source and binary directories must first be populated.  It is always "
"advised to use different directories for the source and the build."
msgstr "必须首先填充源目录和二进制目录。始终建议对源和构建使用不同的目录。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:-1
msgid "Choosing source and binary directories"
msgstr "选择源目录和二进制目录"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:92
msgid "Generating a Buildsystem"
msgstr "生成构建系统"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:94
msgid ""
"There are several user interface tools which may be used to generate a "
"buildsystem from CMake files.  The :manual:`ccmake(1)` and :manual:`cmake-"
"gui(1)` tools guide the user through setting the various necessary "
"options. The :manual:`cmake(1)` tool can be invoked to specify options on "
"the command line.  This manual describes options which may be set using "
"any of the user interface tools, though the mode of setting an option is "
"different for each tool."
msgstr ""
"有几种用户界面工具可用于从 CMake 文件生成构建系统。 :manual:`ccmake(1)` 和 :manual:`cmake-gui(1)` "
"工具指导用户设置各种必要的选项。可以调用 :manual:`cmake(1)` "
"工具在命令行上指定选项。本手册描述了可以使用任何用户界面工具设置的选项，尽管设置选项的模式对于每个工具都是不同的。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:105
msgid "Command line environment"
msgstr "命令行环境"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:107
msgid ""
"When invoking :manual:`cmake(1)` with a command line buildsystem such as "
"``Makefiles`` or ``Ninja``, it is necessary to use the correct build "
"environment to ensure that build tools are available. CMake must be able "
"to find the appropriate :variable:`build tool <CMAKE_MAKE_PROGRAM>`, "
"compiler, linker and other tools as needed."
msgstr ""
"使用命令行构建系统（例如 Makefiles 或 Ninja）调用 :manual:`cmake(1)` "
"时，必须使用正确的构建环境以确保构建工具可用。 CMake 必须能够根据需要找到合适的 :variable:`构建工具 "
"<CMAKE_MAKE_PROGRAM>`、编译器、链接器和其他工具。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:115
msgid ""
"On Linux systems, the appropriate tools are often provided in system-wide "
"locations and may be readily installed through the system package manager."
" Other toolchains provided by the user or installed in non-default "
"locations can also be used."
msgstr ""
"在 Linux 系统上，适当的工具通常在系统范围的位置提供，并且可以通过系统包管理器轻松安装。也可以使用用户提供的或安装在非默认位置的其他工具链。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:121
msgid ""
"When cross-compiling, some platforms may require environment variables to "
"be set or may provide scripts to set the environment."
msgstr "交叉编译时，一些平台可能需要设置环境变量，或者可能会提供脚本来设置环境。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:125
msgid ""
"Visual Studio ships multiple command prompts and ``vcvarsall.bat`` scripts"
" for setting up the correct environments for command line buildsystems. "
"While not strictly necessary to use a corresponding command line "
"environment when using a Visual Studio generator, doing so has no "
"disadvantages."
msgstr ""
"虚拟实验室附带多个命令提示符和“vcvarsall.bat”脚本，用于为命令行构建系统设置正确的环境。虽然在使用 Visual "
"Studio 生成器时不一定非要使用相应的命令行环境，但这样做没有任何缺点。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:132
msgid ""
"When using Xcode, there can be more than one Xcode version installed.  "
"Which one to use can be selected in a number of different ways, but the "
"most common methods are:"
msgstr "使用 Xcode 时，可以安装多个 Xcode 版本。可以通过多种不同的方式选择使用哪一个，但最常见的方法是："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:137
msgid "Setting the default version in the preferences of the Xcode IDE."
msgstr "在 开发环境的首选项中设置默认版本。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:139
msgid ""
"Setting the default version via the ``xcode-select`` command line tool."
msgstr "通过“xcode-select”命令行工具设置默认版本。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:141
msgid ""
"Overriding the default version by setting the ``DEVELOPER_DIR`` "
"environment variable when running CMake and the build tool."
msgstr "在运行 CMake 和构建工具时通过设置“DEVELOPER_DIR”环境变量覆盖默认版本。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:145
msgid ""
"For convenience, :manual:`cmake-gui(1)` provides an environment variable "
"editor."
msgstr "为了方便起见， :manual:`cmake-gui(1)` 提供了一个环境变量编辑器。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:149
msgid "Command line ``-G`` option"
msgstr "命令行 ``-G`` 选项"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:151
msgid ""
"CMake chooses a generator by default based on the platform.  Usually, the "
"default generator is sufficient to allow the user to proceed to build the "
"software."
msgstr "CMake 默认根据平台选择一个生成器。通常，默认生成器足以让用户继续构建软件。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:155
msgid ""
"The user may override the default generator with the :option:`-G <cmake "
"-G>` option:"
msgstr "用户可以使用 :option:`-G <cmake -G>` 选项覆盖默认生成器："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:162
msgid ""
"The output of :option:`cmake --help` includes a list of "
":manual:`generators <cmake-generators(7)>` available for the user to "
"choose from.  Note that generator names are case sensitive."
msgstr ""
":option:`cmake --help` 的输出包括一个可供用户选择的 :manual:`generators <cmake-"
"generators(7)>` 列表。请注意，生成器名称区分大小写。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:167
msgid ""
"On Unix-like systems (including Mac OS X), the :generator:`Unix Makefiles`"
" generator is used by default.  A variant of that generator can also be "
"used on Windows in various environments, such as the :generator:`NMake "
"Makefiles` and :generator:`MinGW Makefiles` generator.  These generators "
"generate a ``Makefile`` variant which can be executed with ``make``, "
"``gmake``, ``nmake`` or similar tools. See the individual generator "
"documentation for more information on targeted environments and tools."
msgstr ""
"在类 Unix 系统（包括 Mac OS X）上，默认使用 :generator:`Unix Makefiles` 生成器。该生成器的变体也可以在 "
"Windows 上的各种环境中使用，例如:generator:`NMake Makefiles` 和:generator:`MinGW Makefiles` "
"生成器。这些生成器生成一个 ``Makefile`` 变体，可以使用 ``make``、``gmake``、``nmake`` "
"或类似工具执行。有关目标环境和工具的更多信息，请参阅各个生成器文档。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:178
msgid ""
"The :generator:`Ninja` generator is available on all major platforms. "
"``ninja`` is a build tool similar in use-cases to ``make``, but with a "
"focus on performance and efficiency."
msgstr ""
":generator:`Ninja` 生成器可在所有主要平台上使用。 ``ninja`` 是一个在用例上类似于 ``make`` "
"的构建工具，但侧重于性能和效率。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:183
msgid ""
"On Windows, :manual:`cmake(1)` can be used to generate solutions for the "
"Visual Studio IDE.  Visual Studio versions may be specified by the product"
" name of the IDE, which includes a four-digit year.  Aliases are provided "
"for other means by which Visual Studio versions are sometimes referred to,"
" such as two digits which correspond to the product version of the "
"VisualC++ compiler, or a combination of the two:"
msgstr ""
"在 Windows 上， :manual:`cmake(1)` 可用于为虚拟实验室集成开发环境生成解决方案。 Visual "
"Studio 版本可以由集成开发环境的产品名称指定，其中包括一个四位数的年份。为有时引用虚拟实验室"
"版本的其他方式提供了别名，例如对应于 VisualC++ 编译器产品版本的两个数字，或两者的组合："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:198
msgid ""
"Visual Studio generators can target different architectures. One can "
"specify the target architecture using the :option:`-A <cmake -A>` option:"
msgstr "虚拟实验室生成器可以针对不同的体系结构。可以使用 :option:`-A <cmake -A>` 选项指定目标架构："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:208
msgid ""
"On Apple, the :generator:`Xcode` generator may be used to generate project"
" files for the Xcode IDE."
msgstr "在 Apple 上， :generator:`Xcode` 生成器可用于为 开发环境生成项目文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:211
msgid ""
"Some IDEs such as KDevelop4, QtCreator and CLion have native support for "
"CMake-based buildsystems.  Those IDEs provide user interface for selecting"
" an underlying generator to use, typically a choice between a ``Makefile``"
" or a ``Ninja`` based generator."
msgstr ""
"一些集成开发环境，例如 KDevelop4、QtCreator 和 CLion 原生支持基于 CMake 的构建系统。这些集成开发环境"
"提供了用于选择要使用的底层生成器的用户界面，通常是在基于“Makefile”或“Ninja”的生成器之间进行选择。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:217
msgid ""
"Note that it is not possible to change the generator with :option:`-G "
"<cmake -G>` after the first invocation of CMake. To change the generator, "
"the build directory must be deleted and the build must be started from "
"scratch."
msgstr ""
"请注意，在第一次调用 CMake 后，无法使用 -G <cmake -G> 更改生成器。要更改生成器，必须删除构建目录并且必须从头开始构建。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:222
msgid ""
"When generating Visual Studio project and solutions files several other "
"options are available to use when initially running :manual:`cmake(1)`."
msgstr "在生成虚拟实验室项目和解决方案文件时，在最初运行 cmake(1) 时可以使用其他几个选项。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:226
msgid ""
"The Visual Studio toolset can be specified with the :option:`cmake -T` "
"option:"
msgstr "可以使用 :option:`cmake -T` 选项指定虚拟实验室工具集："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:236
msgid ""
"Whereas the :option:`-A <cmake -A>` option specifies the _target_ "
"architecture, the :option:`-T <cmake -T>` option can be used to specify "
"details of the toolchain used.  For example, ``-Thost=x64`` can be given "
"to select the 64-bit version of the host tools.  The following "
"demonstrates how to use 64-bit tools and also build for a 64-bit target "
"architecture:"
msgstr ""
":option:`-A <cmake -A>` 选项指定了_target_ 体系结构，而 :option:`-T <cmake -T>` "
"选项可用于指定所用工具链的详细信息。例如，可以给出 ``-Thost=x64`` 来选择主机工具的 64 位版本。下面演示了如何使用 64 "
"位工具以及如何构建 64 位目标架构："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:248
msgid "Choosing a generator in cmake-gui"
msgstr "在 cmake-gui 中选择生成器"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:250
msgid ""
"The \"Configure\" button triggers a new dialog to select the CMake "
"generator to use."
msgstr "“配置”按钮触发一个新对话框以选择要使用的 CMake 生成器。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:-1
msgid "Configuring a generator"
msgstr "配置生成器"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:256
msgid ""
"All generators available on the command line are also available in "
":manual:`cmake-gui(1)`."
msgstr "命令行上可用的所有生成器也可在 :manual:`cmake-gui(1)` 中使用。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:-1
msgid "Choosing a generator"
msgstr "选择生成器"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:262
msgid ""
"When choosing a Visual Studio generator, further options are available to "
"set an architecture to generate for."
msgstr "选择虚拟实验室生成器时，可以使用更多选项来设置要生成的体系结构。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:-1
msgid "Choosing an architecture for Visual Studio generators"
msgstr "为虚拟实验室生成器选择架构"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:271
msgid "Setting Build Variables"
msgstr "设置构建变量"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:273
msgid ""
"Software projects often require variables to be set on the command line "
"when invoking CMake.  Some of the most commonly used CMake variables are "
"listed in the table below:"
msgstr "软件项目通常需要在调用 CMake 时在命令行上设置变量。下表列出了一些最常用的 CMake 变量："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:279
msgid "Variable"
msgstr "变量"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:279
msgid "Meaning"
msgstr "意义"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:281
msgid ":variable:`CMAKE_PREFIX_PATH`"
msgstr ":variable:`CMAKE_PREFIX_PATH`"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:281
msgid ""
"Path to search for :guide:`dependent packages <Using Dependencies Guide>`"
msgstr "搜索路径 :guide:`依赖包 <Using Dependencies Guide>`"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:283
msgid ":variable:`CMAKE_MODULE_PATH`"
msgstr ":variable:`CMAKE_MODULE_PATH`"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:283
msgid "Path to search for additional CMake modules"
msgstr "搜索其他 CMake 模块的路径"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:284
msgid ":variable:`CMAKE_BUILD_TYPE`"
msgstr ":variable:`CMAKE_BUILD_TYPE`"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:284
msgid ""
"Build configuration, such as ``Debug`` or ``Release``, determining "
"debug/optimization flags.  This is only relevant for single-configuration "
"buildsystems such as ``Makefile`` and ``Ninja``.  Multi-configuration "
"buildsystems such as those for Visual Studio and Xcode ignore this "
"setting."
msgstr ""
"构建配置，例如“调试”或“发布”，确定调试/优化标志。这仅与单配置构建系统相关，例如“Makefile”和“Ninja”。用于 Visual "
"Studio 和 Xcode 的多配置构建系统会忽略此设置。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:291
msgid ":variable:`CMAKE_INSTALL_PREFIX`"
msgstr ":variable:`CMAKE_INSTALL_PREFIX`"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:291
msgid ""
"Location to install the software to with the ``install`` build target"
msgstr "使用“install”构建目标安装软件的位置"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:294
msgid ":variable:`CMAKE_TOOLCHAIN_FILE`"
msgstr ":variable:`CMAKE_TOOLCHAIN_FILE`"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:294
msgid ""
"File containing cross-compiling data such as :manual:`toolchains and "
"sysroots <cmake-toolchains(7)>`."
msgstr ""
"包含交叉编译数据的文件，例如 :manual:`toolchains 和 sysroots <cmake-toolchains(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:297
msgid ":variable:`BUILD_SHARED_LIBS`"
msgstr ":variable:`BUILD_SHARED_LIBS`"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:297
msgid ""
"Whether to build shared instead of static libraries for "
":command:`add_library` commands used without a type"
msgstr "是否为没有类型的 :command:`add_library` 命令构建共享库而不是静态库"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:301
msgid ":variable:`CMAKE_EXPORT_COMPILE_COMMANDS`"
msgstr ":variable:`CMAKE_EXPORT_COMPILE_COMMANDS`"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:301
msgid ""
"Generate a ``compile_commands.json`` file for use with clang-based tools"
msgstr "生成一个 ``compile_commands.json`` 文件以与基于 clang 的工具一起使用"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:305
msgid ""
"Other project-specific variables may be available to control builds, such "
"as enabling or disabling components of the project."
msgstr "其他特定于项目的变量可能可用于控制构建，例如启用或禁用项目的组件。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:309
msgid ""
"There is no convention provided by CMake for how such variables are named "
"between different provided buildsystems, except that variables with the "
"prefix ``CMAKE_`` usually refer to options provided by CMake itself and "
"should not be used in third-party options, which should use their own "
"prefix instead.  The :manual:`cmake-gui(1)` tool can display options in "
"groups defined by their prefix, so it makes sense for third parties to "
"ensure that they use a self-consistent prefix."
msgstr ""
"CMake 没有提供关于如何在不同提供的构建系统之间命名此类变量的约定，除了带有前缀 ``CMAKE_`` 的变量通常指的是 CMake "
"本身提供的选项，不应在第三方选项中使用，这应该使用他们自己的前缀。 :manual:`cmake-gui(1)` "
"工具可以按前缀定义的组显示选项，因此第三方确保他们使用自洽前缀是有意义的。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:322
msgid "Setting variables on the command line"
msgstr "在命令行中设置变量"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:324
msgid ""
"CMake variables can be set on the command line either when creating the "
"initial build:"
msgstr "创建初始构建时，可以在命令行上设置 CMake 变量："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:333
msgid "or later on a subsequent invocation of :manual:`cmake(1)`:"
msgstr "或稍后调用 :manual:`cmake(1)` 时："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:341
msgid ""
"The :option:`-U <cmake -U>` flag may be used to unset variables on the "
":manual:`cmake(1)` command line:"
msgstr ":option:`-U <cmake -U>` 标志可用于在 :manual:`cmake(1)` 命令行上取消设置变量："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:349
msgid ""
"A CMake buildsystem which was initially created on the command line can be"
" modified using the :manual:`cmake-gui(1)` and vice-versa."
msgstr "最初在命令行上创建的 CMake 构建系统可以使用 :manual:`cmake-gui(1)` 进行修改，反之亦然。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:353
msgid ""
"The :manual:`cmake(1)` tool allows specifying a file to use to populate "
"the initial cache using the :option:`-C <cmake -C>` option.  This can be "
"useful to simplify commands and scripts which repeatedly require the same "
"cache entries."
msgstr ""
":manual:`cmake(1)` 工具允许使用 :option:`-C <cmake -C>` "
"选项指定用于填充初始缓存的文件。这对于简化重复需要相同缓存条目的命令和脚本很有用。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:360
msgid "Setting variables with cmake-gui"
msgstr "使用 cmake-gui 设置变量"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:362
msgid ""
"Variables may be set in the cmake-gui using the \"Add Entry\" button.  "
"This triggers a new dialog to set the value of the variable."
msgstr "可以使用“添加条目”按钮在 cmake-gui 中设置变量。这会触发一个新对话框来设置变量的值。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:-1
msgid "Editing a cache entry"
msgstr "编辑缓存条目"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:369
msgid ""
"The main view of the :manual:`cmake-gui(1)` user interface can be used to "
"edit existing variables."
msgstr ":manual:`cmake-gui(1)` 用户界面的主视图可用于编辑现有变量。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:373
msgid "The CMake Cache"
msgstr "CMake 缓存"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:375
msgid ""
"When CMake is executed, it needs to find the locations of compilers, tools"
" and dependencies.  It also needs to be able to consistently re-generate a"
" buildsystem to use the same compile/link flags and paths to dependencies."
"  Such parameters are also required to be configurable by the user because"
" they are paths and options specific to the users system."
msgstr ""
"CMake在执行时，需要找到编译器、工具和依赖的位置。它还需要能够始终如一地重新生成构建系统，以使用相同的编译/链接标志和依赖项路径。此类参数也需要由用户配置，因为它们是特定于用户系统的路径和选项。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:383
msgid ""
"When it is first executed, CMake generates a ``CMakeCache.txt`` file in "
"the build directory containing key-value pairs for such artifacts.  The "
"cache file can be viewed or edited by the user by running the "
":manual:`cmake-gui(1)` or :manual:`ccmake(1)` tool.  The tools provide an "
"interactive interface for re-configuring the provided software and re-"
"generating the buildsystem, as is needed after editing cached values.  "
"Each cache entry may have an associated short help text which is displayed"
" in the user interface tools."
msgstr ""
"首次执行时，CMake 在构建目录中生成一个“CMakeCache.txt”文件，其中包含此类工件的键值对。用户可以通过运行 "
":manual:`cmake-gui(1)` 或 :manual:`ccmake(1)` "
"工具查看或编辑缓存文件。这些工具提供了一个交互式界面，用于重新配置所提供的软件并重新生成构建系统，这是在编辑缓存值后需要的。每个缓存条目可能有一个关联的简短帮助文本，该文本显示在用户界面工具中。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:394
msgid ""
"The cache entries may also have a type to signify how it should be "
"presented in the user interface.  For example, a cache entry of type "
"``BOOL`` can be edited by a checkbox in a user interface, a ``STRING`` can"
" be edited in a text field, and a ``FILEPATH`` while similar to a "
"``STRING`` should also provide a way to locate filesystem paths using a "
"file dialog.  An entry of type ``STRING`` may provide a restricted list of"
" allowed values which are then provided in a drop-down menu in the "
":manual:`cmake-gui(1)` user interface (see the :prop_cache:`STRINGS` cache"
" property)."
msgstr ""
"缓存条目也可以有一个类型来表示它应该如何在用户界面中呈现。例如，“BOOL”类型的缓存条目可以通过用户界面中的复选框进行编辑，“STRING”可以在文本字段中编辑，而“FILEPATH”类似于“"
" `STRING`` 还应该提供一种使用文件对话框定位文件系统路径的方法。 ``STRING`` 类型的条目可以提供允许值的限制列表，然后在 "
"cmake-gui(1) 用户界面的下拉菜单中提供这些值（请参阅:prop_cache:`STRINGS ` 缓存属性）。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:406
msgid ""
"The CMake files shipped with a software package may also define boolean "
"toggle options using the :command:`option` command.  The command creates a"
" cache entry which has a help text and a default value.  Such cache "
"entries are typically specific to the provided software and affect the "
"configuration of the build, such as whether tests and examples are built, "
"whether to build with exceptions enabled etc."
msgstr ""
"软件包附带的 CMake 文件也可以使用 :command:`option` "
"命令定义布尔切换选项。该命令创建一个具有帮助文本和默认值的缓存条目。此类缓存条目通常特定于所提供的软件并影响构建的配置，例如是否构建测试和示例，是否在启用异常的情况下构建等。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:418
msgid ""
"CMake understands a file, ``CMakePresets.json``, and its user-specific "
"counterpart, ``CMakeUserPresets.json``, for saving presets for commonly-"
"used configure settings. These presets can set the build directory, "
"generator, cache variables, environment variables, and other command-line "
"options. All of these options can be overridden by the user. The full "
"details of the ``CMakePresets.json`` format are listed in the "
":manual:`cmake-presets(7)` manual."
msgstr ""
"CMake "
"理解文件“CMakePresets.json”及其用户特定的对应文件“CMakeUserPresets.json”，用于保存常用配置设置的预设。这些预设可以设置构建目录、生成器、缓存变量、环境变量和其他命令行选项。所有这些选项都可以被用户覆盖。"
" ``CMakePresets.json`` 格式的完整细节列在 :manual:`cmake-presets(7)` 手册中。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:428
msgid "Using presets on the command-line"
msgstr "在命令行上使用预设"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:430
msgid ""
"When using the :manual:`cmake(1)` command line tool, a preset can be "
"invoked by using the :option:`--preset <cmake --preset>` option. If "
":option:`--preset <cmake --preset>` is specified, the generator and build "
"directory are not required, but can be specified to override them. For "
"example, if you have the following ``CMakePresets.json`` file:"
msgstr ""
"使用 :manual:`cmake(1)` 命令行工具时，可以使用 :option:`--preset <cmake --preset>` "
"选项调用预设。如果 :option:`--preset <cmake --preset>` "
"被指定，则生成器和构建目录不是必需的，但可以指定以覆盖它们。例如，如果您有以下 ``CMakePresets.json`` 文件："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:453
msgid "and you run the following:"
msgstr "然后运行以下命令："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:459
msgid ""
"This will generate a build directory in ``/path/to/source/build/ninja-"
"release`` with the :generator:`Ninja` generator, and with "
":variable:`CMAKE_BUILD_TYPE` set to ``Release``."
msgstr ""
"这将使用 Ninja 生成器在“/path/to/source/build/ninja-"
"release”中生成构建目录，并将“CMAKE_BUILD_TYPE”设置为“Release”。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:464
msgid "If you want to see the list of available presets, you can run:"
msgstr "如果你想查看可用预设列表，你可以运行："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:471
msgid ""
"This will list the presets available in "
"``/path/to/source/CMakePresets.json`` and "
"``/path/to/source/CMakeUsersPresets.json`` without generating a build "
"tree."
msgstr ""
"这将列出``/path/to/source/CMakePresets.json`` "
"和``/path/to/source/CMakeUsersPresets.json`` 中可用的预设，而不生成构建树。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:477
msgid "Using presets in cmake-gui"
msgstr "在 cmake-gui 中使用预设"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:479
msgid ""
"If a project has presets available, either through ``CMakePresets.json`` "
"or ``CMakeUserPresets.json``, the list of presets will appear in a drop-"
"down menu in :manual:`cmake-gui(1)` between the source directory and the "
"binary directory. Choosing a preset sets the binary directory, generator, "
"environment variables, and cache variables, but all of these options can "
"be overridden after a preset is selected."
msgstr ""
"如果项目有可用的预设，无论是通过“CMakePresets.json”还是“CMakeUserPresets.json”，预设列表将出现在 "
":manual:`cmake-gui(1)` "
"之间的下拉菜单中源目录和二进制目录。选择预设设置二进制目录、生成器、环境变量和缓存变量，但在选择预设后可以覆盖所有这些选项。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:489
msgid "Invoking the Buildsystem"
msgstr "调用构建系统"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:491
msgid ""
"After generating the buildsystem, the software can be built by invoking "
"the particular build tool.  In the case of the IDE generators, this can "
"involve loading the generated project file into the IDE to invoke the "
"build."
msgstr "生成构建系统后，可以通过调用特定的构建工具来构建软件。对于集成开发环境生成器，这可能涉及将生成的项目文件加载到集成开发环境中以调用构建。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:497
msgid ""
"CMake is aware of the specific build tool needed to invoke a build so in "
"general, to build a buildsystem or project from the command line after "
"generating, the following command may be invoked in the build directory:"
msgstr "CMake 知道调用构建所需的特定构建工具，因此一般来说，要在生成后从命令行构建构建系统或项目，可以在构建目录中调用以下命令："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:506
msgid ""
"The :option:`--build <cmake --build>` flag enables a particular mode of "
"operation for the :manual:`cmake(1)` tool.  It invokes the  "
":variable:`CMAKE_MAKE_PROGRAM` command associated with the "
":manual:`generator <cmake-generators(7)>`, or the build tool configured by"
" the user."
msgstr ""
":option:`--build <cmake --build>` 标志为 :manual:`cmake(1)` 工具启用特定的操作模式。它调用与 "
"generator <cmake-generators(7)> 或用户配置的构建工具关联的 CMAKE_MAKE_PROGRAM 命令。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:513
msgid ""
"The :option:`--build <cmake --build>` mode also accepts the parameter "
":option:`--target <cmake--build --target>` to specify a particular target "
"to build, for example a particular library, executable or custom target, "
"or a particular special target like ``install``:"
msgstr ""
":option:`--build <cmake --build>` 模式还接受参数 :option:`--target <cmake--build "
"--target>` 来指定要构建的特定目标，例如特定库，可执行文件或自定义目标，或特定的特殊目标，如“install”："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:523
msgid ""
"The :option:`--build <cmake --build>` mode also accepts a "
":option:`--config <cmake--build --config>` parameter in the case of multi-"
"config generators to specify which particular configuration to build:"
msgstr ""
"在多配置生成器的情况下， :option:`--build <cmake --build>` 模式还接受一个 :option:`--config "
"<cmake--build --config>` 参数来指定哪个特定配置建立："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:532
msgid ""
"The :option:`--config <cmake--build --config>` option has no effect if the"
" generator generates a buildsystem specific to a configuration which is "
"chosen when invoking cmake with the :variable:`CMAKE_BUILD_TYPE` variable."
msgstr ""
"如果生成器生成的构建系统特定于使用 CMAKE_BUILD_TYPE 变量调用 cmake 时选择的配置，则 :option:`--config "
"<cmake--build --config>` 选项无效。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:537
msgid ""
"Some buildsystems omit details of command lines invoked during the build."
"  The :option:`--verbose <cmake--build --verbose>` flag can be used to "
"cause those command lines to be shown:"
msgstr ""
"一些构建系统省略了构建期间调用的命令行的详细信息。 :option:`--verbose <cmake--build --verbose>` "
"标志可用于显示这些命令行："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:545
msgid ""
"The :option:`--build <cmake --build>` mode can also pass particular "
"command line options to the underlying build tool by listing them after "
"``--``.  This can be useful to specify options to the build tool, such as "
"to continue the build after a failed job, where CMake does not provide a "
"high-level user interface."
msgstr ""
":option:`--build <cmake --build>` 模式还可以将特定的命令行选项传递给底层构建工具，方法是在 ``--`` "
"之后列出它们。这对于指定构建工具的选项很有用，例如在作业失败后继续构建，其中 CMake 不提供高级用户界面。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:552
msgid ""
"For all generators, it is possible to run the underlying build tool after "
"invoking CMake.  For example, ``make`` may be executed after generating "
"with the :generator:`Unix Makefiles` generator to invoke the build, or "
"``ninja`` after generating with the :generator:`Ninja` generator etc.  The"
" IDE buildsystems usually provide command line tooling for building a "
"project which can also be invoked."
msgstr ""
"对于所有生成器，都可以在调用 CMake 后运行底层构建工具。例如，``make`` 可以在使用 :generator:`Unix "
"Makefiles` 生成器生成后执行以调用构建，或者``ninja`` 在使用 :generator:`Ninja` 生成器等生成后执行。集成开发环境"
"构建系统通常提供用于构建也可以调用的项目的命令行工具。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:562
msgid "Selecting a Target"
msgstr "选择目标"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:564
msgid ""
"Each executable and library described in the CMake files is a build "
"target, and the buildsystem may describe custom targets, either for "
"internal use, or for user consumption, for example to create "
"documentation."
msgstr "CMake 文件中描述的每个可执行文件和库都是构建目标，构建系统可以描述自定义目标，供内部使用或供用户使用，例如创建文档。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:569
msgid ""
"CMake provides some built-in targets for all buildsystems providing CMake "
"files."
msgstr "CMake 为所有提供 CMake 文件的构建系统提供了一些内置目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:578
msgid "``all``"
msgstr "``全部``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:573
msgid ""
"The default target used by ``Makefile`` and ``Ninja`` generators.  Builds "
"all targets in the buildsystem, except those which are excluded by their "
":prop_tgt:`EXCLUDE_FROM_ALL` target property or "
":prop_dir:`EXCLUDE_FROM_ALL` directory property.  The name ``ALL_BUILD`` "
"is used for this purpose for the Xcode and Visual Studio generators."
msgstr ""
"``Makefile`` 和 ``Ninja`` 生成器使用的默认目标。构建构建系统中的所有目标，除了那些被它们的 "
":prop_tgt:`EXCLUDE_FROM_ALL` 目标属性或 :prop_dir:`EXCLUDE_FROM_ALL` "
"目录属性排除的目标。名称“ALL_BUILD”用于 Xcode 和虚拟实验室生成器。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:583
msgid "``help``"
msgstr "``帮助``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:581
msgid ""
"Lists the targets available for build.  This target is available when "
"using the :generator:`Unix Makefiles` or :generator:`Ninja` generator, and"
" the exact output is tool-specific."
msgstr ""
"列出可用于构建的目标。使用 :generator:`Unix Makefiles` 或 :generator:`Ninja` "
"生成器时可以使用此目标，并且确切的输出是特定于工具的。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:589
msgid "``clean``"
msgstr "``干净``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:586
msgid ""
"Delete built object files and other output files.  The ``Makefile`` based "
"generators create a ``clean`` target per directory, so that an individual "
"directory can be cleaned.  The ``Ninja`` tool provides its own granular "
"``-t clean`` system."
msgstr ""
"删除构建的目标文件和其他输出文件。基于``Makefile`` 的生成器为每个目录创建一个``clean`` 目标，以便可以清理单个目录。 "
"``Ninja`` 工具提供了自己的粒度``-t clean`` 系统。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:593
msgid "``test``"
msgstr "``测试``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:592
msgid ""
"Runs tests.  This target is only automatically available if the CMake "
"files provide CTest-based tests.  See also `Running Tests`_."
msgstr "运行测试。此目标仅在 CMake 文件提供基于 CTest 的测试时自动可用。另见`运行测试`_。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:598
msgid "``install``"
msgstr "``安装``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:596
msgid ""
"Installs the software.  This target is only automatically available if the"
" software defines install rules with the :command:`install` command.  See "
"also `Software Installation`_."
msgstr "安装软件。只有当软件使用 :command:`install` 命令定义安装规则时，此目标才会自动可用。另见`软件安装`_。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:602
msgid "``package``"
msgstr "``包``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:601
msgid ""
"Creates a binary package.  This target is only automatically available if "
"the CMake files provide CPack-based packages."
msgstr "创建一个二进制包。只有当 CMake 文件提供基于 CPack 的包时，此目标才会自动可用。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:607
msgid "``package_source``"
msgstr "``package_source``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:605
msgid ""
"Creates a source package.  This target is only automatically available if "
"the CMake files provide CPack-based packages."
msgstr "创建源包。只有当 CMake 文件提供基于 CPack 的包时，此目标才会自动可用。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:609
msgid ""
"For ``Makefile`` based systems, ``/fast`` variants of binary build targets"
" are provided. The ``/fast`` variants are used to build the specified "
"target without regard for its dependencies.  The dependencies are not "
"checked and are not rebuilt if out of date.  The :generator:`Ninja` "
"generator is sufficiently fast at dependency checking that such targets "
"are not provided for that generator."
msgstr ""
"对于基于“Makefile”的系统，提供了二进制构建目标的“/fast”变体。 ``/fast`` "
"变体用于构建指定目标而不考虑其依赖性。不检查依赖项，如果过期则不重建。 :generator:`Ninja` "
"生成器在依赖性检查方面足够快，不会为该生成器提供此类目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:617
msgid ""
"``Makefile`` based systems also provide build-targets to preprocess, "
"assemble and compile individual files in a particular directory."
msgstr "基于``Makefile`` 的系统还提供构建目标来预处理、组装和编译特定目录中的单个文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:627
msgid ""
"The file extension is built into the name of the target because another "
"file with the same name but a different extension may exist.  However, "
"build-targets without the file extension are also provided."
msgstr "文件扩展名内置于目标名称中，因为可能存在另一个同名但扩展名不同的文件。但是，也提供了没有文件扩展名的构建目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:638
msgid ""
"In buildsystems which contain ``foo.c`` and ``foo.cpp``, building the "
"``foo.i`` target will preprocess both files."
msgstr "在包含“foo.c”和“foo.cpp”的构建系统中，构建“foo.i”目标将预处理这两个文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:642
msgid "Specifying a Build Program"
msgstr "指定构建程序"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:644
msgid ""
"The program invoked by the :option:`--build <cmake --build>` mode is "
"determined by the :variable:`CMAKE_MAKE_PROGRAM` variable. For most "
"generators, the particular program does not need to be configured."
msgstr ""
":option:`--build <cmake --build>` 模式调用的程序由 :variable:`CMAKE_MAKE_PROGRAM` "
"变量决定。对于大多数生成器，不需要配置特定程序。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:650
msgid "Generator"
msgstr "生成器"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:650
msgid "Default make program"
msgstr "默认制作程序"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:650
msgid "Alternatives"
msgstr "备择方案"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:652
msgid "XCode"
msgstr "XCode"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:652
msgid "``xcodebuild``"
msgstr "``xcodebuild``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:653
msgid "Unix Makefiles"
msgstr "Unix 生成文件"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:653
#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:657
msgid "``make``"
msgstr "``制作``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:654
msgid "NMake Makefiles"
msgstr "NMake 生成文件"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:654
#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:655
msgid "``nmake``"
msgstr "``nmake``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:654
#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:655
msgid "``jom``"
msgstr "``乔姆``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:655
msgid "NMake Makefiles JOM"
msgstr "NMake 生成文件 JOM"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:656
msgid "MinGW Makefiles"
msgstr "MinGW 生成文件"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:656
msgid "``mingw32-make``"
msgstr "``mingw32-make``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:657
msgid "MSYS Makefiles"
msgstr "MSYS 生成文件"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:658
msgid "Ninja"
msgstr "忍者"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:658
msgid "``ninja``"
msgstr "``忍者``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:659
msgid "Visual Studio"
msgstr "视觉工作室"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:659
msgid "``msbuild``"
msgstr "``msbuild``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:660
msgid "Watcom WMake"
msgstr "沃通WMake"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:660
msgid "``wmake``"
msgstr "``wmake``"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:663
msgid ""
"The ``jom`` tool is capable of reading makefiles of the ``NMake`` flavor "
"and building in parallel, while the ``nmake`` tool always builds serially."
"  After generating with the :generator:`NMake Makefiles` generator a user "
"can run ``jom`` instead of ``nmake``.  The :option:`--build <cmake "
"--build>` mode would also use ``jom`` if the "
":variable:`CMAKE_MAKE_PROGRAM` was set to ``jom`` while using the "
":generator:`NMake Makefiles` generator, and as a convenience, the "
":generator:`NMake Makefiles JOM` generator is provided to find ``jom`` in "
"the normal way and use it as the :variable:`CMAKE_MAKE_PROGRAM`. For "
"completeness, ``nmake`` is an alternative tool which can process the "
"output of the :generator:`NMake Makefiles JOM` generator, but doing so "
"would be a pessimization."
msgstr ""
"``jom`` 工具能够读取 ``NMake`` 风格的 makefile 并并行构建，而 ``nmake`` 工具总是串行构建。使用 "
":generator:`NMake Makefiles` 生成器生成后，用户可以运行 ``jom`` 而不是 ``nmake``。如果在使用 "
"NMake Makefiles 时将 CMAKE_MAKE_PROGRAM 设置为 jom，则 :option:`--build <cmake "
"--build>` 模式也将使用 ``jom``生成器，并且为方便起见，提供了 NMake Makefiles JOM 生成器以正常方式查找 jom"
" 并将其用作 CMAKE_MAKE_PROGRAM。为了完整起见，``nmake`` 是一个替代工具，它可以处理 :generator:`NMake"
" Makefiles JOM` 生成器的输出，但这样做会让人悲观。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:681
msgid "Software Installation"
msgstr "软件安装"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:683
msgid ""
"The :variable:`CMAKE_INSTALL_PREFIX` variable can be set in the CMake "
"cache to specify where to install the provided software.  If the provided "
"software has install rules, specified using the :command:`install` "
"command, they will install artifacts into that prefix.  On Windows, the "
"default installation location corresponds to the ``ProgramFiles`` system "
"directory which may be architecture specific.  On Unix hosts, "
"``/usr/local`` is the default installation location."
msgstr ""
":variable:`CMAKE_INSTALL_PREFIX` 变量可以在 CMake "
"缓存中设置，以指定安装提供的软件的位置。如果提供的软件有安装规则，使用 :command:`install` "
"命令指定，它们会将工件安装到该前缀中。在 Windows 上，默认安装位置对应于可能特定于体系结构的“ProgramFiles”系统目录。在 "
"Unix 主机上，``/usr/local`` 是默认安装位置。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:693
msgid ""
"The :variable:`CMAKE_INSTALL_PREFIX` variable always refers to the "
"installation prefix on the target filesystem."
msgstr ":variable:`CMAKE_INSTALL_PREFIX` 变量总是指目标文件系统上的安装前缀。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:697
msgid ""
"In cross-compiling or packaging scenarios where the sysroot is read-only "
"or where the sysroot should otherwise remain pristine, the "
":variable:`CMAKE_STAGING_PREFIX` variable can be set to a location to "
"actually install the files."
msgstr ""
"在 sysroot 为只读或 sysroot 应保持原始状态的交叉编译或打包场景中，可以将 "
":variable:`CMAKE_STAGING_PREFIX` 变量设置为实际安装文件的位置。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:703
msgid "The commands:"
msgstr "命令："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:713
msgid ""
"result in files being installed to paths such as "
"``/tmp/package/lib/libfoo.so`` on the host machine. The ``/usr/local`` "
"location on the host machine is not affected."
msgstr ""
"导致文件被安装到主机上的路径，例如 ``/tmp/package/lib/libfoo.so``。主机上的 ``/usr/local`` "
"位置不受影响。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:718
msgid ""
"Some provided software may specify ``uninstall`` rules, but CMake does not"
" generate such rules by default itself."
msgstr "某些提供的软件可能会指定“卸载”规则，但 CMake 本身默认不会生成此类规则。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:722
msgid "Running Tests"
msgstr "运行测试"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:724
msgid ""
"The :manual:`ctest(1)` tool is shipped with the CMake distribution to "
"execute provided tests and report results.  The ``test`` build-target is "
"provided to run all available tests, but the :manual:`ctest(1)` tool "
"allows granular control over which tests to run, how to run them, and how "
"to report results.  Executing :manual:`ctest(1)` in the build directory is"
" equivalent to running the ``test`` target:"
msgstr ""
":manual:`ctest(1)` 工具随 CMake 发行版一起提供，用于执行提供的测试并报告结果。 ``test`` "
"构建目标用于运行所有可用的测试，但 :manual:`ctest(1)` "
"工具允许精细控制运行哪些测试、如何运行它们以及如何报告结果。在构建目录中执行 :manual:`ctest(1)` 相当于运行 ``test`` "
"目标："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:737
msgid ""
"A regular expression can be passed to run only tests which match the "
"expression.  To run only tests with ``Qt`` in their name:"
msgstr "可以传递正则表达式以仅运行与表达式匹配的测试。仅运行名称中带有“Qt”的测试："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:745
msgid ""
"Tests can be excluded by regular expression too.  To run only tests "
"without ``Qt`` in their name:"
msgstr "正则表达式也可以排除测试。只运行名称中没有“Qt”的测试："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:752
msgid ""
"Tests can be run in parallel by passing :option:`-j <ctest -j>` arguments "
"to :manual:`ctest(1)`:"
msgstr "通过将 :option:`-j <ctest -j>` 参数传递给 :manual:`ctest(1)` 可以并行运行测试："

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:759
msgid ""
"The environment variable :envvar:`CTEST_PARALLEL_LEVEL` can alternatively "
"be set to avoid the need to pass :option:`-j <ctest -j>`."
msgstr ""
"也可以设置环境变量:envvar:`CTEST_PARALLEL_LEVEL` 以避免需要传递:option:`-j <ctest -j>`。"

#: ../../cmake-prefix/src/cmake/Help/guide/user-interaction/index.rst:763
msgid ""
"By default :manual:`ctest(1)` does not print the output from the tests. "
"The command line argument :option:`-V <ctest -V>` (or ``--verbose``) "
"enables verbose mode to print the output from all tests. The "
":option:`--output-on-failure <ctest --output-on-failure>` option prints "
"the test output for failing tests only. The environment variable "
":envvar:`CTEST_OUTPUT_ON_FAILURE` can be set to ``1`` as an alternative to"
" passing the :option:`--output-on-failure <ctest --output-on-failure>` "
"option to :manual:`ctest(1)`."
msgstr ""
"默认情况下:manual:`ctest(1)` 不打印测试的输出。命令行参数:option:`-V <ctest "
"-V>`（或``--verbose``）启用详细模式以打印所有测试的输出。 :option:`--output-on-failure <ctest "
"--output-on-failure>` 选项仅打印失败测试的测试输出。环境变量 "
":envvar:`CTEST_OUTPUT_ON_FAILURE` 可以设置为 ``1`` 作为将 :option:`--output-on-"
"failure <ctest --output-on-failure>` 选项传递给 :manual 的替代方法：`ctest(1)`。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:2
msgid "Using Dependencies Guide"
msgstr "使用依赖指南"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:11
msgid ""
"Projects will frequently depend on other projects, assets, and artifacts. "
"CMake provides a number of ways to incorporate such things into the build."
" Projects and users have the flexibility to choose between methods that "
"best suit their needs."
msgstr ""
"项目将经常依赖于其他项目、资产和工件。 CMake 提供了多种方法将这些东西合并到构建中。项目和用户可以灵活地选择最适合他们需要的方法。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:16
msgid ""
"The primary methods of bringing dependencies into the build are the "
":command:`find_package` command and the :module:`FetchContent` module. The"
" :module:`FindPkgConfig` module is also sometimes used, although it lacks "
"some of the integration of the other two and is not discussed any further "
"in this guide."
msgstr ""
"将依赖项引入构建的主要方法是:command:`find_package` 命令和:module:`FetchContent` 模块。 "
":module:`FindPkgConfig` 模块有时也会被使用，尽管它缺少其他两个模块的一些集成并且在本指南中没有进一步讨论。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:22
msgid ""
"Dependencies can also be made available by a custom :ref:`dependency "
"provider <dependency_providers>`. This might be a third party package "
"manager, or it might be custom code implemented by the developer.  "
"Dependency providers co-operate with the primary methods mentioned above "
"to extend their flexibility."
msgstr ""
"依赖项也可以通过自定义 :ref:`dependency provider <dependency_providers>` "
"提供。这可能是第三方包管理器，也可能是开发人员实现的自定义代码。依赖提供者与上述主要方法合作以扩展其灵活性。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:31
msgid "Using Pre-built Packages With ``find_package()``"
msgstr "使用带有 ``find_package()`` 的预构建包"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:33
msgid ""
"A package needed by the project may already be built and available at some"
" location on the user's system.  That package might have also been built "
"by CMake, or it could have used a different build system entirely.  It "
"might even just be a collection of files that didn't need to be built at "
"all. CMake provides the :command:`find_package` command for these "
"scenarios. It searches well-known locations, along with additional hints "
"and paths provided by the project or user.  It also supports package "
"components and packages being optional.  Result variables are provided to "
"allow the project to customize its own behavior according to whether the "
"package or specific components were found."
msgstr ""
"项目所需的包可能已经在用户系统的某个位置构建并可用。该包也可能由 CMake "
"构建，或者它可能完全使用不同的构建系统。它甚至可能只是根本不需要构建的文件集合。 CMake 为这些场景提供了 "
":command:`find_package` "
"命令。它搜索众所周知的位置，以及项目或用户提供的其他提示和路径。它还支持包组件和包是可选的。提供结果变量以允许项目根据是否找到包或特定组件来自定义自己的行为。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:44
msgid ""
"In most cases, projects should generally use the :ref:`basic signature`. "
"Most of the time, this will involve just the package name, maybe a version"
" constraint, and the ``REQUIRED`` keyword if the dependency is not "
"optional. A set of package components may also be specified."
msgstr ""
"在大多数情况下，项目通常应该使用 :ref:`basic "
"signature` 。大多数时候，这将只涉及包名称，可能是版本约束，如果依赖项不是可选的，则还包括 ``REQUIRED`` "
"关键字。也可以指定一组包组件。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:49
msgid "Examples of ``find_package()`` basic signature"
msgstr "``find_package()`` 基本签名的例子"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:56
msgid ""
"The :command:`find_package` command supports two main methods for carrying"
" out the search:"
msgstr ":command:`find_package` 命令支持两种主要的搜索方法："

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:62
msgid "**Config mode**"
msgstr "**配置模式**"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:60
msgid ""
"With this method, the command looks for files that are typically provided "
"by the package itself.  This is the more reliable method of the two, since"
" the package details should always be in sync with the package."
msgstr "使用此方法，该命令会查找通常由包本身提供的文件。这是两者中更可靠的方法，因为包详细信息应始终与包同步。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:72
msgid "**Module mode**"
msgstr "**模块模式**"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:65
msgid ""
"Not all packages are CMake-aware. Many don't provide the files needed to "
"support config mode.  For such cases, a Find module file can be provided "
"separately, either by the project or by CMake.  A Find module is typically"
" a heuristic implementation which knows what the package normally provides"
" and how to present that package to the project.  Since Find modules are "
"usually distributed separately from the package, they are not as reliable."
" They are typically maintained separately, and they are likely to follow "
"different release schedules, so they can easily become out-of-date."
msgstr ""
"并非所有包都支持 CMake。许多不提供支持配置模式所需的文件。对于这种情况，可以由项目或 CMake 单独提供 Find 模块文件。 Find "
"模块通常是一种启发式实现，它知道包通常提供什么以及如何将该包呈现给项目。由于 Find "
"模块通常与包分开分发，因此它们不那么可靠。它们通常是分开维护的，并且它们可能遵循不同的发布时间表，因此它们很容易变得过时。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:74
msgid ""
"Depending on the arguments used, :command:`find_package` may use one or "
"both of the above methods.  By restricting the options to just the basic "
"signature, both config mode and module mode can be used to satisfy the "
"dependency. The presence of other options may restrict the call to using "
"only one of the two methods, potentially reducing the command's ability to"
" find the dependency. See the :command:`find_package` documentation for "
"full details about this complex topic."
msgstr ""
"根据使用的参数， :command:`find_package` "
"可以使用上述一种或两种方法。通过将选项限制为基本签名，可以使用配置模式和模块模式来满足依赖性。其他选项的存在可能会将调用限制为仅使用两种方法中的一种，从而可能降低命令查找依赖项的能力。有关此复杂主题的完整详细信息，请参阅 :command:`find_package`"
" 文档。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:82
msgid ""
"For both search methods, the user can also set cache variables on the "
":manual:`cmake(1)` command line or in the :manual:`ccmake(1)` or "
":manual:`cmake-gui(1)` UI tools to influence and override where to find "
"packages. See the :ref:`User Interaction Guide <Setting Build Variables>` "
"for more on how to set cache variables."
msgstr ""
"对于这两种搜索方法，用户还可以在 :manual:`cmake(1)` 命令行或 :manual:`ccmake(1)` 或 "
":manual:`cmake-gui(1)` UI 中设置缓存变量影响和覆盖在哪里可以找到包的工具。有关如何设置缓存变量的更多信息，请参阅 "
":ref:`User Interaction Guide <Setting Build Variables>`。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:91
msgid "Config-file packages"
msgstr "配置文件包"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:93
msgid ""
"The preferred way for a third party to provide executables, libraries, "
"headers, and other files for use with CMake is to provide :ref:`config "
"files <Config File Packages>`.  These are text files shipped with the "
"package, which define CMake targets, variables, commands, and so on. The "
"config file is an ordinary CMake script, which is read in by the "
":command:`find_package` command."
msgstr ""
"第三方提供可执行文件、库、标头和其他与 CMake 一起使用的文件的首选方法是提供:ref:`配置文件 <Config File "
"Packages>`。这些是包附带的文本文件，定义了 CMake 目标、变量、命令等。配置文件是一个普通的 CMake 脚本，由 "
":command:`find_package` 命令读取。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:100
msgid ""
"The config files can usually be found in a directory whose name matches "
"the pattern ``lib/cmake/<PackageName>``, although they may be in other "
"locations instead (see :ref:`search procedure`).  The ``<PackageName>`` is"
" usually the first argument to the :command:`find_package` command, and it"
" may even be the only argument.  Alternative names can also be specified "
"with the ``NAMES`` option:"
msgstr ""
"配置文件通常可以在名称与模式 ``lib/cmake/<PackageName>`` 匹配的目录中找到，尽管它们可能位于其他位置（参见 "
":ref:`search procedure`）。 ``<PackageName>`` 通常是 :command:`find_package` "
"命令的第一个参数，它甚至可能是唯一的参数。也可以使用 ``NAMES`` 选项指定替代名称："

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:107
msgid "Providing alternative names when finding a package"
msgstr "查找包时提供替代名称"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:116
msgid ""
"The config file must be named either ``<PackageName>Config.cmake`` or "
"``<LowercasePackageName>-config.cmake`` (the former is used for the "
"remainder of this guide, but both are supported).  This file is the entry "
"point to the package for CMake.  A separate optional file named "
"``<PackageName>ConfigVersion.cmake`` or ``<LowercasePackageName>-config-"
"version.cmake`` may also exist in the same directory.  This file is used "
"by CMake to determine whether the version of the package satisfies any "
"version constraint included in the call to :command:`find_package`.  It is"
" optional to specify a version when calling :command:`find_package`, even "
"if a ``<PackageName>ConfigVersion.cmake`` file is present."
msgstr ""
"配置文件必须命名为``<PackageName>Config.cmake`` "
"或``<LowercasePackageName>-config.cmake``（前者用于本指南的其余部分，但两者都受支持）。此文件是 CMake "
"包的入口点。名为“<PackageName>ConfigVersion.cmake”或“<LowercasePackageName>-config-"
"version.cmake”的单独可选文件也可能存在于同一目录中。 CMake 使用此文件来确定包的版本是否满足调用 "
":command:`find_package` 时包含的任何版本约束。调用 :command:`find_package` "
"时指定版本是可选的，即使存在 ``<PackageName>ConfigVersion.cmake`` 文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:128
msgid ""
"If the ``<PackageName>Config.cmake`` file is found and any version "
"constraint is satisfied, the :command:`find_package` command considers the"
" package to be found, and the entire package is assumed to be complete as "
"designed."
msgstr ""
"如果找到 ``<PackageName>Config.cmake`` 文件并且满足任何版本约束，则 :command:`find_package` "
"命令认为已找到该包，并且假定整个包已按设计完成。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:132
msgid ""
"There may be additional files providing CMake commands or :ref:`imported "
"targets` for you to use.  CMake does not enforce any naming convention for"
" these files.  They are related to the primary "
"``<PackageName>Config.cmake`` file by use of the CMake :command:`include` "
"command.  The ``<PackageName>Config.cmake`` file would typically include "
"these for you, so they won't usually require any additional step other "
"than the call to :command:`find_package`."
msgstr ""
"可能还有其他文件提供 CMake 命令或 :ref:`imported targets` 供您使用。 CMake "
"不对这些文件强制执行任何命名约定。它们通过使用 CMake:command:`include` "
"命令与主要的``<PackageName>Config.cmake`` 文件相关。 ``<PackageName>Config.cmake`` "
"文件通常会为您包含这些，因此除了调用 :command:`find_package` 之外，它们通常不需要任何额外的步骤。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:140
msgid ""
"If the location of the package is in a :ref:`directory known to CMake "
"<search procedure>`, the :command:`find_package` call should succeed.  The"
" directories known to CMake are platform-specific.  For example, packages "
"installed on Linux with a standard system package manager will be found in"
" the ``/usr`` prefix automatically.  Packages installed in ``Program "
"Files`` on Windows will similarly be found automatically."
msgstr ""
"如果包的位置在 :ref:`已知的 CMake 目录 <search procedure>` 中，则 :command:`find_package` "
"调用应该会成功。 CMake 已知的目录是特定于平台的。例如，使用标准系统包管理器安装在 Linux 上的包将自动在“/usr”前缀中找到。安装在 "
"Windows 上的“Program Files”中的包同样会被自动找到。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:148
msgid ""
"Packages will not be found automatically without help if they are in "
"locations not known to CMake, such as ``/opt/mylib`` or "
"``$HOME/dev/prefix``. This is a normal situation, and CMake provides "
"several ways for users to specify where to find such libraries."
msgstr ""
"如果包位于 CMake 不知道的位置，例如 ``/opt/mylib`` 或 "
"``$HOME/dev/prefix``，则不会在没有帮助的情况下自动找到它们。这是正常情况，CMake "
"提供了几种方式让用户指定在哪里可以找到这样的库。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:153
msgid ""
"The :variable:`CMAKE_PREFIX_PATH` variable may be :ref:`set when invoking "
"CMake <Setting Build Variables>`. It is treated as a list of base paths in"
" which to search for :ref:`config files <Config File Packages>`.  A "
"package installed in ``/opt/somepackage`` will typically install config "
"files such as "
"``/opt/somepackage/lib/cmake/somePackage/SomePackageConfig.cmake``. In "
"that case, ``/opt/somepackage`` should be added to "
":variable:`CMAKE_PREFIX_PATH`."
msgstr ""
":variable:`CMAKE_PREFIX_PATH` 变量可以在 "
":ref:`调用 CMake 时设置 <Setting Build Variables>` 。它被视为一个基本路径列表，可在其中搜索 :ref:`config files <Config File "
"Packages>` 。安装在“/opt/somepackage”中的包通常会安装配置文件，例如“/opt/somepackage/lib/cmake/somePackage/SomePackageConfig.cmake”。在这种情况下， ``/opt/somepackage``"
" 应该添加到 :variable:`CMAKE_PREFIX_PATH` 。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:162
msgid ""
"The environment variable ``CMAKE_PREFIX_PATH`` may also be populated with "
"prefixes to search for packages.  Like the ``PATH`` environment variable, "
"this is a list, but it needs to use the platform-specific environment "
"variable list item separator (``:`` on Unix and ``;`` on Windows)."
msgstr ""
"环境变量“CMAKE_PREFIX_PATH”也可以填充前缀以搜索包。与 ``PATH`` "
"环境变量一样，这是一个列表，但它需要使用特定于平台的环境变量列表项分隔符（Unix 上为 ``:`` ，Windows 上为 ``;`` ）。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:167
msgid ""
"The :variable:`CMAKE_PREFIX_PATH` variable provides convenience in cases "
"where multiple prefixes need to be specified, or when multiple packages "
"are available under the same prefix.  Paths to packages may also be "
"specified by setting variables matching ``<PackageName>_DIR``, such as "
"``SomePackage_DIR``.  Note that this is not a prefix, but should be a full"
" path to a directory containing a config-style package file, such as "
"``/opt/somepackage/lib/cmake/SomePackage`` in the above example. See the "
":command:`find_package` documentation for other CMake variables and "
"environment variables that can affect the search."
msgstr ""
":variable:`CMAKE_PREFIX_PATH` "
"变量在需要指定多个前缀或同一前缀下有多个包可用的情况下提供便利。包的路径也可以通过设置匹配``<PackageName>_DIR``的变量来指定，例如``SomePackage_DIR``。请注意，这不是前缀，而应该是包含配置样式包文件的目录的完整路径，例如上例中的“/opt/somepackage/lib/cmake/SomePackage”。有关可能影响搜索的其他"
" CMake 变量和环境变量，请参阅 :command:`find_package` 文档。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:180
msgid "Find Module Files"
msgstr "查找模块文件"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:182
msgid ""
"Packages which do not provide config files can still be found with the "
":command:`find_package` command, if a ``FindSomePackage.cmake`` file is "
"available.  These Find module files are different to config files in that:"
msgstr ""
"如果 ``FindSomePackage.cmake`` 文件可用，仍然可以使用 :command:`find_package` "
"命令找到不提供配置文件的包。这些 Find 模块文件与配置文件的不同之处在于："

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:186
msgid "Find module files should not be provided by the package itself."
msgstr "包本身不应提供查找模块文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:187
msgid ""
"The availability of a ``Find<PackageName>.cmake`` file does not indicate "
"the availability of the package, or any particular part of the package."
msgstr "``Find<PackageName>.cmake`` 文件的可用性并不表示包或包的任何特定部分的可用性。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:189
msgid ""
"CMake does not search the locations specified in the "
":variable:`CMAKE_PREFIX_PATH` variable for ``Find<PackageName>.cmake`` "
"files.  Instead, CMake searches for such files in the locations given by "
"the :variable:`CMAKE_MODULE_PATH` variable.  It is common for users to set"
" the :variable:`CMAKE_MODULE_PATH` when running CMake, and it is common "
"for CMake projects to append to :variable:`CMAKE_MODULE_PATH` to allow use"
" of local Find module files."
msgstr ""
"CMake 不会在 :variable:`CMAKE_PREFIX_PATH` 变量中指定的位置搜索 "
"``Find<PackageName>.cmake`` 文件。相反，CMake 在 CMAKE_MODULE_PATH "
"变量给定的位置搜索此类文件。用户通常在运行 CMake 时设置 :variable:`CMAKE_MODULE_PATH`，CMake "
"项目通常附加到 :variable:`CMAKE_MODULE_PATH` 以允许使用本地查找模块文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:196
msgid ""
"CMake ships ``Find<PackageName>.cmake`` files for some :manual:`third "
"party packages <cmake-modules(7)>`.  These files are a maintenance burden "
"for CMake, and it is not unusual for these to fall behind the latest "
"releases of the packages they are associated with. In general, new Find "
"modules are not added to CMake any more.  Projects should encourage the "
"upstream packages to provide a config file where possible.  If that is "
"unsuccessful, the project should provide its own Find module for the "
"package."
msgstr ""
"CMake 为一些第三方包 <cmake-modules(7)> 提供了 ``Find<PackageName>.cmake`` 文件。这些文件是 "
"CMake 的维护负担，并且这些文件落后于与其关联的包的最新版本并不罕见。一般来说，新的 Find 模块不再添加到 CMake "
"中。项目应该鼓励上游包尽可能提供配置文件。如果不成功，项目应该为包提供自己的查找模块。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:205
msgid ""
"See :ref:`Find Modules` for a detailed discussion of how to write a Find "
"module file."
msgstr "有关如何编写查找模块文件的详细讨论，请参阅 :ref:`Find Modules`。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:211
msgid "Imported Targets"
msgstr "进口目标"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:213
msgid ""
"Both config files and Find module files can define :ref:`Imported "
"targets`. These will typically have names of the form "
"``SomePrefix::ThingName``. Where these are available, the project should "
"prefer to use them instead of any CMake variables that may also be "
"provided.  Such targets typically carry usage requirements and apply "
"things like header search paths, compiler definitions, etc. automatically "
"to other targets that link to them (e.g. using "
":command:`target_link_libraries`).  This is both more robust and more "
"convenient than trying to apply the same things manually using variables. "
"Check the documentation for the package or Find module to see what "
"imported targets it defines, if any."
msgstr ""
"配置文件和查找模块文件都可以定义 :ref:`Imported "
"targets`。这些通常具有“SomePrefix::ThingName”形式的名称。在这些可用的地方，项目应该更喜欢使用它们而不是也可能提供的任何"
" CMake "
"变量。这些目标通常带有使用要求，并自动将标题搜索路径、编译器定义等应用到链接到它们的其他目标（例如使用 :command:`target_link_libraries`）。这比尝试使用变量手动应用相同的东西更健壮也更方便。检查包或查找模块的文档以查看它定义的导入目标（如果有）。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:224
msgid ""
"Imported targets should also encapsulate any configuration-specific paths."
" This includes the location of binaries (libraries, executables), compiler"
" flags, and any other configuration-dependent quantities.  Find modules "
"may be less reliable in providing these details than config files."
msgstr ""
"导入的目标还应该封装任何特定于配置的路径。这包括二进制文件（库、可执行文件）的位置、编译器标志和任何其他与配置相关的数量。查找模块在提供这些详细信息方面可能不如配置文件可靠。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:229
msgid ""
"A complete example which finds a third party package and uses a library "
"from it might look like the following:"
msgstr "查找第三方包并使用其中的库的完整示例可能如下所示："

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:244
msgid ""
"Note that the above call to :command:`find_package` could be resolved by a"
" config file or a Find module.  It uses only the basic arguments supported"
" by the :ref:`basic signature`.  A ``FindSomePackage.cmake`` file in the "
"``${CMAKE_CURRENT_SOURCE_DIR}/cmake`` directory would allow the "
":command:`find_package` command to succeed using module mode, for example."
" If no such module file is present, the system would be searched for a "
"config file."
msgstr ""
"请注意，上面对 :command:`find_package` 的调用可以通过配置文件或 Find 模块来解析。它仅使用 :ref:`basic "
"signature` 支持的基本参数。例如，``${CMAKE_CURRENT_SOURCE_DIR}/cmake`` 目录中的 "
"``FindSomePackage.cmake`` 文件将允许 :command:`find_package` "
"命令成功使用模块模式。如果不存在这样的模块文件，系统将搜索配置文件。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:254
msgid "Downloading And Building From Source With ``FetchContent``"
msgstr "使用“FetchContent”从源代码下载和构建"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:256
msgid ""
"Dependencies do not necessarily have to be pre-built in order to use them "
"with CMake.  They can be built from sources as part of the main project. "
"The :module:`FetchContent` module provides functionality to download "
"content (typically sources, but can be anything) and add it to the main "
"project if the dependency also uses CMake.  The dependency's sources will "
"be built along with the rest of the project, just as though the sources "
"were part of the project's own sources."
msgstr ""
"依赖项不一定要预先构建才能与 CMake 一起使用。它们可以作为主项目的一部分从源代码构建。 :module:`FetchContent` "
"模块提供下载内容（通常是源代码，但可以是任何内容）并将其添加到主项目（如果依赖项也使用 "
"CMake）的功能。依赖项的源代码将与项目的其余部分一起构建，就好像这些源代码是项目自己的源代码的一部分一样。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:264
msgid ""
"The general pattern is that the project should first declare all the "
"dependencies it wants to use, then ask for them to be made available. The "
"following demonstrates the principle (see :ref:`fetch-content-examples` "
"for more):"
msgstr ""
"一般模式是项目应该首先声明它想要使用的所有依赖项，然后请求它们可用。下面演示原理（更多信息参见:ref:`fetch-content-"
"examples`）："

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:284
msgid ""
"Various download methods are supported, including downloading and "
"extracting archives from a URL (a range of archive formats are supported),"
" and a number of repository formats including Git, Subversion, and "
"Mercurial. Custom download, update, and patch commands can also be used to"
" support arbitrary use cases."
msgstr ""
"支持各种下载方法，包括从 URL 下载和提取存档（支持一系列存档格式），以及多种存储库格式，包括 Git、Subversion 和 "
"Mercurial。自定义下载、更新和补丁命令也可用于支持任意用例。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:290
msgid ""
"When a dependency is added to the project with :module:`FetchContent`, the"
" project links to the dependency's targets just like any other target from"
" the project.  If the dependency provides namespaced targets of the form "
"``SomePrefix::ThingName``, the project should link to those rather than to"
" any non-namespaced targets.  See the next section for why this is "
"recommended."
msgstr ""
"当使用 :module:`FetchContent` "
"将依赖项添加到项目时，项目将链接到依赖项的目标，就像项目中的任何其他目标一样。如果依赖项提供形式为“SomePrefix::ThingName”的命名空间目标，则项目应链接到这些目标而不是任何非命名空间目标。请参阅下一节了解为什么建议这样做。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:296
msgid ""
"Not all dependencies can be brought into the project this way.  Some "
"dependencies define targets whose names clash with other targets from the "
"project or other dependencies.  Concrete executable and library targets "
"created by :command:`add_executable` and :command:`add_library` are "
"global, so each one must be unique across the whole build.  If a "
"dependency would add a clashing target name, it cannot be brought directly"
" into the build with this method."
msgstr ""
"并不是所有的依赖都可以通过这种方式引入到项目中。一些依赖项定义了名称与项目或其他依赖项中的其他目标冲突的目标。由 "
":command:`add_executable` 和 :command:`add_library` "
"创建的具体可执行文件和库目标是全局的，因此每个目标在整个构建过程中都必须是唯一的。如果依赖项会添加冲突的目标名称，则不能使用此方法将其直接引入构建中。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:305
msgid "``FetchContent`` And ``find_package()`` Integration"
msgstr "``FetchContent`` 和 ``find_package()`` 集成"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:309
msgid ""
"Some dependencies support being added by either :command:`find_package` or"
" :module:`FetchContent`.  Such dependencies must ensure they define the "
"same namespaced targets in both installed and built-from-source scenarios."
" A consuming project then links to those namespaced targets and can handle"
" both scenarios transparently, as long as the project does not use "
"anything else that isn't provided by both methods."
msgstr ""
"一些依赖项支持通过 :command:`find_package` 或 :module:`FetchContent` "
"添加。此类依赖项必须确保它们在已安装和从源代码构建的场景中定义相同的命名空间目标。一个消费项目然后链接到那些命名空间的目标，并且可以透明地处理这两种情况，只要该项目不使用这两种方法未提供的任何其他内容。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:316
msgid ""
"The project can indicate it is happy to accept a dependency by either "
"method using the ``FIND_PACKAGE_ARGS`` option to "
":command:`FetchContent_Declare`. This allows "
":command:`FetchContent_MakeAvailable` to try satisfying the dependency "
"with a call to :command:`find_package` first, using the arguments after "
"the ``FIND_PACKAGE_ARGS`` keyword, if any.  If that doesn't find the "
"dependency, it is built from source as described previously instead."
msgstr ""
"该项目可以使用 :command:`FetchContent_Declare` 的 ``FIND_PACKAGE_ARGS`` "
"选项来表明它很乐意通过任一方法接受依赖项。这允许 :command:`FetchContent_MakeAvailable` 尝试首先调用 "
":command:`find_package` 来满足依赖关系，使用 ``FIND_PACKAGE_ARGS`` "
"关键字后的参数（如果有的话）。如果没有找到依赖项，它将按照前面所述从源代码构建。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:337
msgid ""
"The above example calls :command:`find_package(googletest NAMES GTest) "
"<find_package>` first. CMake provides a :module:`FindGTest` module, so if "
"that finds a GTest package installed somewhere, it will make it available,"
" and the dependency will not be built from source.  If no GTest package is"
" found, it *will* be built from source.  In either case, the "
"``GTest::gtest_main`` target is expected to be defined, so we link our "
"unit test executable to that target."
msgstr ""
"上面的例子首先调用 :command:`find_package(googletest NAMES GTest) <find_package>`。 "
"CMake 提供了一个 :module:`FindGTest` 模块，因此如果它找到安装在某处的 GTest "
"包，它将使其可用，并且不会从源代码构建依赖项。如果没有找到 GTest "
"包，它*将*从源代码构建。在任何一种情况下，``GTest::gtest_main`` "
"目标都应该被定义，所以我们将我们的单元测试可执行文件链接到该目标。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:345
msgid ""
"High-level control is also available through the "
":variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` variable.  This can be set "
"to ``NEVER`` to disable all redirection to :command:`find_package`.  It "
"can be set to ``ALWAYS`` to try :command:`find_package` even if "
"``FIND_PACKAGE_ARGS`` was not specified (this should be used with "
"caution)."
msgstr ""
"也可以通过 FETCHCONTENT_TRY_FIND_PACKAGE_MODE 变量进行高级控制。这可以设置为 ``NEVER`` "
"以禁用所有重定向到 :command:`find_package`。它可以设置为 ``ALWAYS`` 来尝试 "
":command:`find_package` 即使没有指定 ``FIND_PACKAGE_ARGS``（这应该谨慎使用）。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:351
msgid ""
"The project might also decide that a particular dependency must be built "
"from source.  This might be needed if a patched or unreleased version of "
"the dependency is required, or to satisfy some policy that requires all "
"dependencies to be built from source.  The project can enforce this by "
"adding the ``OVERRIDE_FIND_PACKAGE`` keyword to "
":command:`FetchContent_Declare`. A call to :command:`find_package` for "
"that dependency will then be redirected to "
":command:`FetchContent_MakeAvailable` instead."
msgstr ""
"该项目还可能决定必须从源代码构建特定的依赖项。如果需要依赖项的补丁版本或未发布版本，或者满足某些要求所有依赖项都从源代码构建的策略，则可能需要这样做。该项目可以通过将“OVERRIDE_FIND_PACKAGE”关键字添加到“FetchContent_Declare”来强制执行此操作。对该依赖项的调用:command:`find_package`"
" 将被重定向到:command:`FetchContent_MakeAvailable`。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:372
msgid ""
"For more advanced use cases, see the "
":variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` variable."
msgstr "有关更高级的用例，请参阅 :variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` 变量。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:378
msgid "Dependency Providers"
msgstr "依赖提供者"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:382
msgid ""
"The preceding section discussed techniques that projects can use to "
"specify their dependencies.  Ideally, the project shouldn't really care "
"where a dependency comes from, as long as it provides the things it "
"expects (often just some imported targets).  The project says what it "
"needs and may also specify where to get it from, in the absence of any "
"other details, so that it can still be built out-of-the-box."
msgstr ""
"上一节讨论了项目可用于指定其依赖项的技术。理想情况下，项目不应该真正关心依赖项来自何处，只要它提供了它期望的东西（通常只是一些导入的目标）。在没有任何其他细节的情况下，该项目说明了它需要什么，并且还可以指定从哪里获得它，以便它仍然可以开箱即用。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:389
msgid ""
"The developer, on the other hand, may be much more interested in "
"controlling *how* a dependency is provided to the project.  You might want"
" to use a particular version of a package that you built yourself.  You "
"might want to use a third party package manager.  You might want to "
"redirect some requests to a different URL on a system you control for "
"security or performance reasons.  CMake supports these sort of scenarios "
"through :ref:`dependency_providers`."
msgstr ""
"另一方面，开发人员可能对控制*如何*向项目提供依赖项更感兴趣。您可能想要使用您自己构建的包的特定版本。您可能想要使用第三方包管理器。出于安全或性能原因，您可能希望将某些请求重定向到您控制的系统上的不同"
" URL。 CMake 通过 dependency_providers 支持这些场景。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:397
msgid ""
"A dependency provider can be set to intercept :command:`find_package` and "
":command:`FetchContent_MakeAvailable` calls.  The provider is given an "
"opportunity to satisfy such requests before falling back to the built-in "
"implementation if the provider doesn't fulfill it."
msgstr ""
"依赖项提供程序可以设置为拦截 :command:`find_package` "
"和 :command:`FetchContent_MakeAvailable` "
"调用。如果提供者不满足这些请求，则提供者有机会在回退到内置实现之前满足此类请求。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:402
msgid ""
"Only one dependency provider can be set, and it can only be set at a very "
"specific point early in the CMake run. The "
":variable:`CMAKE_PROJECT_TOP_LEVEL_INCLUDES` variable lists CMake files "
"that will be read while processing the first :command:`project()` call "
"(and only that call).  This is the only time a dependency provider may be "
"set. At most, one single provider is expected to be used throughout the "
"whole project."
msgstr ""
"只能设置一个依赖提供者，并且只能在 CMake 运行的早期非常特定的时间点设置。 "
":variable:`CMAKE_PROJECT_TOP_LEVEL_INCLUDES` 变量列出了在处理第一个 "
":command:`project()` 调用（并且只有那个调用）时将被读取的 CMake "
"文件。这是唯一可以设置依赖项提供程序的时间。在整个项目中最多只能使用一个供应商。"

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:410
msgid ""
"For some scenarios, the user wouldn't need to know the details of how the "
"dependency provider is set.  A third party may provide a file that can be "
"added to :variable:`CMAKE_PROJECT_TOP_LEVEL_INCLUDES`, which will set up "
"the dependency provider on the user's behalf.  This is the recommended "
"approach for package managers.  The developer can use such a file like "
"so::"
msgstr ""
"对于某些场景，用户不需要知道依赖提供者的设置细节。第三方可能会提供一个可以添加到 CMAKE_PROJECT_TOP_LEVEL_INCLUDES "
"的文件，这将代表用户设置依赖项提供程序。这是包管理器推荐的方法。开发人员可以像这样使用这样的文件："

#: ../../cmake-prefix/src/cmake/Help/guide/using-dependencies/index.rst:418
msgid ""
"For details on how to implement your own custom dependency provider, see "
"the :command:`cmake_language(SET_DEPENDENCY_PROVIDER)` command."
msgstr ""
"有关如何实现您自己的自定义依赖项提供程序的详细信息，请参阅 "
":command:`cmake_language(SET_DEPENDENCY_PROVIDER)` 命令。"
