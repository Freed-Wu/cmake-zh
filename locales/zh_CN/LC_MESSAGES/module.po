# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2000-2023 Kitware, Inc. and Contributors
# This file is distributed under the same license as the CMake package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CMake 3.26.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-01 00:02+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.12.1\n"

#: ../../cmake-prefix/src/cmake/Modules/AddFileDependencies.cmake:6
msgid "AddFileDependencies"
msgstr "添加文件依赖项"

#: ../../cmake-prefix/src/cmake/Modules/AddFileDependencies.cmake:10
msgid "Add dependencies to a source file."
msgstr "将依赖项添加到源文件。"

#: ../../cmake-prefix/src/cmake/Modules/AddFileDependencies.cmake:16
msgid "Adds the given ``<files>`` to the dependencies of file ``<source>``."
msgstr "将给定的 ``<files>`` 添加到文件 ``<source>`` 的依赖项中。"

#: ../../cmake-prefix/src/cmake/Modules/AddFileDependencies.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/MacroAddFileDependencies.cmake:14
msgid "Do not use this command in new code.  It is just a wrapper around:"
msgstr "不要在新代码中使用此命令。它只是一个包装器："

#: ../../cmake-prefix/src/cmake/Modules/AddFileDependencies.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/MacroAddFileDependencies.cmake:20
msgid ""
"Instead use the :command:`set_property` command to append to the "
":prop_sf:`OBJECT_DEPENDS` source file property directly."
msgstr ""
"而是使用 :command:`set_property` 命令直接附加到 :prop_sf:`OBJECT_DEPENDS` 源文件属性。"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:6
msgid "AndroidTestUtilities"
msgstr "Android测试工具"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:10
msgid ""
"Create a test that automatically loads specified data onto an Android "
"device."
msgstr "创建一个自动将指定数据加载到 Android 设备上的测试。"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:15
msgid "Introduction"
msgstr "介绍"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:15
msgid ""
"Use this module to push data needed for testing an Android device behavior"
" onto a connected Android device. The module will accept files and "
"libraries as well as separate destinations for each. It will create a test"
" that loads the files into a device object store and link to them from the"
" specified destination. The files are only uploaded if they are not "
"already in the object store."
msgstr ""
"使用此模块将测试 Android 设备行为所需的数据推送到连接的 Android "
"设备上。该模块将接受文件和库以及每个文件和库的单独目的地。它将创建一个测试，将文件加载到设备对象存储中并从指定目标链接到它们。仅当文件不在对象存储中时才会上传这些文件。"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:51
#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:919
#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:167
msgid "For example:"
msgstr "例如："

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:36
msgid ""
"At build time a test named \"example_setup_test\" will be created.  Run "
"this test on the command line with :manual:`ctest(1)` to load the data "
"onto the Android device."
msgstr ""
"在构建时，将创建一个名为“example_setup_test”的测试。使用 ctest(1) 在命令行上运行此测试，以将数据加载到 Android"
" 设备上。"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:77
msgid "Module Functions"
msgstr "模块功能"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:55
msgid ""
"The ``android_add_test_data`` function is used to copy files and libraries"
" needed to run project-specific tests. On the host operating system, this "
"is done at build time. For on-device testing, the files are loaded onto "
"the device by the manufactured test at run time."
msgstr ""
"``android_add_test_data`` "
"函数用于复制运行项目特定测试所需的文件和库。在主机操作系统上，这是在构建时完成的。对于设备上测试，文件在运行时由制造测试加载到设备上。"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:60
msgid "This function accepts the following named parameters:"
msgstr "此函数接受以下命名参数："

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:62
msgid "``FILES <files>...``"
msgstr "``FILES <文件>...``"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:63
msgid "zero or more files needed for testing"
msgstr "测试需要零个或多个文件"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:64
msgid "``LIBS <libs>...``"
msgstr "``LIBS <库> ...``"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:65
msgid "zero or more libraries needed for testing"
msgstr "测试需要零个或多个库"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:66
msgid "``FILES_DEST <device-dir>``"
msgstr "``FILES_DEST <设备目录>``"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:67
msgid "absolute path where the data files are expected to be"
msgstr "数据文件预期所在的绝对路径"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:68
msgid "``LIBS_DEST <device-dir>``"
msgstr "``LIBS_DEST <设备目录>``"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:69
msgid "absolute path where the libraries are expected to be"
msgstr "库预期所在的绝对路径"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:70
msgid "``DEVICE_OBJECT_STORE <device-dir>``"
msgstr "``DEVICE_OBJECT_STORE <设备目录>``"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:71
msgid "absolute path to the location where the data is stored on-device"
msgstr "数据在设备上存储位置的绝对路径"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:72
msgid "``DEVICE_TEST_DIR <device-dir>``"
msgstr "``DEVICE_TEST_DIR <设备目录>``"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:73
msgid "absolute path to the root directory of the on-device test location"
msgstr "设备上测试位置根目录的绝对路径"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:75
msgid "``NO_LINK_REGEX <strings>...``"
msgstr "``NO_LINK_REGEX <字符串>...``"

#: ../../cmake-prefix/src/cmake/Modules/AndroidTestUtilities.cmake:75
msgid ""
"list of regex strings matching the names of files that should be copied "
"from the object store to the testing directory"
msgstr "与应从对象存储复制到测试目录的文件名匹配的正则表达式字符串列表"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:6
msgid "BundleUtilities"
msgstr "捆绑实用程序"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:8
msgid "Functions to help assemble a standalone bundle application."
msgstr "帮助组装独立捆绑应用程序的功能。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:10
msgid ""
"A collection of CMake utility functions useful for dealing with ``.app`` "
"bundles on the Mac and bundle-like directories on any OS."
msgstr "一组 CMake 实用函数，可用于处理 Mac 上的“.app”包和任何操作系统上的类包目录。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:31
msgid "The following functions are provided by this module:"
msgstr "该模块提供以下功能："

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:35
msgid ""
"Requires CMake 2.6 or greater because it uses function, break and "
"``PARENT_SCOPE``.  Also depends on ``GetPrerequisites.cmake``."
msgstr ""
"需要 CMake 2.6 或更高版本，因为它使用函数、中断和 ``PARENT_SCOPE``。也取决于 "
"``GetPrerequisites.cmake``。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:38
msgid ""
"DO NOT USE THESE FUNCTIONS AT CONFIGURE TIME (from ``CMakeLists.txt``)! "
"Instead, invoke them from an :command:`install(CODE)` or "
":command:`install(SCRIPT)` rule."
msgstr ""
"不要在配置时使用这些函数（来自 ``CMakeLists.txt``）！相反，从 :command:`install(CODE)` 或 "
":command:`install(SCRIPT)` 规则调用它们。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:46
msgid ""
"Fix up ``<app>`` bundle in-place and make it standalone, such that it can "
"be drag-n-drop copied to another machine and run on that machine as long "
"as all of the system libraries are compatible."
msgstr "就地修复 ``<app>`` 包并使其独立，这样只要所有系统库兼容，它就可以拖放复制到另一台机器并在该机器上运行。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:50
msgid ""
"If you pass plugins to ``fixup_bundle`` as the libs parameter, you should "
"install them or copy them into the bundle before calling ``fixup_bundle``."
" The ``<libs>`` parameter is a list of libraries that must be fixed up, "
"but that cannot be determined by ``otool`` output analysis  (i.e. "
"``plugins``)."
msgstr ""
"如果您将插件作为 libs 参数传递给 ``fixup_bundle``，您应该在调用 ``fixup_bundle`` "
"之前安装它们或将它们复制到包中。 ``<libs>`` 参数是必须修复的库列表，但无法通过 ``otool`` 输出分析（即 "
"``plugins``）确定。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:55
msgid ""
"Gather all the keys for all the executables and libraries in a bundle, and"
" then, for each key, copy each prerequisite into the bundle.  Then fix "
"each one up according to its own list of prerequisites."
msgstr "收集捆绑包中所有可执行文件和库的所有密钥，然后针对每个密钥，将每个先决条件复制到捆绑包中。然后根据自己的先决条件列表修复每一个。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:59
msgid ""
"Then clear all the keys and call ``verify_app`` on the final bundle to "
"ensure that it is truly standalone."
msgstr "然后清除所有密钥并在最终包上调用 ``verify_app`` 以确保它是真正独立的。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:62
msgid ""
"As an optional parameter (``IGNORE_ITEM``) a list of file names can be "
"passed, which are then ignored (e.g. ``IGNORE_ITEM "
"\"vcredist_x86.exe;vcredist_x64.exe\"``)."
msgstr ""
"作为一个可选参数（``IGNORE_ITEM``）可以传递一个文件名列表，然后忽略它们（例如``IGNORE_ITEM“vcredist_x86.exe;vcredist_x64.exe”``）。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:71
msgid ""
"Makes a copy of the bundle ``<src>`` at location ``<dst>`` and then fixes "
"up the new copied bundle in-place at ``<dst>``."
msgstr "在位置“<dst>”复制包“<src>”，然后在“<dst>”就地修复新复制的包。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:78
msgid ""
"Verifies that an application ``<app>`` appears valid based on running "
"analysis tools on it.  Calls :command:`message(FATAL_ERROR)` if the "
"application is not verified."
msgstr ""
"根据在其上运行的分析工具，验证应用程序“<app>”是否有效。如果应用程序未通过验证，则调用:command:`message(FATAL_ERROR)`。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:82
#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:160
#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:221
msgid ""
"As an optional parameter (``IGNORE_ITEM``) a list of file names can be "
"passed, which are then ignored (e.g. ``IGNORE_ITEM "
"\"vcredist_x86.exe;vcredist_x64.exe\"``)"
msgstr ""
"作为可选参数（``IGNORE_ITEM``）可以传递文件名列表，然后忽略它们（例如``IGNORE_ITEM“vcredist_x86.exe;vcredist_x64.exe”``）"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:91
msgid ""
"The result will be the full path name of the bundle's main executable file"
" or an ``error:`` prefixed string if it could not be determined."
msgstr "结果将是 bundle 的主要可执行文件的完整路径名，或者如果无法确定则为 ``error:`` 前缀字符串。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:98
msgid ""
"Returns the nearest parent dir whose name ends with ``.app`` given the "
"full path to an executable.  If there is no such parent dir, then simply "
"return the dir containing the executable."
msgstr "给定可执行文件的完整路径，返回名称以“.app”结尾的最近的父目录。如果没有这样的父目录，则只需返回包含可执行文件的目录。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:102
msgid "The returned directory may or may not exist."
msgstr "返回的目录可能存在也可能不存在。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:108
msgid ""
"Takes either a ``.app`` directory name or the name of an executable nested"
" inside a ``.app`` directory and returns the path to the ``.app`` "
"directory in ``<bundle_var>`` and the path to its main executable in "
"``<executable_var>``."
msgstr ""
"获取“.app”目录名称或嵌套在“.app”目录中的可执行文件的名称，并返回“<bundle_var>”中“.app”目录的路径和``<executable_var>``"
" 中其主要可执行文件的路径。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:117
msgid ""
"Scans ``<bundle>`` bundle recursively for all ``<exes_var>`` executable "
"files and accumulates them into a variable."
msgstr "递归扫描 ``<bundle>`` 包以查找所有 ``<exes_var>`` 可执行文件并将它们累积到一个变量中。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:124
msgid ""
"Given ``<item>`` file name, generate ``<key_var>`` key that should be "
"unique considering the set of libraries that need copying or fixing up to "
"make a bundle standalone.  This is essentially the file name including "
"extension with ``.`` replaced by ``_``"
msgstr ""
"给定 ``<item>`` 文件名，生成 ``<key_var>`` "
"键，考虑到需要复制或修复以使捆绑包独立的一组库，该键应该是唯一的。这本质上是文件名，包括用 ``.`` 替换为 ``_`` 的扩展名"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:129
msgid ""
"This key is used as a prefix for CMake variables so that we can associate "
"a set of variables with a given item based on its key."
msgstr "此键用作 CMake 变量的前缀，以便我们可以根据其键将一组变量与给定项目相关联。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:136
msgid ""
"Loop over the ``<keys_var>`` list of keys, clearing all the variables "
"associated with each key.  After the loop, clear the list of keys itself."
msgstr "遍历“<keys_var>”键列表，清除与每个键关联的所有变量。循环后，清除键列表本身。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:139
msgid ""
"Caller of ``get_bundle_keys`` should call ``clear_bundle_keys`` when done "
"with list of keys."
msgstr "``get_bundle_keys`` 的调用者在完成键列表后应该调用``clear_bundle_keys``。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:147
msgid ""
"Add ``<keys_var>`` key to the list (if necessary) for the given item. If "
"added, also set all the variables associated with that key."
msgstr "将 ``<keys_var>`` 键添加到给定项目的列表（如有必要）。如果添加，还要设置与该键关联的所有变量。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:154
msgid ""
"Loop over all the executable and library files within ``<app>`` bundle "
"(and given as extra ``<libs>``) and accumulate a list of keys representing"
" them.  Set values associated with each key such that we can loop over all"
" of them and copy prerequisite libs into the bundle and then do "
"appropriate ``install_name_tool`` fixups."
msgstr ""
"遍历``<app>`` 包中的所有可执行文件和库文件（并作为额外的``<libs>`` "
"给出）并累积代表它们的键列表。设置与每个键关联的值，以便我们可以遍历所有键并将先决条件库复制到包中，然后进行适当的“install_name_tool”修复。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:169
msgid ""
"Copy a resolved item into the bundle if necessary. Copy is not necessary, "
"if the ``<resolved_item>`` is \"the same as\" the "
"``<resolved_embedded_item>``."
msgstr ""
"如有必要，将已解决的项目复制到捆绑包中。如果``<resolved_item>``与``<resolved_embedded_item>``“相同”，则不需要复制。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:177
msgid ""
"Copy a resolved framework into the bundle if necessary. Copy is not "
"necessary, if the ``<resolved_item>`` is \"the same as\" the "
"``<resolved_embedded_item>``."
msgstr ""
"如有必要，将已解析的框架复制到包中。如果``<resolved_item>``与``<resolved_embedded_item>``“相同”，则不需要复制。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:181
msgid ""
"By default, ``BU_COPY_FULL_FRAMEWORK_CONTENTS`` is not set.  If you want "
"full frameworks embedded in your bundles, set "
"``BU_COPY_FULL_FRAMEWORK_CONTENTS`` to ``ON`` before calling fixup_bundle."
"  By default, ``COPY_RESOLVED_FRAMEWORK_INTO_BUNDLE`` copies the framework"
" dylib itself plus the framework ``Resources`` directory."
msgstr ""
"默认情况下，“BU_COPY_FULL_FRAMEWORK_CONTENTS”未设置。如果你想在你的包中嵌入完整的框架，请在调用 "
"fixup_bundle "
"之前将“BU_COPY_FULL_FRAMEWORK_CONTENTS”设置为“ON”。默认情况下，``COPY_RESOLVED_FRAMEWORK_INTO_BUNDLE``"
" 复制框架 dylib 本身加上框架``Resources`` 目录。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:191
msgid ""
"Get the direct/non-system prerequisites of the "
"``<resolved_embedded_item>``. For each prerequisite, change the way it is "
"referenced to the value of the ``_EMBEDDED_ITEM`` keyed variable for that "
"prerequisite.  (Most likely changing to an ``@executable_path`` style "
"reference.)"
msgstr ""
"获取``<resolved_embedded_item>``的直接/非系统先决条件。对于每个先决条件，将其引用方式更改为该先决条件的“_EMBEDDED_ITEM”键控变量的值。"
" （很可能更改为“@executable_path”样式参考。）"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:196
msgid ""
"This function requires that the ``<resolved_embedded_item>`` be ``inside``"
" the bundle already.  In other words, if you pass plugins to "
"``fixup_bundle`` as the libs parameter, you should install them or copy "
"them into the bundle before calling ``fixup_bundle``.  The ``libs`` "
"parameter is a list of libraries that must be fixed up, but that cannot be"
" determined by otool output analysis.  (i.e., ``plugins``)"
msgstr ""
"此函数要求``<resolved_embedded_item>`` 已经``inside`` 包。换句话说，如果您将插件作为 libs 参数传递给 "
"``fixup_bundle``，您应该在调用 ``fixup_bundle`` 之前安装它们或将它们复制到包中。 ``libs`` "
"参数是必须修复的库列表，但无法通过 otool 输出分析确定。 （即``插件``）"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:203
msgid ""
"Also, change the id of the item being fixed up to its own "
"``_EMBEDDED_ITEM`` value."
msgstr "此外，将要修复的项目的 ID 更改为它自己的 ``_EMBEDDED_ITEM`` 值。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:206
msgid ""
"Accumulate changes in a local variable and make *one* call to "
"``install_name_tool`` at the end of the function with all the changes at "
"once."
msgstr "累积局部变量中的更改，并在函数末尾*一次*调用 ``install_name_tool``，同时包含所有更改。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:210
msgid ""
"If the ``BU_CHMOD_BUNDLE_ITEMS`` variable is set then bundle items will be"
" marked writable before ``install_name_tool`` tries to change them."
msgstr ""
"如果设置了 ``BU_CHMOD_BUNDLE_ITEMS`` 变量，那么在 ``install_name_tool`` "
"尝试更改它们之前，捆绑项目将被标记为可写。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:217
msgid ""
"Verifies that the sum of all prerequisites of all files inside the bundle "
"are contained within the bundle or are ``system`` libraries, presumed to "
"exist everywhere."
msgstr "验证捆绑包中所有文件的所有先决条件的总和是否包含在捆绑包中，或者是假定存在于任何地方的“系统”库。"

#: ../../cmake-prefix/src/cmake/Modules/BundleUtilities.cmake:230
msgid ""
"Verifies that any symlinks found in the ``<bundle>`` bundle point to other"
" files that are already also in the bundle...  Anything that points to an "
"external file causes this function to fail the verification."
msgstr ""
"验证在 ``<bundle>`` 包中找到的任何符号链接是否指向其他已经在包中的文件...任何指向外部文件的内容都会导致此函数无法通过验证。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeAddFortranSubdirectory.cmake:6
msgid "CMakeAddFortranSubdirectory"
msgstr "CMakeAddFortran 子目录"

#: ../../cmake-prefix/src/cmake/Modules/CMakeAddFortranSubdirectory.cmake:8
msgid "Add a fortran-only subdirectory, find a fortran compiler, and build."
msgstr "添加一个仅限 fortran 的子目录，找到一个 fortran 编译器，然后构建。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeAddFortranSubdirectory.cmake:10
msgid ""
"The ``cmake_add_fortran_subdirectory`` function adds a subdirectory to a "
"project that contains a fortran-only subproject.  The module will check "
"the current compiler and see if it can support fortran.  If no fortran "
"compiler is found and the compiler is MSVC, then this module will find the"
" MinGW gfortran.  It will then use an external project to build with the "
"MinGW tools.  It will also create imported targets for the libraries "
"created.  This will only work if the fortran code is built into a dll, so "
":variable:`BUILD_SHARED_LIBS` is turned on in the project.  In addition "
"the :variable:`CMAKE_GNUtoMS` option is set to on, so that Microsoft "
"``.lib`` files are created.  Usage is as follows:"
msgstr ""
"``cmake_add_fortran_subdirectory`` 函数将一个子目录添加到一个包含仅 fortran "
"子项目的项目中。该模块将检查当前的编译器并查看它是否可以支持 Fortran。如果没有找到 fortran 编译器并且编译器是 "
"MSVC，那么这个模块将找到 MinGW gfortran。然后它将使用外部项目通过 MinGW "
"工具进行构建。它还将为创建的库创建导入的目标。这仅在将 fortran 代码内置到 dll "
"中时才有效，因此 :variable:`BUILD_SHARED_LIBS` 在项目中打开。此外， :variable:`CMAKE_GNUtoMS` 选项设置为 "
"on，以便创建 Microsoft ``.lib`` 文件。用法如下："

#: ../../cmake-prefix/src/cmake/Modules/CMakeAddFortranSubdirectory.cmake:35
msgid ""
"Relative paths in ``ARCHIVE_DIR`` and ``RUNTIME_DIR`` are interpreted with"
" respect to the build directory corresponding to the source directory in "
"which the function is invoked."
msgstr "``ARCHIVE_DIR`` 和 ``RUNTIME_DIR`` 中的相对路径根据与调用函数的源目录相对应的构建目录进行解释。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeAddFortranSubdirectory.cmake:39
msgid "Limitations:"
msgstr "限制："

#: ../../cmake-prefix/src/cmake/Modules/CMakeAddFortranSubdirectory.cmake:41
msgid ""
"``NO_EXTERNAL_INSTALL`` is required for forward compatibility with a "
"future version that supports installation of the external project binaries"
" during ``make install``."
msgstr ""
"``NO_EXTERNAL_INSTALL`` 是为了与支持在``make install`` "
"期间安装外部项目二进制文件的未来版本向前兼容所必需的。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeBackwardCompatibilityCXX.cmake:6
msgid "CMakeBackwardCompatibilityCXX"
msgstr "CMakeBackwardCompatibilityCXX"

#: ../../cmake-prefix/src/cmake/Modules/CMakeBackwardCompatibilityCXX.cmake:8
msgid "define a bunch of backwards compatibility variables"
msgstr "定义一堆向后兼容变量"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:6
msgid "CMakeDependentOption"
msgstr "CMakeDependentOption"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:8
msgid "Macro to provide an option dependent on other options."
msgstr "提供依赖于其他选项的选项的宏。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:10
msgid ""
"This macro presents an option to the user only if a set of other "
"conditions are true."
msgstr "仅当一组其他条件为真时，此宏才会向用户提供一个选项。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:19
msgid ""
"Makes ``<option>`` available to the user if the :ref:`semicolon-separated "
"list <CMake Language Lists>` of conditions in ``<depends>`` are all true."
"  Otherwise, a local variable named ``<option>`` is set to ``<force>``."
msgstr ""
"如果 ``<depends>`` 中条件的分号分隔列表 <CMake Language Lists>` 全部为真，则使 ``<option>`` "
"对用户可用。否则，名为“<option>”的局部变量将设置为“<force>”。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:24
msgid ""
"When ``<option>`` is available, the given ``<help_text>`` and initial "
"``<value>`` are used. Otherwise, any value set by the user is preserved "
"for when ``<depends>`` is satisfied in the future."
msgstr ""
"当``<option>`` 可用时，使用给定的``<help_text>`` "
"和初始的``<value>``。否则，将保留用户设置的任何值，以供将来满足 <depends> 时使用。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:28
msgid ""
"Note that the ``<option>`` variable only has a value which satisfies the "
"``<depends>`` condition within the scope of the caller because it is a "
"local variable."
msgstr "请注意，``<option>`` 变量只有一个值满足调用者范围内的``<depends>`` 条件，因为它是一个局部变量。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:32
msgid "Example invocation:"
msgstr "调用示例："

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:38
msgid ""
"If ``USE_BAR`` is true and ``USE_ZOT`` is false, this provides an option "
"called ``USE_FOO`` that defaults to ON. Otherwise, it sets ``USE_FOO`` to "
"OFF and hides the option from the user. If the status of ``USE_BAR`` or "
"``USE_ZOT`` ever changes, any value for the ``USE_FOO`` option is saved so"
" that when the option is re-enabled it retains its old value."
msgstr ""
"如果 ``USE_BAR`` 为真而 ``USE_ZOT`` 为假，这提供了一个名为 ``USE_FOO`` 的选项，默认为 ON。否则，它会将 "
"``USE_FOO`` 设置为 OFF 并向用户隐藏该选项。如果 ``USE_BAR`` 或 ``USE_ZOT`` 的状态发生变化，则 "
"``USE_FOO`` 选项的任何值都会被保存，以便在重新启用该选项时保留其旧值。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDependentOption.cmake:46
msgid ""
"Full :ref:`Condition Syntax` is now supported.  See policy "
":policy:`CMP0127`."
msgstr "现在支持完整的 :ref:`Condition Syntax`。请参阅政策:policy:`CMP0127`。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDetermineVSServicePack.cmake:6
msgid "CMakeDetermineVSServicePack"
msgstr "CMakeDetermineVSServicePack"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDetermineVSServicePack.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/CMakeExpandImportedTargets.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:10
msgid "Do not use."
msgstr "不使用。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDetermineVSServicePack.cmake:12
msgid ""
"The functionality of this module has been superseded by the "
":variable:`CMAKE_<LANG>_COMPILER_VERSION` variable that contains the "
"compiler version number."
msgstr "此模块的功能已被包含编译器版本号的 CMAKE_<LANG>_COMPILER_VERSION 变量取代。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDetermineVSServicePack.cmake:16
msgid "Determine the Visual Studio service pack of the 'cl' in use."
msgstr "确定正在使用的“cl”的 Visual Studio 服务包。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeDetermineVSServicePack.cmake:18
msgid "Usage::"
msgstr "用法：："

#: ../../cmake-prefix/src/cmake/Modules/CMakeDetermineVSServicePack.cmake:28
msgid ""
"Function DetermineVSServicePack sets the given variable to one of the "
"following values or an empty string if unknown::"
msgstr "函数 DetermineVSServicePack 将给定变量设置为以下值之一或空字符串（如果未知） ::"

#: ../../cmake-prefix/src/cmake/Modules/CMakeExpandImportedTargets.cmake:6
msgid "CMakeExpandImportedTargets"
msgstr "CMakeExpandImportedTargets"

#: ../../cmake-prefix/src/cmake/Modules/CMakeExpandImportedTargets.cmake:12
msgid ""
"This module was once needed to expand imported targets to the underlying "
"libraries they reference on disk for use with the :command:`try_compile` "
"and :command:`try_run` commands.  These commands now support imported "
"libraries in their ``LINK_LIBRARIES`` options (since CMake 2.8.11 for "
":command:`try_compile` and since CMake 3.2 for :command:`try_run`)."
msgstr ""
"曾经需要此模块将导入的目标扩展到它们在磁盘上引用的基础库，以便与 :command:`try_compile` 和 "
":command:`try_run` 命令一起使用。这些命令现在在其“LINK_LIBRARIES”选项中支持导入的库（自 CMake 2.8.11"
" 开始用于 :command:`try_compile`，自 CMake 3.2 开始用于 :command:`try_run`）。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeExpandImportedTargets.cmake:18
msgid ""
"This module does not support the policy :policy:`CMP0022` ``NEW`` behavior"
" or use of the :prop_tgt:`INTERFACE_LINK_LIBRARIES` property because "
":manual:`generator expressions <cmake-generator-expressions(7)>` cannot be"
" evaluated during configuration."
msgstr ""
"此模块不支持策略:policy:`CMP0022` ``NEW`` 行为或使用:prop_tgt:`INTERFACE_LINK_LIBRARIES` "
"属性，因为:manual:`generator expressions <cmake-generator-expressions(7)>` "
"不能在配置期间进行评估。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeExpandImportedTargets.cmake:28
msgid ""
"CMAKE_EXPAND_IMPORTED_TARGETS() takes a list of libraries and replaces all"
" imported targets contained in this list with their actual file paths of "
"the referenced libraries on disk, including the libraries from their link "
"interfaces.  If a CONFIGURATION is given, it uses the respective "
"configuration of the imported targets if it exists.  If no CONFIGURATION "
"is given, it uses the first configuration from "
"${CMAKE_CONFIGURATION_TYPES} if set, otherwise ${CMAKE_BUILD_TYPE}."
msgstr ""
"CMAKE_EXPAND_IMPORTED_TARGETS() "
"获取库列表，并将此列表中包含的所有导入目标替换为磁盘上引用库的实际文件路径，包括来自其链接接口的库。如果给出了 "
"CONFIGURATION，它会使用导入目标的相应配置（如果存在）。如果未给出 CONFIGURATION，它将使用 "
"${CMAKE_CONFIGURATION_TYPES} 中的第一个配置（如果已设置），否则使用 ${CMAKE_BUILD_TYPE}。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:6
msgid "CMakeFindDependencyMacro"
msgstr "CMakeFindDependencyMacro"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:10
msgid ""
"The ``find_dependency()`` macro wraps a :command:`find_package` call for a"
" package dependency::"
msgstr "``find_dependency()`` 宏包装了一个 :command:`find_package` 对包依赖的调用："

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:15
msgid ""
"It is designed to be used in a :ref:`Package Configuration File <Config "
"File Packages>` (``<PackageName>Config.cmake``).  ``find_dependency`` "
"forwards the correct parameters for ``QUIET`` and ``REQUIRED`` which were "
"passed to the original :command:`find_package` call.  Any additional "
"arguments specified are forwarded to :command:`find_package`."
msgstr ""
"它旨在用于 :ref:`Package Configuration File <Config File Packages>` "
"(``<PackageName>Config.cmake``)。 ``find_dependency`` 转发传递给原始 "
":command:`find_package` 调用的 ``QUIET`` 和 ``REQUIRED`` 的正确参数。指定的任何其他参数都将转发给 "
":command:`find_package`。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:22
msgid ""
"If the dependency could not be found it sets an informative diagnostic "
"message and calls :command:`return` to end processing of the calling "
"package configuration file and return to the :command:`find_package` "
"command that loaded it."
msgstr ""
"如果找不到依赖项，它会设置一条信息性诊断消息并调用 :command:`return` 以结束调用包配置文件的处理并返回到加载它的 "
":command:`find_package` 命令。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:29
msgid ""
"The call to :command:`return` makes this macro unsuitable to call from "
":ref:`Find Modules`."
msgstr "调用 :command:`return` 使得这个宏不适合从 :ref:`Find Modules` 调用。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:33
msgid "Package Dependency Search Optimizations"
msgstr "包依赖搜索优化"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:35
msgid ""
"If ``find_dependency`` is called with arguments identical to a previous "
"call in the same directory, perhaps due to diamond-shaped package "
"dependencies, the underlying call to :command:`find_package` is optimized "
"out.  This optimization is important to support large package dependency "
"graphs while avoiding a combinatorial explosion of repeated searches. "
"However, the heuristic cannot account for ambient variables that affect "
"package behavior, such as ``<PackageName>_USE_STATIC_LIBS``, offered by "
"some packages.  Therefore package configuration files should avoid setting"
" such variables before their calls to ``find_dependency``."
msgstr ""
"如果调用 ``find_dependency`` 时使用的参数与同一目录中的先前调用相同，可能是由于菱形包依赖性，对 "
":command:`find_package` "
"的底层调用将被优化掉。这种优化对于支持大型包依赖图同时避免重复搜索的组合爆炸很重要。但是，启发式无法解释影响包行为的环境变量，例如某些包提供的``<PackageName>_USE_STATIC_LIBS``。因此，包配置文件应避免在调用“find_dependency”之前设置此类变量。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:45
msgid ""
"Previously, the underlying call to :command:`find_package` was always "
"optimized out if the package had already been found.  CMake 3.15 removed "
"the optimization to support cases in which ``find_dependency`` call "
"arguments request different components."
msgstr ""
"以前，如果包已经找到，对 :command:`find_package` 的底层调用总是被优化掉。 CMake 3.15 "
"删除了优化以支持“find_dependency”调用参数请求不同组件的情况。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindDependencyMacro.cmake:51
msgid ""
"The pre-3.15 optimization was restored, but with the above-described "
"heuristic to account for varying ``find_dependency`` call arguments."
msgstr "3.15 之前的优化已恢复，但使用上述启发式方法来解释不同的“find_dependency”调用参数。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindFrameworks.cmake:6
msgid "CMakeFindFrameworks"
msgstr "CMakeFindFrameworks"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindFrameworks.cmake:8
msgid "helper module to find OSX frameworks"
msgstr "查找 OSX 框架的辅助模块"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindFrameworks.cmake:10
msgid "This module reads hints about search locations from variables::"
msgstr "该模块从变量中读取有关搜索位置的提示："

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:6
msgid "CMakeFindPackageMode"
msgstr "CMakeFindPackageMode"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:10
msgid ""
"This file is executed by cmake when invoked with --find-package.  It "
"expects that the following variables are set using -D:"
msgstr "当使用 --find-package 调用时，该文件由 cmake 执行。它期望使用 -D 设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:80
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:222
#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:180
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:918
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1029
msgid "``NAME``"
msgstr "``名字``"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:14
msgid "name of the package"
msgstr "包裹名称"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:16
msgid "``COMPILER_ID``"
msgstr "``COMPILER_ID``"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:16
msgid ""
"the CMake compiler ID for which the result is, i.e. GNU/Intel/Clang/MSVC, "
"etc."
msgstr "结果所在的 CMake 编译器 ID，即 GNU/Intel/Clang/MSVC 等。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:88
msgid "``LANGUAGE``"
msgstr "``语言``"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:19
msgid "language for which the result will be used, i.e. C/CXX/Fortran/ASM"
msgstr "将使用结果的语言，即 C/CXX/Fortran/ASM"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:27
msgid "``MODE``"
msgstr "``模式``"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:22
msgid "``EXIST``"
msgstr "``存在``"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:23
msgid "only check for existence of the given package"
msgstr "只检查给定包是否存在"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:25
msgid "``COMPILE``"
msgstr "``编译``"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:25
msgid ""
"print the flags needed for compiling an object file which uses the given "
"package"
msgstr "打印编译使用给定包的目标文件所需的标志"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:27
msgid "``LINK``"
msgstr "``链接``"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:28
msgid "print the flags needed for linking when using the given package"
msgstr "使用给定包时打印链接所需的标志"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:204
#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:86
#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:505
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:95
msgid "``QUIET``"
msgstr "``安静``"

#: ../../cmake-prefix/src/cmake/Modules/CMakeFindPackageMode.cmake:30
msgid "if TRUE, don't print anything"
msgstr "如果为真，则不打印任何内容"

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:6
msgid "CMakeForceCompiler"
msgstr "CMakeForceCompiler"

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:12
msgid ""
"The macros provided by this module were once intended for use by cross-"
"compiling toolchain files when CMake was not able to automatically detect "
"the compiler identification.  Since the introduction of this module, "
"CMake's compiler identification capabilities have improved and can now be "
"taught to recognize any compiler.  Furthermore, the suite of information "
"CMake detects from a compiler is now too extensive to be provided by "
"toolchain files using these macros."
msgstr ""
"当 CMake 无法自动检测编译器标识时，此模块提供的宏曾用于交叉编译工具链文件。自引入该模块以来，CMake "
"的编译器识别能力得到了改进，现在可以被教导识别任何编译器。此外，CMake 从编译器检测到的信息套件现在过于广泛，无法由使用这些宏的工具链文件提供。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:20
msgid ""
"One common use case for this module was to skip CMake's checks for a "
"working compiler when using a cross-compiler that cannot link binaries "
"without special flags or custom linker scripts.  This case is now "
"supported by setting the :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` "
"variable in the toolchain file instead."
msgstr ""
"该模块的一个常见用例是在使用无法链接没有特殊标志或自定义链接器脚本的二进制文件的交叉编译器时跳过 CMake "
"对工作编译器的检查。现在通过在工具链文件中设置 CMAKE_TRY_COMPILE_TARGET_TYPE 变量来支持这种情况。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:28
msgid "Macro ``CMAKE_FORCE_C_COMPILER`` has the following signature:"
msgstr "宏“CMAKE_FORCE_C_COMPILER”具有以下签名："

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:34
msgid ""
"It sets :variable:`CMAKE_C_COMPILER <CMAKE_<LANG>_COMPILER>` to the given "
"compiler and the cmake internal variable :variable:`CMAKE_C_COMPILER_ID "
"<CMAKE_<LANG>_COMPILER_ID>` to the given compiler-id.  It also bypasses "
"the check for working compiler and basic compiler information tests."
msgstr ""
"它将 :variable:`CMAKE_C_COMPILER <CMAKE_<LANG>_COMPILER>` 设置为给定的编译器，并将 cmake"
" 内部变量 :variable:`CMAKE_C_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID>` 设置为给定的编译器"
" ID。它还绕过了工作编译器检查和基本编译器信息测试。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:40
msgid "Macro ``CMAKE_FORCE_CXX_COMPILER`` has the following signature:"
msgstr "宏“CMAKE_FORCE_CXX_COMPILER”具有以下签名："

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:46
msgid ""
"It sets :variable:`CMAKE_CXX_COMPILER <CMAKE_<LANG>_COMPILER>` to the "
"given compiler and the cmake internal variable "
":variable:`CMAKE_CXX_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID>` to the given "
"compiler-id.  It also bypasses the check for working compiler and basic "
"compiler information tests."
msgstr ""
"它将 :variable:`CMAKE_CXX_COMPILER <CMAKE_<LANG>_COMPILER>` 设置为给定的编译器，并将 "
"cmake 内部变量 :variable:`CMAKE_CXX_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID>` "
"设置为给定的编译器 ID。它还绕过了工作编译器检查和基本编译器信息测试。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:52
msgid "Macro ``CMAKE_FORCE_Fortran_COMPILER`` has the following signature:"
msgstr "宏“CMAKE_FORCE_Fortran_COMPILER”具有以下签名："

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:58
msgid ""
"It sets :variable:`CMAKE_Fortran_COMPILER <CMAKE_<LANG>_COMPILER>` to the "
"given compiler and the cmake internal variable "
":variable:`CMAKE_Fortran_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID>` to the "
"given compiler-id.  It also bypasses the check for working compiler and "
"basic compiler information tests."
msgstr ""
"它将 :variable:`CMAKE_Fortran_COMPILER <CMAKE_<LANG>_COMPILER>` 设置为给定的编译器，并将"
" cmake 内部变量 :variable:`CMAKE_Fortran_COMPILER_ID "
"<CMAKE_<LANG>_COMPILER_ID>` 设置为给定的编译器 ID。它还绕过了工作编译器检查和基本编译器信息测试。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeForceCompiler.cmake:64
msgid "So a simple toolchain file could look like this:"
msgstr "因此，一个简单的工具链文件可能如下所示："

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:6
msgid "CMakeGraphVizOptions"
msgstr "CMakeGraphViz选项"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:8
msgid "The builtin Graphviz support of CMake."
msgstr "CMake 的内置 Graphviz 支持。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:11
msgid "Generating Graphviz files"
msgstr "生成 Graphviz 文件"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:13
msgid ""
"CMake can generate `Graphviz <https://www.graphviz.org/>`_ files showing "
"the dependencies between the targets in a project, as well as external "
"libraries which are linked against."
msgstr ""
"CMake 可以生成 `Graphviz <https://www.graphviz.org/>`_ "
"文件，显示项目中目标之间的依赖关系，以及链接的外部库。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:17
msgid ""
"When running CMake with the ``--graphviz=foo.dot`` option, it produces:"
msgstr "当使用 ``--graphviz=foo.dot`` 选项运行 CMake 时，它​​会产生："

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:19
msgid "a ``foo.dot`` file, showing all dependencies in the project"
msgstr "一个 ``foo.dot`` 文件，显示项目中的所有依赖项"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:20
msgid ""
"a ``foo.dot.<target>`` file for each target, showing on which other "
"targets it depends"
msgstr "每个目标的 ``foo.dot.<target>`` 文件，显示它所依赖的其他目标"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:22
msgid ""
"a ``foo.dot.<target>.dependers`` file for each target, showing which other"
" targets depend on it"
msgstr "每个目标的 ``foo.dot.<target>.dependers`` 文件，显示哪些其他目标依赖于它"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:25
msgid ""
"Those .dot files can be converted to images using the *dot* command from "
"the Graphviz package:"
msgstr "可以使用 Graphviz 包中的 *dot* 命令将这些 .dot 文件转换为图像："

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:32
msgid ""
"The different dependency types ``PUBLIC``, ``INTERFACE`` and ``PRIVATE`` "
"are represented as solid, dashed and dotted edges."
msgstr "不同的依赖类型 ``PUBLIC``、``INTERFACE`` 和 ``PRIVATE`` 表示为实线、虚线和点线边缘。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:37
msgid "Variables specific to the Graphviz support"
msgstr "特定于 Graphviz 支持的变量"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:39
msgid ""
"The resulting graphs can be huge.  The look and content of the generated "
"graphs can be controlled using the file ``CMakeGraphVizOptions.cmake``.  "
"This file is first searched in :variable:`CMAKE_BINARY_DIR`, and then in "
":variable:`CMAKE_SOURCE_DIR`.  If found, the variables set in it are used "
"to adjust options for the generated Graphviz files."
msgstr ""
"生成的图表可能会很大。生成的图形的外观和内容可以使用文件“CMakeGraphVizOptions.cmake”来控制。该文件首先在 "
":variable:`CMAKE_BINARY_DIR` 中搜索，然后在 :variable:`CMAKE_SOURCE_DIR` "
"中搜索。如果找到，其中设置的变量将用于调整生成的 Graphviz 文件的选项。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:47
msgid "The graph name."
msgstr "图形名称。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:63
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:70
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:77
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:84
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:91
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:98
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:105
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:112
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:119
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:126
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:134
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:141
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:148
msgid "Mandatory: NO"
msgstr "强制性：否"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:50
msgid "Default: value of :variable:`CMAKE_PROJECT_NAME`"
msgstr "默认值： :variable:`CMAKE_PROJECT_NAME` 的值"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:54
msgid "The header written at the top of the Graphviz files."
msgstr "标头写在 Graphviz 文件的顶部。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:57
msgid "Default: \"node [ fontsize = \"12\" ];\""
msgstr "默认值： \"node [ fontsize = \"12\" ];\""

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:61
msgid "The prefix for each node in the Graphviz files."
msgstr "Graphviz 文件中每个节点的前缀。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:64
msgid "Default: \"node\""
msgstr "默认值： \"node\""

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:68
msgid "Set to FALSE to exclude executables from the generated graphs."
msgstr "设置为 FALSE 以从生成的图形中排除可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:71
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:78
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:85
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:92
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:99
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:106
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:113
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:120
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:142
#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:149
msgid "Default: TRUE"
msgstr "默认值：真"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:75
msgid "Set to FALSE to exclude static libraries from the generated graphs."
msgstr "设置为 FALSE 以从生成的图形中排除静态库。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:82
msgid "Set to FALSE to exclude shared libraries from the generated graphs."
msgstr "设置为 FALSE 以从生成的图形中排除共享库。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:89
msgid "Set to FALSE to exclude module libraries from the generated graphs."
msgstr "设置为 FALSE 以从生成的图形中排除模块库。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:96
msgid ""
"Set to FALSE to exclude interface libraries from the generated graphs."
msgstr "设置为 FALSE 以从生成的图形中排除接口库。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:103
msgid "Set to FALSE to exclude object libraries from the generated graphs."
msgstr "设置为 FALSE 以从生成的图形中排除对象库。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:110
msgid "Set to FALSE to exclude unknown libraries from the generated graphs."
msgstr "设置为 FALSE 以从生成的图形中排除未知库。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:117
msgid ""
"Set to FALSE to exclude external libraries from the generated graphs."
msgstr "设置为 FALSE 以从生成的图形中排除外部库。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:124
msgid "Set to TRUE to include custom targets in the generated graphs."
msgstr "设置为 TRUE 以在生成的图形中包含自定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:127
msgid "Default: FALSE"
msgstr "默认值：假"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:131
msgid ""
"A list of regular expressions for names of targets to exclude from the "
"generated graphs."
msgstr "要从生成的图形中排除的目标名称的正则表达式列表。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:135
msgid "Default: empty"
msgstr "默认值：空"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:139
msgid "Set to FALSE to not generate per-target graphs ``foo.dot.<target>``."
msgstr "设置为 FALSE 不生成每个目标图 ``foo.dot.<target>``。"

#: ../../cmake-prefix/src/cmake/Modules/CMakeGraphVizOptions.cmake:146
msgid ""
"Set to FALSE to not generate depender graphs "
"``foo.dot.<target>.dependers``."
msgstr "设置为 FALSE 不生成依赖图``foo.dot.<target>.dependers``。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:6
msgid "CMakePackageConfigHelpers"
msgstr "CMakePackageConfigHelpers"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:8
msgid ""
"Helpers functions for creating config files that can be included by other "
"projects to find and use a package."
msgstr "用于创建可以被其他项目包含以查找和使用包的配置文件的帮助函数。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:11
msgid ""
"Adds the :command:`configure_package_config_file()` and "
":command:`write_basic_package_version_file()` commands."
msgstr ""
"添加 :command:`configure_package_config_file()` 和 "
":command:`write_basic_package_version_file()` 命令。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:15
msgid "Generating a Package Configuration File"
msgstr "生成包配置文件"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:19
msgid "Create a config file for a project::"
msgstr "为项目创建配置文件 ::"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:29
msgid ""
"``configure_package_config_file()`` should be used instead of the plain "
":command:`configure_file()` command when creating the "
"``<PackageName>Config.cmake`` or ``<PackageName>-config.cmake`` file for "
"installing a project or library. It helps making the resulting package "
"relocatable by avoiding hardcoded paths in the installed ``Config.cmake`` "
"file."
msgstr ""
"在创建 ``<PackageName>Config.cmake`` 或 ``<PackageName>-config.cmake`` "
"文件时，应该使用 ``configure_package_config_file()`` 而不是普通的 "
":command:`configure_file()` 命令安装项目或库。它通过避免在已安装的 ``Config.cmake`` "
"文件中使用硬编码路径，帮助使生成的包可重定位。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:35
msgid ""
"In a ``FooConfig.cmake`` file there may be code like this to make the "
"install destinations know to the using project:"
msgstr "在``FooConfig.cmake`` 文件中可能有这样的代码来让使用的项目知道安装目的地："

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:46
msgid ""
"All 4 options shown above are not sufficient, since the first 3 hardcode "
"the absolute directory locations, and the 4th case works only if the logic"
" to determine the ``installedPrefix`` is correct, and if "
"``CONFIG_INSTALL_DIR`` contains a relative path, which in general cannot "
"be guaranteed.  This has the effect that the resulting ``FooConfig.cmake``"
" file would work poorly under Windows and OSX, where users are used to "
"choose the install location of a binary package at install time, "
"independent from how :variable:`CMAKE_INSTALL_PREFIX` was set at "
"build/cmake time."
msgstr ""
"上面显示的所有 4 个选项都不够，因为前 3 个硬编码绝对目录位置，而第 4 种情况仅在确定 ``installedPrefix`` 的逻辑正确且 "
"``CONFIG_INSTALL_DIR`` 包含相对路径时才有效，这通常无法保证。这会导致生成的 ``FooConfig.cmake`` 文件在 "
"Windows 和 OSX 下运行不佳，其中用户习惯于在安装时选择二进制包的安装位置，与 CMAKE_INSTALL_PREFIX "
"的方式无关在构建/cmake 时设置。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:55
msgid ""
"Using ``configure_package_config_file`` helps.  If used correctly, it "
"makes the resulting ``FooConfig.cmake`` file relocatable.  Usage:"
msgstr ""
"使用 ``configure_package_config_file`` "
"有帮助。如果使用正确，它会使生成的“FooConfig.cmake”文件可重定位。用法："

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:58
msgid "write a ``FooConfig.cmake.in`` file as you are used to"
msgstr "像你习惯的那样写一个``FooConfig.cmake.in``文件"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:59
msgid "insert a line containing only the string ``@PACKAGE_INIT@``"
msgstr "插入一行只包含字符串``@PACKAGE_INIT@``"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:60
msgid ""
"instead of ``set(FOO_DIR \"@SOME_INSTALL_DIR@\")``, use ``set(FOO_DIR "
"\"@PACKAGE_SOME_INSTALL_DIR@\")`` (this must be after the "
"``@PACKAGE_INIT@`` line)"
msgstr ""
"而不是``set(FOO_DIR \"@SOME_INSTALL_DIR@\")``，使用``set(FOO_DIR "
"\"@PACKAGE_SOME_INSTALL_DIR@\")``（这必须在``@PACKAGE_INIT@``行之后）"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:63
msgid ""
"instead of using the normal :command:`configure_file()`, use "
"``configure_package_config_file()``"
msgstr ""
"而不是使用正常的 :command:`configure_file（）`，使用``configure_package_config_file（）``"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:68
msgid ""
"The ``<input>`` and ``<output>`` arguments are the input and output file, "
"the same way as in :command:`configure_file()`."
msgstr ""
"``<input>`` 和 ``<output>`` 参数是输入和输出文件，与 :command:`configure_file()` "
"中的方式相同。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:71
msgid ""
"The ``<path>`` given to ``INSTALL_DESTINATION`` must be the destination "
"where the ``FooConfig.cmake`` file will be installed to.  This path can "
"either be absolute, or relative to the ``INSTALL_PREFIX`` path."
msgstr ""
"给 ``INSTALL_DESTINATION`` 的 ``<path>`` 必须是 ``FooConfig.cmake`` "
"文件将被安装到的目的地。此路径可以是绝对路径，也可以是相对于“INSTALL_PREFIX”路径的相对路径。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:75
msgid ""
"The variables ``<var1>`` to ``<varN>`` given as ``PATH_VARS`` are the "
"variables which contain install destinations.  For each of them the macro "
"will create a helper variable ``PACKAGE_<var...>``.  These helper "
"variables must be used in the ``FooConfig.cmake.in`` file for setting the "
"installed location. They are calculated by "
"``configure_package_config_file`` so that they are always relative to the "
"installed location of the package.  This works both for relative and also "
"for absolute locations.  For absolute locations it works only if the "
"absolute location is a subdirectory of ``INSTALL_PREFIX``."
msgstr ""
"作为 PATH_VARS 给出的变量 ``<var1>`` 到 ``<varN>`` "
"是包含安装目的地的变量。对于它们中的每一个，宏都会创建一个辅助变量``PACKAGE_<var...>``。这些辅助变量必须在 "
"FooConfig.cmake.in 文件中使用以设置安装位置。它们由 ``configure_package_config_file`` "
"计算，因此它们始终与包的安装位置相关。这既适用于相对位置，也适用于绝对位置。对于绝对位置，它仅在绝对位置是 ``INSTALL_PREFIX`` "
"的子目录时才有效。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:84
msgid ""
"If the ``INSTALL_PREFIX`` argument is passed, this is used as base path to"
" calculate all the relative paths.  The ``<path>`` argument must be an "
"absolute path.  If this argument is not passed, the "
":variable:`CMAKE_INSTALL_PREFIX` variable will be used instead.  The "
"default value is good when generating a FooConfig.cmake file to use your "
"package from the install tree.  When generating a FooConfig.cmake file to "
"use your package from the build tree this option should be used."
msgstr ""
"如果传递了 ``INSTALL_PREFIX`` 参数，这将用作计算所有相对路径的基本路径。 ``<path>`` "
"参数必须是绝对路径。如果未传递此参数，则将使用 :variable:`CMAKE_INSTALL_PREFIX` 变量。生成 "
"FooConfig.cmake 文件以使用安装树中的包时，默认值很好。当生成 FooConfig.cmake "
"文件以使用构建树中的包时，应使用此选项。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:93
msgid ""
"By default ``configure_package_config_file`` also generates two helper "
"macros, ``set_and_check()`` and ``check_required_components()`` into the "
"``FooConfig.cmake`` file."
msgstr ""
"默认情况下，``configure_package_config_file`` 还会在``FooConfig.cmake`` "
"文件中生成两个辅助宏，``set_and_check()`` 和``check_required_components()``。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:97
msgid ""
"``set_and_check()`` should be used instead of the normal ``set()`` command"
" for setting directories and file locations.  Additionally to setting the "
"variable it also checks that the referenced file or directory actually "
"exists and fails with a ``FATAL_ERROR`` otherwise.  This makes sure that "
"the created ``FooConfig.cmake`` file does not contain wrong references. "
"When using the ``NO_SET_AND_CHECK_MACRO``, this macro is not generated "
"into the ``FooConfig.cmake`` file."
msgstr ""
"``set_and_check()`` 应该用来代替普通的 ``set()`` "
"命令来设置目录和文件位置。除了设置变量之外，它还会检查引用的文件或目录是否实际存在，否则会失败并返回“致命错误”。这确保创建的“FooConfig.cmake”文件不包含错误的引用。使用"
" ``NO_SET_AND_CHECK_MACRO`` 时，该宏不会生成到 ``FooConfig.cmake`` 文件中。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:105
msgid ""
"``check_required_components(<PackageName>)`` should be called at the end "
"of the ``FooConfig.cmake`` file. This macro checks whether all requested, "
"non-optional components have been found, and if this is not the case, sets"
" the ``Foo_FOUND`` variable to ``FALSE``, so that the package is "
"considered to be not found.  It does that by testing the "
"``Foo_<Component>_FOUND`` variables for all requested required components."
"  This macro should be called even if the package doesn't provide any "
"components to make sure users are not specifying components erroneously.  "
"When using the ``NO_CHECK_REQUIRED_COMPONENTS_MACRO`` option, this macro "
"is not generated into the ``FooConfig.cmake`` file."
msgstr ""
"``check_required_components(<PackageName>)`` 应该在 ``FooConfig.cmake`` "
"文件的末尾调用。此宏检查是否已找到所有请求的非可选组件，如果未找到，则将“Foo_FOUND”变量设置为“FALSE”，以便认为未找到包。它通过测试所有请求的必需组件的"
" ``Foo_<Component>_FOUND`` 变量来做到这一点。即使包没有提供任何组件，也应该调用这个宏以确保用户没有错误地指定组件。使用 "
"``NO_CHECK_REQUIRED_COMPONENTS_MACRO`` 选项时，该宏不会生成到 ``FooConfig.cmake`` "
"文件中。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:116
msgid ""
"For an example see below the documentation for "
":command:`write_basic_package_version_file()`."
msgstr "有关示例，请参见下面的 :command:`write_basic_package_version_file()` 文档。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:120
msgid "Generating a Package Version File"
msgstr "生成包版本文件"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:124
msgid "Create a version file for a project::"
msgstr "为项目创建版本文件 ::"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:132
msgid ""
"Writes a file for use as ``<PackageName>ConfigVersion.cmake`` file to "
"``<filename>``.  See the documentation of :command:`find_package()` for "
"details on this."
msgstr ""
"将用作 ``<PackageName>ConfigVersion.cmake`` 文件的文件写入 ``<filename>``。有关详细信息，请参阅"
" :command:`find_package()` 的文档。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:136
msgid ""
"``<filename>`` is the output filename, it should be in the build tree. "
"``<major.minor.patch>`` is the version number of the project to be "
"installed."
msgstr ""
"``<filename>`` 是输出文件名，它应该在构建树中。 ``<major.minor.patch>`` 是要安装的项目的版本号。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:139
msgid ""
"If no ``VERSION`` is given, the :variable:`PROJECT_VERSION` variable is "
"used. If this hasn't been set, it errors out."
msgstr "如果未给出 ``VERSION``，则使用 :variable:`PROJECT_VERSION` 变量。如果尚未设置，则会出错。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:142
msgid ""
"The ``COMPATIBILITY`` mode ``AnyNewerVersion`` means that the installed "
"package version will be considered compatible if it is newer or exactly "
"the same as the requested version.  This mode should be used for packages "
"which are fully backward compatible, also across major versions. If "
"``SameMajorVersion`` is used instead, then the behavior differs from "
"``AnyNewerVersion`` in that the major version number must be the same as "
"requested, e.g.  version 2.0 will not be considered compatible if 1.0 is "
"requested.  This mode should be used for packages which guarantee backward"
" compatibility within the same major version. If ``SameMinorVersion`` is "
"used, the behavior is the same as ``SameMajorVersion``, but both major and"
" minor version must be the same as requested, e.g version 0.2 will not be "
"compatible if 0.1 is requested. If ``ExactVersion`` is used, then the "
"package is only considered compatible if the requested version matches "
"exactly its own version number (not considering the tweak version).  For "
"example, version 1.2.3 of a package is only considered compatible to "
"requested version 1.2.3.  This mode is for packages without compatibility "
"guarantees. If your project has more elaborated version matching rules, "
"you will need to write your own custom ``ConfigVersion.cmake`` file "
"instead of using this macro."
msgstr ""
"``COMPATIBILITY`` 模式 ``AnyNewerVersion`` "
"意味着安装的包版本将被认为是兼容的，如果它更新或与请求的版本完全相同。这种模式应用于完全向后兼容的包，也适用于主要版本。如果改为使用“SameMajorVersion”，则行为不同于“AnyNewerVersion”，因为主版本号必须与请求的相同，例如如果请求"
" 1.0，则 2.0 "
"版将被视为不兼容。此模式应用于保证在同一主要版本中向后兼容的包。如果使用“SameMinorVersion”，行为与“SameMajorVersion”相同，但主要版本和次要版本必须与请求的相同，例如，如果请求"
" 0.1，则版本 0.2 "
"将不兼容。如果使用“ExactVersion”，则仅当请求的版本与它自己的版本号完全匹配时才认为该包兼容（不考虑调整版本）。例如，包的 1.2.3 "
"版仅被认为与请求的 1.2.3 版兼容。此模式适用于没有兼容性保证的包。如果您的项目有更详细的版本匹配规则，您将需要编写自己的自定义 "
"``ConfigVersion.cmake`` 文件，而不是使用此宏。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:163
msgid "The ``SameMinorVersion`` compatibility mode."
msgstr "``SameMinorVersion`` 兼容模式。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:166
msgid ""
"If ``ARCH_INDEPENDENT`` is given, the installed package version will be "
"considered compatible even if it was built for a different architecture "
"than the requested architecture.  Otherwise, an architecture check will be"
" performed, and the package will be considered compatible only if the "
"architecture matches exactly.  For example, if the package is built for a "
"32-bit architecture, the package is only considered compatible if it is "
"used on a 32-bit architecture, unless ``ARCH_INDEPENDENT`` is given, in "
"which case the package is considered compatible on any architecture."
msgstr ""
"如果给出 "
"``ARCH_INDEPENDENT``，安装的包版本将被认为是兼容的，即使它是为与请求的体系结构不同的体系结构构建的。否则，将执行体系结构检查，只有在体系结构完全匹配时才会认为包兼容。例如，如果包是为"
" 32 位架构构建的，则只有在 32 位架构上使用该包才被认为是兼容的，除非给出 "
"``ARCH_INDEPENDENT``，在这种情况下，该包被认为是兼容的任何架构。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:176
msgid ""
"``ARCH_INDEPENDENT`` is intended for header-only libraries or similar "
"packages with no binaries."
msgstr "``ARCH_INDEPENDENT`` 适用于只有头文件的库或没有二进制文件的类似包。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:179
msgid ""
"The version file generated by ``AnyNewerVersion``, ``SameMajorVersion`` "
"and ``SameMinorVersion`` arguments of ``COMPATIBILITY`` handle the version"
" range if any is specified (see :command:`find_package` command for the "
"details). ``ExactVersion`` mode is incompatible with version ranges and "
"will display an author warning if one is specified."
msgstr ""
"由 ``COMPATIBILITY`` 的 ``AnyNewerVersion``、``SameMajorVersion`` 和 "
"``SameMinorVersion`` "
"参数生成的版本文件处理版本范围（如果指定）（有关详细信息，请参阅:command:`find_package` 命令） . "
"``ExactVersion`` 模式与版本范围不兼容，如果指定，将显示作者警告。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:186
msgid ""
"Internally, this macro executes :command:`configure_file()` to create the "
"resulting version file.  Depending on the ``COMPATIBILITY``, the "
"corresponding ``BasicConfigVersion-<COMPATIBILITY>.cmake.in`` file is "
"used. Please note that these files are internal to CMake and you should "
"not call :command:`configure_file()` on them yourself, but they can be "
"used as starting point to create more sophisticted custom "
"``ConfigVersion.cmake`` files."
msgstr ""
"在内部，此宏执行 :command:`configure_file()` 以创建生成的版本文件。根据 "
"``COMPATIBILITY``，使用相应的``BasicConfigVersion-<COMPATIBILITY>.cmake.in`` "
"文件。请注意，这些文件是 CMake 的内部文件，您不应该自己调用 "
":command:`configure_file()`，但它们可以用作创建更复杂的自定义 ``ConfigVersion.cmake`` "
"文件的起点。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:194
msgid "Example Generating Package Files"
msgstr "示例生成包文件"

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:196
msgid ""
"Example using both :command:`configure_package_config_file` and "
"``write_basic_package_version_file()``:"
msgstr ""
"同时使用 :command:`configure_package_config_file` 和 "
"``write_basic_package_version_file()`` 的示例："

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:199
msgid "``CMakeLists.txt``:"
msgstr "``CMakeLists.txt``："

#: ../../cmake-prefix/src/cmake/Modules/CMakePackageConfigHelpers.cmake:222
msgid "``FooConfig.cmake.in``:"
msgstr "``FooConfig.cmake.in``:"

#: ../../cmake-prefix/src/cmake/Modules/CMakeParseArguments.cmake:6
msgid "CMakeParseArguments"
msgstr "CMakeParseArguments"

#: ../../cmake-prefix/src/cmake/Modules/CMakeParseArguments.cmake:8
msgid ""
"This module once implemented the :command:`cmake_parse_arguments` command "
"that is now implemented natively by CMake.  It is now an empty placeholder"
" for compatibility with projects that include it to get the command from "
"CMake 3.4 and lower."
msgstr ""
"该模块曾经实现了 :command:`cmake_parse_arguments` 命令，现在由 CMake "
"本机实现。它现在是一个空占位符，用于与包含它以从 CMake 3.4 及更低版本获取命令的项目兼容。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintHelpers.cmake:6
msgid "CMakePrintHelpers"
msgstr "CMakePrintHelpers"

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintHelpers.cmake:8
msgid ""
"Convenience functions for printing properties and variables, useful e.g. "
"for debugging."
msgstr "用于打印属性和变量的便捷函数，例如很有用用于调试。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintHelpers.cmake:20
msgid ""
"This function prints the values of the properties of the given targets, "
"source files, directories, tests or cache entries.  Exactly one of the "
"scope keywords must be used.  The scope keyword and its arguments must "
"come before the ``PROPERTIES`` keyword, in the arguments list."
msgstr ""
"此函数打印给定目标、源文件、目录、测试或缓存条目的属性值。必须恰好使用范围关键字之一。在参数列表中，scope 关键字及其参数必须位于 "
"``PROPERTIES`` 关键字之前。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintHelpers.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:306
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:270
msgid "Example::"
msgstr "例子：："

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintHelpers.cmake:30
msgid ""
"This will print the LOCATION and INTERFACE_INCLUDE_DIRECTORIES properties "
"for both targets foo and bar."
msgstr "这将为目标 foo 和 bar 打印 LOCATION 和 INTERFACE_INCLUDE_DIRECTORIES 属性。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintHelpers.cmake:37
msgid ""
"This function will print the name of each variable followed by its value. "
"Example::"
msgstr "此函数将打印每个变量的名称及其值。例子：："

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintHelpers.cmake:42
msgid "Gives::"
msgstr "给出：："

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintSystemInformation.cmake:6
msgid "CMakePrintSystemInformation"
msgstr "CMakePrintSystemInformation"

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintSystemInformation.cmake:8
msgid "Print system information."
msgstr "打印系统信息。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePrintSystemInformation.cmake:10
msgid ""
"This module serves diagnostic purposes. Just include it in a project to "
"see various internal CMake variables."
msgstr "该模块用于诊断目的。只需将其包含在项目中即可查看各种内部 CMake 变量。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePushCheckState.cmake:6
msgid "CMakePushCheckState"
msgstr "CMakePushCheckState"

#: ../../cmake-prefix/src/cmake/Modules/CMakePushCheckState.cmake:10
msgid ""
"This module defines three macros: ``CMAKE_PUSH_CHECK_STATE()`` "
"``CMAKE_POP_CHECK_STATE()`` and ``CMAKE_RESET_CHECK_STATE()`` These macros"
" can be used to save, restore and reset (i.e., clear contents) the state "
"of the variables ``CMAKE_REQUIRED_FLAGS``, ``CMAKE_REQUIRED_DEFINITIONS``,"
" ``CMAKE_REQUIRED_LINK_OPTIONS``, ``CMAKE_REQUIRED_LIBRARIES``, "
"``CMAKE_REQUIRED_INCLUDES`` and ``CMAKE_EXTRA_INCLUDE_FILES`` used by the "
"various Check-files coming with CMake, like e.g. "
"``check_function_exists()`` etc. The variable contents are pushed on a "
"stack, pushing multiple times is supported.  This is useful e.g.  when "
"executing such tests in a Find-module, where they have to be set, but "
"after the Find-module has been executed they should have the same value as"
" they had before."
msgstr ""
"该模块定义了三个宏：``CMAKE_PUSH_CHECK_STATE()`` ``CMAKE_POP_CHECK_STATE()`` "
"和``CMAKE_RESET_CHECK_STATE()`` "
"这些宏可用于保存、恢复和重置（即清除内容）变量的状态``cmake_required_flags`，`cmake_required_definitions'像Cmake一样的Iles，例如``check_function_exists()``"
" 等变量内容入栈，支持多次入栈。这很有用，例如在 Find-module 中执行此类测试时，必须在其中设置它们，但在执行 Find-module "
"之后，它们应该具有与之前相同的值。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePushCheckState.cmake:23
msgid ""
"``CMAKE_PUSH_CHECK_STATE()`` macro receives optional argument ``RESET``. "
"Whether it's specified, ``CMAKE_PUSH_CHECK_STATE()`` will set all "
"``CMAKE_REQUIRED_*`` variables to empty values, same as "
"``CMAKE_RESET_CHECK_STATE()`` call will do."
msgstr ""
"``CMAKE_PUSH_CHECK_STATE()`` 宏接收可选参数 "
"``RESET``。无论是否指定，``CMAKE_PUSH_CHECK_STATE()`` 都会将所有``CMAKE_REQUIRED_*`` "
"变量设置为空值，与``CMAKE_RESET_CHECK_STATE()`` 调用一样。"

#: ../../cmake-prefix/src/cmake/Modules/CMakePushCheckState.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/CheckLanguage.cmake:10
msgid "Usage:"
msgstr "用法："

#: ../../cmake-prefix/src/cmake/Modules/CMakeVerifyManifest.cmake:6
msgid "CMakeVerifyManifest"
msgstr "CMakeVerifyManifest"

#: ../../cmake-prefix/src/cmake/Modules/CMakeVerifyManifest.cmake:10
msgid "CMakeVerifyManifest.cmake"
msgstr "CMakeVerifyManifest.cmake"

#: ../../cmake-prefix/src/cmake/Modules/CMakeVerifyManifest.cmake:12
msgid ""
"This script is used to verify that embedded manifests and side by side "
"manifests for a project match.  To run this script, cd to a directory and "
"run the script with cmake -P.  On the command line you can pass in "
"versions that are OK even if not found in the .manifest files.  For "
"example, cmake -Dallow_versions=8.0.50608.0 -PCmakeVerifyManifest.cmake "
"could be used to allow an embedded manifest of 8.0.50608.0 to be used in a"
" project even if that version was not found in the .manifest file."
msgstr ""
"此脚本用于验证项目匹配的嵌入式清单和并排清单。要运行此脚本，请 cd 到一个目录并使用 cmake -P 运行脚本。在命令行上，您可以传入即使在 "
".manifest 文件中找不到也可以的版本。例如，cmake -Dallow_versions=8.0.50608.0 "
"-PCmakeVerifyManifest.cmake 可用于允许在项目中使用 8.0.50608.0 的嵌入式清单，即使在 .manifest "
"文件中找不到该版本。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:6
msgid "CPack"
msgstr "包装"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:8
msgid "Configure generators for binary installers and source packages."
msgstr "为二进制安装程序和源包配置生成器。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:13
msgid ""
"The CPack module generates the configuration files ``CPackConfig.cmake`` "
"and ``CPackSourceConfig.cmake``. They are intended for use in a subsequent"
" run of  the :manual:`cpack <cpack(1)>` program where they steer the "
"generation of installers or/and source packages."
msgstr ""
"CPack 模块生成配置文件“CPackConfig.cmake”和“CPackSourceConfig.cmake”。它们旨在用于 "
":manual:`cpack <cpack(1)>` 程序的后续运行，在那里它们引导安装程序或/和源包的生成。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:18
msgid ""
"Depending on the CMake generator, the CPack module may also add two new "
"build targets, ``package`` and ``package_source``. See the `packaging "
"targets`_ section below for details."
msgstr ""
"根据 CMake 生成器，CPack 模块还可以添加两个新的构建目标，``package`` "
"和``package_source``。有关详细信息，请参阅下面的“打包目标”部分。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:22
msgid ""
"The generated binary installers will contain all files that have been "
"installed via CMake's :command:`install` command (and the deprecated "
"commands :command:`install_files`, :command:`install_programs`, and "
":command:`install_targets`). Note that the ``DESTINATION`` option of the "
":command:`install` command must be a relative path; otherwise installed "
"files are ignored by CPack."
msgstr ""
"生成的二进制安装程序将包含通过 CMake 的 :command:`install` 命令（以及已弃用的命令 "
":command:`install_files`、 :command:`install_programs` 和 "
":command:`install_targets`）安装的所有文件。请注意:command:`install` "
"命令的``DESTINATION`` 选项必须是相对路径；否则安装的文件将被 CPack 忽略。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:29
msgid ""
"Certain kinds of binary installers can be configured such that users can "
"select individual application components to install.  See the "
":module:`CPackComponent` module for further details."
msgstr ""
"可以配置某些类型的二进制安装程序，以便用户可以选择要安装的单个应用程序组件。有关更多详细信息，请参阅 :module:`CPackComponent` 模块。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:33
msgid ""
"Source packages (configured through ``CPackSourceConfig.cmake`` and "
"generated by the :cpack_gen:`CPack Archive Generator`) will contain all "
"source files in the project directory except those specified in "
":variable:`CPACK_SOURCE_IGNORE_FILES`."
msgstr ""
"源包（通过 CPackSourceConfig.cmake 配置并由 CPack Archive Generator "
"生成）将包含项目目录中的所有源文件，CPACK_SOURCE_IGNORE_FILES 中指定的除外。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:39
msgid "CPack Generators"
msgstr "CPack 生成器"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:41
msgid ""
"The :variable:`CPACK_GENERATOR` variable has different meanings in "
"different contexts.  In a ``CMakeLists.txt`` file, "
":variable:`CPACK_GENERATOR` is a *list of generators*: and when "
":manual:`cpack <cpack(1)>` is run with no other arguments, it will iterate"
" over that list and produce one package for each generator.  In a "
":variable:`CPACK_PROJECT_CONFIG_FILE`, :variable:`CPACK_GENERATOR` is a "
"*string naming a single generator*.  If you need per-cpack-generator logic"
" to control *other* cpack settings, then you need a "
":variable:`CPACK_PROJECT_CONFIG_FILE`. If set, the "
":variable:`CPACK_PROJECT_CONFIG_FILE` is included automatically on a per-"
"generator basis.  It only need contain overrides."
msgstr ""
":variable:`CPACK_GENERATOR` 变量在不同的上下文中具有不同的含义。在 ``CMakeLists.txt`` "
"文件中， :variable:`CPACK_GENERATOR` 是一个 *生成器列表*: 当 :manual:`cpack <cpack(1)>` "
"没有其他参数运行时，它将遍历列出并为每个生成器生成一个包。在 :variable:`CPACK_PROJECT_CONFIG_FILE` "
"中， :variable:`CPACK_GENERATOR` 是一个*字符串命名单个生成器*。如果您需要每个 cpack 生成器逻辑来控制 "
"*other* cpack 设置，那么您需要一个 "
":variable:`CPACK_PROJECT_CONFIG_FILE`。如果设置，CPACK_PROJECT_CONFIG_FILE "
"将自动包含在每个生成器的基础上。它只需要包含覆盖。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:52
msgid "Here's how it works:"
msgstr "它是这样工作的："

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:54
msgid ":manual:`cpack <cpack(1)>` runs"
msgstr ":manual:`cpack <cpack(1)>` 运行"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:55
msgid "it includes ``CPackConfig.cmake``"
msgstr "它包括``CPackConfig.cmake``"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:56
msgid ""
"it iterates over the generators given by the :option:`-G <cpack -G>` "
"command line option, or if no such option was specified, over the list of "
"generators given by the :variable:`CPACK_GENERATOR` variable set in the "
"``CPackConfig.cmake`` input file."
msgstr ""
"它遍历 :option:`-G <cpack -G>` 命令行选项给出的生成器，或者如果没有指定这样的选项，则遍历由 "
":variable:`CPACK_GENERATOR` 变量设置的生成器列表``CPackConfig.cmake`` 输入文件。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:60
msgid "foreach generator, it then"
msgstr "foreach 生成器，然后"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:62
msgid "sets :variable:`CPACK_GENERATOR` to the one currently being iterated"
msgstr "将 :variable:`CPACK_GENERATOR` 设置为当前正在迭代的那个"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:63
msgid "includes the :variable:`CPACK_PROJECT_CONFIG_FILE`"
msgstr "包括 :variable:`CPACK_PROJECT_CONFIG_FILE`"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:64
msgid "produces the package for that generator"
msgstr "为该生成器生成包"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:66
msgid ""
"This is the key: For each generator listed in :variable:`CPACK_GENERATOR` "
"in ``CPackConfig.cmake``, cpack will *reset* :variable:`CPACK_GENERATOR` "
"internally to *the one currently being used* and then include the "
":variable:`CPACK_PROJECT_CONFIG_FILE`."
msgstr ""
"这是关键：对于 ``CPackConfig.cmake`` 中的 CPACK_GENERATOR 中列出的每个生成器，cpack 将在内部*重置* "
"CPACK_GENERATOR 为*当前正在使用的*，然后包括 :variable:`CPACK_PROJECT_CONFIG_FILE`。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:71
msgid ""
"For a list of available generators, see :manual:`cpack-generators(7)`."
msgstr "有关可用生成器的列表，请参阅 :manual:`cpack-generators(7)`。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:76
msgid "Targets package and package_source"
msgstr "目标包和 package_source"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:78
msgid ""
"If CMake is run with the Makefile, Ninja, or Xcode generator, then "
"``include(CPack)`` generates a target ``package``. This makes it possible "
"to build a binary installer from CMake, Make, or Ninja: Instead of "
"``cpack``, one may call ``cmake --build . --target package`` or ``make "
"package`` or ``ninja package``. The VS generator creates an uppercase "
"target ``PACKAGE``."
msgstr ""
"如果 CMake 与 Makefile、Ninja 或 Xcode 生成器一起运行，则 ``include(CPack)`` 会生成一个目标 "
"``package``。这使得从 CMake、Make 或 Ninja 构建二进制安装程序成为可能：可以调用 ``cmake --build 而不是"
" ``cpack``。 --target package`` 或 ``make package`` 或 ``ninja package``。 VS "
"生成器创建一个大写目标“PACKAGE”。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:84
msgid ""
"If CMake is run with the Makefile or Ninja generator, then "
"``include(CPack)`` also generates a target ``package_source``. To build a "
"source package, instead of ``cpack -G TGZ --config "
"CPackSourceConfig.cmake`` one may call ``cmake --build . --target "
"package_source``, ``make package_source``, or ``ninja package_source``."
msgstr ""
"如果 CMake 使用 Makefile 或 Ninja 生成器运行，则 ``include(CPack)`` 也会生成一个目标 "
"``package_source``。要构建源包，而不是 ``cpack -G TGZ --config "
"CPackSourceConfig.cmake`` 可以调用 ``cmake --build 。 --target "
"package_source``、``make package_source`` 或 ``ninja package_source``。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:92
msgid "Variables common to all CPack Generators"
msgstr "所有 CPack 生成器通用的变量"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:94
msgid ""
"Before including this CPack module in your ``CMakeLists.txt`` file, there "
"are a variety of variables that can be set to customize the resulting "
"installers.  The most commonly-used variables are:"
msgstr "在您的“CMakeLists.txt”文件中包含此 CPack 模块之前，可以设置各种变量来自定义生成的安装程序。最常用的变量是："

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:100
msgid ""
"The name of the package (or application).  If not specified, it defaults "
"to the project name."
msgstr "包（或应用程序）的名称。如果未指定，则默认为项目名称。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:105
msgid ""
"The name of the package vendor. (e.g., \"Kitware\").  The default is "
"\"Humanity\"."
msgstr "包供应商的名称。 （例如，“Kitware”）。默认值为“人性化”。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:109
msgid ""
"The directory in which CPack is doing its packaging.  If it is not set "
"then this will default (internally) to the build dir.  This variable may "
"be defined in a CPack config file or from the :manual:`cpack <cpack(1)>` "
"command line option ``-B``.  If set, the command line option overrides the"
" value found in the config file."
msgstr ""
"CPack 进行打包的目录。如果未设置，则这将默认（内部）到构建目录。这个变量可以在 CPack 配置文件中定义，也可以从 "
":manual:`cpack <cpack(1)>` 命令行选项 ``-B`` 中定义。如果设置，命令行选项将覆盖在配置文件中找到的值。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:117
msgid ""
"Package major version.  This variable will always be set, but its default "
"value depends on whether or not version details were given to the "
":command:`project` command in the top level CMakeLists.txt file.  If "
"version details were given, the default value will be "
":variable:`CMAKE_PROJECT_VERSION_MAJOR`.  If no version details were "
"given, a default version of 0.1.1 will be assumed, leading to "
"``CPACK_PACKAGE_VERSION_MAJOR`` having a default value of 0."
msgstr ""
"包主要版本。此变量将始终设置，但其默认值取决于是否将版本详细信息提供给顶层 CMakeLists.txt 文件中的 "
":command:`project` "
"命令。如果提供了版本详细信息，则默认值为 :variable:`CMAKE_PROJECT_VERSION_MAJOR`。如果没有给出版本详细信息，将假定默认版本为"
" 0.1.1，导致 ``CPACK_PACKAGE_VERSION_MAJOR`` 的默认值为 0。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:127
msgid ""
"Package minor version.  The default value is determined based on whether "
"or not version details were given to the :command:`project` command in the"
" top level CMakeLists.txt file.  If version details were given, the "
"default value will be :variable:`CMAKE_PROJECT_VERSION_MINOR`, but if no "
"minor version component was specified then ``CPACK_PACKAGE_VERSION_MINOR``"
" will be left unset.  If no project version was given at all, a default "
"version of 0.1.1 will be assumed, leading to "
"``CPACK_PACKAGE_VERSION_MINOR`` having a default value of 1."
msgstr ""
"包次要版本。默认值取决于版本详细信息是否提供给顶层 CMakeLists.txt 文件中的 :command:`project` "
"命令。如果提供了版本详细信息，则默认值为 :variable:`CMAKE_PROJECT_VERSION_MINOR`，但如果未指定次要版本组件，则``CPACK_PACKAGE_VERSION_MINOR``"
" 将保持未设置状态。如果根本没有给出项目版本，将假定默认版本为 0.1.1，导致 ``CPACK_PACKAGE_VERSION_MINOR`` "
"的默认值为 1。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:138
msgid ""
"Package patch version.  The default value is determined based on whether "
"or not version details were given to the :command:`project` command in the"
" top level CMakeLists.txt file.  If version details were given, the "
"default value will be :variable:`CMAKE_PROJECT_VERSION_PATCH`, but if no "
"patch version component was specified then ``CPACK_PACKAGE_VERSION_PATCH``"
" will be left unset.  If no project version was given at all, a default "
"version of 0.1.1 will be assumed, leading to "
"``CPACK_PACKAGE_VERSION_PATCH`` having a default value of 1."
msgstr ""
"包补丁版本。默认值取决于版本详细信息是否提供给顶层 CMakeLists.txt 文件中的 :command:`project` "
"命令。如果给出了版本详细信息，则默认值为 :variable:`CMAKE_PROJECT_VERSION_PATCH`，但如果未指定补丁版本组件，则 "
"``CPACK_PACKAGE_VERSION_PATCH`` 将保持未设置状态。如果根本没有给出项目版本，将假定默认版本为 0.1.1，导致 "
"``CPACK_PACKAGE_VERSION_PATCH`` 的默认值为 1。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:149
msgid ""
"A description of the project, used in places such as the introduction "
"screen of CPack-generated Windows installers.  If not set, the value of "
"this variable is populated from the file named by "
":variable:`CPACK_PACKAGE_DESCRIPTION_FILE`."
msgstr ""
"项目的描述，用于 CPack 生成的 Windows 安装程序的介绍屏幕等地方。如果未设置，此变量的值将从 "
"CPACK_PACKAGE_DESCRIPTION_FILE 命名的文件中填充。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:156
msgid ""
"A text file used to describe the project when "
":variable:`CPACK_PACKAGE_DESCRIPTION` is not explicitly set.  The default "
"value for ``CPACK_PACKAGE_DESCRIPTION_FILE`` points to a built-in template"
" file ``Templates/CPack.GenericDescription.txt``."
msgstr ""
"未明确设置 CPACK_PACKAGE_DESCRIPTION 时用于描述项目的文本文件。 "
"``CPACK_PACKAGE_DESCRIPTION_FILE`` "
"的默认值指向内置模板文件``Templates/CPack.GenericDescription.txt``。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:163
msgid ""
"Short description of the project (only a few words).  If the "
":variable:`CMAKE_PROJECT_DESCRIPTION` variable is set, it is used as the "
"default value, otherwise the default will be a string generated by CMake "
"based on :variable:`CMAKE_PROJECT_NAME`."
msgstr ""
"项目的简短描述（只有几句话）。如果设置了 :variable:`CMAKE_PROJECT_DESCRIPTION` "
"变量，它将用作默认值，否则默认值将是 CMake 基于 :variable:`CMAKE_PROJECT_NAME` 生成的字符串。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:170
msgid ""
"Project homepage URL.  The default value is taken from the "
":variable:`CMAKE_PROJECT_HOMEPAGE_URL` variable, which is set by the top "
"level :command:`project` command, or else the default will be empty if no "
"URL was provided to :command:`project`."
msgstr ""
"项目主页 URL。默认值取自 :variable:`CMAKE_PROJECT_HOMEPAGE_URL` 变量，该变量由顶级 "
":command:`project` 命令设置，否则如果没有向 :command:`project` 提供 URL，则默认值为空。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:177
msgid ""
"The name of the package file to generate, not including the extension.  "
"For example, ``cmake-2.6.1-Linux-i686``.  The default value is::"
msgstr "要生成的包文件的名称，不包括扩展名。例如，``cmake-2.6.1-Linux-i686``。默认值为：："

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:185
msgid ""
"Installation directory on the target system. This may be used by some "
"CPack generators like NSIS to create an installation directory e.g., "
"\"CMake 2.5\" below the installation prefix.  All installed elements will "
"be put inside this directory."
msgstr ""
"目标系统上的安装目录。一些 CPack 生成器（如 NSIS）可能会使用它来创建安装目录，例如安装前缀下方的“CMake "
"2.5”。所有安装的元素都将放在这个目录中。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:192
msgid ""
"A branding image that will be displayed inside the installer (used by GUI "
"installers)."
msgstr "将在安装程序中显示的品牌图像（由 GUI 安装程序使用）。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:199
msgid ""
"An algorithm that will be used to generate an additional file with the "
"checksum of the package.  The output file name will be::"
msgstr "一种算法，用于生成带有包校验和的附加文件。输出文件名将是 ::"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:204
msgid ""
"Supported algorithms are those listed by the :ref:`string(\\<HASH\\>) "
"<Supported Hash Algorithms>` command."
msgstr "支持的算法是 :ref:`string(\\<HASH\\>) <Supported Hash Algorithms>` 命令列出的算法。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:209
msgid ""
"CPack-time project CPack configuration file.  This file is included at "
"cpack time, once per generator after CPack has set "
":variable:`CPACK_GENERATOR` to the actual generator being used.  It allows"
" per-generator setting of ``CPACK_*`` variables at cpack time."
msgstr ""
"CPack-time 项目 CPack 配置文件。此文件包含在 cpack 时间，在 CPack 将 "
":variable:`CPACK_GENERATOR` 设置为实际使用的生成器后，每个生成器一次。它允许在 cpack 时间为每个生成器设置 "
"``CPACK_*`` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:216
msgid ""
"License to be embedded in the installer.  It will typically be displayed "
"to the user by the produced installer (often with an explicit \"Accept\" "
"button, for graphical installers) prior to installation.  This license "
"file is NOT added to the installed files but is used by some CPack "
"generators like NSIS.  If you want to use UTF-8 characters, the file needs"
" to be encoded in UTF-8 BOM.  If you want to install a license file (may "
"be the same as this one) along with your project, you must add an "
"appropriate CMake :command:`install` command in your ``CMakeLists.txt``."
msgstr ""
"嵌入在安装程序中的许可证。它通常会在安装之前由生成的安装程序显示给用户（对于图形安装程序，通常带有明确的“接受”按钮）。此许可证文件未添加到已安装的文件中，但被某些"
" CPack 生成器（如 NSIS）使用。如果要使用 UTF-8 字符，则需要将文件编码为 UTF-8 "
"BOM。如果您想随项目一起安装许可证文件（可能与此文件相同），则必须在 ``CMakeLists.txt`` 中添加适当的 "
"CMake:command:`install` 命令。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:227
msgid ""
"ReadMe file to be embedded in the installer.  It typically describes in "
"some detail the purpose of the project during the installation.  Not all "
"CPack generators use this file."
msgstr "要嵌入安装程序的自述文件。它通常会在安装过程中详细描述项目的目的。并非所有 CPack 生成器都使用此文件。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:233
msgid ""
"Welcome file to be embedded in the installer.  It welcomes users to this "
"installer.  Typically used in the graphical installers on Windows and Mac "
"OS X."
msgstr "欢迎文件嵌入到安装程序中。它欢迎用户使用此安装程序。通常用于 Windows 和 Mac OS X 上的图形安装程序。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:239
msgid ""
"Disables the component-based installation mechanism.  When set, the "
"component specification is ignored and all installed items are put in a "
"single \"MONOLITHIC\" package.  Some CPack generators do monolithic "
"packaging by default and may be asked to do component packaging by setting"
" ``CPACK_<GENNAME>_COMPONENT_INSTALL`` to ``TRUE``."
msgstr ""
"禁用基于组件的安装机制。设置后，组件规范将被忽略，所有已安装的项目都放在一个“MONOLITHIC”包中。一些 CPack "
"生成器默认进行整体打包，并且可能会被要求通过将 ``CPACK_<GENNAME>_COMPONENT_INSTALL`` 设置为 ``TRUE``"
" 来进行组件打包。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:247
msgid ""
"List of CPack generators to use.  If not specified, CPack will create a "
"set of options following the naming pattern "
":variable:`CPACK_BINARY_<GENNAME>` (e.g. ``CPACK_BINARY_NSIS``) allowing "
"the user to enable/disable individual generators.  If the :option:`-G "
"<cpack -G>` option is given on the :manual:`cpack <cpack(1)>` command "
"line, it will override this variable and any ``CPACK_BINARY_<GENNAME>`` "
"options."
msgstr ""
"要使用的 CPack 生成器列表。如果未指定，CPack "
"将创建一组遵循命名模式的选项 :variable:`CPACK_BINARY_<GENNAME>`（例如``CPACK_BINARY_NSIS``）允许用户启用/禁用各个生成器。如果在"
" :manual:`cpack <cpack(1)>` 命令行上给出了 :option:`-G <cpack -G>` 选项，它将覆盖此变量和任何 "
"``CPACK_BINARY_<GENNAME>`` 选项."

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:256
msgid ""
"The name of the CPack binary configuration file.  This file is the CPack "
"configuration generated by the CPack module for binary installers. "
"Defaults to ``CPackConfig.cmake``."
msgstr ""
"CPack 二进制配置文件的名称。此文件是由 CPack 模块为二进制安装程序生成的 CPack "
"配置。默认为“CPackConfig.cmake”。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:262
msgid ""
"Lists each of the executables and associated text label to be used to "
"create Start Menu shortcuts.  For example, setting this to the list "
"``ccmake;CMake`` will create a shortcut named \"CMake\" that will execute "
"the installed executable :program:`ccmake`.  Not all CPack generators use "
"it (at least NSIS, and WIX do)."
msgstr ""
"列出每个可执行文件和关联的文本标签，用于创建开始菜单快捷方式。例如，将此设置为列表 ``ccmake;CMake`` "
"将创建一个名为“CMake”的快捷方式，该快捷方式将执行已安装的可执行文件 :program:`ccmake`。并非所有 CPack "
"生成器都使用它（至少 NSIS 和 WIX 使用）。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:270
msgid ""
"List of files to be stripped.  Starting with CMake 2.6.0, "
"``CPACK_STRIP_FILES`` will be a boolean variable which enables stripping "
"of all files (a list of files evaluates to ``TRUE`` in CMake, so this "
"change is compatible)."
msgstr ""
"要删除的文件列表。从 CMake 2.6.0 开始，``CPACK_STRIP_FILES`` 将是一个布尔变量，可以剥离所有文件（文件列表在 "
"CMake 中计算为 ``TRUE``，因此此更改是兼容的）。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:279
msgid ""
"If set to ``TRUE``, values of variables prefixed with ``CPACK_`` will be "
"escaped before being written to the configuration files, so that the cpack"
" program receives them exactly as they were specified.  If not, characters"
" like quotes and backslashes can cause parsing errors or alter the value "
"received by the cpack program.  Defaults to ``FALSE`` for backwards "
"compatibility."
msgstr ""
"如果设置为“TRUE”，以“CPACK_”为前缀的变量值将在写入配置文件之前进行转义，以便 cpack "
"程序完全按照指定的方式接收它们。否则，引号和反斜杠等字符可能会导致解析错误或更改 cpack 程序接收到的值。为了向后兼容，默认为“FALSE”。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:290
msgid ""
"Number of threads to use when performing parallelized operations, such as "
"compressing the installer package."
msgstr "执行并行操作时使用的线程数，例如压缩安装程序包。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:293
msgid ""
"Some compression methods used by CPack generators such as Debian or "
"Archive may take advantage of multiple CPU cores to speed up compression. "
"``CPACK_THREADS`` can be set to specify how many threads will be used for "
"compression."
msgstr ""
"CPack 生成器（例如 Debian 或 Archive）使用的一些压缩方法可能会利用多个 CPU 内核来加速压缩。 "
"``CPACK_THREADS`` 可以设置为指定将使用多少线程进行压缩。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:298
msgid ""
"A positive integer can be used to specify an exact desired thread count."
msgstr "正整数可用于指定确切的所需线程数。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:300
msgid ""
"When given a negative integer CPack will use the absolute value as the "
"upper limit but may choose a lower value based on the available hardware "
"concurrency."
msgstr "当给定一个负整数时，CPack 将使用绝对值作为上限，但可以根据可用的硬件并发选择一个较低的值。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:304
msgid "Given 0 CPack will try to use all available CPU cores."
msgstr "给定 0 CPack 将尝试使用所有可用的 CPU 内核。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:306
msgid "By default ``CPACK_THREADS`` is set to ``1``."
msgstr "默认情况下，“CPACK_THREADS”设置为“1”。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:308
msgid ""
"The following compression methods may take advantage of multiple cores:"
msgstr "以下压缩方法可以利用多核："

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:318
msgid "``xz``"
msgstr "``xz``"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:311
msgid ""
"Supported if CMake is built with a ``liblzma`` that supports parallel "
"compression."
msgstr "如果 CMake 是使用支持并行压缩的 ``liblzma`` 构建的，则支持。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:316
msgid ""
"Official CMake binaries available on ``cmake.org`` now ship with a "
"``liblzma`` that supports parallel compression. Older versions did not."
msgstr "``cmake.org`` 上可用的官方 CMake 二进制文件现在附带支持并行压缩的 ``liblzma``。旧版本没有。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:324
msgid "``zstd``"
msgstr "``zstd``"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:323
msgid ""
"Supported if CMake is built with libarchive 3.6 or higher. Official CMake "
"binaries available on ``cmake.org`` support it."
msgstr ""
"如果 CMake 是使用 libarchive 3.6 或更高版本构建的，则受支持。 ``cmake.org`` 上提供的官方 CMake "
"二进制文件支持它。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:326
msgid "Other compression methods ignore this value and use only one thread."
msgstr "其他压缩方法忽略此值并仅使用一个线程。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:329
msgid "Variables for Source Package Generators"
msgstr "源包生成器的变量"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:331
msgid ""
"The following CPack variables are specific to source packages, and will "
"not affect binary packages:"
msgstr "以下 CPack 变量特定于源包，不会影响二进制包："

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:336
msgid "The name of the source package.  For example ``cmake-2.6.1``."
msgstr "源包的名称。例如``cmake-2.6.1``。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:340
msgid ""
"List of files in the source tree that will be stripped.  Starting with "
"CMake 2.6.0, ``CPACK_SOURCE_STRIP_FILES`` will be a boolean variable which"
" enables stripping of all files (a list of files evaluates to ``TRUE`` in "
"CMake, so this change is compatible)."
msgstr ""
"将被剥离的源树中的文件列表。从 CMake 2.6.0 开始，``CPACK_SOURCE_STRIP_FILES`` "
"将是一个布尔变量，可以剥离所有文件（文件列表在 CMake 中计算为 ``TRUE``，因此此更改是兼容的）。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:347
msgid ""
"List of generators used for the source packages.  As with "
":variable:`CPACK_GENERATOR`, if this is not specified then CPack will "
"create a set of options (e.g. ``CPACK_SOURCE_ZIP``) allowing users to "
"select which packages will be generated."
msgstr ""
"用于源包的生成器列表。与 :variable:`CPACK_GENERATOR` 一样，如果未指定，则 CPack 将创建一组选项（例如 "
"``CPACK_SOURCE_ZIP``），允许用户选择将生成哪些包。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:354
msgid ""
"The name of the CPack source configuration file.  This file is the CPack "
"configuration generated by the CPack module for source installers. "
"Defaults to ``CPackSourceConfig.cmake``."
msgstr ""
"CPack 源配置文件的名称。此文件是由 CPack 模块为源安装程序生成的 CPack "
"配置。默认为“CPackSourceConfig.cmake”。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:360
msgid ""
"Pattern of files in the source tree that won't be packaged when building a"
" source package.  This is a list of regular expression patterns (that must"
" be properly escaped), e.g., "
"``/CVS/;/\\\\.svn/;\\\\.swp$;\\\\.#;/#;.*~;cscope.*``"
msgstr ""
"构建源包时不会打包的源树中的文件模式。这是一个正则表达式模式列表（必须正确转义），例如，``/CVS/;/\\\\.svn/;\\\\.swp$;\\\\.#;/#;.*~;cscope"
" .*``"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:366
msgid "Variables for Advanced Use"
msgstr "高级使用的变量"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:368
msgid "The following variables are for advanced uses of CPack:"
msgstr "以下变量用于 CPack 的高级用途："

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:372
msgid ""
"What CMake generator should be used if the project is a CMake project.  "
"Defaults to the value of :variable:`CMAKE_GENERATOR`.  Few users will want"
" to change this setting."
msgstr ""
"如果项目是 CMake 项目，应该使用什么 CMake 生成器。默认为 CMAKE_GENERATOR 的值。很少有用户会想要更改此设置。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:378
msgid ""
"List of four values that specify what project to install.  The four values"
" are: Build directory, Project Name, Project Component, Directory.  If "
"omitted, CPack will build an installer that installs everything."
msgstr ""
"指定要安装的项目的四个值的列表。这四个值是：Build directory、Project Name、Project "
"Component、Directory。如果省略，CPack 将构建一个安装程序来安装所有内容。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:384
msgid ""
"System name, defaults to the value of :variable:`CMAKE_SYSTEM_NAME`, "
"except on Windows where it will be ``win32`` or ``win64``."
msgstr ""
"系统名称，默认为 :variable:`CMAKE_SYSTEM_NAME` 的值，但在 Windows 上为 ``win32`` 或 "
"``win64`` 除外。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:389
msgid ""
"Package full version, used internally.  By default, this is built from "
":variable:`CPACK_PACKAGE_VERSION_MAJOR`, "
":variable:`CPACK_PACKAGE_VERSION_MINOR`, and "
":variable:`CPACK_PACKAGE_VERSION_PATCH`."
msgstr ""
"打包完整版，内部使用。默认情况下，这是从 "
"CPACK_PACKAGE_VERSION_MAJOR、CPACK_PACKAGE_VERSION_MINOR 和 "
"CPACK_PACKAGE_VERSION_PATCH 构建的。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:396
msgid "Directory for the installed files."
msgstr "安装文件的目录。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:400
msgid ""
"Extra commands to install components.  The environment variable "
"``CMAKE_INSTALL_PREFIX`` is set to the temporary install directory during "
"execution."
msgstr "用于安装组件的额外命令。环境变量“CMAKE_INSTALL_PREFIX”在执行期间设置为临时安装目录。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:408
msgid ""
"Extra CMake scripts executed by CPack during its local staging "
"installation.  They are executed before installing the files to be "
"packaged. The scripts are not called by a standalone install (e.g.: ``make"
" install``). For every script, the following variables will be set: "
":variable:`CMAKE_CURRENT_SOURCE_DIR`, :variable:`CMAKE_CURRENT_BINARY_DIR`"
" and :variable:`CMAKE_INSTALL_PREFIX` (which is set to the staging install"
" directory).  The singular form ``CMAKE_INSTALL_SCRIPT`` is supported as "
"an alternative variable for historical reasons, but its value is ignored "
"if ``CMAKE_INSTALL_SCRIPTS`` is set and a warning will be issued."
msgstr ""
"CPack 在其本地暂存安装期间执行的额外 CMake 脚本。它们在安装要打包的文件之前执行。这些脚本不会被独立安装调用（例如：``make "
"install``）。对于每个脚本，将设置以下变量： :variable:`CMAKE_CURRENT_SOURCE_DIR`、 :variable:`CMAKE_CURRENT_BINARY_DIR`"
" 和 :variable:`CMAKE_INSTALL_PREFIX`（设置为暂存安装目录）。由于历史原因，单数形式的 CMAKE_INSTALL_SCRIPT "
"被支持作为替代变量，但如果设置了 CMAKE_INSTALL_SCRIPTS 并发出警告，则其值将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:418
msgid ""
"See also :variable:`CPACK_PRE_BUILD_SCRIPTS` and "
":variable:`CPACK_POST_BUILD_SCRIPTS` which can be used to specify scripts "
"to be executed later in the packaging process."
msgstr ""
"另见 :variable:`CPACK_PRE_BUILD_SCRIPTS` 和 "
":variable:`CPACK_POST_BUILD_SCRIPTS` 可用于指定稍后在打包过程中执行的脚本。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:426
msgid ""
"List of CMake scripts to execute after CPack has installed the files to be"
" packaged into a staging directory and before producing the package(s) "
"from those files. See also :variable:`CPACK_INSTALL_SCRIPTS` and "
":variable:`CPACK_POST_BUILD_SCRIPTS`."
msgstr ""
"在 CPack 将要打包的文件安装到暂存目录之后以及从这些文件生成包之前要执行的 CMake "
"脚本列表。另见 :variable:`CPACK_INSTALL_SCRIPTS` 和 :variable:`CPACK_POST_BUILD_SCRIPTS`。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:435
msgid ""
"List of CMake scripts to execute after CPack has produced the resultant "
"packages and before copying them back to the build directory. See also "
":variable:`CPACK_INSTALL_SCRIPTS`, :variable:`CPACK_PRE_BUILD_SCRIPTS` and"
" :variable:`CPACK_PACKAGE_FILES`."
msgstr ""
"在 CPack 生成结果包之后以及将它们复制回构建目录之前要执行的 CMake "
"脚本列表。另见 :variable:`CPACK_INSTALL_SCRIPTS`、 :variable:`CPACK_PRE_BUILD_SCRIPTS` "
"和 :variable:`CPACK_PACKAGE_FILES`。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:444
msgid ""
"List of package files created in the staging directory, with each file "
"provided as a full absolute path.  This variable is populated by CPack "
"just before invoking the post-build scripts listed in "
":variable:`CPACK_POST_BUILD_SCRIPTS`.  It is the preferred way for the "
"post-build scripts to know the set of package files to operate on. "
"Projects should not try to set this variable themselves."
msgstr ""
"在暂存目录中创建的包文件列表，每个文件都作为完整的绝对路径提供。在调用 CPACK_POST_BUILD_SCRIPTS "
"中列出的构建后脚本之前，此变量由 CPack 填充。这是构建后脚本了解要操作的包文件集的首选方式。项目不应尝试自己设置此变量。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:453
msgid "Extra directories to install."
msgstr "要安装的额外目录。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:457
msgid ""
"Registry key used when installing this project.  This is only used by "
"installers for Windows.  The default value is based on the installation "
"directory."
msgstr "安装此项目时使用的注册表项。这仅供 Windows 安装程序使用。默认值基于安装目录。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:463
msgid ""
"List of desktop links to create.  Each desktop link requires a "
"corresponding start menu shortcut as created by "
":variable:`CPACK_PACKAGE_EXECUTABLES`."
msgstr ""
"要创建的桌面链接列表。每个桌面链接都需要一个相应的开始菜单快捷方式，由 :variable:`CPACK_PACKAGE_EXECUTABLES` "
"创建。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:469
msgid ""
"CPack generated options for binary generators.  The ``CPack.cmake`` module"
" generates (when :variable:`CPACK_GENERATOR` is not set) a set of CMake "
"options (see CMake :command:`option` command) which may then be used to "
"select the CPack generator(s) to be used when building the ``package`` "
"target or when running :manual:`cpack <cpack(1)>` without the :option:`-G "
"<cpack -G>` option."
msgstr ""
"CPack 为二进制生成器生成选项。 ``CPack.cmake`` 模块生成（当 :variable:`CPACK_GENERATOR` "
"未设置时）一组 CMake 选项（参见 CMake :command:`option` 命令），然后可用于选择 CPack 生成器（s ) 在构建 "
"``package`` 目标或运行 :manual:`cpack <cpack(1)>` 时使用，但不使用 :option:`-G <cpack "
"-G>` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:480
msgid ""
"Specify the ``readelf`` executable path used by CPack. The default value "
"will be ``CMAKE_READELF`` when set.  Otherwise, the default value will be "
"empty and CPack will use :command:`find_program` to determine the "
"``readelf`` path when needed."
msgstr ""
"指定 CPack 使用的 ``readelf`` 可执行路径。设置时默认值为“CMAKE_READELF”。否则，默认值为空，CPack "
"将在需要时使用 :command:`find_program` 确定 ``readelf`` 路径。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:489
msgid ""
"Specify the ``objcopy`` executable path used by CPack. The default value "
"will be ``CMAKE_OBJCOPY`` when set.  Otherwise, the default value will be "
"empty and CPack will use :command:`find_program` to determine the "
"``objcopy`` path when needed."
msgstr ""
"指定 CPack 使用的 ``objcopy`` 可执行路径。设置时默认值为“CMAKE_OBJCOPY”。否则，默认值为空，CPack "
"将在需要时使用 :command:`find_program` 确定 ``objcopy`` 路径。"

#: ../../cmake-prefix/src/cmake/Modules/CPack.cmake:498
msgid ""
"Specify the ``objdump`` executable path used by CPack. The default value "
"will be ``CMAKE_OBJDUMP`` when set.  Otherwise, the default value will be "
"empty and CPack will use :command:`find_program` to determine the "
"``objdump`` path when needed."
msgstr ""
"指定 CPack 使用的 ``objdump`` 可执行路径。设置时默认值为“CMAKE_OBJDUMP”。否则，默认值为空，CPack "
"将在需要时使用 :command:`find_program` 确定 ``objdump`` 路径。"

#: ../../cmake-prefix/src/cmake/Help/module/CPackArchive.rst:2
msgid "CPackArchive"
msgstr "CPack存档"

#: ../../cmake-prefix/src/cmake/Help/module/CPackArchive.rst:6
msgid ""
"The documentation for the CPack Archive generator has moved here: "
":cpack_gen:`CPack Archive Generator`"
msgstr "CPack 存档生成器的文档已移至此处： :cpack_gen:`CPack 存档生成器`"

#: ../../cmake-prefix/src/cmake/Help/module/CPackBundle.rst:2
msgid "CPackBundle"
msgstr "CPackBundle"

#: ../../cmake-prefix/src/cmake/Help/module/CPackBundle.rst:4
msgid ""
"The documentation for the CPack Bundle generator has moved here: "
":cpack_gen:`CPack Bundle Generator`"
msgstr "CPack Bundle 生成器的文档已移至此处： :cpack_gen:`CPack Bundle Generator`"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:6
msgid "CPackComponent"
msgstr "CPack组件"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:8
msgid "Configure components for binary installers and source packages."
msgstr "为二进制安装程序和源包配置组件。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:9
#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:12
msgid "Contents"
msgstr "内容"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:17
msgid "This module is automatically included by :module:`CPack`."
msgstr "该模块自动包含在 CPack 中。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:19
msgid ""
"Certain binary installers (especially the graphical installers) generated "
"by CPack allow users to select individual application *components* to "
"install. This module allows developers to configure the packaging of such "
"components."
msgstr ""
"CPack 生成的某些二进制安装程序（尤其是图形安装程序）允许用户选择要安装的单个应用程序*组件*。该模块允许开发人员配置此类组件的包装。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:23
msgid ""
"Contents is assigned to components by the ``COMPONENT`` argument of "
"CMake's :command:`install` command.  Components can be annotated with "
"user-friendly names and descriptions, inter-component dependencies, etc., "
"and grouped in various ways to customize the resulting installer, using "
"the commands described below."
msgstr ""
"内容通过 CMake 的 :command:`install` 命令的 ``COMPONENT`` "
"参数分配给组件。组件可以用用户友好的名称和描述、组件间的依赖关系等进行注释，并以各种方式分组以使用下面描述的命令自定义生成的安装程序。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:29
msgid ""
"To specify different groupings for different CPack generators use a "
"CPACK_PROJECT_CONFIG_FILE."
msgstr "要为不同的 CPack 生成器指定不同的分组，请使用 CPACK_PROJECT_CONFIG_FILE。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:623
#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:20
msgid "Variables"
msgstr "变量"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:35
msgid "The following variables influence the component-specific packaging:"
msgstr "以下变量会影响组件特定的包装："

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:39
msgid "The list of component to install."
msgstr "要安装的组件列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:41
msgid ""
"The default value of this variable is computed by CPack and contains all "
"components defined by the project.  The user may set it to only include "
"the specified components."
msgstr "此变量的默认值由 CPack 计算并包含项目定义的所有组件。用户可以将其设置为仅包含指定的组件。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:45
msgid ""
"Instead of specifying all the desired components, it is possible to obtain"
" a list of all defined components and then remove the unwanted ones from "
"the list. The :command:`get_cmake_property` command can be used to obtain "
"the ``COMPONENTS`` property, then the :command:`list(REMOVE_ITEM)` command"
" can be used to remove the unwanted ones. For example, to use all defined "
"components except ``foo`` and ``bar``::"
msgstr ""
"无需指定所有需要的组件，可以获得所有已定义组件的列表，然后从列表中删除不需要的组件。 :command:`get_cmake_property` "
"命令可用于获取 ``COMPONENTS`` 属性，然后 :command:`list(REMOVE_ITEM)` "
"命令可用于删除不需要的。例如，要使用除 ``foo`` 和 ``bar`` 之外的所有已定义组件："

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:57
msgid "Enable/Disable component install for CPack generator <GENNAME>."
msgstr "为 CPack 生成器 <GENNAME> 启用/禁用组件安装。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:59
msgid ""
"Each CPack Generator (RPM, DEB, ARCHIVE, NSIS, DMG, etc...) has a legacy "
"default behavior.  e.g.  RPM builds monolithic whereas NSIS builds "
"component.  One can change the default behavior by setting this variable "
"to 0/1 or OFF/ON."
msgstr ""
"每个 CPack 生成器（RPM、DEB、ARCHIVE、NSIS、DMG 等）都有一个遗留的默认行为。例如RPM 构建单体，而 NSIS "
"构建组件。可以通过将此变量设置为 0/1 或 OFF/ON 来更改默认行为。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:66
msgid ""
"Specify how components are grouped for multi-package component-aware CPack"
" generators."
msgstr "指定如何为多包组件感知 CPack 生成器对组件进行分组。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:69
msgid ""
"Some generators like RPM or ARCHIVE (TGZ, ZIP, ...) may generate several "
"packages files when there are components, depending on the value of this "
"variable:"
msgstr "某些生成器，如 RPM 或 ARCHIVE（TGZ、ZIP，...）可能会在有组件时生成多个包文件，具体取决于此变量的值："

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:73
msgid "ONE_PER_GROUP (default): create one package per component group"
msgstr "ONE_PER_GROUP（默认）：为每个组件组创建一个包"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:74
msgid "IGNORE : create one package per component (ignore the groups)"
msgstr "IGNORE ：为每个组件创建一个包（忽略组）"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:75
msgid ""
"ALL_COMPONENTS_IN_ONE : create a single package with all requested "
"components"
msgstr "ALL_COMPONENTS_IN_ONE ：创建包含所有请求组件的单个包"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:80
msgid "The name to be displayed for a component."
msgstr "要为组件显示的名称。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:84
msgid "The description of a component."
msgstr "组件的描述。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:88
msgid "The group of a component."
msgstr "组件的组。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:92
msgid ""
"The dependencies (list of components) on which this component depends."
msgstr "该组件所依赖的依赖项（组件列表）。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:96
msgid "True if this component is hidden from the user."
msgstr "如果此组件对用户隐藏，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:100
msgid "True if this component is required."
msgstr "如果需要此组件，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:104
msgid "True if this component is not selected to be installed by default."
msgstr "如果未选择默认安装此组件，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:107
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/CPackIFWConfigureFile.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:105
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:173
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:516
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:408
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:514
msgid "Commands"
msgstr "命令"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:110
msgid "Add component"
msgstr "添加组件"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:114
msgid "Describe an installation component."
msgstr "描述一个安装组件。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:129
msgid ""
"``compname`` is the name of an installation component, as defined by the "
"``COMPONENT`` argument of one or more CMake :command:`install` commands. "
"With the ``cpack_add_component`` command one can set a name, a "
"description, and other attributes of an installation component. One can "
"also assign a component to a component group."
msgstr ""
"``compname`` 是安装组件的名称，由一个或多个 CMake:command:`install` 命令的 ``COMPONENT`` "
"参数定义。使用 ``cpack_add_component`` 命令可以设置安装组件的名称、描述和其他属性。还可以将组件分配给组件组。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:135
msgid ""
"DISPLAY_NAME is the displayed name of the component, used in graphical "
"installers to display the component name.  This value can be any string."
msgstr "DISPLAY_NAME 是组件的显示名称，在图形安装程序中用于显示组件名称。该值可以是任何字符串。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:139
msgid ""
"DESCRIPTION is an extended description of the component, used in graphical"
" installers to give the user additional information about the component.  "
"Descriptions can span multiple lines using ``\\n`` as the line separator."
"  Typically, these descriptions should be no more than a few lines long."
msgstr ""
"DESCRIPTION 是组件的扩展描述，在图形安装程序中用于为用户提供有关组件的附加信息。描述可以使用 ``\\n`` "
"作为行分隔符跨越多行。通常，这些描述不应超过几行。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:145
msgid ""
"HIDDEN indicates that this component will be hidden in the graphical "
"installer, so that the user cannot directly change whether it is installed"
" or not."
msgstr "HIDDEN表示该组件将隐藏在图形安装程序中，用户无法直接更改是否安装。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:149
msgid ""
"REQUIRED indicates that this component is required, and therefore will "
"always be installed.  It will be visible in the graphical installer, but "
"it cannot be unselected.  (Typically, required components are shown greyed"
" out)."
msgstr "REQUIRED 指示此组件是必需的，因此将始终安装。它将在图形安装程序中可见，但无法取消选择。 （通常，所需组件显示为灰色）。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:154
msgid ""
"DISABLED indicates that this component should be disabled (unselected) by "
"default.  The user is free to select this component for installation, "
"unless it is also HIDDEN."
msgstr "DISABLED 指示默认情况下应禁用（未选中）此组件。用户可以自由选择该组件进行安装，除非它也是隐藏的。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:158
msgid ""
"DEPENDS lists the components on which this component depends.  If this "
"component is selected, then each of the components listed must also be "
"selected.  The dependency information is encoded within the installer "
"itself, so that users cannot install inconsistent sets of components."
msgstr ""
"DEPENDS "
"列出该组件所依赖的组件。如果选择此组件，则还必须选择列出的每个组件。依赖信息在安装程序本身中进行了编码，因此用户无法安装不一致的组件集。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:163
msgid ""
"GROUP names the component group of which this component is a part.  If not"
" provided, the component will be a standalone component, not part of any "
"component group.  Component groups are described with the "
"cpack_add_component_group command, detailed below."
msgstr ""
"GROUP 命名该组件所属的组件组。如果没有提供，该组件将是一个独立的组件，而不是任何组件组的一部分。组件组使用 "
"cpack_add_component_group 命令进行描述，详情如下。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:168
msgid ""
"INSTALL_TYPES lists the installation types of which this component is a "
"part.  When one of these installations types is selected, this component "
"will automatically be selected.  Installation types are described with the"
" cpack_add_install_type command, detailed below."
msgstr ""
"INSTALL_TYPES 列出了该组件所属的安装类型。选择其中一种安装类型时，将自动选择该组件。安装类型使用 "
"cpack_add_install_type 命令进行描述，详情如下。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:173
msgid ""
"DOWNLOADED indicates that this component should be downloaded on-the-fly "
"by the installer, rather than packaged in with the installer itself.  For "
"more information, see the cpack_configure_downloads command."
msgstr ""
"DOWNLOADED 表示此组件应由安装程序即时下载，而不是与安装程序本身一起打包。有关详细信息，请参阅 "
"cpack_configure_downloads 命令。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:178
msgid ""
"ARCHIVE_FILE provides a name for the archive file created by CPack to be "
"used for downloaded components.  If not supplied, CPack will create a file"
" with some name based on CPACK_PACKAGE_FILE_NAME and the name of the "
"component.  See cpack_configure_downloads for more information."
msgstr ""
"ARCHIVE_FILE 为 CPack 创建的用于下载组件的存档文件提供名称。如果未提供，CPack 将根据 "
"CPACK_PACKAGE_FILE_NAME 和组件名称创建一个具有某个名称的文件。有关详细信息，请参阅 "
"cpack_configure_downloads。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:183
msgid ""
"PLIST gives a filename that is passed to pkgbuild with the ``--component-"
"plist`` argument when using the productbuild generator."
msgstr ""
"PLIST 给出一个文件名，该文件名在使用 productbuild 生成器时通过 ``--component-plist`` 参数传递给 "
"pkgbuild。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:187
msgid "Add component group"
msgstr "添加组件组"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:191
msgid "Describes a group of related CPack installation components."
msgstr "描述了一组相关的 CPack 安装组件。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:204
msgid ""
"The cpack_add_component_group describes a group of installation "
"components, which will be placed together within the listing of options.  "
"Typically, component groups allow the user to select/deselect all of the "
"components within a single group via a single group-level option.  Use "
"component groups to reduce the complexity of installers with many options."
"  groupname is an arbitrary name used to identify the group in the GROUP "
"argument of the cpack_add_component command, which is used to place a "
"component in a group.  The name of the group must not conflict with the "
"name of any component."
msgstr ""
"cpack_add_component_group "
"描述了一组安装组件，它们将一起放置在选项列表中。通常，组件组允许用户通过单个组级选项选择/取消选择单个组内的所有组件。使用组件组来降低具有多种选项的安装程序的复杂性。"
" groupname 是一个任意名称，用于标识 cpack_add_component 命令的 GROUP "
"参数中的组，该命令用于将组件放入组中。组的名称不得与任何组件的名称冲突。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:215
msgid ""
"DISPLAY_NAME is the displayed name of the component group, used in "
"graphical installers to display the component group name.  This value can "
"be any string."
msgstr "DISPLAY_NAME 是组件组的显示名称，在图形安装程序中用于显示组件组名称。该值可以是任何字符串。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:219
msgid ""
"DESCRIPTION is an extended description of the component group, used in "
"graphical installers to give the user additional information about the "
"components within that group.  Descriptions can span multiple lines using "
"``\\n`` as the line separator.  Typically, these descriptions should be no"
" more than a few lines long."
msgstr ""
"DESCRIPTION 是组件组的扩展描述，在图形安装程序中使用，以向用户提供有关该组中组件的附加信息。描述可以使用 ``\\n`` "
"作为行分隔符跨越多行。通常，这些描述不应超过几行。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:225
msgid ""
"PARENT_GROUP, if supplied, names the parent group of this group. Parent "
"groups are used to establish a hierarchy of groups, providing an arbitrary"
" hierarchy of groups."
msgstr "PARENT_GROUP（如果提供）命名该组的父组。父组用于建立组的层次结构，提供任意的组层次结构。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:229
msgid ""
"EXPANDED indicates that, by default, the group should show up as "
"\"expanded\", so that the user immediately sees all of the components "
"within the group.  Otherwise, the group will initially show up as a single"
" entry."
msgstr "EXPANDED 表示，默认情况下，该组应显示为“已扩展”，以便用户立即看到该组中的所有组件。否则，该组最初将显示为单个条目。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:234
msgid ""
"BOLD_TITLE indicates that the group title should appear in bold, to call "
"the user's attention to the group."
msgstr "BOLD_TITLE 表示组标题应以粗体显示，以引起用户对该组的注意。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:238
msgid "Add installation type"
msgstr "添加安装类型"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:242
msgid ""
"Add a new installation type containing a set of predefined component "
"selections to the graphical installer."
msgstr "将包含一组预定义组件选择的新安装类型添加到图形安装程序。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:252
msgid ""
"The cpack_add_install_type command identifies a set of preselected "
"components that represents a common use case for an application.  For "
"example, a \"Developer\" install type might include an application along "
"with its header and library files, while an \"End user\" install type "
"might just include the application's executable.  Each component "
"identifies itself with one or more install types via the INSTALL_TYPES "
"argument to cpack_add_component."
msgstr ""
"cpack_add_install_type "
"命令标识一组预选组件，代表应用程序的常见用例。例如，“开发人员”安装类型可能包括应用程序及其头文件和库文件，而“最终用户”安装类型可能只包括应用程序的可执行文件。每个组件通过"
" cpack_add_component 的 INSTALL_TYPES 参数用一种或多种安装类型标识自己。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:260
msgid ""
"DISPLAY_NAME is the displayed name of the install type, which will "
"typically show up in a drop-down box within a graphical installer. This "
"value can be any string."
msgstr "DISPLAY_NAME 是安装类型的显示名称，通常会显示在图形安装程序的下拉框中。该值可以是任何字符串。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:265
msgid "Configure downloads"
msgstr "配置下载"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:269
msgid ""
"Configure CPack to download selected components on-the-fly as part of the "
"installation process."
msgstr "配置 CPack 以在安装过程中即时下载选定的组件。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:281
msgid ""
"The cpack_configure_downloads command configures installation-time "
"downloads of selected components.  For each downloadable component, CPack "
"will create an archive containing the contents of that component, which "
"should be uploaded to the given site.  When the user selects that "
"component for installation, the installer will download and extract the "
"component in place.  This feature is useful for creating small installers "
"that only download the requested components, saving bandwidth.  "
"Additionally, the installers are small enough that they will be installed "
"as part of the normal installation process, and the \"Change\" button in "
"Windows Add/Remove Programs control panel will allow one to add or remove "
"parts of the application after the original installation.  On Windows, the"
" downloaded-components functionality requires the ZipDLL plug-in for NSIS,"
" available at:"
msgstr ""
"cpack_configure_downloads 命令配置所选组件的安装时下载。对于每个可下载的组件，CPack "
"将创建一个包含该组件内容的存档，该存档应上传到给定的站点。当用户选择要安装的组件时，安装程​​序将下载并解压缩该组件。此功能对于创建仅下载请求的组件的小型安装程序非常有用，从而节省了带宽。此外，安装程序非常小，可以作为正常安装过程的一部分进行安装，Windows"
" 添加/删除程序控制面板中的“更改”按钮将允许在原始安装后添加或删除部分应用程序。在 Windows 上，下载组件功能需要 NSIS 的 "
"ZipDLL 插件，可从以下网址获得："

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:299
msgid ""
"On macOS, installers that download components on-the-fly can only be built"
" and installed on system using macOS 10.5 or later."
msgstr "在 macOS 上，即时下载组件的安装程序只能在使用 macOS 10.5 或更高版本的系统上构建和安装。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:302
msgid ""
"The site argument is a URL where the archives for downloadable components "
"will reside, e.g., https://cmake.org/files/v3.25/ All of the archives "
"produced by CPack should be uploaded to that location."
msgstr ""
"site 参数是可下载组件的存档所在的 URL，例如 https://cmake.org/files/v3.25/ CPack "
"生成的所有存档都应上传到该位置。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:307
msgid ""
"UPLOAD_DIRECTORY is the local directory where CPack will create the "
"various archives for each of the components.  The contents of this "
"directory should be uploaded to a location accessible by the URL given in "
"the site argument.  If omitted, CPack will use the directory CPackUploads "
"inside the CMake binary directory to store the generated archives."
msgstr ""
"UPLOAD_DIRECTORY 是 CPack 将为每个组件创建各种存档的本地目录。此目录的内容应上传到站点参数中给出的 URL "
"可访问的位置。如果省略，CPack 将使用 CMake 二进制目录中的目录 CPackUploads 来存储生成的档案。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:314
msgid ""
"The ALL flag indicates that all components be downloaded.  Otherwise, only"
" those components explicitly marked as DOWNLOADED or that have a specified"
" ARCHIVE_FILE will be downloaded.  Additionally, the ALL option implies "
"ADD_REMOVE (unless NO_ADD_REMOVE is specified)."
msgstr ""
"ALL 标志指示下载所有组件。否则，只会下载那些明确标记为已下载或具有指定 ARCHIVE_FILE 的组件。此外，ALL 选项意味着 "
"ADD_REMOVE（除非指定了 NO_ADD_REMOVE）。"

#: ../../cmake-prefix/src/cmake/Modules/CPackComponent.cmake:319
msgid ""
"ADD_REMOVE indicates that CPack should install a copy of the installer "
"that can be called from Windows' Add/Remove Programs dialog (via the "
"\"Modify\" button) to change the set of installed components. "
"NO_ADD_REMOVE turns off this behavior.  This option is ignored on Mac OS "
"X."
msgstr ""
"ADD_REMOVE 表示 CPack 应该安装安装程序的副本，可以从 Windows "
"的“添加/删除程序”对话框（通过“修改”按钮）调用该副本以更改已安装组件集。 NO_ADD_REMOVE 关闭此行为。在 Mac OS X "
"上忽略此选项。"

#: ../../cmake-prefix/src/cmake/Help/module/CPackCygwin.rst:2
msgid "CPackCygwin"
msgstr "CPackCygwin"

#: ../../cmake-prefix/src/cmake/Help/module/CPackCygwin.rst:4
msgid ""
"The documentation for the CPack Cygwin generator has moved here: "
":cpack_gen:`CPack Cygwin Generator`"
msgstr "CPack Cygwin 生成器的文档已移至此处： :cpack_gen:`CPack Cygwin 生成器`"

#: ../../cmake-prefix/src/cmake/Help/module/CPackDMG.rst:2
msgid "CPackDMG"
msgstr "CPackDMG"

#: ../../cmake-prefix/src/cmake/Help/module/CPackDMG.rst:4
msgid ""
"The documentation for the CPack DragNDrop generator has moved here: "
":cpack_gen:`CPack DragNDrop Generator`"
msgstr "CPack DragNDrop 生成器的文档已移至此处： :cpack_gen:`CPack DragNDrop Generator`"

#: ../../cmake-prefix/src/cmake/Help/module/CPackDeb.rst:2
msgid "CPackDeb"
msgstr "CPackDeb"

#: ../../cmake-prefix/src/cmake/Help/module/CPackDeb.rst:4
msgid ""
"The documentation for the CPack DEB generator has moved here: "
":cpack_gen:`CPack DEB Generator`"
msgstr "CPack DEB 生成器的文档已移至此处： :cpack_gen:`CPack DEB 生成器`"

#: ../../cmake-prefix/src/cmake/Help/module/CPackFreeBSD.rst:2
msgid "CPackFreeBSD"
msgstr "CPackFreeBSD"

#: ../../cmake-prefix/src/cmake/Help/module/CPackFreeBSD.rst:6
msgid ""
"The documentation for the CPack FreeBSD generator has moved here: "
":cpack_gen:`CPack FreeBSD Generator`"
msgstr "CPack FreeBSD 生成器的文档已移至此处： :cpack_gen:`CPack FreeBSD 生成器`"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:6
msgid "CPackIFW"
msgstr "CPackIFW"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:10
msgid ""
"This module looks for the location of the command-line utilities supplied "
"with the `Qt Installer Framework "
"<http://doc.qt.io/qtinstallerframework/index.html>`_ (QtIFW)."
msgstr ""
"此模块查找随“Qt 安装程序框架 "
"<http://doc.qt.io/qtinstallerframework/index.html>”(QtIFW) "
"一起提供的命令行实用程序的位置。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:14
msgid ""
"The module also defines several commands to control the behavior of the "
":cpack_gen:`CPack IFW Generator`."
msgstr "该模块还定义了几个命令来控制 CPack IFW Generator 的行为。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:20
#: ../../cmake-prefix/src/cmake/Modules/CPackIFWConfigureFile.cmake:17
msgid "The module defines the following commands:"
msgstr "该模块定义了以下命令："

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:177
msgid "Sets the arguments specific to the CPack IFW generator."
msgstr "设置特定于 CPack IFW 生成器的参数。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:47
msgid ""
"This command should be called after :command:`cpack_add_component` "
"command."
msgstr "此命令应在 :command:`cpack_add_component` 命令之后调用。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:51
msgid "``COMMON``"
msgstr "``常见``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:50
msgid ""
"if set, then the component will be packaged and installed as part of a "
"group to which it belongs."
msgstr "如果已设置，则该组件将作为其所属组的一部分进行打包和安装。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:57
msgid "``ESSENTIAL``"
msgstr "``基本``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:56
msgid ""
"if set, then the package manager stays disabled until that component is "
"updated."
msgstr "如果设置，则包管理器将保持禁用状态，直到更新该组件。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:64
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:207
msgid "``VIRTUAL``"
msgstr "``虚拟``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:62
msgid ""
"if set, then the component will be hidden from the installer. It is a "
"equivalent of the ``HIDDEN`` option from the "
":command:`cpack_add_component` command."
msgstr ""
"如果设置，则该组件将对安装程序隐藏。它等同于 :command:`cpack_add_component` 命令中的 ``HIDDEN`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:71
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:212
msgid "``FORCED_INSTALLATION``"
msgstr "``强制安装``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:69
msgid ""
"if set, then the component must always be installed. It is a equivalent of"
" the ``REQUIRED`` option from the :command:`cpack_add_component` command."
msgstr ""
"如果设置，则必须始终安装该组件。它等效于 :command:`cpack_add_component` 命令中的 ``REQUIRED`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:76
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:218
msgid "``REQUIRES_ADMIN_RIGHTS``"
msgstr "``REQUIRES_ADMIN_RIGHTS``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:76
msgid ""
"set it if the component needs to be installed with elevated permissions."
msgstr "如果组件需要以提升的权限安装，请设置它。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:79
msgid ""
"is used to create domain-like identification for this component. By "
"default used origin component name."
msgstr "用于为此组件创建类似域的标识。默认情况下使用原始组件名称。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:86
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:228
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:343
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:380
msgid "``DISPLAY_NAME``"
msgstr "``DISPLAY_NAME``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:85
msgid ""
"set to rewrite original name configured by :command:`cpack_add_component` "
"command."
msgstr "设置重写由 :command:`cpack_add_component` 命令配置的原始名称。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:92
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:234
msgid "``DESCRIPTION``"
msgstr "``描述``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:91
msgid ""
"set to rewrite original description configured by "
":command:`cpack_add_component` command."
msgstr "设置重写由 :command:`cpack_add_component` 命令配置的原始描述。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:98
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:240
msgid "``UPDATE_TEXT``"
msgstr "``更新文本``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:97
msgid ""
"will be added to the component description if this is an update to the "
"component."
msgstr "如果这是对组件的更新，则将添加到组件描述中。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:102
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:244
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:116
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:545
msgid "``VERSION``"
msgstr "``版本``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:101
msgid ""
"is version of component. By default used "
":variable:`CPACK_PACKAGE_VERSION`."
msgstr "是组件的版本。默认使用 :variable:`CPACK_PACKAGE_VERSION`。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:107
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:249
msgid "``RELEASE_DATE``"
msgstr "``发布日期``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:107
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:249
msgid "keep empty to auto generate."
msgstr "留空自动生成。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:111
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:253
msgid "``SCRIPT``"
msgstr "``脚本``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:110
msgid ""
"is a relative or absolute path to operations script for this component."
msgstr "是此组件的操作脚本的相对或绝对路径。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:116
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:256
msgid "``SORTING_PRIORITY``"
msgstr "``SORTING_PRIORITY``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:116
msgid "is priority of the component in the tree."
msgstr "是树中组件的优先级。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:120
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:260
msgid "``PRIORITY``"
msgstr "``优先级``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:119
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:259
msgid "Old name for ``SORTING_PRIORITY``."
msgstr "``SORTING_PRIORITY`` 的旧名称。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:131
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:271
msgid "``DEPENDS``, ``DEPENDENCIES``"
msgstr "``取决于``，``依赖``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:125
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:265
msgid ""
"list of dependency component or component group identifiers in QtIFW "
"style."
msgstr "QtIFW 样式的依赖组件或组件组标识符列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:130
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:270
msgid ""
"Component or group names listed as dependencies may contain hyphens. This "
"requires QtIFW 3.1 or later."
msgstr "作为依赖项列出的组件或组名称可能包含连字符。这需要 QtIFW 3.1 或更高版本。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:137
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:277
msgid "``AUTO_DEPEND_ON``"
msgstr "``AUTO_DEPEND_ON``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:136
msgid ""
"list of identifiers of component or component group in QtIFW style that "
"this component has an automatic dependency on."
msgstr "此组件具有自动依赖性的 QtIFW 样式的组件或组件组的标识符列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:141
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:281
msgid "``LICENSES``"
msgstr "``许可证``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:140
msgid ""
"pair of <display_name> and <file_path> of license text for this component."
" You can specify more then one license."
msgstr "此组件的一对 <display_name> 和 <file_path> 许可文本。您可以指定多个许可证。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:149
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:290
msgid "``DEFAULT``"
msgstr "``默认``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:146
msgid ""
"Possible values are: TRUE, FALSE, and SCRIPT. Set to FALSE to disable the "
"component in the installer or to SCRIPT to resolved during runtime (don't "
"forget add the file of the script as a value of the ``SCRIPT`` option)."
msgstr ""
"可能的值为：TRUE、FALSE 和 SCRIPT。设置为 FALSE 以禁用安装程序中的组件或设置为 SCRIPT "
"以在运行时解析（不要忘记将脚本文件添加为 ``SCRIPT`` 选项的值）。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:154
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:295
msgid "``USER_INTERFACES``"
msgstr "``用户界面``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:154
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:295
msgid "is a list of <file_path> ('.ui' files) representing pages to load."
msgstr "是代表要加载的页面的 <file_path>（'.ui' 文件）列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:159
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:300
msgid "``TRANSLATIONS``"
msgstr "``翻译``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:159
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:300
msgid ""
"is a list of <file_path> ('.qm' files) representing translations to load."
msgstr "是代表要加载的翻译的 <file_path>（'.qm' 文件）列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:164
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:305
msgid "``REPLACES``"
msgstr "``替换``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:164
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:305
msgid "list of identifiers of component or component group to replace."
msgstr "要替换的组件或组件组的标识符列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:171
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:312
msgid "``CHECKABLE``"
msgstr "``可检查``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:169
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:310
msgid ""
"Possible values are: TRUE, FALSE. Set to FALSE if you want to hide the "
"checkbox for an item. This is useful when only a few subcomponents should "
"be selected instead of all."
msgstr "可能的值是：TRUE、FALSE。如果要隐藏项目的复选框，请设置为 FALSE。当只应选择几个子组件而不是全部时，这很有用。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:200
msgid ""
"This command should be called after :command:`cpack_add_component_group` "
"command."
msgstr "此命令应在 :command:`cpack_add_component_group` 命令之后调用。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:206
msgid ""
"if set, then the group will be hidden from the installer. Note that "
"setting this on a root component does not work."
msgstr "如果设置，则该组将对安装程序隐藏。请注意，在根组件上设置此设置不起作用。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:212
msgid "if set, then the group must always be installed."
msgstr "如果设置，则必须始终安装该组。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:217
msgid ""
"set it if the component group needs to be installed with elevated "
"permissions."
msgstr "如果组件组需要以提升的权限安装，请设置它。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:221
msgid ""
"is used to create domain-like identification for this component group. By "
"default used origin component group name."
msgstr "用于为此组件组创建类似域的标识。默认情况下使用原始组件组名称。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:227
msgid ""
"set to rewrite original name configured by "
":command:`cpack_add_component_group` command."
msgstr "设置重写由 :command:`cpack_add_component_group` 命令配置的原始名称。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:233
msgid ""
"set to rewrite original description configured by "
":command:`cpack_add_component_group` command."
msgstr "设置重写由 :command:`cpack_add_component_group` 命令配置的原始描述。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:239
msgid ""
"will be added to the component group description if this is an update to "
"the component group."
msgstr "如果这是对组件组的更新，将被添加到组件组描述中。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:243
msgid ""
"is version of component group. By default used "
":variable:`CPACK_PACKAGE_VERSION`."
msgstr "是组件组的版本。默认使用 :variable:`CPACK_PACKAGE_VERSION`。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:252
msgid ""
"is a relative or absolute path to operations script for this component "
"group."
msgstr "是此组件组的操作脚本的相对或绝对路径。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:256
msgid "is priority of the component group in the tree."
msgstr "是树中组件组的优先级。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:276
msgid ""
"list of identifiers of component or component group in QtIFW style that "
"this component group has an automatic dependency on."
msgstr "该组件组具有自动依赖性的 QtIFW 样式的组件或组件组的标识符列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:280
msgid ""
"pair of <display_name> and <file_path> of license text for this component "
"group. You can specify more then one license."
msgstr "此组件组的一对 <display_name> 和 <file_path> 许可证文本。您可以指定多个许可证。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:286
msgid ""
"Possible values are: TRUE, FALSE, and SCRIPT. Set to TRUE to preselect the"
" group in the installer (this takes effect only on groups that have no "
"visible child components) or to SCRIPT to resolved during runtime (don't "
"forget add the file of the script as a value of the ``SCRIPT`` option)."
msgstr ""
"可能的值为：TRUE、FALSE 和 SCRIPT。设置为 TRUE 以预选安装程序中的组（这仅对没有可见子组件的组有效）或设置为 SCRIPT "
"以在运行时解析（不要忘记将脚本文件添加为 ``SCRIPT 的值``选项）。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:318
msgid "Add QtIFW specific remote repository to binary installer."
msgstr "将 QtIFW 特定的远程存储库添加到二进制安装程序。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:328
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:362
msgid ""
"This command will also add the <reponame> repository to a variable "
":variable:`CPACK_IFW_REPOSITORIES_ALL`."
msgstr "此命令还将 <reponame> 存储库添加到变量 :variable:`CPACK_IFW_REPOSITORIES_ALL`。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:332
msgid "``DISABLED``"
msgstr "``禁用``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:332
msgid "if set, then the repository will be disabled by default."
msgstr "如果设置，则默认情况下将禁用存储库。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:335
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:366
msgid "``URL``"
msgstr "``网址``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:335
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:366
msgid "is points to a list of available components."
msgstr "是指向可用组件的列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:338
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:375
msgid "``USERNAME``"
msgstr "``用户名``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:338
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:375
msgid "is used as user on a protected repository."
msgstr "在受保护的存储库上用作用户。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:341
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:378
msgid "``PASSWORD``"
msgstr "``密码``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:341
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:378
msgid "is password to use on a protected repository."
msgstr "是在受保护的存储库上使用的密码。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:344
#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:381
msgid "is string to display instead of the URL."
msgstr "是要显示的字符串而不是 URL。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:351
msgid "Update QtIFW specific repository from remote repository."
msgstr "从远程存储库更新 QtIFW 特定存储库。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:369
msgid "``OLD_URL``"
msgstr "``旧网址``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:369
msgid "is points to a list that will replaced."
msgstr "是指向将被替换的列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:372
msgid "``NEW_URL``"
msgstr "``新网址``"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:372
msgid "is points to a list that will replace to."
msgstr "是指向将替换为的列表。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:388
msgid "Add additional resources in the installer binary."
msgstr "在安装程序二进制文件中添加其他资源。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFW.cmake:394
msgid ""
"This command will also add the specified files to a variable "
":variable:`CPACK_IFW_PACKAGE_RESOURCES`."
msgstr "此命令还将指定的文件添加到变量 :variable:`CPACK_IFW_PACKAGE_RESOURCES`。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFWConfigureFile.cmake:6
msgid "CPackIFWConfigureFile"
msgstr "CPackIFW配置文件"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFWConfigureFile.cmake:10
msgid ""
"The module defines :command:`configure_file` similar command to configure "
"file templates prepared in QtIFW/SDK/Creator style."
msgstr ""
"该模块定义了 :command:`configure_file` 类似的命令来配置以 QtIFW/SDK/Creator 风格准备的文件模板。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFWConfigureFile.cmake:21
msgid "Copy a file to another location and modify its contents."
msgstr "将文件复制到另一个位置并修改其内容。"

#: ../../cmake-prefix/src/cmake/Modules/CPackIFWConfigureFile.cmake:27
msgid ""
"Copies an ``<input>`` file to an ``<output>`` file and substitutes "
"variable values referenced as ``%{VAR}`` or ``%VAR%`` in the input file "
"content. Each variable reference will be replaced with the current value "
"of the variable, or the empty string if the variable is not defined."
msgstr ""
"将 ``<input>`` 文件复制到 ``<output>`` 文件，并在输入文件内容中替换引用为 ``%{VAR}`` 或 ``%VAR%`` "
"的变量值。每个变量引用都将替换为变量的当前值，如果未定义变量，则替换为空字符串。"

#: ../../cmake-prefix/src/cmake/Help/module/CPackNSIS.rst:2
msgid "CPackNSIS"
msgstr "CPackNSIS"

#: ../../cmake-prefix/src/cmake/Help/module/CPackNSIS.rst:4
msgid ""
"The documentation for the CPack NSIS generator has moved here: "
":cpack_gen:`CPack NSIS Generator`"
msgstr "CPack NSIS 生成器的文档已移至此处： :cpack_gen:`CPack NSIS 生成器`"

#: ../../cmake-prefix/src/cmake/Help/module/CPackNuGet.rst:2
msgid "CPackNuGet"
msgstr "CPackNuGet"

#: ../../cmake-prefix/src/cmake/Help/module/CPackNuGet.rst:6
msgid ""
"The documentation for the CPack NuGet generator has moved here: "
":cpack_gen:`CPack NuGet Generator`"
msgstr "CPack NuGet 生成器的文档已移至此处： :cpack_gen:`CPack NuGet Generator`"

#: ../../cmake-prefix/src/cmake/Help/module/CPackProductBuild.rst:2
msgid "CPackProductBuild"
msgstr "CPack产品构建"

#: ../../cmake-prefix/src/cmake/Help/module/CPackProductBuild.rst:6
msgid ""
"The documentation for the CPack productbuild generator has moved here: "
":cpack_gen:`CPack productbuild Generator`"
msgstr ""
"CPack productbuild 生成器的文档已移至此处： :cpack_gen:`CPack productbuild Generator`"

#: ../../cmake-prefix/src/cmake/Help/module/CPackRPM.rst:2
msgid "CPackRPM"
msgstr "CPack转速"

#: ../../cmake-prefix/src/cmake/Help/module/CPackRPM.rst:4
msgid ""
"The documentation for the CPack RPM generator has moved here: "
":cpack_gen:`CPack RPM Generator`"
msgstr "CPack RPM 生成器的文档已移至此处： :cpack_gen:`CPack RPM 生成器`"

#: ../../cmake-prefix/src/cmake/Help/module/CPackWIX.rst:2
msgid "CPackWIX"
msgstr "CPackWIX"

#: ../../cmake-prefix/src/cmake/Help/module/CPackWIX.rst:4
msgid ""
"The documentation for the CPack WIX generator has moved here: "
":cpack_gen:`CPack WIX Generator`"
msgstr "CPack WIX 生成器的文档已移至此处： :cpack_gen:`CPack WIX 生成器`"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:6
msgid "CSharpUtilities"
msgstr "CSharp实用程序"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:10
msgid "Functions to make configuration of CSharp/.NET targets easier."
msgstr "使 CSharp/.NET 目标的配置更容易的功能。"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:12
msgid ""
"A collection of CMake utility functions useful for dealing with CSharp "
"targets for Visual Studio generators from version 2010 and later."
msgstr "一组 CMake 实用程序函数，可用于处理 2010 版及更高版本的 Visual Studio 生成器的 CSharp 目标。"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:17
msgid "**Main functions**"
msgstr "**主要功能**"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:19
msgid ":command:`csharp_set_windows_forms_properties`"
msgstr ":command:`csharp_set_windows_forms_properties`"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:20
msgid ":command:`csharp_set_designer_cs_properties`"
msgstr ":command:`csharp_set_designer_cs_properties`"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:21
msgid ":command:`csharp_set_xaml_cs_properties`"
msgstr ":command:`csharp_set_xaml_cs_properties`"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:23
msgid "**Helper functions**"
msgstr "**辅助函数**"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:25
msgid ":command:`csharp_get_filename_keys`"
msgstr ":command:`csharp_get_filename_keys`"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:26
msgid ":command:`csharp_get_filename_key_base`"
msgstr ":command:`csharp_get_filename_key_base`"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:27
msgid ":command:`csharp_get_dependentupon_name`"
msgstr ":command:`csharp_get_dependentupon_name`"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:30
msgid "Main functions provided by the module"
msgstr "模块提供的主要功能"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:34
msgid ""
"Sets source file properties for use of Windows Forms. Use this, if your "
"CSharp target uses Windows Forms::"
msgstr "设置源文件属性以使用 Windows 窗体。如果您的 CSharp 目标使用 Windows Forms::"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:74
#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:111
#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:137
msgid "``<fileN>``"
msgstr "``<fileN>``"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:40
msgid ""
"List of all source files which are relevant for setting the "
":prop_sf:`VS_CSHARP_<tagname>` properties (including ``.cs``, ``.resx`` "
"and ``.Designer.cs`` extensions)."
msgstr ""
"与设置 :prop_sf:`VS_CSHARP_<tagname>` 属性相关的所有源文件列表（包括 ``.cs``、``.resx`` 和 "
"``.Designer.cs`` 扩展名）。"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:44
msgid ""
"In the list of all given files for all files ending with ``.Designer.cs`` "
"and ``.resx`` is searched.  For every *designer* or *resource* file a file"
" with the same base name but only ``.cs`` as extension is searched.  If "
"this is found, the :prop_sf:`VS_CSHARP_<tagname>` properties are set as "
"follows:"
msgstr ""
"在所有给定文件的列表中搜索以“.Designer.cs”和“.resx”结尾的所有文件。对于每个 *designer* 或 *resource* "
"文件，搜索具有相同基本名称但仅扩展名为“.cs”的文件。如果找到，则 :prop_sf:`VS_CSHARP_<tagname>` 属性设置如下："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:50
msgid "for the **.cs** file:"
msgstr "对于 **.cs** 文件："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:50
msgid "VS_CSHARP_SubType \"Form\""
msgstr "VS_CSHARP_SubType“表单”"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:55
msgid "for the **.Designer.cs** file (if it exists):"
msgstr "对于 **.Designer.cs** 文件（如果存在）："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:88
msgid "VS_CSHARP_DependentUpon <cs-filename>"
msgstr "VS_CSHARP_DependentUpon <cs 文件名>"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:54
msgid "VS_CSHARP_DesignTime \"\" (delete tag if previously defined)"
msgstr "VS_CSHARP_DesignTime \"\"（如果之前定义过则删除标签）"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:55
msgid "VS_CSHARP_AutoGen \"\"(delete tag if previously defined)"
msgstr "VS_CSHARP_AutoGen \"\"（如果之前定义过则删除标签）"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:59
msgid "for the **.resx** file (if it exists):"
msgstr "对于 **.resx** 文件（如果存在）："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:58
msgid "VS_RESOURCE_GENERATOR \"\" (delete tag if previously defined)"
msgstr "VS_RESOURCE_GENERATOR \"\"（如果之前定义过则删除标签）"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:60
msgid "VS_CSHARP_SubType \"Designer\""
msgstr "VS_CSHARP_SubType“设计师”"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:64
msgid ""
"Sets source file properties of ``.Designer.cs`` files depending on sibling"
" filenames. Use this, if your CSharp target does **not** use Windows Forms"
" (for Windows Forms use :command:`csharp_set_designer_cs_properties` "
"instead)::"
msgstr ""
"根据兄弟文件名设置 ``.Designer.cs`` 文件的源文件属性。如果您的 CSharp 目标不**不**使用 Windows 窗体（对于 "
"Windows 窗体，请改用 :command:`csharp_set_designer_cs_properties`），请使用它："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:72
msgid ""
"List of all source files which are relevant for setting the "
":prop_sf:`VS_CSHARP_<tagname>` properties (including ``.cs``, ``.resx``, "
"``.settings`` and ``.Designer.cs`` extensions)."
msgstr ""
"与设置 :prop_sf:`VS_CSHARP_<tagname>` 属性相关的所有源文件列表（包括 "
"``.cs``、``.resx``、``.settings`` 和 ``.Designer.cs `` 扩展）。"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:76
msgid ""
"In the list of all given files for all files ending with ``.Designer.cs`` "
"is searched. For every *designer* file all files with the same base name "
"but different extensions are searched. If a match is found, the source "
"file properties of the *designer* file are set depending on the extension "
"of the matched file:"
msgstr ""
"在所有给定文件的列表中搜索以“.Designer.cs”结尾的所有文件。对于每个 *designer* "
"文件，搜索具有相同基本名称但不同扩展名的所有文件。如果找到匹配项，则根据匹配文件的扩展名设置 *designer* 文件的源文件属性："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:85
msgid "if match is **.resx** file:"
msgstr "如果匹配是 **.resx** 文件："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:83
#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:91
msgid "VS_CSHARP_AutoGen \"True\""
msgstr "VS_CSHARP_AutoGen“真”"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:84
msgid "VS_CSHARP_DesignTime \"True\""
msgstr "VS_CSHARP_DesignTime“真”"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:85
msgid "VS_CSHARP_DependentUpon <resx-filename>"
msgstr "VS_CSHARP_DependentUpon <resx 文件名>"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:88
msgid "if match is **.cs** file:"
msgstr "如果匹配是 **.cs** 文件："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:92
msgid "if match is **.settings** file:"
msgstr "如果匹配是 **.settings** 文件："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:92
msgid "VS_CSHARP_DesignTimeSharedInput \"True\""
msgstr "VS_CSHARP_DesignTimeSharedInput \"真\""

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:93
msgid "VS_CSHARP_DependentUpon <settings-filename>"
msgstr "VS_CSHARP_DependentUpon <设置文件名>"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:97
msgid ""
"Because the source file properties of the ``.Designer.cs`` file are set "
"according to the found matches and every match sets the "
"**VS_CSHARP_DependentUpon** property, there should only be one match for "
"each ``Designer.cs`` file."
msgstr ""
"因为 ``.Designer.cs`` 文件的源文件属性是根据找到的匹配项设置的，并且每个匹配项都设置 "
"**VS_CSHARP_DependentUpon** 属性，所以每个 ``Designer.cs`` 应该只有一个匹配项文件。"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:103
msgid ""
"Sets source file properties for use of Windows Presentation Foundation "
"(WPF) and XAML. Use this, if your CSharp target uses WPF/XAML::"
msgstr ""
"设置源文件属性以使用 Windows Presentation Foundation (WPF) 和 XAML。如果您的 CSharp 目标使用 "
"WPF/XAML::，请使用它："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:109
msgid ""
"List of all source files which are relevant for setting the "
":prop_sf:`VS_CSHARP_<tagname>` properties (including ``.cs``, ``.xaml``, "
"and ``.xaml.cs`` extensions)."
msgstr ""
"与设置 :prop_sf:`VS_CSHARP_<tagname>` 属性相关的所有源文件列表（包括 ``.cs``、``.xaml`` 和 "
"``.xaml.cs`` 扩展名）。"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:113
msgid ""
"In the list of all given files for all files ending with ``.xaml.cs`` is "
"searched. For every *xaml-cs* file, a file with the same base name but "
"extension ``.xaml`` is searched. If a match is found, the source file "
"properties of the ``.xaml.cs`` file are set:"
msgstr ""
"在所有给定文件的列表中搜索以“.xaml.cs”结尾的所有文件。对于每个 *xaml-cs* "
"文件，搜索具有相同基本名称但扩展名为“.xaml”的文件。如果找到匹配项，则设置 .xaml.cs 文件的源文件属性："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:119
msgid "VS_CSHARP_DependentUpon <xaml-filename>"
msgstr "VS_CSHARP_DependentUpon <xaml 文件名>"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:122
msgid "Helper functions which are used by the above ones"
msgstr "上述函数使用的辅助函数"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:126
msgid ""
"Helper function which computes a list of key values to identify source "
"files independently of relative/absolute paths given in cmake and "
"eliminates case sensitivity::"
msgstr "计算键值列表的辅助函数，以独立于 cmake 中给出的相对/绝对路径来识别源文件，并消除区分大小写 ::"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:133
msgid "``OUT``"
msgstr "``出去``"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:133
msgid "Name of the variable in which the list of keys is stored"
msgstr "存储键列表的变量的名称"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:136
msgid ""
"filename(s) as given to to CSharp target using :command:`add_library` or "
":command:`add_executable`"
msgstr ""
"使用 :command:`add_library` 或 :command:`add_executable` 提供给 CSharp 目标的文件名"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:139
msgid ""
"In some way the function applies a canonicalization to the source names. "
"This is necessary to find file matches if the files have been added to the"
" target with different directory prefixes:"
msgstr "该函数以某种方式对源名称应用规范化。如果文件已添加到具有不同目录前缀的目标，则需要查找文件匹配项："

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:159
msgid ""
"Returns the full filepath and name **without** extension of a key. KEY is "
"expected to be a key from csharp_get_filename_keys. In BASE the value of "
"KEY without the file extension is returned::"
msgstr ""
"返回完整的文件路径和名称**不带**密钥扩展名。 KEY 应该是来自 csharp_get_filename_keys 的密钥。在 BASE "
"中返回不带文件扩展名的 KEY 的值 ::"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:166
msgid "``BASE``"
msgstr "``基础``"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:166
msgid "Name of the variable with the computed \"base\" of ``KEY``."
msgstr "具有“KEY”的计算“基数”的变量名称。"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:169
msgid "``KEY``"
msgstr "``关键``"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:169
msgid ""
"The key of which the base will be computed. Expected to be a upper case "
"full filename."
msgstr "将计算其基数的键。应为大写的完整文件名。"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:174
msgid ""
"Computes a string which can be used as value for the source file property "
":prop_sf:`VS_CSHARP_<tagname>` with *target* being ``DependentUpon``::"
msgstr "计算一个字符串，该字符串可用作源文件属性的值"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:180
msgid "Name of the variable with the result value"
msgstr "具有结果值的变量名称"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:183
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:378
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:411
msgid "``FILE``"
msgstr "``文件``"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:183
msgid "Filename to convert to ``<DependentUpon>`` value"
msgstr "要转换为 ``<DependentUpon>`` 值的文件名"

#: ../../cmake-prefix/src/cmake/Modules/CSharpUtilities.cmake:185
msgid ""
"Actually this is only the filename without any path given at the moment."
msgstr "实际上这只是文件名，目前没有给出任何路径。"

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:6
msgid "CTest"
msgstr "C测试"

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:8
msgid "Configure a project for testing with CTest/CDash"
msgstr "配置项目以使用 CTest/CDash 进行测试"

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:10
msgid ""
"Include this module in the top CMakeLists.txt file of a project to enable "
"testing with CTest and dashboard submissions to CDash::"
msgstr "将此模块包含在项目的顶部 CMakeLists.txt 文件中，以启用使用 CTest 进行测试，并将仪表板提交到 CDash::"

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:17
msgid ""
"The module automatically creates a ``BUILD_TESTING`` option that selects "
"whether to enable testing support (``ON`` by default).  After including "
"the module, use code like::"
msgstr "该模块自动创建一个“BUILD_TESTING”选项，用于选择是否启用测试支持（默认为“ON”）。包含模块后，使用如下代码："

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:25
msgid "to creating tests when testing is enabled."
msgstr "在启用测试时创建测试。"

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:27
msgid ""
"To enable submissions to a CDash server, create a ``CTestConfig.cmake`` "
"file at the top of the project with content such as::"
msgstr "要启用向 CDash 服务器的提交，请在项目顶部创建一个“CTestConfig.cmake”文件，其内容如下："

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:33
msgid ""
"(the CDash server can provide the file to a project administrator who "
"configures ``MyProject``).  Settings in the config file are shared by both"
" this ``CTest`` module and the :manual:`ctest(1)` command-line "
":ref:`Dashboard Client` mode (:option:`ctest -S`)."
msgstr ""
"（CDash 服务器可以将文件提供给配置“MyProject”的项目管理员）。配置文件中的设置由此 ``CTest`` "
"模块和 :manual:`ctest(1)` 命令行 :ref:`Dashboard Client` 模式 (:option:`ctest -S`) "
"共享。"

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:38
msgid ""
"While building a project for submission to CDash, CTest scans the build "
"output for errors and warnings and reports them with surrounding context "
"from the build log.  This generic approach works for all build tools, but "
"does not give details about the command invocation that produced a given "
"problem.  One may get more detailed reports by setting the "
":variable:`CTEST_USE_LAUNCHERS` variable::"
msgstr ""
"在构建提交给 CDash 的项目时，CTest "
"会扫描构建输出以查找错误和警告，并通过构建日志中的周围上下文报告它们。这种通用方法适用于所有构建工具，但不提供有关产生给定问题的命令调用的详细信息。通过设置"
" CTEST_USE_LAUNCHERS 变量可以获得更详细的报告："

#: ../../cmake-prefix/src/cmake/Modules/CTest.cmake:47
msgid "in the ``CTestConfig.cmake`` file."
msgstr "在“CTestConfig.cmake”文件中。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:6
msgid "CTestCoverageCollectGCOV"
msgstr "CTestCoverageCollectGCOV"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:10
msgid "This module provides the ``ctest_coverage_collect_gcov`` function."
msgstr "该模块提供了``ctest_coverage_collect_gcov`` 功能。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:12
msgid ""
"This function runs gcov on all .gcda files found in the binary tree and "
"packages the resulting .gcov files into a tar file. This tarball also "
"contains the following:"
msgstr ""
"此函数对二叉树中找到的所有 .gcda 文件运行 gcov，并将生成的 .gcov 文件打包到一个 tar 文件中。此 tarball "
"还包含以下内容："

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:16
msgid ""
"*data.json* defines the source and build directories for use by CDash."
msgstr "*data.json* 定义供 CDash 使用的源目录和构建目录。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:17
msgid ""
"*Labels.json* indicates any :prop_sf:`LABELS` that have been set on the "
"source files."
msgstr "*Labels.json* 表示已在源文件上设置的任何 :prop_sf:`LABELS`。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:19
msgid ""
"The *uncovered* directory holds any uncovered files found by "
":variable:`CTEST_EXTRA_COVERAGE_GLOB`."
msgstr "*uncovered* 目录包含 CTEST_EXTRA_COVERAGE_GLOB 找到的所有未覆盖文件。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:22
msgid ""
"After generating this tar file, it can be sent to CDash for display with "
"the :command:`ctest_submit(CDASH_UPLOAD)` command."
msgstr "生成此 tar 文件后，可以使用 ctest_submit(CDASH_UPLOAD) 命令将其发送到 CDash 进行显示。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:35
msgid "Run gcov and package a tar file for CDash.  The options are:"
msgstr "运行 gcov 并为 CDash 打包一个 tar 文件。选项是："

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:40
msgid "``TARBALL <tarfile>``"
msgstr "``TARBALL <tarfile>``"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:38
msgid ""
"Specify the location of the ``.tar`` file to be created for later upload "
"to CDash.  Relative paths will be interpreted with respect to the top-"
"level build directory."
msgstr "指定要创建的 ``.tar`` 文件的位置，以便稍后上传到 CDash。相对路径将根据顶级构建目录进行解释。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:54
msgid "``TARBALL_COMPRESSION <option>``"
msgstr "``TARBALL_COMPRESSION <选项>``"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:45
msgid ""
"Specify a compression algorithm for the ``TARBALL`` data file.  Using this"
" option reduces the size of the data file before it is submitted to CDash."
"  ``<option>`` must be one of ``GZIP``, ``BZIP2``, ``XZ``, ``ZSTD``, "
"``FROM_EXT``, or an expression that CMake evaluates as ``FALSE``. The "
"default value is ``BZIP2``."
msgstr ""
"为“TARBALL”数据文件指定压缩算法。在将数据文件提交给 CDash 之前，使用该选项可以减小数据文件的大小。 ``<option>`` 必须是"
" ``GZIP``、``BZIP2``、``XZ``、``ZSTD``、``FROM_EXT`` 或 CMake 计算为 `` "
"的表达式之一假的``。默认值为“BZIP2”。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:51
msgid ""
"If ``FROM_EXT`` is specified, the resulting file will be compressed based "
"on the file extension of the ``<tarfile>`` (i.e. ``.tar.gz`` will use "
"``GZIP`` compression). File extensions that will produce compressed output"
" include ``.tar.gz``, ``.tgz``, ``.tar.bzip2``, ``.tbz``, ``.tar.xz``, and"
" ``.txz``."
msgstr ""
"如果指定了“FROM_EXT”，生成的文件将根据“<tarfile>”的文件扩展名进行压缩（即“.tar.gz”将使用“GZIP”压缩）。将产生压缩输出的文件扩展名包括``.tar.gz``、``.tgz``、``.tar.bzip2``、``.tbz``、``.tar.xz``"
" 和``.txz``。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:58
msgid "``SOURCE <source_dir>``"
msgstr "``来源 <source_dir>``"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:57
msgid ""
"Specify the top-level source directory for the build. Default is the value"
" of :variable:`CTEST_SOURCE_DIRECTORY`."
msgstr "指定构建的顶级源目录。默认值为 CTEST_SOURCE_DIRECTORY 的值。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:62
msgid "``BUILD <build_dir>``"
msgstr "``构建 <build_dir>``"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:61
msgid ""
"Specify the top-level build directory for the build. Default is the value "
"of :variable:`CTEST_BINARY_DIRECTORY`."
msgstr "指定构建的顶级构建目录。默认值为 CTEST_BINARY_DIRECTORY 的值。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:66
msgid "``GCOV_COMMAND <gcov_command>``"
msgstr "``GCOV_COMMAND <gcov_command>``"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:65
msgid ""
"Specify the full path to the ``gcov`` command on the machine. Default is "
"the value of :variable:`CTEST_COVERAGE_COMMAND`."
msgstr "指定机器上 ``gcov`` 命令的完整路径。默认值为 CTEST_COVERAGE_COMMAND 的值。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:71
msgid "``GCOV_OPTIONS <options>...``"
msgstr "``GCOV_OPTIONS <选项>...``"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:69
msgid ""
"Specify options to be passed to gcov.  The ``gcov`` command is run as "
"``gcov <options>... -o <gcov-dir> <file>.gcda``. If not specified, the "
"default option is just ``-b -x``."
msgstr ""
"指定要传递给 gcov 的选项。 ``gcov`` 命令作为 ``gcov <options>... -o <gcov-dir> "
"<file>.gcda`` 运行。如果未指定，默认选项只是 ``-b -x``。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:77
msgid "``GLOB``"
msgstr "``全球``"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:76
msgid ""
"Recursively search for .gcda files in build_dir rather than determining "
"search locations by reading TargetDirectories.txt."
msgstr "在 build_dir 中递归搜索 .gcda 文件，而不是通过读取 TargetDirectories.txt 来确定搜索位置。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:82
msgid "``DELETE``"
msgstr "``删除``"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:82
msgid "Delete coverage files after they've been packaged into the .tar."
msgstr "将覆盖文件打包到 .tar 后删除它们。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:85
msgid ""
"Suppress non-error messages that otherwise would have been printed out by "
"this function."
msgstr "抑制本函数打印出的非错误消息。"

#: ../../cmake-prefix/src/cmake/Modules/CTestCoverageCollectGCOV.cmake:88
msgid ""
"Added support for the :variable:`CTEST_CUSTOM_COVERAGE_EXCLUDE` variable."
msgstr "添加了对 CTEST_CUSTOM_COVERAGE_EXCLUDE 变量的支持。"

#: ../../cmake-prefix/src/cmake/Modules/CTestScriptMode.cmake:6
msgid "CTestScriptMode"
msgstr "CTestScript模式"

#: ../../cmake-prefix/src/cmake/Modules/CTestScriptMode.cmake:10
msgid "This file is read by ctest in script mode (-S)"
msgstr "该文件由ctest以脚本模式（-S）读取"

#: ../../cmake-prefix/src/cmake/Modules/CTestUseLaunchers.cmake:6
msgid "CTestUseLaunchers"
msgstr "CTestUseLaunchers"

#: ../../cmake-prefix/src/cmake/Modules/CTestUseLaunchers.cmake:8
msgid ""
"Set the RULE_LAUNCH_* global properties when CTEST_USE_LAUNCHERS is on."
msgstr "当 CTEST_USE_LAUNCHERS 打开时设置 RULE_LAUNCH_* 全局属性。"

#: ../../cmake-prefix/src/cmake/Modules/CTestUseLaunchers.cmake:10
msgid ""
"CTestUseLaunchers is automatically included when you include(CTest). "
"However, it is split out into its own module file so projects can use the "
"CTEST_USE_LAUNCHERS functionality independently."
msgstr ""
"当您包含 (CTest) 时，会自动包含 CTestUseLaunchers。但是，它被拆分到自己的模块文件中，因此项目可以独立使用 "
"CTEST_USE_LAUNCHERS 功能。"

#: ../../cmake-prefix/src/cmake/Modules/CTestUseLaunchers.cmake:14
msgid ""
"To use launchers, set CTEST_USE_LAUNCHERS to ON in a :option:`ctest -S` "
"dashboard script, and then also set it in the cache of the configured "
"project.  Both cmake and ctest need to know the value of it for the "
"launchers to work properly.  CMake needs to know in order to generate "
"proper build rules, and ctest, in order to produce the proper error and "
"warning analysis."
msgstr ""
"要使用启动器，请在 ctest -S 仪表板脚本中将 CTEST_USE_LAUNCHERS 设置为 ON，然后将其设置在已配置项目的缓存中。 "
"cmake 和 ctest 都需要知道它的值才能使启动器正常工作。 CMake 需要知道才能生成正确的构建规则，需要知道 ctest "
"才能生成正确的错误和警告分析。"

#: ../../cmake-prefix/src/cmake/Modules/CTestUseLaunchers.cmake:21
msgid ""
"For convenience, you may set the ENV variable CTEST_USE_LAUNCHERS_DEFAULT "
"in your ctest -S script, too.  Then, as long as your CMakeLists uses "
"include(CTest) or include(CTestUseLaunchers), it will use the value of the"
" ENV variable to initialize a CTEST_USE_LAUNCHERS cache variable.  This "
"cache variable initialization only occurs if CTEST_USE_LAUNCHERS is not "
"already defined."
msgstr ""
"为方便起见，您也可以在 ctest -S 脚本中设置 ENV 变量 CTEST_USE_LAUNCHERS_DEFAULT。然后，只要您的 "
"CMakeLists 使用 include(CTest) 或 include(CTestUseLaunchers)，它就会使用 ENV "
"变量的值来初始化一个 CTEST_USE_LAUNCHERS 缓存变量。此缓存变量初始化仅在尚未定义 CTEST_USE_LAUNCHERS "
"时发生。"

#: ../../cmake-prefix/src/cmake/Modules/CTestUseLaunchers.cmake:29
msgid ""
"If CTEST_USE_LAUNCHERS is on in a :option:`ctest -S` script the "
"ctest_configure command will add -DCTEST_USE_LAUNCHERS:BOOL=TRUE to the "
"cmake command used to configure the project."
msgstr ""
"如果 CTEST_USE_LAUNCHERS 在 ctest -S 脚本中打开，ctest_configure 命令会将 "
"-DCTEST_USE_LAUNCHERS:BOOL=TRUE 添加到用于配置项目的 cmake 命令中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCCompilerFlag.cmake:6
msgid "CheckCCompilerFlag"
msgstr "检查 CCompilerFlag"

#: ../../cmake-prefix/src/cmake/Modules/CheckCCompilerFlag.cmake:8
msgid "Check whether the C compiler supports a given flag."
msgstr "检查 C 编译器是否支持给定的标志。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCCompilerFlag.cmake:16
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXCompilerFlag.cmake:16
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranCompilerFlag.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCCompilerFlag.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXCompilerFlag.cmake:18
msgid ""
"Check that the ``<flag>`` is accepted by the compiler without a "
"diagnostic.  Stores the result in an internal cache entry named ``<var>``."
msgstr "检查编译器是否在没有诊断的情况下接受了``<flag>``。将结果存储在名为“<var>”的内部缓存条目中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCCompilerFlag.cmake:20
msgid ""
"This command temporarily sets the ``CMAKE_REQUIRED_DEFINITIONS`` variable "
"and calls the ``check_c_source_compiles`` macro from the "
":module:`CheckCSourceCompiles` module.  See documentation of that module "
"for a listing of variables that can otherwise modify the build."
msgstr ""
"此命令临时设置“CMAKE_REQUIRED_DEFINITIONS”变量并从 CheckCSourceCompiles "
"模块调用“check_c_source_compiles”宏。请参阅该模块的文档以获取可以以其他方式修改构建的变量列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCCompilerFlag.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXCompilerFlag.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/CheckCompilerFlag.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranCompilerFlag.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCCompilerFlag.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXCompilerFlag.cmake:27
msgid ""
"A positive result from this check indicates only that the compiler did not"
" issue a diagnostic message when given the flag.  Whether the flag has any"
" effect or even a specific one is beyond the scope of this module."
msgstr "此检查的肯定结果仅表示编译器在给定标志时未发出诊断消息。该标志是否有任何影响，甚至是否有特定影响超出了本模块的范围。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCCompilerFlag.cmake:30
msgid ""
"Since the :command:`try_compile` command forwards flags from variables "
"like :variable:`CMAKE_C_FLAGS <CMAKE_<LANG>_FLAGS>`, unknown flags in such"
" variables may cause a false negative for this check."
msgstr ""
"由于 :command:`try_compile` 命令转发来自变量的标志，如 :variable:`CMAKE_C_FLAGS "
"<CMAKE_<LANG>_FLAGS>`，此类变量中的未知标志可能会导致此检查出现假阴性。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:6
msgid "CheckCSourceCompiles"
msgstr "检查CSourceCompiles"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:8
msgid "Check if given C source compiles and links into an executable."
msgstr "检查给定的 C 源代码是否编译并链接到可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:17
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a C source"
" file and linked as an executable (so it must contain at least a "
"``main()`` function). The result will be stored in the internal cache "
"variable specified by ``<resultVar>``, with a boolean true value for "
"success and boolean false for failure. If ``FAIL_REGEX`` is provided, then"
" failure is determined by checking if anything in the output matches any "
"of the specified regular expressions."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 C 源文件并链接为可执行文件（因此它必须至少包含一个 ``main()`` "
"函数）。结果将存储在由“<resultVar>”指定的内部缓存变量中，布尔值为真表示成功，布尔值为假表示失败。如果提供了“FAIL_REGEX”，则通过检查输出中的任何内容是否与任何指定的正则表达式匹配来确定失败。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:25
msgid ""
"The underlying check is performed by the :command:`try_compile` command. "
"The compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_c_source_compiles()``:"
msgstr ""
"底层检查由 :command:`try_compile` 命令执行。在调用 ``check_c_source_compiles()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:54
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:70
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:29
msgid "``CMAKE_REQUIRED_FLAGS``"
msgstr "``CMAKE_REQUIRED_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:29
msgid ""
"Additional flags to pass to the compiler. Note that the contents of "
":variable:`CMAKE_C_FLAGS <CMAKE_<LANG>_FLAGS>` and its associated "
"configuration-specific variable are automatically added to the compiler "
"command before the contents of ``CMAKE_REQUIRED_FLAGS``."
msgstr ""
"要传递给编译器的附加标志。请注意 :variable:`CMAKE_C_FLAGS <CMAKE_<LANG>_FLAGS>` "
"的内容及其关联的特定于配置的变量会自动添加到编译器命令中的 ``CMAKE_REQUIRED_FLAGS`` 内容之前。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:63
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:40
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:40
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:40
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:63
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:63
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:72
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:31
msgid "``CMAKE_REQUIRED_DEFINITIONS``"
msgstr "``CMAKE_REQUIRED_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:57
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:61
msgid ""
"A :ref:`;-list <CMake Language Lists>` of compiler definitions of the form"
" ``-DFOO`` or ``-DFOO=bar``. A definition for the name specified by "
"``<resultVar>`` will also be added automatically."
msgstr ""
"A :ref:`;-list <CMake Language Lists>` 形式为``-DFOO`` 或``-DFOO=bar`` "
"的编译器定义。由 ``<resultVar>`` 指定的名称的定义也将自动添加。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:69
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:65
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:69
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:69
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:74
msgid "``CMAKE_REQUIRED_INCLUDES``"
msgstr "``CMAKE_REQUIRED_INCLUDES``"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:66
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:66
msgid ""
"A :ref:`;-list <CMake Language Lists>` of header search paths to pass to "
"the compiler. These will be the only header search paths used by "
"``try_compile()``, i.e. the contents of the "
":prop_dir:`INCLUDE_DIRECTORIES` directory property will be ignored."
msgstr ""
"传递给编译器的标头搜索路径的 :ref:`;-list <CMake Language Lists>`。这些将是 ``try_compile()``"
" 使用的唯一标题搜索路径，即 :prop_dir:`INCLUDE_DIRECTORIES` 目录属性的内容将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:75
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:69
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:73
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:73
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:77
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:34
msgid "``CMAKE_REQUIRED_LINK_OPTIONS``"
msgstr "``CMAKE_REQUIRED_LINK_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:74
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:72
msgid ""
"A :ref:`;-list <CMake Language Lists>` of options to add to the link "
"command (see :command:`try_compile` for further details)."
msgstr ""
"A :ref:`;-list <CMake Language Lists>` 要添加到链接命令的选项（有关更多详细信息，请参阅 "
":command:`try_compile`）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:83
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:81
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:75
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:47
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:79
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:79
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:79
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:36
msgid "``CMAKE_REQUIRED_LIBRARIES``"
msgstr "``CMAKE_REQUIRED_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:78
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:76
msgid ""
"A :ref:`;-list <CMake Language Lists>` of libraries to add to the link "
"command. These can be the name of system libraries or they can be "
":ref:`Imported Targets <Imported Targets>` (see :command:`try_compile` for"
" further details)."
msgstr ""
"A :ref:`;-list <CMake Language Lists>` 要添加到链接命令的库。这些可以是系统库的名称，也可以是 "
":ref:`Imported Targets <Imported Targets>`（有关详细信息，请参阅 "
":command:`try_compile`）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:62
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:62
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:85
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:79
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:94
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:60
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:60
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:122
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:83
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:83
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:82
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:83
msgid "``CMAKE_REQUIRED_QUIET``"
msgstr "``CMAKE_REQUIRED_QUIET``"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:60
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:60
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:84
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:78
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:82
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:82
msgid ""
"If this variable evaluates to a boolean true value, all status messages "
"associated with the check will be suppressed."
msgstr "如果此变量的计算结果为布尔真值，则将抑制与检查相关的所有状态消息。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceCompiles.cmake:64
#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:63
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:64
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:63
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:87
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:81
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:62
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:62
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:85
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:85
msgid ""
"The check is only performed once, with the result cached in the variable "
"named by ``<resultVar>``. Every subsequent CMake run will re-use this "
"cached value rather than performing the check again, even if the "
"``<code>`` changes. In order to force the check to be re-evaluated, the "
"variable named by ``<resultVar>`` must be manually removed from the cache."
msgstr ""
"检查只执行一次，结果缓存在名为 <resultVar> 的变量中。每次后续 CMake 运行都将重新使用此缓存值，而不是再次执行检查，即使 "
"<code> 更改也是如此。为了强制重新评估检查，必须从缓存中手动删除由 ``<resultVar>`` 命名的变量。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:6
msgid "CheckCSourceRuns"
msgstr "检查CSourceRuns"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:8
msgid ""
"Check if given C source compiles and links into an executable and can "
"subsequently be run."
msgstr "检查给定的 C 源代码是否编译并链接到可执行文件，并且随后可以运行。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:17
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a C source"
" file, linked as an executable and then run. The ``<code>`` must contain "
"at least a ``main()`` function. If the ``<code>`` could be built and run "
"successfully, the internal cache variable specified by ``<resultVar>`` "
"will be set to 1, otherwise it will be set to an value that evaluates to "
"boolean false (e.g. an empty string or an error message)."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 C 源文件，链接为可执行文件，然后运行。 ``<code>`` 必须至少包含一个 "
"``main()`` 函数。如果 ``<code>`` 可以成功构建和运行，则由 ``<resultVar>`` 指定的内部缓存变量将被设置为 "
"1，否则它将被设置为一个计算结果为布尔值 false 的值（例如空字符串或错误消息）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:24
msgid ""
"The underlying check is performed by the :command:`try_run` command. The "
"compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_c_source_runs()``:"
msgstr ""
"底层检查由 :command:`try_run` 命令执行。在调用 ``check_c_source_runs()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:40
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:40
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:62
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:66
msgid ""
"A :ref:`;-list <CMake Language Lists>` of header search paths to pass to "
"the compiler. These will be the only header search paths used by "
"``try_run()``, i.e. the contents of the :prop_dir:`INCLUDE_DIRECTORIES` "
"directory property will be ignored."
msgstr ""
"传递给编译器的标头搜索路径的 :ref:`;-list <CMake Language Lists>`。这些将是 ``try_run()`` "
"使用的唯一标题搜索路径，即:prop_dir:`INCLUDE_DIRECTORIES` 目录属性的内容将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:68
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:72
msgid ""
"A :ref:`;-list <CMake Language Lists>` of options to add to the link "
"command (see :command:`try_run` for further details)."
msgstr ""
"A :ref:`;-list <CMake Language Lists>` 要添加到链接命令的选项（有关更多详细信息，请参阅 "
":command:`try_run`）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCSourceRuns.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:72
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:76
msgid ""
"A :ref:`;-list <CMake Language Lists>` of libraries to add to the link "
"command. These can be the name of system libraries or they can be "
":ref:`Imported Targets <Imported Targets>` (see :command:`try_run` for "
"further details)."
msgstr ""
"A :ref:`;-list <CMake Language Lists>` 要添加到链接命令的库。这些可以是系统库的名称，也可以是 "
":ref:`Imported Targets <Imported Targets>`（有关详细信息，请参阅 :command:`try_run`）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXCompilerFlag.cmake:6
msgid "CheckCXXCompilerFlag"
msgstr "检查CXXCompilerFlag"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXCompilerFlag.cmake:8
msgid "Check whether the CXX compiler supports a given flag."
msgstr "检查 CXX 编译器是否支持给定的标志。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXCompilerFlag.cmake:20
msgid ""
"This command temporarily sets the ``CMAKE_REQUIRED_DEFINITIONS`` variable "
"and calls the ``check_cxx_source_compiles`` macro from the "
":module:`CheckCXXSourceCompiles` module.  See documentation of that module"
" for a listing of variables that can otherwise modify the build."
msgstr ""
"此命令临时设置“CMAKE_REQUIRED_DEFINITIONS”变量并从 CheckCXXSourceCompiles "
"模块调用“check_cxx_source_compiles”宏。请参阅该模块的文档以获取可以以其他方式修改构建的变量列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXCompilerFlag.cmake:30
msgid ""
"Since the :command:`try_compile` command forwards flags from variables "
"like :variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>`, unknown flags in "
"such variables may cause a false negative for this check."
msgstr ""
"由于 :command:`try_compile` 命令转发来自变量的标志，例如 :variable:`CMAKE_CXX_FLAGS "
"<CMAKE_<LANG>_FLAGS>`，此类变量中的未知标志可能会导致此检查出现假阴性。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:6
msgid "CheckCXXSourceCompiles"
msgstr "CheckCXXSourceCompiles"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:8
msgid "Check if given C++ source compiles and links into an executable."
msgstr "检查给定的 C++ 源代码是否编译并链接到可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:17
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a C++ "
"source file and linked as an executable (so it must contain at least a "
"``main()`` function). The result will be stored in the internal cache "
"variable specified by ``<resultVar>``, with a boolean true value for "
"success and boolean false for failure. If ``FAIL_REGEX`` is provided, then"
" failure is determined by checking if anything in the output matches any "
"of the specified regular expressions."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 C++ 源文件并链接为可执行文件（因此它必须至少包含一个 ``main()`` "
"函数）。结果将存储在由“<resultVar>”指定的内部缓存变量中，布尔值为真表示成功，布尔值为假表示失败。如果提供了“FAIL_REGEX”，则通过检查输出中的任何内容是否与任何指定的正则表达式匹配来确定失败。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:25
msgid ""
"The underlying check is performed by the :command:`try_compile` command. "
"The compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_cxx_source_compiles()``:"
msgstr ""
"底层检查由 :command:`try_compile` 命令执行。在调用 ``check_cxx_source_compiles()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceCompiles.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:29
msgid ""
"Additional flags to pass to the compiler. Note that the contents of "
":variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>` and its associated "
"configuration-specific variable are automatically added to the compiler "
"command before the contents of ``CMAKE_REQUIRED_FLAGS``."
msgstr ""
"要传递给编译器的附加标志。请注意 :variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>` "
"的内容及其关联的特定于配置的变量会自动添加到编译器命令中，位于 ``CMAKE_REQUIRED_FLAGS`` 的内容之前。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:6
msgid "CheckCXXSourceRuns"
msgstr "CheckCXXSourceRuns"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:8
msgid ""
"Check if given C++ source compiles and links into an executable and can "
"subsequently be run."
msgstr "检查给定的 C++ 源代码是否编译并链接到可执行文件，然后可以运行。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:17
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a C++ "
"source file, linked as an executable and then run. The ``<code>`` must "
"contain at least a ``main()`` function. If the ``<code>`` could be built "
"and run successfully, the internal cache variable specified by "
"``<resultVar>`` will be set to 1, otherwise it will be set to an value "
"that evaluates to boolean false (e.g. an empty string or an error "
"message)."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 C++ 源文件，链接为可执行文件，然后运行。 ``<code>`` 必须至少包含一个 "
"``main()`` 函数。如果 ``<code>`` 可以成功构建和运行，则由 ``<resultVar>`` 指定的内部缓存变量将被设置为 "
"1，否则它将被设置为一个计算结果为布尔值 false 的值（例如空字符串或错误消息）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSourceRuns.cmake:24
msgid ""
"The underlying check is performed by the :command:`try_run` command. The "
"compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_cxx_source_runs()``:"
msgstr ""
"底层检查由 :command:`try_run` 命令执行。在调用 ``check_cxx_source_runs()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:6
msgid "CheckCXXSymbolExists"
msgstr "检查CXXSymbolExists"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:8
msgid ""
"Check if a symbol exists as a function, variable, or macro in ``C++``."
msgstr "检查一个符号在 C++ 中是否作为函数、变量或宏存在。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:16
msgid ""
"Check that the ``<symbol>`` is available after including given header "
"``<files>`` and store the result in a ``<variable>``.  Specify the list of"
" files in one argument as a semicolon-separated list. "
"``check_cxx_symbol_exists()`` can be used to check for symbols as seen by "
"the C++ compiler, as opposed to :command:`check_symbol_exists`, which "
"always uses the ``C`` compiler."
msgstr ""
"检查 ``<symbol>`` 在包含给定的标题 ``<files>`` 之后是否可用，并将结果存储在 ``<variable>`` "
"中。将一个参数中的文件列表指定为分号分隔的列表。 ``check_cxx_symbol_exists()`` 可用于检查 C++ "
"编译器看到的符号，而不是 :command:`check_symbol_exists`，后者始终使用 ``C`` 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:23
msgid ""
"If the header files define the symbol as a macro it is considered "
"available and assumed to work.  If the header files declare the symbol as "
"a function or variable then the symbol must also be available for linking."
"  If the symbol is a type, enum value, or C++ template it will not be "
"recognized: consider using the :module:`CheckTypeSize` or "
":module:`CheckSourceCompiles` module instead."
msgstr ""
"如果头文件将符号定义为宏，则它被认为是可用的并假定可以工作。如果头文件将符号声明为函数或变量，则该符号也必须可用于链接。如果符号是类型、枚举值或 "
"C++ 模板，它将无法识别：考虑改用 CheckTypeSize 或 CheckSourceCompiles 模块。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:32
msgid ""
"This command is unreliable when ``<symbol>`` is (potentially) an "
"overloaded function. Since there is no reliable way to predict whether a "
"given function in the system environment may be defined as an overloaded "
"function or may be an overloaded function on other systems or will become "
"so in the future, it is generally advised to use the "
":module:`CheckCXXSourceCompiles` module for checking any function symbol "
"(unless somehow you surely know the checked function is not overloaded on "
"other systems or will not be so in the future)."
msgstr ""
"当``<symbol>``（可能）是一个重载函数时，这个命令是不可靠的。由于没有可靠的方法来预测系统环境中的给定函数是否可能被定义为重载函数，或者可能是其他系统上的重载函数或将来会变成重载函数，因此通常建议使用"
" :module: `CheckCXXSourceCompiles` "
"模块用于检查任何函数符号（除非您确定知道被检查的函数没有在其他系统上过载或将来不会过载）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:20
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:67
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:26
msgid ""
"The following variables may be set before calling this macro to modify the"
" way the check is run:"
msgstr "在调用此宏以修改检查运行方式之前，可以设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:71
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:30
msgid "string of compile command line flags."
msgstr "编译命令行标志的字符串。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:47
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:37
msgid ""
"a :ref:`;-list <CMake Language Lists>` of macros to define (-DFOO=bar)."
msgstr "a :ref:`;-list <CMake Language Lists>` 要定义的宏 (-DFOO=bar)。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:39
msgid ""
"a :ref:`;-list <CMake Language Lists>` of header search paths to pass to "
"the compiler."
msgstr "a :ref:`;-list <CMake Language Lists>` 要传递给编译器的标头搜索路径。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:42
msgid ""
"a :ref:`;-list <CMake Language Lists>` of options to add to the link "
"command."
msgstr "a :ref:`;-list <CMake Language Lists>` 添加到链接命令的选项。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:45
msgid ""
"a :ref:`;-list <CMake Language Lists>` of libraries to add to the link "
"command. See policy :policy:`CMP0075`."
msgstr ""
"a :ref:`;-list <CMake Language Lists>` 要添加到链接命令的库。请参阅政策:policy:`CMP0075`。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCXXSymbolExists.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:82
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:39
msgid "execute quietly without messages."
msgstr "在没有消息的情况下安静地执行。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCompilerFlag.cmake:6
msgid "CheckCompilerFlag"
msgstr "检查编译器标志"

#: ../../cmake-prefix/src/cmake/Modules/CheckCompilerFlag.cmake:10
msgid "Check whether the compiler supports a given flag."
msgstr "检查编译器是否支持给定的标志。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCompilerFlag.cmake:18
msgid ""
"Check that the ``<flag>`` is accepted by the compiler without a "
"diagnostic. Stores the result in an internal cache entry named ``<var>``."
msgstr "检查编译器是否在没有诊断的情况下接受了``<flag>``。将结果存储在名为“<var>”的内部缓存条目中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCompilerFlag.cmake:21
msgid ""
"This command temporarily sets the ``CMAKE_REQUIRED_DEFINITIONS`` variable "
"and calls the ``check_source_compiles(<LANG>)`` function from the "
":module:`CheckSourceCompiles` module.  See documentation of that module "
"for a listing of variables that can otherwise modify the build."
msgstr ""
"此命令临时设置 ``CMAKE_REQUIRED_DEFINITIONS`` 变量并从 CheckSourceCompiles 模块调用 "
"``check_source_compiles(<LANG>)`` 函数。请参阅该模块的文档以获取可以以其他方式修改构建的变量列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckCompilerFlag.cmake:31
msgid ""
"Since the :command:`try_compile` command forwards flags from variables "
"like :variable:`CMAKE_<LANG>_FLAGS <CMAKE_<LANG>_FLAGS>`, unknown flags in"
" such variables may cause a false negative for this check."
msgstr ""
"由于 :command:`try_compile` 命令转发来自变量的标志，如 :variable:`CMAKE_<LANG>_FLAGS "
"<CMAKE_<LANG>_FLAGS>`，此类变量中的未知标志可能会导致此检查出现假阴性。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranCompilerFlag.cmake:6
msgid "CheckFortranCompilerFlag"
msgstr "检查 Fortran 编译器标志"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranCompilerFlag.cmake:10
msgid "Check whether the Fortran compiler supports a given flag."
msgstr "检查 Fortran 编译器是否支持给定的标志。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranCompilerFlag.cmake:22
msgid ""
"This command temporarily sets the ``CMAKE_REQUIRED_DEFINITIONS`` variable "
"and calls the ``check_fortran_source_compiles`` macro from the "
":module:`CheckFortranSourceCompiles` module.  See documentation of that "
"module for a listing of variables that can otherwise modify the build."
msgstr ""
"此命令临时设置“CMAKE_REQUIRED_DEFINITIONS”变量并从 CheckFortranSourceCompiles "
"模块调用“check_fortran_source_compiles”宏。请参阅该模块的文档以获取可以以其他方式修改构建的变量列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranCompilerFlag.cmake:32
msgid ""
"Since the :command:`try_compile` command forwards flags from variables "
"like :variable:`CMAKE_Fortran_FLAGS <CMAKE_<LANG>_FLAGS>`, unknown flags "
"in such variables may cause a false negative for this check."
msgstr ""
"由于 :command:`try_compile` 命令转发来自变量的标志，如 :variable:`CMAKE_Fortran_FLAGS "
"<CMAKE_<LANG>_FLAGS>`，此类变量中的未知标志可能会导致此检查出现假阴性。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:6
msgid "CheckFortranFunctionExists"
msgstr "检查 FortranFunctionExists"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:8
msgid "Check if a Fortran function exists."
msgstr "检查 Fortran 函数是否存在。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:16
msgid "where"
msgstr "在哪里"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:18
msgid "``<function>``"
msgstr "``<函数>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:19
msgid "the name of the Fortran function"
msgstr "Fortran 函数的名称"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:20
msgid "``<result>``"
msgstr "``<结果>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:21
msgid ""
"variable to store the result; will be created as an internal cache "
"variable."
msgstr "存储结果的变量；将被创建为内部缓存变量。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranFunctionExists.cmake:25
msgid ""
"This command does not detect functions in Fortran modules. In general it "
"is recommended to use :module:`CheckSourceCompiles` instead to determine "
"if a Fortran function or subroutine is available."
msgstr ""
"此命令不检测 Fortran 模块中的函数。一般来说，建议使用 CheckSourceCompiles 来确定 Fortran "
"函数或子例程是否可用。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:6
msgid "CheckFortranSourceCompiles"
msgstr "检查 FortranSourceCompiles"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:10
msgid "Check if given Fortran source compiles and links into an executable."
msgstr "检查给定的 Fortran 源代码是否编译并链接到可执行文件中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:21
msgid ""
"Checks that the source supplied in ``<code>`` can be compiled as a Fortran"
" source file and linked as an executable. The ``<code>`` must be a Fortran"
" ``program``."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 Fortran 源文件并链接为可执行文件。 ``<code>`` 必须是 Fortran "
"``program``。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:33
msgid ""
"This command can help avoid costly build processes when a compiler lacks "
"support for a necessary feature, or a particular vendor library is not "
"compatible with the Fortran compiler version being used. This generate-"
"time check may advise the user of such before the main build process. See "
"also the :command:`check_fortran_source_runs` command to run the compiled "
"code."
msgstr ""
"当编译器缺乏对必要功能的支持，或者特定供应商库与正在使用的 Fortran "
"编译器版本不兼容时，此命令可以帮助避免昂贵的构建过程。此生成时检查可能会在主构建过程之前向用户提供此类建议。另请参阅 "
":command:`check_fortran_source_runs` 命令以运行编译后的代码。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:39
msgid ""
"The result will be stored in the internal cache variable ``<resultVar>``, "
"with a boolean true value for success and boolean false for failure."
msgstr "结果将存储在内部缓存变量“<resultVar>”中，布尔值为真表示成功，布尔值为假表示失败。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:43
msgid ""
"If ``FAIL_REGEX`` is provided, then failure is determined by checking if "
"anything in the output matches any of the specified regular expressions."
msgstr "如果提供了“FAIL_REGEX”，则通过检查输出中的任何内容是否与任何指定的正则表达式匹配来确定失败。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:46
msgid ""
"By default, the test source file will be given a ``.F`` file extension. "
"The ``SRC_EXT`` option can be used to override this with ``.<extension>`` "
"instead-- ``.F90`` is a typical choice."
msgstr ""
"默认情况下，测试源文件将被赋予一个 ``.F`` 文件扩展名。 ``SRC_EXT`` 选项可用于用 ``.<extension>`` "
"覆盖它——``.F90`` 是一个典型的选择。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:50
msgid ""
"The underlying check is performed by the :command:`try_compile` command. "
"The compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_fortran_source_compiles()``:"
msgstr ""
"底层检查由 :command:`try_compile` 命令执行。在调用 ``check_fortran_source_compiles()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceCompiles.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:51
msgid ""
"Additional flags to pass to the compiler. Note that the contents of "
":variable:`CMAKE_Fortran_FLAGS <CMAKE_<LANG>_FLAGS>` and its associated "
"configuration-specific variable are automatically added to the compiler "
"command before the contents of ``CMAKE_REQUIRED_FLAGS``."
msgstr ""
"要传递给编译器的附加标志。请注意 :variable:`CMAKE_Fortran_FLAGS <CMAKE_<LANG>_FLAGS>` "
"的内容及其关联的特定于配置的变量会自动添加到编译器命令中的 ``CMAKE_REQUIRED_FLAGS`` 内容之前。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:6
msgid "CheckFortranSourceRuns"
msgstr "检查 FortranSourceRuns"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:10
msgid ""
"Check if given Fortran source compiles and links into an executable and "
"can subsequently be run."
msgstr "检查给定的 Fortran 源代码是否编译并链接到可执行文件中并随后可以运行。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:20
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a Fortran "
"source file, linked as an executable and then run. The ``<code>`` must be "
"a Fortran ``program``."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 Fortran 源文件，链接为可执行文件，然后运行。 ``<code>`` 必须是 "
"Fortran ``program``。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:32
msgid ""
"This command can help avoid costly build processes when a compiler lacks "
"support for a necessary feature, or a particular vendor library is not "
"compatible with the Fortran compiler version being used. Some of these "
"failures only occur at runtime instead of linktime, and a trivial runtime "
"example can catch the issue before the main build process."
msgstr ""
"当编译器缺乏对必要功能的支持，或者特定供应商库与正在使用的 Fortran "
"编译器版本不兼容时，此命令可以帮助避免昂贵的构建过程。其中一些故障只发生在运行时而不是链接时，一个简单的运行时示例可以在主构建过程之前捕获问题。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:38
msgid ""
"If the ``<code>`` could be built and run successfully, the internal cache "
"variable specified by ``<resultVar>`` will be set to 1, otherwise it will "
"be set to an value that evaluates to boolean false (e.g. an empty string "
"or an error message)."
msgstr ""
"如果 ``<code>`` 可以成功构建和运行，则由 ``<resultVar>`` 指定的内部缓存变量将被设置为 "
"1，否则它将被设置为一个计算结果为布尔值 false 的值（例如空字符串或错误消息）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:43
msgid ""
"By default, the test source file will be given a ``.F90`` file extension. "
"The ``SRC_EXT`` option can be used to override this with ``.<extension>`` "
"instead."
msgstr ""
"默认情况下，测试源文件将被赋予一个 ``.F90`` 文件扩展名。 ``SRC_EXT`` 选项可用于用 ``.<extension>`` 覆盖它。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFortranSourceRuns.cmake:46
msgid ""
"The underlying check is performed by the :command:`try_run` command. The "
"compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_fortran_source_runs()``:"
msgstr ""
"底层检查由 :command:`try_run` 命令执行。在调用 ``check_fortran_source_runs()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:6
msgid "CheckFunctionExists"
msgstr "检查函数存在"

#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:8
msgid "Check if a C function can be linked"
msgstr "检查是否可以链接 C 函数"

#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:16
msgid ""
"Checks that the ``<function>`` is provided by libraries on the system and "
"store the result in a ``<variable>``, which will be created as an internal"
" cache variable."
msgstr "检查 ``<function>`` 是否由系统上的库提供，并将结果存储在 ``<variable>`` 中，它将被创建为内部缓存变量。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:42
msgid ""
"Prefer using :Module:`CheckSymbolExists` instead of this module, for the "
"following reasons:"
msgstr "出于以下原因，更喜欢使用 CheckSymbolExists 而不是此模块："

#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:45
msgid ""
"``check_function_exists()`` can't detect functions that are inlined in "
"headers or specified as a macro."
msgstr "``check_function_exists()`` 无法检测到标头中内联或指定为宏的函数。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:48
msgid ""
"``check_function_exists()`` can't detect anything in the 32-bit versions "
"of the Win32 API, because of a mismatch in calling conventions."
msgstr ""
"``check_function_exists()`` 无法检测到 32 位版本的 Win32 API 中的任何内容，因为调用约定不匹配。"

#: ../../cmake-prefix/src/cmake/Modules/CheckFunctionExists.cmake:51
msgid ""
"``check_function_exists()`` only verifies linking, it does not verify that"
" the function is declared in system headers."
msgstr "``check_function_exists()`` 只验证链接，不验证函数是否在系统头文件中声明。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:6
msgid "CheckIPOSupported"
msgstr "CheckIPO支持"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:10
msgid ""
"Check whether the compiler supports an interprocedural optimization "
"(IPO/LTO). Use this before enabling the "
":prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` target property."
msgstr ""
"检查编译器是否支持过程间优化 (IPO/LT​​O)。在启用 :prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` "
"目标属性之前使用它。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:22
msgid "Options are:"
msgstr "选项是："

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:25
msgid "``RESULT <result>``"
msgstr "``结果<结果>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:24
msgid ""
"Set ``<result>`` variable to ``YES`` if IPO is supported by the compiler "
"and ``NO`` otherwise.  If this option is not given then the command will "
"issue a fatal error if IPO is not supported."
msgstr ""
"如果编译器支持 IPO，则将 ``<result>`` 变量设置为 ``YES``，否则设置为 ``NO``。如果未给出此选项，则如果不支持 "
"IPO，该命令将发出致命错误。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:27
msgid "``OUTPUT <output>``"
msgstr "``输出<输出>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:28
msgid "Set ``<output>`` variable with details about any error."
msgstr "使用有关任何错误的详细信息设置 ``<output>`` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:36
msgid "``LANGUAGES <lang>...``"
msgstr "``语言 <lang>...``"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:30
msgid ""
"Specify languages whose compilers to check. Languages ``C``, ``CXX``, and "
"``Fortran`` are supported."
msgstr "指定要检查其编译器的语言。支持语言“C”、“CXX”和“Fortran”。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:33
msgid ""
"It makes no sense to use this module when :policy:`CMP0069` is set to "
"``OLD`` so module will return error in this case. See policy "
":policy:`CMP0069` for details."
msgstr ""
"当 :policy:`CMP0069` 设置为 ``OLD`` "
"时使用此模块没有任何意义，因此在这种情况下模块将返回错误。有关详细信息，请参阅政策:policy:`CMP0069`。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:36
msgid "Add support for Visual Studio generators."
msgstr "添加对 Visual Studio 生成器的支持。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:39
msgid ""
"The check uses the caller's :variable:`CMAKE_<LANG>_FLAGS` and "
":variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` values. See policy "
":policy:`CMP0138`."
msgstr ""
"检查使用调用者的 :variable:`CMAKE_<LANG>_FLAGS` 和 :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` "
"值。请参阅政策:policy:`CMP0138`。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIPOSupported.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:54
#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1092
#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:746
#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:319
msgid "Examples"
msgstr "例子"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:6
msgid "CheckIncludeFile"
msgstr "检查包含文件"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:8
msgid "Provides a macro to check if a header file can be included in ``C``."
msgstr "提供一个宏来检查头文件是否可以包含在“C”中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:16
msgid ""
"Check if the given ``<include>`` file may be included in a ``C`` source "
"file and store the result in an internal cache entry named ``<variable>``."
"  The optional third argument may be used to add compilation flags to the "
"check (or use ``CMAKE_REQUIRED_FLAGS`` below)."
msgstr ""
"检查给定的``<include>`` 文件是否可能包含在``C`` 源文件中，并将结果存储在名为``<variable>`` "
"的内部缓存条目中。可选的第三个参数可用于将编译标志添加到检查中（或使用下面的“CMAKE_REQUIRED_FLAGS”）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFile.cmake:41
msgid ""
"See the :module:`CheckIncludeFiles` module to check for multiple headers "
"at once.  See the :module:`CheckIncludeFileCXX` module to check for "
"headers using the ``CXX`` language."
msgstr ""
"请参阅 :module:`CheckIncludeFiles` 模块一次检查多个标头。请参阅 :module:`CheckIncludeFileCXX` "
"模块以使用``CXX`` 语言检查标头。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:6
msgid "CheckIncludeFileCXX"
msgstr "检查包含文件CXX"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:8
msgid ""
"Provides a macro to check if a header file can be included in ``CXX``."
msgstr "提供一个宏来检查头文件是否可以包含在“CXX”中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:16
msgid ""
"Check if the given ``<include>`` file may be included in a ``CXX`` source "
"file and store the result in an internal cache entry named ``<variable>``."
"  The optional third argument may be used to add compilation flags to the "
"check (or use ``CMAKE_REQUIRED_FLAGS`` below)."
msgstr ""
"检查给定的 ``<include>`` 文件是否可能包含在 ``CXX`` 源文件中，并将结果存储在名为 ``<variable>`` "
"的内部缓存条目中。可选的第三个参数可用于将编译标志添加到检查中（或使用下面的“CMAKE_REQUIRED_FLAGS”）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFileCXX.cmake:41
msgid ""
"See modules :module:`CheckIncludeFile` and :module:`CheckIncludeFiles` to "
"check for one or more ``C`` headers."
msgstr "请参阅模块 :module:`CheckIncludeFile` 和 :module:`CheckIncludeFiles` 以检查一个或多个“C”标头。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:6
msgid "CheckIncludeFiles"
msgstr "检查包含文件"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:8
msgid ""
"Provides a macro to check if a list of one or more header files can be "
"included together."
msgstr "提供一个宏来检查一个或多个头文件的列表是否可以包含在一起。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:17
msgid ""
"Check if the given ``<includes>`` list may be included together in a "
"source file and store the result in an internal cache entry named "
"``<variable>``.  Specify the ``<includes>`` argument as a :ref:`;-list "
"<CMake Language Lists>` of header file names."
msgstr ""
"检查给定的 ``<includes>`` 列表是否可以一起包含在源文件中，并将结果存储在名为 ``<variable>`` 的内部缓存条目中。将 "
"``<includes>`` 参数指定为头文件名的 :ref:`;-list <CMake Language Lists>`。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:22
msgid ""
"If ``LANGUAGE`` is set, the specified compiler will be used to perform the"
" check. Acceptable values are ``C`` and ``CXX``. If not set, the C "
"compiler will be used if enabled. If the C compiler is not enabled, the "
"C++ compiler will be used if enabled."
msgstr ""
"如果设置了 LANGUAGE ，则将使用指定的编译器来执行检查。可接受的值为“C”和“CXX”。如果未设置，则在启用时将使用 C 编译器。如果未启用"
" C 编译器，则在启用时将使用 C++ 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/CheckIncludeFiles.cmake:47
msgid ""
"See modules :module:`CheckIncludeFile` and :module:`CheckIncludeFileCXX` "
"to check for a single header file in ``C`` or ``CXX`` languages."
msgstr ""
"请参阅模块:module:`CheckIncludeFile` 和:module:`CheckIncludeFileCXX` 以检查 ``C`` 或"
" ``CXX`` 语言中的单个头文件。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLanguage.cmake:6
msgid "CheckLanguage"
msgstr "检查语言"

#: ../../cmake-prefix/src/cmake/Modules/CheckLanguage.cmake:8
msgid "Check if a language can be enabled"
msgstr "检查是否可以启用语言"

#: ../../cmake-prefix/src/cmake/Modules/CheckLanguage.cmake:16
msgid ""
"where ``<lang>`` is a language that may be passed to "
":command:`enable_language` such as ``Fortran``.  If "
":variable:`CMAKE_<LANG>_COMPILER` is already defined the check does "
"nothing.  Otherwise it tries enabling the language in a test project.  The"
" result is cached in :variable:`CMAKE_<LANG>_COMPILER` as the compiler "
"that was found, or ``NOTFOUND`` if the language cannot be enabled. For "
"CUDA which can have an explicit host compiler, the cache "
":variable:`CMAKE_CUDA_HOST_COMPILER` variable will be set if it was "
"required for compilation (and cleared if it was not)."
msgstr ""
"其中 ``<lang>`` 是一种可以传递给 :command:`enable_language` 的语言，例如 ``Fortran``。如果 "
":variable:`CMAKE_<LANG>_COMPILER` 已定义，则检查不执行任何操作。否则它会尝试在测试项目中启用该语言。结果缓存在 "
":variable:`CMAKE_<LANG>_COMPILER` 作为找到的编译器，如果无法启用该语言，则缓存在 ``NOTFOUND`` "
"中。对于可以具有显式主机编译器的 CUDA，如果编译需要缓存 :variable:`CMAKE_CUDA_HOST_COMPILER` "
"变量将被设置（如果不需要则被清除）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLanguage.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/FindPackageMessage.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:864
#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:88
msgid "Example:"
msgstr "例子："

#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:6
msgid "CheckLibraryExists"
msgstr "检查库是否存在"

#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:8
msgid "Check if the function exists."
msgstr "检查函数是否存在。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:73
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:32
msgid "list of macros to define (-DFOO=bar)."
msgstr "要定义的宏列表 (-DFOO=bar)。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:77
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:34
msgid "list of options to pass to link command."
msgstr "传递给链接命令的选项列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLibraryExists.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:80
#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:37
msgid "list of libraries to link."
msgstr "要链接的库列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLinkerFlag.cmake:6
msgid "CheckLinkerFlag"
msgstr "检查链接器标志"

#: ../../cmake-prefix/src/cmake/Modules/CheckLinkerFlag.cmake:10
msgid "Check whether the compiler supports a given link flag."
msgstr "检查编译器是否支持给定的链接标志。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLinkerFlag.cmake:18
msgid ""
"Check that the link ``<flag>`` is accepted by the ``<lang>`` compiler "
"without a diagnostic.  Stores the result in an internal cache entry named "
"``<var>``."
msgstr "检查链接 ``<flag>`` 是否被 ``<lang>`` 编译器接受而无需诊断。将结果存储在名为“<var>”的内部缓存条目中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLinkerFlag.cmake:21
msgid ""
"This command temporarily sets the ``CMAKE_REQUIRED_LINK_OPTIONS`` variable"
" and calls the :command:`check_source_compiles` command from the "
":module:`CheckSourceCompiles` module.  See that module's documentation for"
" a listing of variables that can otherwise modify the build."
msgstr ""
"此命令临时设置 ``CMAKE_REQUIRED_LINK_OPTIONS`` 变量并从 :module:`CheckSourceCompiles`"
" 模块调用 :command:`check_source_compiles` 命令。请参阅该模块的文档以获取可以以其他方式修改构建的变量列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLinkerFlag.cmake:26
msgid ""
"The underlying implementation relies on the :prop_tgt:`LINK_OPTIONS` "
"property to check the specified flag. The ``LINKER:`` prefix, as described"
" in the :command:`target_link_options` command, can be used as well."
msgstr ""
"底层实现依赖于 LINK_OPTIONS 属性来检查指定的标志。也可以使用 ``LINKER:`` 前缀，如 "
":command:`target_link_options` 命令中所述。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLinkerFlag.cmake:30
msgid ""
"A positive result from this check indicates only that the compiler did not"
" issue a diagnostic message when given the link flag.  Whether the flag "
"has any effect or even a specific one is beyond the scope of this module."
msgstr "此检查的肯定结果仅表示编译器在给定链接标志时未发出诊断消息。该标志是否有任何影响，甚至是否有特定影响超出了本模块的范围。"

#: ../../cmake-prefix/src/cmake/Modules/CheckLinkerFlag.cmake:35
msgid ""
"Since the :command:`try_compile` command forwards flags from variables "
"like :variable:`CMAKE_<LANG>_FLAGS`, unknown flags in such variables may "
"cause a false negative for this check."
msgstr ""
"由于 :command:`try_compile` 命令转发来自 :variable:`CMAKE_<LANG>_FLAGS` "
"等变量的标志，此类变量中的未知标志可能会导致此检查出现假阴性。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCCompilerFlag.cmake:6
msgid "CheckOBJCCompilerFlag"
msgstr "检查 OBJCCompilerFlag"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCCompilerFlag.cmake:10
msgid "Check whether the Objective-C compiler supports a given flag."
msgstr "检查 Objective-C 编译器是否支持给定的标志。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCCompilerFlag.cmake:22
msgid ""
"This command temporarily sets the ``CMAKE_REQUIRED_DEFINITIONS`` variable "
"and calls the ``check_objc_source_compiles`` macro from the "
":module:`CheckOBJCSourceCompiles` module.  See documentation of that "
"module for a listing of variables that can otherwise modify the build."
msgstr ""
"此命令临时设置“CMAKE_REQUIRED_DEFINITIONS”变量并从 CheckOBJCSourceCompiles "
"模块调用“check_objc_source_compiles”宏。请参阅该模块的文档以获取可以以其他方式修改构建的变量列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCCompilerFlag.cmake:32
msgid ""
"Since the :command:`try_compile` command forwards flags from variables "
"like :variable:`CMAKE_OBJC_FLAGS <CMAKE_<LANG>_FLAGS>`, unknown flags in "
"such variables may cause a false negative for this check."
msgstr ""
"由于 :command:`try_compile` 命令转发来自变量的标志，如 :variable:`CMAKE_OBJC_FLAGS "
"<CMAKE_<LANG>_FLAGS>`，此类变量中的未知标志可能会导致此检查出现假阴性。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:6
msgid "CheckOBJCSourceCompiles"
msgstr "检查 OBJCSourceCompiles"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:10
msgid ""
"Check if given Objective-C source compiles and links into an executable."
msgstr "检查给定的 Objective-C 源代码是否编译并链接到可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:19
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a "
"Objectie-C source file and linked as an executable (so it must contain at "
"least a ``main()`` function). The result will be stored in the internal "
"cache variable specified by ``<resultVar>``, with a boolean true value for"
" success and boolean false for failure. If ``FAIL_REGEX`` is provided, "
"then failure is determined by checking if anything in the output matches "
"any of the specified regular expressions."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 Objectie-C 源文件并链接为可执行文件（因此它必须至少包含一个 "
"``main()`` "
"函数）。结果将存储在由“<resultVar>”指定的内部缓存变量中，布尔值为真表示成功，布尔值为假表示失败。如果提供了“FAIL_REGEX”，则通过检查输出中的任何内容是否与任何指定的正则表达式匹配来确定失败。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:27
msgid ""
"The underlying check is performed by the :command:`try_compile` command. "
"The compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_objc_source_compiles()``:"
msgstr ""
"底层检查由 :command:`try_compile` 命令执行。在调用 ``check_objc_source_compiles()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceCompiles.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:31
msgid ""
"Additional flags to pass to the compiler. Note that the contents of "
":variable:`CMAKE_OBJC_FLAGS <CMAKE_<LANG>_FLAGS>` and its associated "
"configuration-specific variable are automatically added to the compiler "
"command before the contents of ``CMAKE_REQUIRED_FLAGS``."
msgstr ""
"要传递给编译器的附加标志。请注意 :variable:`CMAKE_OBJC_FLAGS <CMAKE_<LANG>_FLAGS>` "
"的内容及其关联的特定于配置的变量会自动添加到编译器命令中，位于 ``CMAKE_REQUIRED_FLAGS`` 的内容之前。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:6
msgid "CheckOBJCSourceRuns"
msgstr "检查 OBJCSourceRuns"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:10
msgid ""
"Check if given Objective-C source compiles and links into an executable "
"and can subsequently be run."
msgstr "检查给定的 Objective-C 源代码是否编译并链接到可执行文件中，然后可以运行。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:19
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a "
"Objective-C source file, linked as an executable and then run. The "
"``<code>`` must contain at least a ``main()`` function. If the ``<code>`` "
"could be built and run successfully, the internal cache variable specified"
" by ``<resultVar>`` will be set to 1, otherwise it will be set to an value"
" that evaluates to boolean false (e.g. an empty string or an error "
"message)."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 Objective-C 源文件，链接为可执行文件，然后运行。 ``<code>`` "
"必须至少包含一个 ``main()`` 函数。如果 ``<code>`` 可以成功构建和运行，则由 ``<resultVar>`` "
"指定的内部缓存变量将被设置为 1，否则它将被设置为一个计算结果为布尔值 false 的值（例如空字符串或错误消息）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCSourceRuns.cmake:26
msgid ""
"The underlying check is performed by the :command:`try_run` command. The "
"compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_objc_source_runs()``:"
msgstr ""
"底层检查由 :command:`try_run` 命令执行。在调用 ``check_objc_source_runs()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXCompilerFlag.cmake:6
msgid "CheckOBJCXXCompilerFlag"
msgstr "检查 OBJCXXCompilerFlag"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXCompilerFlag.cmake:10
msgid "Check whether the Objective-C++ compiler supports a given flag."
msgstr "检查 Objective-C++ 编译器是否支持给定的标志。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXCompilerFlag.cmake:22
msgid ""
"This command temporarily sets the ``CMAKE_REQUIRED_DEFINITIONS`` variable "
"and calls the ``check_objcxx_source_compiles`` macro from the "
":module:`CheckOBJCXXSourceCompiles` module.  See documentation of that "
"module for a listing of variables that can otherwise modify the build."
msgstr ""
"此命令临时设置“CMAKE_REQUIRED_DEFINITIONS”变量并从 CheckOBJCXXSourceCompiles "
"模块调用“check_objcxx_source_compiles”宏。请参阅该模块的文档以获取可以以其他方式修改构建的变量列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXCompilerFlag.cmake:32
msgid ""
"Since the :command:`try_compile` command forwards flags from variables "
"like :variable:`CMAKE_OBJCXX_FLAGS <CMAKE_<LANG>_FLAGS>`, unknown flags in"
" such variables may cause a false negative for this check."
msgstr ""
"由于 :command:`try_compile` 命令转发来自变量的标志，如 :variable:`CMAKE_OBJCXX_FLAGS "
"<CMAKE_<LANG>_FLAGS>`，此类变量中的未知标志可能会导致此检查出现假阴性。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:6
msgid "CheckOBJCXXSourceCompiles"
msgstr "CheckOBJCXXSourceCompiles"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:10
msgid ""
"Check if given Objective-C++ source compiles and links into an executable."
msgstr "检查给定的 Objective-C++ 源代码是否编译并链接到可执行文件中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:19
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a "
"Objective-C++ source file and linked as an executable (so it must contain "
"at least a ``main()`` function). The result will be stored in the internal"
" cache variable specified by ``<resultVar>``, with a boolean true value "
"for success and boolean false for failure. If ``FAIL_REGEX`` is provided, "
"then failure is determined by checking if anything in the output matches "
"any of the specified regular expressions."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 Objective-C++ 源文件并链接为可执行文件（因此它必须至少包含一个 "
"``main()`` "
"函数）。结果将存储在由“<resultVar>”指定的内部缓存变量中，布尔值为真表示成功，布尔值为假表示失败。如果提供了“FAIL_REGEX”，则通过检查输出中的任何内容是否与任何指定的正则表达式匹配来确定失败。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:27
msgid ""
"The underlying check is performed by the :command:`try_compile` command. "
"The compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_objcxx_source_compiles()``:"
msgstr ""
"底层检查由 :command:`try_compile` 命令执行。在调用 ``check_objcxx_source_compiles()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceCompiles.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:31
msgid ""
"Additional flags to pass to the compiler. Note that the contents of "
":variable:`CMAKE_OBJCXX_FLAGS <CMAKE_<LANG>_FLAGS>` and its associated "
"configuration-specific variable are automatically added to the compiler "
"command before the contents of ``CMAKE_REQUIRED_FLAGS``."
msgstr ""
"要传递给编译器的附加标志。请注意 :variable:`CMAKE_OBJCXX_FLAGS <CMAKE_<LANG>_FLAGS>` "
"的内容及其关联的特定于配置的变量会自动添加到编译器命令中的 ``CMAKE_REQUIRED_FLAGS`` 内容之前。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:6
msgid "CheckOBJCXXSourceRuns"
msgstr "检查 OBJCXXSourceRuns"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:10
msgid ""
"Check if given Objective-C++ source compiles and links into an executable "
"and can subsequently be run."
msgstr "检查给定的 Objective-C++ 源代码是否编译并链接到可执行文件中，然后可以运行。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:19
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a "
"Objective-C++ source file, linked as an executable and then run. The "
"``<code>`` must contain at least a ``main()`` function. If the ``<code>`` "
"could be built and run successfully, the internal cache variable specified"
" by ``<resultVar>`` will be set to 1, otherwise it will be set to an value"
" that evaluates to boolean false (e.g. an empty string or an error "
"message)."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为 Objective-C++ 源文件，链接为可执行文件然后运行。 ``<code>`` "
"必须至少包含一个 ``main()`` 函数。如果 ``<code>`` 可以成功构建和运行，则由 ``<resultVar>`` "
"指定的内部缓存变量将被设置为 1，否则它将被设置为一个计算结果为布尔值 false 的值（例如空字符串或错误消息）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckOBJCXXSourceRuns.cmake:26
msgid ""
"The underlying check is performed by the :command:`try_run` command. The "
"compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_objcxx_source_runs()``:"
msgstr ""
"底层检查由 :command:`try_run` 命令执行。在调用 ``check_objcxx_source_runs()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:6
msgid "CheckPIESupported"
msgstr "检查PIES支持"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:10
msgid ""
"Check whether the linker supports Position Independent Code (PIE) or No "
"Position Independent Code (NO_PIE) for executables. Use this to ensure "
"that the :prop_tgt:`POSITION_INDEPENDENT_CODE` target property for "
"executables will be honored at link time."
msgstr ""
"检查链接器是否支持可执行文件的位置独立代码 (PIE) 或无位置独立代码 "
"(NO_PIE)。使用它来确保:prop_tgt:`POSITION_INDEPENDENT_CODE` 可执行文件的目标属性将在链接时得到遵守。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:27
msgid "``OUTPUT_VARIABLE <output>``"
msgstr "``OUTPUT_VARIABLE <输出>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:25
msgid ""
"Set ``<output>`` variable with details about any error. If the check is "
"bypassed because it uses cached results from a previous call, the output "
"will be empty even if errors were present in the previous call."
msgstr ""
"使用有关任何错误的详细信息设置 ``<output>`` 变量。如果检查因为使用先前调用的缓存结果而被绕过，则即使先前调用中存在错误，输出也将为空。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:30
msgid ""
"Check the linkers used for each of the specified languages. If this option"
" is not provided, the command checks all enabled languages."
msgstr "检查用于每种指定语言的链接器。如果未提供此选项，该命令将检查所有启用的语言。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:33
msgid "``C``, ``CXX``, ``Fortran`` are supported."
msgstr "支持``C``、``CXX``、``Fortran``。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:37
msgid "``OBJC``, ``OBJCXX``, ``CUDA``, and ``HIP`` are supported."
msgstr "支持``OBJC``、``OBJCXX``、``CUDA`` 和``HIP``。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:39
msgid ""
"It makes no sense to use this module when :policy:`CMP0083` is set to "
"``OLD``, so the command will return an error in this case.  See policy "
":policy:`CMP0083` for details."
msgstr ""
"当 :policy:`CMP0083` 设置为 ``OLD`` "
"时使用此模块没有任何意义，因此在这种情况下该命令将返回错误。有关详细信息，请参阅政策:policy:`CMP0083`。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:46
msgid "For each language checked, two boolean cache variables are defined."
msgstr "对于检查的每种语言，定义了两个布尔缓存变量。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:48
msgid "``CMAKE_<lang>_LINK_PIE_SUPPORTED``"
msgstr "``CMAKE_<lang>_LINK_PIE_SUPPORTED``"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:49
msgid ""
"Set to true if ``PIE`` is supported by the linker and false otherwise."
msgstr "如果链接器支持“PIE”，则设置为 true，否则设置为 false。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:51
msgid "``CMAKE_<lang>_LINK_NO_PIE_SUPPORTED``"
msgstr "``CMAKE_<lang>_LINK_NO_PIE_SUPPORTED``"

#: ../../cmake-prefix/src/cmake/Modules/CheckPIESupported.cmake:51
msgid ""
"Set to true if ``NO_PIE`` is supported by the linker and false otherwise."
msgstr "如果链接器支持“NO_PIE”，则设置为 true，否则设置为 false。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:6
msgid "CheckPrototypeDefinition"
msgstr "检查原型定义"

#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:8
msgid "Check if the prototype we expect is correct."
msgstr "检查我们期望的原型是否正确。"

#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:35
msgid ""
"The following variables may be set before calling this function to modify "
"the way the check is run:"
msgstr "在调用此函数以修改检查运行方式之前，可以设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/CheckPrototypeDefinition.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:75
msgid "list of include directories."
msgstr "包含目录列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:7
msgid "CheckSourceCompiles"
msgstr "CheckSourceCompiles"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:11
msgid "Check if given source compiles and links into an executable."
msgstr "检查给定的源代码是否编译并链接到可执行文件中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:21
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a source "
"file for the requested language and linked as an executable. The result "
"will be stored in the internal cache variable specified by "
"``<resultVar>``, with a boolean true value for success and boolean false "
"for failure. If ``FAIL_REGEX`` is provided, then failure is determined by "
"checking if anything in the compiler output matches any of the specified "
"regular expressions."
msgstr ""
"检查 ``<code>`` "
"中提供的源代码是否可以编译为所请求语言的源文件并链接为可执行文件。结果将存储在由“<resultVar>”指定的内部缓存变量中，布尔值为真表示成功，布尔值为假表示失败。如果提供了“FAIL_REGEX”，则通过检查编译器输出中的任何内容是否与任何指定的正则表达式匹配来确定失败。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:28
msgid ""
"By default, the test source file will be given a file extension that "
"matches the requested language. The ``SRC_EXT`` option can be used to "
"override this with ``.<extension>`` instead."
msgstr ""
"默认情况下，测试源文件将被赋予与请求的语言相匹配的文件扩展名。 ``SRC_EXT`` 选项可用于用 ``.<extension>`` 覆盖它。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:32
msgid "The ``<code>`` must contain a valid main program. For example:"
msgstr "``<code>`` 必须包含一个有效的主程序。例如："

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:50
msgid ""
"The underlying check is performed by the :command:`try_compile` command. "
"The compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_source_compiles()``:"
msgstr ""
"底层检查由 :command:`try_compile` 命令执行。在调用 ``check_source_compiles()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceCompiles.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:55
msgid ""
"Additional flags to pass to the compiler. Note that the contents of "
":variable:`CMAKE_<LANG>_FLAGS <CMAKE_<LANG>_FLAGS>` and its associated "
"configuration-specific variable are automatically added to the compiler "
"command before the contents of ``CMAKE_REQUIRED_FLAGS``."
msgstr ""
"要传递给编译器的附加标志。请注意 :variable:`CMAKE_<LANG>_FLAGS <CMAKE_<LANG>_FLAGS>` "
"的内容及其关联的特定于配置的变量会自动添加到编译器命令中的 ``CMAKE_REQUIRED_FLAGS`` 内容之前。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:7
msgid "CheckSourceRuns"
msgstr "检查源运行"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:11
msgid ""
"Check if given source compiles and links into an executable and can "
"subsequently be run."
msgstr "检查给定的源代码是否编译并链接到可执行文件中，然后可以运行。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:21
msgid ""
"Check that the source supplied in ``<code>`` can be compiled as a source "
"file for the requested language, linked as an executable and then run. If "
"the ``<code>`` could be built and run successfully, the internal cache "
"variable specified by ``<resultVar>`` will be set to 1, otherwise it will "
"be set to a value that evaluates to boolean false (e.g. an empty string or"
" an error message)."
msgstr ""
"检查 ``<code>`` 中提供的源代码是否可以编译为所请求语言的源文件，链接为可执行文件然后运行。如果 ``<code>`` "
"可以成功构建并运行，则由 ``<resultVar>`` 指定的内部缓存变量将被设置为 1，否则它将被设置为一个计算结果为布尔值 false "
"的值（例如空字符串或错误消息）。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSourceRuns.cmake:50
msgid ""
"The underlying check is performed by the :command:`try_run` command. The "
"compile and link commands can be influenced by setting any of the "
"following variables prior to calling ``check_source_runs()``:"
msgstr ""
"底层检查由 :command:`try_run` 命令执行。在调用 ``check_source_runs()`` "
"之前设置以下任何变量可以影响编译和链接命令："

#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:6
msgid "CheckStructHasMember"
msgstr "检查结构有成员"

#: ../../cmake-prefix/src/cmake/Modules/CheckStructHasMember.cmake:8
msgid "Check if the given struct or class has the specified member variable"
msgstr "检查给定的结构或类是否具有指定的成员变量"

#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:6
msgid "CheckSymbolExists"
msgstr "检查符号存在"

#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:8
msgid ""
"Provides a macro to check if a symbol exists as a function, variable, or "
"macro in ``C``."
msgstr "提供一个宏来检查符号是否作为函数、变量或宏存在于“C”中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:17
msgid ""
"Check that the ``<symbol>`` is available after including given header "
"``<files>`` and store the result in a ``<variable>``.  Specify the list of"
" files in one argument as a semicolon-separated list. ``<variable>`` will "
"be created as an internal cache variable."
msgstr ""
"检查 ``<symbol>`` 在包含给定的标题 ``<files>`` 之后是否可用，并将结果存储在 ``<variable>`` "
"中。将一个参数中的文件列表指定为分号分隔的列表。 ``<variable>`` 将被创建为内部缓存变量。"

#: ../../cmake-prefix/src/cmake/Modules/CheckSymbolExists.cmake:22
msgid ""
"If the header files define the symbol as a macro it is considered "
"available and assumed to work.  If the header files declare the symbol as "
"a function or variable then the symbol must also be available for linking "
"(so intrinsics may not be detected). If the symbol is a type, enum value, "
"or intrinsic it will not be recognized (consider using "
":module:`CheckTypeSize` or :module:`CheckSourceCompiles`). If the check "
"needs to be done in C++, consider using :module:`CheckCXXSymbolExists` "
"instead."
msgstr ""
"如果头文件将符号定义为宏，则它被认为是可用的并假定可以工作。如果头文件将符号声明为函数或变量，则该符号也必须可用于链接（因此可能无法检测到内在函数）。如果符号是类型、枚举值或内在符号，它将不会被识别（考虑使用:module:`CheckTypeSize`"
" 或:module:`CheckSourceCompiles`）。如果需要在 C++ 中完成检查，请考虑改用 "
"CheckCXXSymbolExists。"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:6
msgid "CheckTypeSize"
msgstr "检查类型大小"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:8
msgid "Check sizeof a type"
msgstr "检查类型的大小"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:17
msgid ""
"Check if the type exists and determine its size.  Results are reported in "
"the following variables:"
msgstr "检查类型是否存在并确定其大小。结果在以下变量中报告："

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:21
msgid "``HAVE_<variable>``"
msgstr "``有_<变量>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:21
msgid "Holds a true or false value indicating whether the type exists."
msgstr "保存一个 true 或 false 值，指示该类型是否存在。"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/TestCXXAcceptsFlag.cmake:37
msgid "``<variable>``"
msgstr "``<变量>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:24
msgid "Holds one of the following values:"
msgstr "持有以下值之一："

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:27
msgid "``<size>``"
msgstr "``<尺寸>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:27
msgid "Type has non-zero size ``<size>``."
msgstr "类型具有非零大小 ``<size>``。"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:35
msgid "``0``"
msgstr "``0``"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:30
msgid ""
"Type has architecture-dependent size.  This may occur when "
":variable:`CMAKE_OSX_ARCHITECTURES` has multiple architectures. In this "
"case ``<variable>_CODE`` contains C preprocessor tests mapping from each "
"architecture macro to the corresponding type size. The list of "
"architecture macros is stored in ``<variable>_KEYS``, and the value for "
"each key is stored in ``<variable>-<key>``."
msgstr ""
"类型具有依赖于体系结构的大小。当 :variable:`CMAKE_OSX_ARCHITECTURES` "
"具有多个架构时，可能会发生这种情况。在这种情况下，``<variable>_CODE`` 包含从每个架构宏到相应类型大小的 C "
"预处理器测试映射。架构宏列表存储在``<variable>_KEYS``中，每个键的值存储在``<variable>-<key>``中。"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:38
msgid "\"\" (empty string)"
msgstr "\"\"（空字符串）"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:38
msgid "Type does not exist."
msgstr "类型不存在。"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:42
msgid "``<variable>_CODE``"
msgstr "``<变量>_CODE``"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:41
msgid ""
"Holds C preprocessor code to define the macro ``<variable>`` to the size "
"of the type, or to leave the macro undefined if the type does not exist."
msgstr "保留 C 预处理器代码以将宏“<variable>”定义为类型的大小，或者如果类型不存在则保留宏未定义。"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:95
#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:190
#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:106
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:63
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:183
msgid "The options are:"
msgstr "选项是："

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:46
msgid "``BUILTIN_TYPES_ONLY``"
msgstr "``BUILTIN_TYPES_ONLY``"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:48
msgid ""
"Support only compiler-builtin types.  If *not* given, the macro checks for"
" headers ``<sys/types.h>``, ``<stdint.h>``, and ``<stddef.h>``, and saves "
"results in ``HAVE_SYS_TYPES_H``, ``HAVE_STDINT_H``, and ``HAVE_STDDEF_H``."
"  The type size check automatically includes the available headers, thus "
"supporting checks of types defined in the headers."
msgstr ""
"仅支持编译器内置类型。如果*未*给出，宏将检查标题``<sys/types.h>``、``<stdint.h>`` "
"和``<stddef.h>``，并将结果保存在`` HAVE_SYS_TYPES_H``、``HAVE_STDINT_H`` "
"和``HAVE_STDDEF_H``。类型大小检查自动包含可用的标头，因此支持对标头中定义的类型进行检查。"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:55
msgid "``LANGUAGE <language>``"
msgstr "``语言<语言>``"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:55
msgid ""
"Use the ``<language>`` compiler to perform the check. Acceptable values "
"are ``C`` and ``CXX``."
msgstr "使用``<language>`` 编译器来执行检查。可接受的值为“C”和“CXX”。"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:58
msgid ""
"Despite the name of the macro you may use it to check the size of more "
"complex expressions, too.  To check e.g.  for the size of a struct member "
"you can do something like this:"
msgstr "不管宏的名称如何，您也可以使用它来检查更复杂的表达式的大小。检查例如对于结构成员的大小，您可以执行以下操作："

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:297
msgid "``CMAKE_EXTRA_INCLUDE_FILES``"
msgstr "``CMAKE_EXTRA_INCLUDE_FILES``"

#: ../../cmake-prefix/src/cmake/Modules/CheckTypeSize.cmake:85
msgid "list of extra headers to include."
msgstr "要包含的额外标题列表。"

#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:6
msgid "CheckVariableExists"
msgstr "检查变量存在"

#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:8
msgid "Check if the variable exists."
msgstr "检查变量是否存在。"

#: ../../cmake-prefix/src/cmake/Modules/CheckVariableExists.cmake:24
msgid "This macro is only for ``C`` variables."
msgstr "此宏仅适用于“C”变量。"

#: ../../cmake-prefix/src/cmake/Modules/Dart.cmake:6
msgid "Dart"
msgstr "镖"

#: ../../cmake-prefix/src/cmake/Modules/Dart.cmake:8
msgid "Configure a project for testing with CTest or old Dart Tcl Client"
msgstr "配置项目以使用 CTest 或旧的 Dart Tcl Client 进行测试"

#: ../../cmake-prefix/src/cmake/Modules/Dart.cmake:10
msgid ""
"This file is the backwards-compatibility version of the CTest module. It "
"supports using the old Dart 1 Tcl client for driving dashboard submissions"
" as well as testing with CTest.  This module should be included in the "
"CMakeLists.txt file at the top of a project.  Typical usage:"
msgstr ""
"此文件是 CTest 模块的向后兼容版本。它支持使用旧的 Dart 1 Tcl 客户端来驱动仪表板提交以及使用 CTest "
"进行测试。该模块应包含在项目顶部的 CMakeLists.txt 文件中。典型用法："

#: ../../cmake-prefix/src/cmake/Modules/Dart.cmake:23
msgid ""
"The BUILD_TESTING option is created by the Dart module to determine "
"whether testing support should be enabled.  The default is ON."
msgstr "BUILD_TESTING 选项由 Dart 模块创建，用于确定是否应启用测试支持。默认为开。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:6
msgid "DeployQt4"
msgstr "部署Qt4"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:8
msgid "Functions to help assemble a standalone Qt4 executable."
msgstr "帮助组装独立 Qt4 可执行文件的功能。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:10
msgid ""
"A collection of CMake utility functions useful for deploying Qt4 "
"executables."
msgstr "用于部署 Qt4 可执行文件的 CMake 实用程序函数集合。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:24
msgid ""
"Requires CMake 2.6 or greater because it uses function and PARENT_SCOPE.  "
"Also depends on BundleUtilities.cmake."
msgstr ""
"需要 CMake 2.6 或更高版本，因为它使用函数和 PARENT_SCOPE。也取决于 BundleUtilities.cmake。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:31
msgid ""
"Writes a qt.conf file with the <qt_conf_contents> into <qt_conf_dir>."
msgstr "将带有 <qt_conf_contents> 的 qt.conf 文件写入 <qt_conf_dir>。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:37
msgid ""
"Loop through <paths_var> list and if any don't exist resolve them relative"
" to the <executable_path> (if supplied) or the CMAKE_INSTALL_PREFIX."
msgstr ""
"遍历 <paths_var> 列表，如果不存在，则相对于 <executable_path>（如果提供）或 CMAKE_INSTALL_PREFIX"
" 解析它们。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:46
msgid ""
"Copies Qt plugins, writes a Qt configuration file (if needed) and fixes up"
" a Qt4 executable using BundleUtilities so it is standalone and can be "
"drag-and-drop copied to another machine as long as all of the system "
"libraries are compatible."
msgstr ""
"复制 Qt 插件，编写 Qt 配置文件（如果需要）并使用 BundleUtilities 修复 Qt4 "
"可执行文件，因此它是独立的，只要所有系统库兼容，就可以拖放复制到另一台机器。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:51
msgid "<executable> should point to the executable to be fixed-up."
msgstr "<executable> 应该指向要修复的可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:53
msgid ""
"<qtplugins> should contain a list of the names or paths of any Qt plugins "
"to be installed."
msgstr "<qtplugins> 应包含要安装的任何 Qt 插件的名称或路径列表。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:56
msgid ""
"<libs> will be passed to BundleUtilities and should be a list of any "
"already installed plugins, libraries or executables to also be fixed-up."
msgstr ""
"<libs> 将被传递给 BundleUtilities，并且应该是任何已安装的插件、库或可执行文件的列表，这些插件、库或可执行文件也将被修复。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:60
msgid ""
"<dirs> will be passed to BundleUtilities and should contain and "
"directories to be searched to find library dependencies."
msgstr "<dirs> 将被传递给 BundleUtilities 并且应该包含要搜索的目录以查找库依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:63
msgid "<plugins_dir> allows an custom plugins directory to be used."
msgstr "<plugins_dir> 允许使用自定义插件目录。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:65
msgid ""
"<request_qt_conf> will force a qt.conf file to be written even if not "
"needed."
msgstr "<request_qt_conf> 将强制写入 qt.conf 文件，即使不需要也是如此。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:73
msgid ""
"Install (or copy) a resolved <plugin> to the default plugins directory (or"
" <plugins_dir>) relative to <executable> and store the result in "
"<installed_plugin_path_var>."
msgstr ""
"安装（或复制）已解析的 <plugin> 到相对于 <executable> 的默认插件目录（或 <plugins_dir>），并将结果存储在 "
"<installed_plugin_path_var> 中。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:77
msgid ""
"If <copy> is set to TRUE then the plugins will be copied rather than "
"installed.  This is to allow this module to be used at CMake time rather "
"than install time."
msgstr "如果 <copy> 设置为 TRUE，那么插件将被复制而不是安装。这是为了允许在 CMake 时而不是在安装时使用此模块。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:81
msgid ""
"If <component> is set then anything installed will use this COMPONENT."
msgstr "如果设置了 <component>，那么安装的任何东西都将使用这个 COMPONENT。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:88
msgid ""
"Install (or copy) an unresolved <plugin> to the default plugins directory "
"(or <plugins_dir>) relative to <executable> and store the result in "
"<installed_plugin_path_var>.  See documentation of "
"INSTALL_QT4_PLUGIN_PATH."
msgstr ""
"将未解析的 <plugin> 安装（或复制）到相对于 <executable> 的默认插件目录（或 <plugins_dir>），并将结果存储在 "
"<installed_plugin_path_var> 中。请参阅 INSTALL_QT4_PLUGIN_PATH 的文档。"

#: ../../cmake-prefix/src/cmake/Modules/DeployQt4.cmake:98
msgid ""
"Installs Qt plugins, writes a Qt configuration file (if needed) and fixes "
"up a Qt4 executable using BundleUtilities so it is standalone and can be "
"drag-and-drop copied to another machine as long as all of the system "
"libraries are compatible.  The executable will be fixed-up at install "
"time.  <component> is the COMPONENT used for bundle fixup and plugin "
"installation.  See documentation of FIXUP_QT4_BUNDLE."
msgstr ""
"安装 Qt 插件，编写 Qt 配置文件（如果需要）并使用 BundleUtilities 修复 Qt4 "
"可执行文件，因此它是独立的，只要所有系统库兼容，就可以拖放复制到另一台机器。可执行文件将在安装时修复。 <component> "
"是用于捆绑修复和插件安装的组件。请参阅 FIXUP_QT4_BUNDLE 的文档。"

#: ../../cmake-prefix/src/cmake/Modules/Documentation.cmake:6
msgid "Documentation"
msgstr "文档"

#: ../../cmake-prefix/src/cmake/Modules/Documentation.cmake:8
msgid ""
"This module does nothing, unless policy :policy:`CMP0106` is set to "
"``OLD``."
msgstr "这个模块什么都不做，除非策略 :policy:`CMP0106` 被设置为``OLD``。"

#: ../../cmake-prefix/src/cmake/Modules/Documentation.cmake:11
msgid ""
"This module provides support for the VTK documentation framework.  It "
"relies on several tools (Doxygen, Perl, etc)."
msgstr "该模块提供对 VTK 文档框架的支持。它依赖于多种工具（Doxygen、Perl 等）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:6
msgid "ExternalData"
msgstr "外部数据"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:12
msgid "Manage data files stored outside source tree"
msgstr "管理存储在源代码树之外的数据文件"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:17
msgid ""
"Use this module to unambiguously reference data files stored outside the "
"source tree and fetch them at build time from arbitrary local and remote "
"content-addressed locations.  Functions provided by this module recognize "
"arguments with the syntax ``DATA{<name>}`` as references to external data,"
" replace them with full paths to local copies of those data, and create "
"build rules to fetch and update the local copies."
msgstr ""
"使用此模块可以明确引用存储在源树外部的数据文件，并在构建时从任意本地和远程内容寻址位置获取它们。此模块提供的函数将语法为“DATA{<name>}”的参数识别为对外部数据的引用，将它们替换为这些数据的本地副本的完整路径，并创建构建规则以获取和更新本地副本。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:38
msgid ""
"When test ``MyTest`` runs the ``DATA{MyInput.png}`` argument will be "
"replaced by the full path to a real instance of the data file "
"``MyInput.png`` on disk.  If the source tree contains a content link such "
"as ``MyInput.png.md5`` then the ``MyData`` target creates a real "
"``MyInput.png`` in the build tree."
msgstr ""
"当测试“MyTest”运行时，“DATA{MyInput.png}”参数将替换为磁盘上数据文件“MyInput.png”的真实实例的完整路径。如果源代码树包含诸如“MyInput.png.md5”之类的内容链接，则“MyData”目标会在构建树中创建一个真正的“MyInput.png”。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:49
msgid ""
"The ``ExternalData_Expand_Arguments`` function evaluates ``DATA{}`` "
"references in its arguments and constructs a new list of arguments::"
msgstr ""
"``ExternalData_Expand_Arguments`` 函数评估其参数中的 ``DATA{}`` 引用并构建一个新的参数列表："

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:58
msgid ""
"It replaces each ``DATA{}`` reference in an argument with the full path of"
" a real data file on disk that will exist after the ``<target>`` builds."
msgstr "它将参数中的每个 ``DATA{}`` 引用替换为磁盘上真实数据文件的完整路径，该文件将在 ``<target>`` 构建后存在。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:63
msgid ""
"The ``ExternalData_Add_Test`` function wraps around the CMake "
":command:`add_test` command but supports ``DATA{}`` references in its "
"arguments::"
msgstr ""
"``ExternalData_Add_Test`` 函数环绕 CMake:command:`add_test` 命令，但在其参数中支持 "
"``DATA{}`` 引用 ::"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:72
msgid ""
"It passes its arguments through ``ExternalData_Expand_Arguments`` and then"
" invokes the :command:`add_test` command using the results."
msgstr ""
"它通过 ``ExternalData_Expand_Arguments`` 传递其参数，然后使用结果调用 :command:`add_test` "
"命令。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:77
msgid ""
"The ``ExternalData_Add_Target`` function creates a custom target to manage"
" local instances of data files stored externally::"
msgstr "``ExternalData_Add_Target`` 函数创建一个自定义目标来管理外部存储的数据文件的本地实例："

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:85
msgid ""
"It creates custom commands in the target as necessary to make data files "
"available for each ``DATA{}`` reference previously evaluated by other "
"functions provided by this module. Data files may be fetched from one of "
"the URL templates specified in the ``ExternalData_URL_TEMPLATES`` "
"variable, or may be found locally in one of the paths specified in the "
"``ExternalData_OBJECT_STORES`` variable."
msgstr ""
"它根据需要在目标中创建自定义命令，以使数据文件可用于先前由该模块提供的其他函数评估的每个“DATA{}”引用。数据文件可以从 "
"``ExternalData_URL_TEMPLATES`` 变量中指定的 URL 模板之一获取，或者可以在 "
"``ExternalData_OBJECT_STORES`` 变量中指定的路径之一中本地找到。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:93
msgid ""
"The ``SHOW_PROGRESS`` argument may be passed to suppress progress "
"information during the download of objects. If not provided, it defaults "
"to ``OFF`` for :generator:`Ninja` and :generator:`Ninja Multi-Config` "
"generators and ``ON`` otherwise."
msgstr ""
"``SHOW_PROGRESS`` 参数可以被传递以在对象下载期间抑制进度信息。如果未提供，则 Ninja 和 Ninja Multi-Config"
" 生成器默认为 OFF，否则默认为 ON。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:99
msgid ""
"Typically only one target is needed to manage all external data within a "
"project.  Call this function once at the end of configuration after all "
"data references have been processed."
msgstr "通常只需要一个目标来管理项目中的所有外部数据。在处理完所有数据引用后，在配置结束时调用此函数一次。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:104
#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:14
msgid "Module Variables"
msgstr "模块变量"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:106
msgid ""
"The following variables configure behavior.  They should be set before "
"calling any of the functions provided by this module."
msgstr "以下变量配置行为。它们应该在调用该模块提供的任何函数之前设置。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:111
msgid ""
"The ``ExternalData_BINARY_ROOT`` variable may be set to the directory to "
"hold the real data files named by expanded ``DATA{}`` references.  The "
"default is ``CMAKE_BINARY_DIR``.  The directory layout will mirror that of"
" content links under ``ExternalData_SOURCE_ROOT``."
msgstr ""
"``ExternalData_BINARY_ROOT`` 变量可以设置为保存由扩展的``DATA{}`` 引用命名的真实数据文件的目录。默认是 "
"``CMAKE_BINARY_DIR``。目录布局将反映“ExternalData_SOURCE_ROOT”下的内容链接。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:120
msgid ""
"Specify a full path to a ``.cmake`` custom fetch script identified by "
"``<key>`` in entries of the ``ExternalData_URL_TEMPLATES`` list. See "
"`Custom Fetch Scripts`_."
msgstr ""
"在 ``ExternalData_URL_TEMPLATES`` 列表的条目中指定 ``.cmake`` 自定义提取脚本的完整路径，该脚本由 "
"``<key>`` 标识。请参阅“自定义获取脚本”。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:126
msgid ""
"The ``ExternalData_LINK_CONTENT`` variable may be set to the name of a "
"supported hash algorithm to enable automatic conversion of real data files"
" referenced by the ``DATA{}`` syntax into content links.  For each such "
"``<file>`` a content link named ``<file><ext>`` is created.  The original "
"file is renamed to the form ``.ExternalData_<algo>_<hash>`` to stage it "
"for future transmission to one of the locations in the list of URL "
"templates (by means outside the scope of this module).  The data fetch "
"rule created for the content link will use the staged object if it cannot "
"be found using any URL template."
msgstr ""
"``ExternalData_LINK_CONTENT`` 变量可以设置为支持的哈希算法的名称，以启用将``DATA{}`` "
"语法引用的真实数据文件自动转换为内容链接。对于每个这样的“<file>”，都会创建一个名为“<file><ext>”的内容链接。原始文件被重命名为 "
"``.ExternalData_<algo>_<hash>`` 的形式，以便将来传输到 URL "
"模板列表中的位置之一（通过本模块范围之外的方式）。如果使用任何 URL 模板都找不到，则为内容链接创建的数据获取规则将使用暂存对象。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:140
msgid ""
"The real data files named by expanded ``DATA{}`` references may be made "
"available under ``ExternalData_BINARY_ROOT`` using symbolic links on some "
"platforms.  The ``ExternalData_NO_SYMLINKS`` variable may be set to "
"disable use of symbolic links and enable use of copies instead."
msgstr ""
"在某些平台上，可以使用符号链接在 ExternalData_BINARY_ROOT 下提供由扩展的 DATA{} 引用命名的真实数据文件。 "
"``ExternalData_NO_SYMLINKS`` 变量可以设置为禁止使用符号链接并启用副本。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:147
msgid ""
"The ``ExternalData_OBJECT_STORES`` variable may be set to a list of local "
"directories that store objects using the layout ``<dir>/%(algo)/%(hash)``."
" These directories will be searched first for a needed object.  If the "
"object is not available in any store then it will be fetched remotely "
"using the URL templates and added to the first local store listed.  If no "
"stores are specified the default is a location inside the build tree."
msgstr ""
"``ExternalData_OBJECT_STORES`` 变量可以设置为使用布局``<dir>/%(algo)/%(hash)`` "
"存储对象的本地目录列表。将首先在这些目录中搜索所需的对象。如果该对象在任何商店中都不可用，那么它将使用 URL "
"模板远程获取并添加到列出的第一个本地商店。如果没有指定商店，默认是构建树中的一个位置。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:161
msgid "See `Referencing File Series`_."
msgstr "请参阅“引用文件系列”。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:165
msgid ""
"The ``ExternalData_SOURCE_ROOT`` variable may be set to the highest source"
" directory containing any path named by a ``DATA{}`` reference.  The "
"default is ``CMAKE_SOURCE_DIR``.  ``ExternalData_SOURCE_ROOT`` and "
"``CMAKE_SOURCE_DIR`` must refer to directories within a single source "
"distribution (e.g.  they come together in one tarball)."
msgstr ""
"``ExternalData_SOURCE_ROOT`` 变量可以设置为包含由 ``DATA{}`` 引用命名的任何路径的最高源目录。默认为 "
"``CMAKE_SOURCE_DIR``。 ``ExternalData_SOURCE_ROOT`` 和 ``CMAKE_SOURCE_DIR`` "
"必须引用单个源分发中的目录（例如，它们放在一个 tarball 中）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:173
msgid ""
"The ``ExternalData_TIMEOUT_ABSOLUTE`` variable sets the download absolute "
"timeout, in seconds, with a default of ``300`` seconds. Set to ``0`` to "
"disable enforcement."
msgstr ""
"``ExternalData_TIMEOUT_ABSOLUTE`` 变量设置下载绝对超时，以秒为单位，默认值为 ``300`` "
"秒。设置为“0”以禁用强制执行。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:179
msgid ""
"The ``ExternalData_TIMEOUT_INACTIVITY`` variable sets the download "
"inactivity timeout, in seconds, with a default of ``60`` seconds. Set to "
"``0`` to disable enforcement."
msgstr ""
"``ExternalData_TIMEOUT_INACTIVITY`` 变量设置下载不活动超时，以秒为单位，默认值为 ``60`` "
"秒。设置为“0”以禁用强制执行。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:187
msgid ""
"Specify a custom URL component to be substituted for URL template "
"placeholders of the form ``%(algo:<key>)``, where ``<key>`` is a valid C "
"identifier, when fetching an object referenced via hash algorithm "
"``<algo>``.  If not defined, the default URL component is just ``<algo>`` "
"for any ``<key>``."
msgstr ""
"在获取通过哈希算法引用的对象时，指定一个自定义 URL 组件来替换形式为 ``%(algo:<key>)`` 的 URL 模板占位符，其中 "
"``<key>`` 是有效的 C 标识符``<算法>``。如果未定义，则默认 URL 组件只是任何 ``<key>`` 的 ``<algo>``。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:195
msgid ""
"The ``ExternalData_URL_TEMPLATES`` may be set to provide a list of URL "
"templates using the placeholders ``%(algo)`` and ``%(hash)`` in each "
"template.  Data fetch rules try each URL template in order by substituting"
" the hash algorithm name for ``%(algo)`` and the hash value for "
"``%(hash)``.  Alternatively one may use ``%(algo:<key>)`` with "
"``ExternalData_URL_ALGO_<algo>_<key>`` variables to gain more flexibility "
"in remote URLs."
msgstr ""
"``ExternalData_URL_TEMPLATES`` 可以设置为在每个模板中使用占位符 ``%(algo)`` 和 ``%(hash)`` "
"来提供 URL 模板列表。数据获取规则按顺序尝试每个 URL 模板，方法是用散列算法名称代替 ``%(algo)`` 和散列值代替 "
"``%(hash)``。或者，可以将 %(algo:<key>) 与 ExternalData_URL_ALGO_<algo>_<key> "
"变量一起使用，以获得远程 URL 的更大灵活性。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:204
msgid "Referencing Files"
msgstr "引用文件"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:207
msgid "Referencing Single Files"
msgstr "引用单个文件"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:209
msgid ""
"The ``DATA{}`` syntax is literal and the ``<name>`` is a full or relative "
"path within the source tree.  The source tree must contain either a real "
"data file at ``<name>`` or a \"content link\" at ``<name><ext>`` "
"containing a hash of the real file using a hash algorithm corresponding to"
" ``<ext>``. For example, the argument ``DATA{img.png}`` may be satisfied "
"by either a real ``img.png`` file in the current source directory or a "
"``img.png.md5`` file containing its MD5 sum."
msgstr ""
"``DATA{}`` 语法是文字，``<name>`` 是源代码树中的完整路径或相对路径。源树必须在 ``<name>`` "
"处包含一个真实的数据文件，或者在 ``<name><ext>`` 处包含一个“内容链接”，其中包含使用对应于 `` "
"的散列算法的真实文件的散列<分机号>``。例如，参数 DATA{img.png} 可以由当前源目录中的真实 img.png 文件或包含其 MD5 的"
" img.png.md5 文件满足和。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:217
msgid ""
"Multiple content links of the same name with different hash algorithms are"
" supported (e.g. ``img.png.sha256`` and ``img.png.sha1``) so long as they "
"all correspond to the same real file.  This allows objects to be fetched "
"from sources indexed by different hash algorithms."
msgstr ""
"支持具有不同哈希算法的多个同名内容链接（例如 ``img.png.sha256`` 和 "
"``img.png.sha1``），只要它们都对应于同一个真实文件。这允许从由不同哈希算法索引的源中获取对象。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:224
msgid "Referencing File Series"
msgstr "参考文件系列"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:226
msgid ""
"The ``DATA{}`` syntax can be told to fetch a file series using the form "
"``DATA{<name>,:}``, where the ``:`` is literal.  If the source tree "
"contains a group of files or content links named like a series then a "
"reference to one member adds rules to fetch all of them.  Although all "
"members of a series are fetched, only the file originally named by the "
"``DATA{}`` argument is substituted for it.  The default configuration "
"recognizes file series names ending with ``#.ext``, ``_#.ext``, "
"``.#.ext``, or ``-#.ext`` where ``#`` is a sequence of decimal digits and "
"``.ext`` is any single extension.  Configure it with a regex that parses "
"``<number>`` and ``<suffix>`` parts from the end of ``<name>``::"
msgstr ""
"可以告诉 ``DATA{}`` 语法使用 ``DATA{<name>,:}`` 的形式获取文件系列，其中 ``:`` "
"是文字。如果源树包含一组文件或内容链接，其名称类似于系列，则对一个成员的引用会添加规则以获取所有这些文件或内容链接。尽管获取了系列的所有成员，但只有最初由"
" DATA{} 参数命名的文件被替换。默认配置识别以``#.ext``、``_#.ext``、``.#.ext`` 或``-#.ext`` "
"结尾的文件系列名称，其中``#``是十进制数字序列，``.ext`` 是任何单个扩展名。用一个正则表达式配置它，该正则表达式从 ``<name>``"
" 的末尾解析 ``<number>`` 和 ``<suffix>`` 部分 ::"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:239
msgid "For more complicated cases set::"
msgstr "对于更复杂的情况集 ::"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:246
msgid ""
"Configure series number matching with a regex that matches the "
"``<number>`` part of series members named ``<prefix><number><suffix>``::"
msgstr ""
"使用正则表达式配置系列号匹配，该正则表达式匹配名为 ``<prefix><number><suffix>`` 的系列成员的 ``<number>``"
" 部分 ::"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:251
msgid ""
"Note that the ``<suffix>`` of a series does not include a hash-algorithm "
"extension."
msgstr "请注意，系列的“<后缀>”不包括哈希算法扩展。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:255
msgid "Referencing Associated Files"
msgstr "引用关联文件"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:257
msgid ""
"The ``DATA{}`` syntax can alternatively match files associated with the "
"named file and contained in the same directory.  Associated files may be "
"specified by options using the syntax ``DATA{<name>,<opt1>,<opt2>,...}``."
"  Each option may specify one file by name or specify a regular expression"
" to match file names using the syntax ``REGEX:<regex>``.  For example, the"
" arguments::"
msgstr ""
"``DATA{}`` "
"语法可以选择匹配与指定文件关联并包含在同一目录中的文件。关联文件可以通过使用语法“DATA{<name>,<opt1>,<opt2>,...}”的选项指定。每个选项可以按名称指定一个文件，或使用语法“REGEX:<regex>”指定一个正则表达式来匹配文件名。例如，参数 ::"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:267
msgid ""
"will pass ``MyInput.mha`` and ``MyFrames00.png`` on the command line but "
"ensure that the associated files are present next to them."
msgstr "将在命令行上传递 ``MyInput.mha`` 和 ``MyFrames00.png`` 但确保相关文件出现在它们旁边。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:271
msgid "Referencing Directories"
msgstr "引用目录"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:273
msgid ""
"The ``DATA{}`` syntax may reference a directory using a trailing slash and"
" a list of associated files.  The form ``DATA{<name>/,<opt1>,<opt2>,...}``"
" adds rules to fetch any files in the directory that match one of the "
"associated file options.  For example, the argument "
"``DATA{MyDataDir/,REGEX:.*}`` will pass the full path to a ``MyDataDir`` "
"directory on the command line and ensure that the directory contains files"
" corresponding to every file or content link in the ``MyDataDir`` source "
"directory."
msgstr ""
"``DATA{}`` 语法可以使用尾部斜杠和相关文件列表来引用目录。 ``DATA{<name>/,<opt1>,<opt2>,...}`` "
"的形式添加了规则以获取目录中与关联文件选项之一匹配的任何文件。例如，参数 ``DATA{MyDataDir/,REGEX:.*}`` "
"将在命令行上将完整路径传递到 ``MyDataDir`` 目录，并确保该目录包含与每个文件或内容链接对应的文件在 ``MyDataDir`` "
"源目录中。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:282
msgid ""
"In order to match associated files in subdirectories, specify a "
"``RECURSE:`` option, e.g. ``DATA{MyDataDir/,RECURSE:,REGEX:.*}``."
msgstr ""
"为了匹配子目录中的相关文件，指定一个``RECURSE:`` "
"选项，例如``DATA{MyDataDir/,RECURSE:,REGEX:.*}``。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:287
msgid "Hash Algorithms"
msgstr "哈希算法"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:289
msgid "The following hash algorithms are supported::"
msgstr "支持以下哈希算法："

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:304
msgid "Added the ``SHA3_*`` hash algorithms."
msgstr "添加了``SHA3_*`` 哈希算法。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:307
msgid ""
"Note that the hashes are used only for unique data identification and "
"download verification."
msgstr "请注意，哈希仅用于唯一数据标识和下载验证。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:313
msgid "Custom Fetch Scripts"
msgstr "自定义获取脚本"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:317
msgid ""
"When a data file must be fetched from one of the URL templates specified "
"in the ``ExternalData_URL_TEMPLATES`` variable, it is normally downloaded "
"using the :command:`file(DOWNLOAD)` command. One may specify usage of a "
"custom fetch script by using a URL template of the form "
"``ExternalDataCustomScript://<key>/<loc>``. The ``<key>`` must be a C "
"identifier, and the ``<loc>`` must contain the ``%(algo)`` and ``%(hash)``"
" placeholders. A variable corresponding to the key, "
"``ExternalData_CUSTOM_SCRIPT_<key>``, must be set to the full path to a "
"``.cmake`` script file.  The script will be included to perform the actual"
" fetch, and provided with the following variables:"
msgstr ""
"当必须从 ``ExternalData_URL_TEMPLATES`` 变量中指定的 URL 模板之一获取数据文件时，通常使用 "
":command:`file(DOWNLOAD)` 命令下载。可以通过使用 "
"``ExternalDataCustomScript://<key>/<loc>`` 形式的 URL 模板来指定自定义获取脚本的使用。 "
"``<key>`` 必须是 C 标识符，``<loc>`` 必须包含 ``%(algo)`` 和 ``%(hash)`` "
"占位符。与键对应的变量，``ExternalData_CUSTOM_SCRIPT_<key>``，必须设置为``.cmake``脚本文件的完整路径。该脚本将被包含以执行实际的提取，并提供以下变量："

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:331
msgid ""
"When a custom fetch script is loaded, this variable is set to the location"
" part of the URL, which will contain the substituted hash algorithm name "
"and content hash value."
msgstr "加载自定义提取脚本时，此变量将设置为 URL 的位置部分，其中将包含替换的哈希算法名称和内容哈希值。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:337
msgid ""
"When a custom fetch script is loaded, this variable is set to the full "
"path to a file in which the script must store the fetched content.  The "
"name of the file is unspecified and should not be interpreted in any way."
msgstr "加载自定义提取脚本时，此变量将设置为脚本必须存储提取内容的文件的完整路径。该文件的名称未指定，不应以任何方式进行解释。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:342
msgid ""
"The custom fetch script is expected to store fetched content in the file "
"or set a variable:"
msgstr "自定义获取脚本应该将获取的内容存储在文件中或设置一个变量："

#: ../../cmake-prefix/src/cmake/Modules/ExternalData.cmake:347
msgid ""
"When a custom fetch script fails to fetch the requested content, it must "
"set this variable to a short one-line message describing the reason for "
"failure."
msgstr "当自定义获取脚本无法获取请求的内容时，它必须将此变量设置为一条简短的单行消息，描述失败的原因。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:8
msgid "ExternalProject"
msgstr "外部项目"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:18
msgid "External Project Definition"
msgstr "外部项目定义"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:22
msgid ""
"The ``ExternalProject_Add()`` function creates a custom target to drive "
"download, update/patch, configure, build, install and test steps of an "
"external project:"
msgstr ""
"``ExternalProject_Add()`` 函数创建一个自定义目标来驱动外部项目的下载、更新/补丁、配置、构建、安装和测试步骤："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:30
msgid ""
"The individual steps within the process can be driven independently if "
"required (e.g. for CDash submission) and extra custom steps can be "
"defined, along with the ability to control the step dependencies. The "
"directory structure used for the management of the external project can "
"also be customized. The function supports a large number of options which "
"can be used to tailor the external project behavior."
msgstr ""
"如果需要（例如，对于 CDash "
"提交），流程中的各个步骤可以独立驱动，并且可以定义额外的自定义步骤，以及控制步骤依赖性的能力。也可以自定义用于管理外部项目的目录结构。该功能支持大量选项，可用于定制外部项目行为。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:122
msgid "**Directory Options:**"
msgstr "**目录选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:38
msgid ""
"Most of the time, the default directory layout is sufficient. It is "
"largely an implementation detail that the main project usually doesn't "
"need to change. In some circumstances, however, control over the directory"
" layout can be useful or necessary. The directory options are potentially "
"more useful from the point of view that the main build can use the "
":command:`ExternalProject_Get_Property` command to retrieve their values, "
"thereby allowing the main project to refer to build artifacts of the "
"external project."
msgstr ""
"大多数时候，默认的目录布局就足够了。它主要是主要项目通常不需要更改的实现细节。然而，在某些情况下，控制目录布局可能是有用的或必要的。从主构建可以使用"
" ExternalProject_Get_Property 命令检索它们的值的角度来看，目录选项可能更有用，从而允许主项目引用外部项目的构建工件。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:50
msgid "``PREFIX <dir>``"
msgstr "``前缀<目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:48
msgid ""
"Root directory for the external project. Unless otherwise noted below, all"
" other directories associated with the external project will be created "
"under here."
msgstr "外部项目的根目录。除非下面另有说明，否则与外部项目关联的所有其他目录都将在此处创建。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:53
msgid "``TMP_DIR <dir>``"
msgstr "``TMP_DIR <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:53
msgid "Directory in which to store temporary files."
msgstr "存储临时文件的目录。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:58
msgid "``STAMP_DIR <dir>``"
msgstr "``STAMP_DIR <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:56
msgid ""
"Directory in which to store the timestamps of each step. Log files from "
"individual steps are also created in here unless overridden by LOG_DIR "
"(see *Logging Options* below)."
msgstr "存储每个步骤的时间戳的目录。来自各个步骤的日志文件也在这里创建，除非被 LOG_DIR 覆盖（参见下面的*日志选项*）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:63
msgid "``LOG_DIR <dir>``"
msgstr "``LOG_DIR <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:63
msgid "Directory in which to store the logs of each step."
msgstr "存放每一步日志的目录。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:68
msgid "``DOWNLOAD_DIR <dir>``"
msgstr "``DOWNLOAD_DIR <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:66
msgid ""
"Directory in which to store downloaded files before unpacking them. This "
"directory is only used by the URL download method, all other download "
"methods use ``SOURCE_DIR`` directly instead."
msgstr "解压前存储下载文件的目录。此目录仅供 URL 下载方法使用，所有其他下载方法直接使用 ``SOURCE_DIR`` 代替。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:83
msgid "``SOURCE_DIR <dir>``"
msgstr "``SOURCE_DIR <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:71
msgid ""
"Source directory into which downloaded contents will be unpacked, or for "
"non-URL download methods, the directory in which the repository should be "
"checked out, cloned, etc. If no download method is specified, this must "
"point to an existing directory where the external project has already been"
" unpacked or cloned/checked out."
msgstr ""
"下载的内容将被解压到的源目录，或者对于非 URL "
"下载方法，存储库应该被检出、克隆等的目录。如果没有指定下载方法，这必须指向一个现有的目录，其中外部项目已经解压或克隆/签出。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:78
msgid ""
"If a download method is specified, any existing contents of the source "
"directory may be deleted. Only the URL download method checks whether this"
" directory is either missing or empty before initiating the download, "
"stopping with an error if it is not empty. All other download methods "
"silently discard any previous contents of the source directory."
msgstr ""
"如果指定了下载方法，则可能会删除源目录中的任何现有内容。只有 URL "
"下载方法会在开始下载之前检查此目录是否丢失或为空，如果不为空则停止并报错。所有其他下载方法都会默默地丢弃源目录中以前的任何内容。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:87
msgid "``BINARY_DIR <dir>``"
msgstr "``BINARY_DIR <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:86
msgid ""
"Specify the build directory location. This option is ignored if "
"``BUILD_IN_SOURCE`` is enabled."
msgstr "指定构建目录位置。如果启用“BUILD_IN_SOURCE”，则忽略此选项。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:93
msgid "``INSTALL_DIR <dir>``"
msgstr "``INSTALL_DIR <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:90
msgid ""
"Installation prefix to be placed in the ``<INSTALL_DIR>`` placeholder. "
"This does not actually configure the external project to install to the "
"given prefix. That must be done by passing appropriate arguments to the "
"external project configuration step, e.g. using ``<INSTALL_DIR>``."
msgstr ""
"安装前缀放在 ``<INSTALL_DIR>`` "
"占位符中。这实际上并没有配置外部项目安装到给定的前缀。这必须通过将适当的参数传递给外部项目配置步骤来完成，例如使用``<INSTALL_DIR>``。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:95
msgid ""
"If any of the above ``..._DIR`` options are not specified, their defaults "
"are computed as follows. If the ``PREFIX`` option is given or the "
"``EP_PREFIX`` directory property is set, then an external project is built"
" and installed under the specified prefix::"
msgstr ""
"如果未指定上述任何 ``..._DIR`` 选项，则它们的默认值计算如下。如果给出了 ``PREFIX`` 选项或设置了 ``EP_PREFIX``"
" 目录属性，那么将在指定的前缀下构建和安装外部项目 ::"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:108
msgid ""
"Otherwise, if the ``EP_BASE`` directory property is set then components of"
" an external project are stored under the specified base::"
msgstr "否则，如果设置了 ``EP_BASE`` 目录属性，则外部项目的组件将存储在指定的 base::"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:119
msgid ""
"If no ``PREFIX``, ``EP_PREFIX``, or ``EP_BASE`` is specified, then the "
"default is to set ``PREFIX`` to ``<name>-prefix``. Relative paths are "
"interpreted with respect to :variable:`CMAKE_CURRENT_BINARY_DIR` at the "
"point where ``ExternalProject_Add()`` is called."
msgstr ""
"如果未指定 ``PREFIX``、``EP_PREFIX`` 或 ``EP_BASE``，则默认设置 ``PREFIX`` 为 "
"``<name>-prefix``。相对路径在调用 ExternalProject_Add() 时根据 "
"CMAKE_CURRENT_BINARY_DIR 进行解释。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:429
msgid "**Download Step Options:**"
msgstr "**下载步骤选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:125
msgid ""
"A download method can be omitted if the ``SOURCE_DIR`` option is used to "
"point to an existing non-empty directory. Otherwise, one of the download "
"methods below must be specified (multiple download methods should not be "
"given) or a custom ``DOWNLOAD_COMMAND`` provided."
msgstr ""
"如果 ``SOURCE_DIR`` "
"选项用于指向现有的非空目录，则可以省略下载方法。否则，必须指定以下下载方法之一（不应提供多种下载方法）或提供自定义的“DOWNLOAD_COMMAND”。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:135
msgid "``DOWNLOAD_COMMAND <cmd>...``"
msgstr "``DOWNLOAD_COMMAND <cmd> ...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:131
msgid ""
"Overrides the command used for the download step (:manual:`generator "
"expressions <cmake-generator-expressions(7)>` are supported). If this "
"option is specified, all other download options will be ignored. Providing"
" an empty string for ``<cmd>`` effectively disables the download step."
msgstr ""
"覆盖用于下载步骤的命令（支持 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`）。如果指定此选项，所有其他下载选项将被忽略。为 ``<cmd>`` 提供一个空字符串可以有效地禁用下载步骤。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:271
msgid "*URL Download*"
msgstr "*网址下载*"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:152
msgid "``URL <url1> [<url2>...]``"
msgstr "``URL <url1> [<url2>...]``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:139
msgid ""
"List of paths and/or URL(s) of the external project's source. When more "
"than one URL is given, they are tried in turn until one succeeds. A URL "
"may be an ordinary path in the local file system (in which case it must be"
" the only URL provided) or any downloadable URL supported by the "
":command:`file(DOWNLOAD)` command. A local filesystem path may refer to "
"either an existing directory or to an archive file, whereas a URL is "
"expected to point to a file which can be treated as an archive. When an "
"archive is used, it will be unpacked automatically unless the "
"``DOWNLOAD_NO_EXTRACT`` option is set to prevent it. The archive type is "
"determined by inspecting the actual content rather than using logic based "
"on the file extension."
msgstr ""
"外部项目源的路径和/或 URL 列表。当给出多个 URL 时，将依次尝试，直到一个成功。 URL "
"可以是本地文件系统中的普通路径（在这种情况下，它必须是唯一提供的 URL）或 :command:`file(DOWNLOAD)` "
"命令支持的任何可下载 URL。本地文件系统路径可以引用现有目录或存档文件，而 URL "
"应指向可被视为存档的文件。使用存档时，它将自动解压缩，除非设置了 ``DOWNLOAD_NO_EXTRACT`` "
"选项来阻止它。存档类型是通过检查实际内容而不是使用基于文件扩展名的逻辑来确定的。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:151
msgid "Multiple URLs are allowed."
msgstr "允许多个 URL。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:162
msgid "``URL_HASH <algo>=<hashValue>``"
msgstr "``URL_HASH <算法>=<哈希值>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:155
msgid ""
"Hash of the archive file to be downloaded. The argument should be of the "
"form ``<algo>=<hashValue>`` where ``algo`` can be any of the hashing "
"algorithms supported by the :command:`file()` command. Specifying this "
"option is strongly recommended for URL downloads, as it ensures the "
"integrity of the downloaded content. It is also used as a check for a "
"previously downloaded file, allowing connection to the remote location to "
"be avoided altogether if the local directory already has a file from an "
"earlier download that matches the specified hash."
msgstr ""
"要下载的存档文件的哈希值。参数的形式应为``<algo>=<hashValue>``，其中``algo`` 可以是 :command:`file()`"
" 命令支持的任何哈希算法。强烈建议为 URL "
"下载指定此选项，因为它可确保下载内容的完整性。它还用于检查先前下载的文件，如果本地目录已经有来自较早下载的与指定哈希匹配的文件，则允许完全避免连接到远程位置。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:165
msgid "``URL_MD5 <md5>``"
msgstr "``URL_MD5 <md5>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:165
msgid "Equivalent to ``URL_HASH MD5=<md5>``."
msgstr "相当于 ``URL_HASH MD5=<md5>``。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:171
msgid "``DOWNLOAD_NAME <fname>``"
msgstr "``DOWNLOAD_NAME <fname>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:168
msgid ""
"File name to use for the downloaded file. If not given, the end of the URL"
" is used to determine the file name. This option is rarely needed, the "
"default name is generally suitable and is not normally used outside of "
"code internal to the ``ExternalProject`` module."
msgstr ""
"用于下载文件的文件名。如果未给出，则 URL 的末尾用于确定文件名。很少需要这个选项，默认名称通常是合适的，通常不会在 "
"``ExternalProject`` 模块的内部代码之外使用。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:184
msgid "``DOWNLOAD_EXTRACT_TIMESTAMP <bool>``"
msgstr "``DOWNLOAD_EXTRACT_TIMESTAMP <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:176
msgid ""
"When specified with a true value, the timestamps of the extracted files "
"will match those in the archive. When false, the timestamps of the "
"extracted files will reflect the time at which the extraction was "
"performed. If the download URL changes, timestamps based off those in the "
"archive can result in dependent targets not being rebuilt when they "
"potentially should have been. Therefore, unless the file timestamps are "
"significant to the project in some way, use a false value for this option."
" If ``DOWNLOAD_EXTRACT_TIMESTAMP`` is not given, the default is false. See"
" policy :policy:`CMP0135`."
msgstr ""
"当使用真值指定时，提取文件的时间戳将与存档中的时间戳匹配。如果为 false，提取文件的时间戳将反映执行提取的时间。如果下载 URL "
"发生变化，基于存档中时间戳的时间戳可能会导致依赖目标在可能应该重建时未重建。因此，除非文件时间戳在某种程度上对项目很重要，否则请为此选项使用假值。如果未给出"
" ``DOWNLOAD_EXTRACT_TIMESTAMP``，则默认为 false。请参阅政策:policy:`CMP0135`。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:195
msgid "``DOWNLOAD_NO_EXTRACT <bool>``"
msgstr "``DOWNLOAD_NO_EXTRACT <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:189
msgid ""
"Allows the extraction part of the download step to be disabled by passing "
"a boolean true value for this option. If this option is not given, the "
"downloaded contents will be unpacked automatically if required. If "
"extraction has been disabled, the full path to the downloaded file is "
"available as ``<DOWNLOADED_FILE>`` in subsequent steps or as the property "
"``DOWNLOADED_FILE`` with the :command:`ExternalProject_Get_Property` "
"command."
msgstr ""
"允许通过为此选项传递一个布尔真值来禁用下载步骤的提取部分。如果没有给出这个选项，下载的内容将在需要时自动解压。如果已禁用提取，则下载文件的完整路径可在后续步骤中作为“<DOWNLOADED_FILE>”使用，或作为属性“DOWNLOADED_FILE”使用 :command:“ExternalProject_Get_Property”命令使用。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:199
msgid "``DOWNLOAD_NO_PROGRESS <bool>``"
msgstr "``DOWNLOAD_NO_PROGRESS <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:198
msgid ""
"Can be used to disable logging the download progress. If this option is "
"not given, download progress messages will be logged."
msgstr "可用于禁用记录下载进度。如果未给出此选项，将记录下载进度消息。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:202
msgid "``TIMEOUT <seconds>``"
msgstr "``超时<秒>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:202
msgid "Maximum time allowed for file download operations."
msgstr "文件下载操作允许的最长时间。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:207
msgid "``INACTIVITY_TIMEOUT <seconds>``"
msgstr "``INACTIVITY_TIMEOUT <秒数>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:207
msgid "Terminate the operation after a period of inactivity."
msgstr "一段时间不活动后终止操作。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:212
msgid "``HTTP_USERNAME <username>``"
msgstr "``HTTP_USERNAME <用户名>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:212
msgid "Username for the download operation if authentication is required."
msgstr "如果需要身份验证，则为下载操作的用户名。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:217
msgid "``HTTP_PASSWORD <password>``"
msgstr "``HTTP_PASSWORD <密码>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:217
msgid "Password for the download operation if authentication is required."
msgstr "如果需要身份验证，则为下载操作的密码。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:223
msgid "``HTTP_HEADER <header1> [<header2>...]``"
msgstr "``HTTP_HEADER <header1> [<header2>...]``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:222
msgid ""
"Provides an arbitrary list of HTTP headers for the download operation. "
"This can be useful for accessing content in systems like AWS, etc."
msgstr "为下载操作提供任意 HTTP 标头列表。这对于访问 AWS 等系统中的内容很有用。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:235
msgid "``TLS_VERIFY <bool>``"
msgstr "``TLS_VERIFY <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:226
msgid ""
"Specifies whether certificate verification should be performed for https "
"URLs. If this option is not provided, the default behavior is determined "
"by the :variable:`CMAKE_TLS_VERIFY` variable (see "
":command:`file(DOWNLOAD)`). If that is also not set, certificate "
"verification will not be performed. In situations where ``URL_HASH`` "
"cannot be provided, this option can be an alternative verification "
"measure."
msgstr ""
"指定是否应对 https URL 执行证书验证。如果未提供此选项，则默认行为由 :variable:`CMAKE_TLS_VERIFY` "
"变量确定（参见 :command:`file(DOWNLOAD)`）。如果也没有设置，则不会执行证书验证。在无法提供 ``URL_HASH`` "
"的情况下，此选项可以作为替代验证措施。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:234
msgid "This option also applies to ``git clone`` invocations."
msgstr "此选项也适用于 ``git clone`` 调用。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:241
msgid "``TLS_CAINFO <file>``"
msgstr "``TLS_CAINFO <文件>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:238
msgid ""
"Specify a custom certificate authority file to use if ``TLS_VERIFY`` is "
"enabled. If this option is not specified, the value of the "
":variable:`CMAKE_TLS_CAINFO` variable will be used instead (see "
":command:`file(DOWNLOAD)`)"
msgstr ""
"如果启用了“TLS_VERIFY”，请指定要使用的自定义证书颁发机构文件。如果未指定此选项，则将使用 "
":variable:`CMAKE_TLS_CAINFO` 变量的值（参见 :command:`file(DOWNLOAD)`）"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:260
msgid "``NETRC <level>``"
msgstr "``NETRC <级别>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:246
msgid ""
"Specify whether the ``.netrc`` file is to be used for operation. If this "
"option is not specified, the value of the :variable:`CMAKE_NETRC` variable"
" will be used instead (see :command:`file(DOWNLOAD)`).  Valid levels are:"
msgstr ""
"指定是否使用 ``.netrc`` 文件进行操作。如果未指定此选项，则将使用 :variable:`CMAKE_NETRC` 变量的值（参见 "
":command:`file(DOWNLOAD)`）。有效级别是："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:252
msgid "``IGNORED``"
msgstr "``忽略``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:252
msgid "The ``.netrc`` file is ignored. This is the default."
msgstr "``.netrc`` 文件被忽略。这是默认设置。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:256
msgid "``OPTIONAL``"
msgstr "``可选的``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:255
msgid ""
"The ``.netrc`` file is optional, and information in the URL is preferred."
"  The file will be scanned to find which ever information is not specified"
" in the URL."
msgstr "``.netrc`` 文件是可选的，URL 中的信息是首选。将扫描文件以查找 URL 中未指定的信息。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:260
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:91
msgid "``REQUIRED``"
msgstr "``需要``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:259
msgid ""
"The ``.netrc`` file is required, and information in the URL is ignored."
msgstr "``.netrc`` 文件是必需的，URL 中的信息将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:268
msgid "``NETRC_FILE <file>``"
msgstr "``NETRC_FILE <文件>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:265
msgid ""
"Specify an alternative ``.netrc`` file to the one in your home directory "
"if the ``NETRC`` level is ``OPTIONAL`` or ``REQUIRED``. If this option is "
"not specified, the value of the :variable:`CMAKE_NETRC_FILE` variable will"
" be used instead (see :command:`file(DOWNLOAD)`)"
msgstr ""
"如果 ``NETRC`` 级别是 ``OPTIONAL`` 或 ``REQUIRED``，请在您的主目录中指定一个替代的 ``.netrc`` "
"文件。如果未指定此选项，将使用 :variable:`CMAKE_NETRC_FILE` 变量的值（参见 "
":command:`file(DOWNLOAD)`）"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:270
msgid "Added support for `tbz2`, `.tar.xz`, `.txz`, and `.7z` extensions."
msgstr "添加了对“tbz2”、“.tar.xz”、“.txz”和“.7z”扩展名的支持。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:394
msgid "*Git*"
msgstr "*混帐*"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:274
msgid ""
"NOTE: A git version of 1.6.5 or later is required if this download method "
"is used."
msgstr "注意：如果使用这种下载方式，则需要 git 1.6.5 或更高版本。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:279
msgid "``GIT_REPOSITORY <url>``"
msgstr "``GIT_REPOSITORY <url>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:278
msgid ""
"URL of the git repository. Any URL understood by the ``git`` command may "
"be used."
msgstr "git 存储库的 URL。可以使用 ``git`` 命令理解的任何 URL。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:305
msgid "``GIT_TAG <tag>``"
msgstr "``GIT_TAG <标签>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:282
msgid ""
"Git branch name, tag or commit hash. Note that branch names and tags "
"should generally be specified as remote names (i.e. ``origin/myBranch`` "
"rather than simply ``myBranch``). This ensures that if the remote end has "
"its tag moved or branch rebased or history rewritten, the local clone will"
" still be updated correctly. In general, however, specifying a commit hash"
" should be preferred for a number of reasons:"
msgstr ""
"Git 分支名称、标记或提交哈希。请注意，分支名称和标签通常应指定为远程名称（即 ``origin/myBranch`` 而不是简单的 "
"``myBranch``）。这确保了如果远程端的标签被移动或分支变基或历史重写，本地克隆仍将正确更新。但是，一般来说，出于多种原因，应该首选指定提交哈希："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:289
msgid ""
"If the local clone already has the commit corresponding to the hash, no "
"``git fetch`` needs to be performed to check for changes each time CMake "
"is re-run. This can result in a significant speed up if many external "
"projects are being used."
msgstr ""
"如果本地克隆已经有哈希对应的提交，则每次重新运行 CMake 时都不需要执行 ``git fetch`` "
"来检查更改。如果使用许多外部项目，这可能会显着加快速度。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:293
msgid ""
"Using a specific git hash ensures that the main project's own history is "
"fully traceable to a specific point in the external project's evolution. "
"If a branch or tag name is used instead, then checking out a specific "
"commit of the main project doesn't necessarily pin the whole build to a "
"specific point in the life of the external project. The lack of such "
"deterministic behavior makes the main project lose traceability and "
"repeatability."
msgstr ""
"使用特定的 git hash "
"可确保主项目自身的历史完全可追溯至外部项目演变中的特定点。如果改用分支或标记名称，则签出主项目的特定提交不一定会将整个构建固定到外部项目生命周期中的特定点。这种确定性行为的缺乏使得主项目失去了可追溯性和可重复性。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:301
msgid ""
"If ``GIT_SHALLOW`` is enabled then ``GIT_TAG`` works only with branch "
"names and tags.  A commit hash is not allowed."
msgstr "如果启用了 ``GIT_SHALLOW`` 则 ``GIT_TAG`` 仅适用于分支名称和标签。不允许提交哈希。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:304
msgid ""
"Note that if not provided, ``GIT_TAG`` defaults to ``master``, not the "
"default Git branch name."
msgstr "请注意，如果未提供，``GIT_TAG`` 默认为 ``master``，而不是默认的 Git 分支名称。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:309
msgid "``GIT_REMOTE_NAME <name>``"
msgstr "``GIT_REMOTE_NAME <名称>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:308
msgid ""
"The optional name of the remote. If this option is not specified, it "
"defaults to ``origin``."
msgstr "遥控器的可选名称。如果未指定此选项，则默认为 ``origin``。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:317
msgid "``GIT_SUBMODULES <module>...``"
msgstr "``GIT_SUBMODULES <模块>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:312
msgid ""
"Specific git submodules that should also be updated. If this option is not"
" provided, all git submodules will be updated."
msgstr "还应更新的特定 git 子模块。如果未提供此选项，将更新所有 git 子模块。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:315
msgid ""
"When :policy:`CMP0097` is set to ``NEW``, if this value is set to an empty"
" string then no submodules are initialized or updated."
msgstr "当 CMP0097 设置为 NEW 时，如果此值设置为空字符串，则不会初始化或更新任何子模块。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:324
msgid "``GIT_SUBMODULES_RECURSE <bool>``"
msgstr "``GIT_SUBMODULES_RECURSE <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:322
msgid ""
"Specify whether git submodules (if any) should update recursively by "
"passing the ``--recursive`` flag to ``git submodule update``. If not "
"specified, the default is on."
msgstr ""
"通过将 ``--recursive`` 标志传递给 ``git submodule update`` 来指定 git "
"子模块（如果有的话）是否应该递归更新。如果未指定，则默认为打开。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:332
msgid "``GIT_SHALLOW <bool>``"
msgstr "``GIT_SHALLOW <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:329
msgid ""
"When this option is enabled, the ``git clone`` operation will be given the"
" ``--depth 1`` option. This performs a shallow clone, which avoids "
"downloading the whole history and instead retrieves just the commit "
"denoted by the ``GIT_TAG`` option."
msgstr ""
"启用此选项后，``git clone`` 操作将被赋予``--depth 1`` 选项。这执行了一个浅克隆，避免下载整个历史，而是只检索由 "
"``GIT_TAG`` 选项表示的提交。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:343
msgid "``GIT_PROGRESS <bool>``"
msgstr "``GIT_PROGRESS <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:337
msgid ""
"When enabled, this option instructs the ``git clone`` operation to report "
"its progress by passing it the ``--progress`` option. Without this option,"
" the clone step for large projects may appear to make the build stall, "
"since nothing will be logged until the clone operation finishes. While "
"this option can be used to provide progress to prevent the appearance of "
"the build having stalled, it may also make the build overly noisy if lots "
"of external projects are used."
msgstr ""
"启用后，此选项指示 ``git clone`` 操作通过将 ``--progress`` "
"选项传递给它来报告其进度。如果没有此选项，大型项目的克隆步骤可能会使构建停滞，因为在克隆操作完成之前不会记录任何内容。虽然此选项可用于提供进度以防止构建出现停滞，但如果使用大量外部项目，它也可能使构建过于嘈杂。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:351
msgid "``GIT_CONFIG <option1> [<option2>...]``"
msgstr "``GIT_CONFIG <option1> [<option2>...]``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:348
msgid ""
"Specify a list of config options to pass to ``git clone``. Each option "
"listed will be transformed into its own ``--config <option>`` on the ``git"
" clone`` command line, with each option required to be in the form "
"``key=value``."
msgstr ""
"指定要传递给 ``git clone`` 的配置选项列表。列出的每个选项都将在 ``git clone`` 命令行上转换为它自己的 "
"``--config <option>``，每个选项都需要采用 ``key=value`` 的形式。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:394
msgid "``GIT_REMOTE_UPDATE_STRATEGY <strategy>``"
msgstr "``GIT_REMOTE_UPDATE_STRATEGY <策略>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:356
msgid ""
"When ``GIT_TAG`` refers to a remote branch, this option can be used to "
"specify how the update step behaves.  The ``<strategy>`` must be one of "
"the following:"
msgstr "当 ``GIT_TAG`` 引用远程分支时，此选项可用于指定更新步骤的行为方式。 ``<strategy>`` 必须是以下之一："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:362
msgid "``CHECKOUT``"
msgstr "``结帐``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:361
msgid ""
"Ignore the local branch and always checkout the branch specified by "
"``GIT_TAG``."
msgstr "忽略本地分支并始终检查由 ``GIT_TAG`` 指定的分支。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:375
msgid "``REBASE``"
msgstr "``重置``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:365
msgid ""
"Try to rebase the current branch to the one specified by ``GIT_TAG``. If "
"there are local uncommitted changes, they will be stashed first and popped"
" again after rebasing.  If rebasing or popping stashed changes fail, abort"
" the rebase and halt with an error. When ``GIT_REMOTE_UPDATE_STRATEGY`` is"
" not present, this is the default strategy unless the default has been "
"overridden with ``CMAKE_EP_GIT_REMOTE_UPDATE_STRATEGY`` (see below). Note "
"that if the branch specified in ``GIT_TAG`` is different to the upstream "
"branch currently being tracked, it is not safe to perform a rebase. In "
"that situation, ``REBASE`` will silently be treated as ``CHECKOUT`` "
"instead."
msgstr ""
"尝试将当前分支变基为 ``GIT_TAG`` 指定的分支。如果有本地未提交的更改，它们将首先被隐藏并在 rebase "
"后再次弹出。如果变基或弹出隐藏的更改失败，则中止变基并因错误而停止。当 ``GIT_REMOTE_UPDATE_STRATEGY`` "
"不存在时，这是默认策略，除非默认策略已被 ``CMAKE_EP_GIT_REMOTE_UPDATE_STRATEGY`` "
"覆盖（见下文）。请注意，如果 ``GIT_TAG`` 中指定的分支与当前正在跟踪的上游分支不同，则执行 rebase "
"是不安全的。在这种情况下，``REBASE`` 将被默默地视为 ``CHECKOUT``。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:386
msgid "``REBASE_CHECKOUT``"
msgstr "``REBASE_CHECKOUT``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:378
msgid ""
"Same as ``REBASE`` except if the rebase fails, an annotated tag will be "
"created at the original ``HEAD`` position from before the rebase and then "
"checkout ``GIT_TAG`` just like the ``CHECKOUT`` strategy. The message "
"stored on the annotated tag will give information about what was attempted"
" and the tag name will include a timestamp so that each failed run will "
"add a new tag.  This strategy ensures no changes will be lost, but updates"
" should always succeed if ``GIT_TAG`` refers to a valid ref unless there "
"are uncommitted changes that cannot be popped successfully."
msgstr ""
"与 ``REBASE`` 相同，除非变基失败，将在变基之前的原始 ``HEAD`` 位置创建带注释的标签，然后像 ``CHECKOUT`` "
"策略一样检出 "
"``GIT_TAG``。存储在注释标签上的消息将提供有关尝试的信息，标签名称将包含时间戳，以便每次失败的运行都会添加一个新标签。此策略确保不会丢失任何更改，但如果"
" ``GIT_TAG`` 引用有效引用，则更新应该始终成功，除非存在无法成功弹出的未提交更改。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:388
msgid ""
"The variable ``CMAKE_EP_GIT_REMOTE_UPDATE_STRATEGY`` can be set to "
"override the default strategy.  This variable should not be set by a "
"project, it is intended for the user to set.  It is primarily intended for"
" use in continuous integration scripts to ensure that when history is "
"rewritten on a remote branch, the build doesn't end up with unintended "
"changes or failed builds resulting from conflicts during rebase "
"operations."
msgstr ""
"可以设置变量“CMAKE_EP_GIT_REMOTE_UPDATE_STRATEGY”来覆盖默认策略。此变量不应由项目设置，它旨在供用户设置。它主要用于持续集成脚本，以确保在远程分支上重写历史时，构建不会以意外更改或因变基操作期间的冲突而导致构建失败而告终。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:412
msgid "*Subversion*"
msgstr "*颠覆*"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:398
msgid "``SVN_REPOSITORY <url>``"
msgstr "``SVN_REPOSITORY <url>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:398
msgid "URL of the Subversion repository."
msgstr "Subversion 存储库的 URL。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:401
msgid "``SVN_REVISION -r<rev>``"
msgstr "``SVN_REVISION -r<rev>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:401
msgid "Revision to checkout from the Subversion repository."
msgstr "从 Subversion 存储库中检出的修订。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:404
msgid "``SVN_USERNAME <username>``"
msgstr "``SVN_USERNAME <用户名>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:404
msgid "Username for the Subversion checkout and update."
msgstr "Subversion 检出和更新的用户名。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:407
msgid "``SVN_PASSWORD <password>``"
msgstr "``SVN_PASSWORD <密码>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:407
msgid "Password for the Subversion checkout and update."
msgstr "Subversion 检出和更新的密码。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:412
msgid "``SVN_TRUST_CERT <bool>``"
msgstr "``SVN_TRUST_CERT <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:410
msgid ""
"Specifies whether to trust the Subversion server site certificate. If "
"enabled, the ``--trust-server-cert`` option is passed to the ``svn`` "
"checkout and update commands."
msgstr ""
"指定是否信任 Subversion 服务器站点证书。如果启用，``--trust-server-cert`` 选项将传递给 ``svn`` "
"checkout 和 update 命令。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:419
msgid "*Mercurial*"
msgstr "*水银*"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:416
msgid "``HG_REPOSITORY <url>``"
msgstr "``HG_REPOSITORY <url>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:416
msgid "URL of the mercurial repository."
msgstr "Mercurial 存储库的 URL。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:419
msgid "``HG_TAG <tag>``"
msgstr "``HG_TAG <标签>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:419
msgid "Mercurial branch name, tag or commit id."
msgstr "Mercurial 分支名称、标记或提交 ID。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:429
msgid "*CVS*"
msgstr "*简历*"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:423
msgid "``CVS_REPOSITORY <cvsroot>``"
msgstr "``CVS_REPOSITORY <cvsroot>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:423
msgid "CVSROOT of the CVS repository."
msgstr "CVS 存储库的 CVSROOT。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:426
msgid "``CVS_MODULE <mod>``"
msgstr "``CVS_MODULE <mod>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:426
msgid "Module to checkout from the CVS repository."
msgstr "从 CVS 存储库检出的模块。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:429
msgid "``CVS_TAG <tag>``"
msgstr "``CVS_TAG <标签>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:429
msgid "Tag to checkout from the CVS repository."
msgstr "从 CVS 存储库签出的标记。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:464
msgid "**Update Step Options:**"
msgstr "**更新步骤选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:432
msgid ""
"Whenever CMake is re-run, by default the external project's sources will "
"be updated if the download method supports updates (e.g. a git repository "
"would be checked if the ``GIT_TAG`` does not refer to a specific commit)."
msgstr ""
"每当重新运行 CMake 时，如果下载方法支持更新，默认情况下将更新外部项目的源代码（例如，如果 ``GIT_TAG`` 未引用特定提交，将检查 "
"git 存储库）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:439
msgid "``UPDATE_COMMAND <cmd>...``"
msgstr "``UPDATE_COMMAND <cmd> ...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:437
msgid ""
"Overrides the download method's update step with a custom command. The "
"command may use :manual:`generator expressions <cmake-generator-"
"expressions(7)>`."
msgstr ""
"使用自定义命令覆盖下载方法的更新步骤。该命令可以使用 :manual:`generator expressions <cmake-"
"generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:464
msgid "``UPDATE_DISCONNECTED <bool>``"
msgstr "``UPDATE_DISCONNECTED <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:444
msgid ""
"When enabled, this option causes the update step to be skipped. It does "
"not, however, prevent the download step. The update step can still be "
"added as a step target (see :command:`ExternalProject_Add_StepTargets`) "
"and called manually. This is useful if you want to allow developers to "
"build the project when disconnected from the network (the network may "
"still be needed for the download step though)."
msgstr ""
"启用后，此选项会导致跳过更新步骤。但是，它不会阻止下载步骤。更新步骤仍然可以添加为步骤目标（请参阅 :command:`ExternalProject_Add_StepTargets`）并手动调用。如果您希望允许开发人员在断开网络连接时构建项目（尽管下载步骤可能仍需要网络），这将很有用。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:451
msgid ""
"When this option is present, it is generally advisable to make the value a"
" cache variable under the developer's control rather than hard-coding it. "
"If this option is not present, the default value is taken from the "
"``EP_UPDATE_DISCONNECTED`` directory property. If that is also not "
"defined, updates are performed as normal. The ``EP_UPDATE_DISCONNECTED`` "
"directory property is intended as a convenience for controlling the "
"``UPDATE_DISCONNECTED`` behavior for an entire section of a project's "
"directory hierarchy and may be a more convenient method of giving "
"developers control over whether or not to perform updates (assuming the "
"project also provides a cache variable or some other convenient method for"
" setting the directory property)."
msgstr ""
"当存在此选项时，通常建议将该值设为开发人员控制下的缓存变量，而不是对其进行硬编码。如果此选项不存在，则默认值取自 "
"``EP_UPDATE_DISCONNECTED`` 目录属性。如果也未定义，则更新将照常执行。 "
"``EP_UPDATE_DISCONNECTED`` "
"目录属性旨在方便地控制项目目录层次结构的整个部分的``UPDATE_DISCONNECTED`` "
"行为，并且可能是让开发人员控制是否执行更新的更方便的方法（假设该项目还提供了一个缓存变量或其他一些方便的方法来设置目录属性）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:463
msgid ""
"This may cause a step target to be created automatically for the "
"``download`` step.  See policy :policy:`CMP0114`."
msgstr "这可能会导致为“下载”步骤自动创建一个步骤目标。请参阅政策:policy:`CMP0114`。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:473
msgid "**Patch Step Options:**"
msgstr "**补丁步骤选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:473
msgid "``PATCH_COMMAND <cmd>...``"
msgstr "``PATCH_COMMAND <cmd>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:468
msgid ""
"Specifies a custom command to patch the sources after an update. By "
"default, no patch command is defined. Note that it can be quite difficult "
"to define an appropriate patch command that performs robustly, especially "
"for download methods such as git where changing the ``GIT_TAG`` will not "
"discard changes from a previous patch, but the patch command will be "
"called again after updating to the new tag."
msgstr ""
"指定自定义命令以在更新后修补源。缺省情况下，没有定义补丁命令。请注意，定义一个能够稳健执行的适当补丁命令可能非常困难，特别是对于下载方法，例如 "
"git，其中更改 ``GIT_TAG`` 不会丢弃先前补丁的更改，但补丁命令将在之后再次调用更新到新标签。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:589
msgid "**Configure Step Options:**"
msgstr "**配置步骤选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:476
msgid ""
"The configure step is run after the download and update steps. By default,"
" the external project is assumed to be a CMake project, but this can be "
"overridden if required."
msgstr "配置步骤在下载和更新步骤之后运行。默认情况下，外部项目被假定为 CMake 项目，但如果需要可以覆盖它。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:493
msgid "``CONFIGURE_COMMAND <cmd>...``"
msgstr "``CONFIGURE_COMMAND <cmd>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:481
msgid ""
"The default configure command runs CMake with a few options based on the "
"main project.  The options added are typically only those needed to use "
"the same generator as the main project, but the ``CMAKE_GENERATOR`` option"
" can be given to override this.  The project is responsible for adding any"
" toolchain details, flags or other settings it wants to re-use from the "
"main project or otherwise specify (see ``CMAKE_ARGS``, "
"``CMAKE_CACHE_ARGS`` and ``CMAKE_CACHE_DEFAULT_ARGS`` below)."
msgstr ""
"默认配置命令使用基于主项目的一些选项运行 CMake。添加的选项通常只是那些需要使用与主项目相同的生成器的选项，但是可以给出 "
"``CMAKE_GENERATOR`` "
"选项来覆盖它。该项目负责添加任何工具链详细信息、标志或其他它想从主项目中重用或以其他方式指定的设置（请参阅下面的“CMAKE_ARGS”、“CMAKE_CACHE_ARGS”和“CMAKE_CACHE_DEFAULT_ARGS”）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:489
msgid ""
"For non-CMake external projects, the ``CONFIGURE_COMMAND`` option must be "
"used to override the default configure command (:manual:`generator "
"expressions <cmake-generator-expressions(7)>` are supported). For projects"
" that require no configure step, specify this option with an empty string "
"as the command to execute."
msgstr ""
"对于非 CMake 外部项目，必须使用 ``CONFIGURE_COMMAND`` "
"选项来覆盖默认的配置命令（支持:manual:`generator expressions <cmake-generator-"
"expressions(7)>`）。对于不需要配置步骤的项目，请使用空字符串指定此选项作为要执行的命令。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:500
msgid "``CMAKE_COMMAND /.../cmake``"
msgstr "``CMAKE_COMMAND /.../cmake``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:496
msgid ""
"Specify an alternative cmake executable for the configure step (use an "
"absolute path). This is generally not recommended, since it is usually "
"desirable to use the same CMake version throughout the whole build. This "
"option is ignored if a custom configure command has been specified with "
"``CONFIGURE_COMMAND``."
msgstr ""
"为配置步骤指定一个替代的 cmake 可执行文件（使用绝对路径）。通常不推荐这样做，因为通常希望在整个构建过程中使用相同的 CMake "
"版本。如果使用“CONFIGURE_COMMAND”指定了自定义配置命令，则忽略此选项。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:506
msgid "``CMAKE_GENERATOR <gen>``"
msgstr "``CMAKE_GENERATOR <gen>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:503
msgid ""
"Override the CMake generator used for the configure step. Without this "
"option, the same generator as the main build will be used. This option is "
"ignored if a custom configure command has been specified with the "
"``CONFIGURE_COMMAND`` option."
msgstr ""
"覆盖用于配置步骤的 CMake 生成器。如果没有此选项，将使用与主构建相同的生成器。如果使用 ``CONFIGURE_COMMAND`` "
"选项指定了自定义配置命令，则忽略此选项。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:513
msgid "``CMAKE_GENERATOR_PLATFORM <platform>``"
msgstr "``CMAKE_GENERATOR_PLATFORM <平台>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:511
msgid ""
"Pass a generator-specific platform name to the CMake command (see "
":variable:`CMAKE_GENERATOR_PLATFORM`). It is an error to provide this "
"option without the ``CMAKE_GENERATOR`` option."
msgstr ""
"将特定于生成器的平台名称传递给 CMake 命令（请参阅 :variable:`CMAKE_GENERATOR_PLATFORM`）。在没有 "
"``CMAKE_GENERATOR`` 选项的情况下提供此选项是错误的。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:518
msgid "``CMAKE_GENERATOR_TOOLSET <toolset>``"
msgstr "``CMAKE_GENERATOR_TOOLSET <工具集>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:516
msgid ""
"Pass a generator-specific toolset name to the CMake command (see "
":variable:`CMAKE_GENERATOR_TOOLSET`). It is an error to provide this "
"option without the ``CMAKE_GENERATOR`` option."
msgstr ""
"将特定于生成器的工具集名称传递给 CMake 命令（请参阅 :variable:`CMAKE_GENERATOR_TOOLSET`）。在没有 "
"``CMAKE_GENERATOR`` 选项的情况下提供此选项是错误的。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:525
msgid "``CMAKE_GENERATOR_INSTANCE <instance>``"
msgstr "``CMAKE_GENERATOR_INSTANCE <实例>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:523
msgid ""
"Pass a generator-specific instance selection to the CMake command (see "
":variable:`CMAKE_GENERATOR_INSTANCE`). It is an error to provide this "
"option without the ``CMAKE_GENERATOR`` option."
msgstr ""
"将特定于生成器的实例选择传递给 CMake 命令（请参阅 :variable:`CMAKE_GENERATOR_INSTANCE`）。在没有 "
"``CMAKE_GENERATOR`` 选项的情况下提供此选项是错误的。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:535
msgid "``CMAKE_ARGS <arg>...``"
msgstr "``CMAKE_ARGS <参数>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:528
msgid ""
"The specified arguments are passed to the :program:`cmake` command line. "
"They can be any argument the :program:`cmake` command understands, not "
"just cache values defined by ``-D...`` arguments (see also :manual:`CMake "
"Options <cmake(1)>`)."
msgstr ""
"指定的参数被传递到 :program:`cmake` 命令行。它们可以是 :program:`cmake` 命令理解的任何参数，而不仅仅是缓存由 "
"``-D...`` 参数定义的值（另请参见 :manual:`CMake Options <cmake(1)>`）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:533
#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:545
msgid ""
"Arguments may use :manual:`generator expressions <cmake-generator-"
"expressions(7)>`."
msgstr ""
"参数可以使用 :manual:`generator expressions <cmake-generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:547
msgid "``CMAKE_CACHE_ARGS <arg>...``"
msgstr "``CMAKE_CACHE_ARGS <arg>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:538
msgid ""
"This is an alternate way of specifying cache variables where command line "
"length issues may become a problem. The arguments are expected to be in "
"the form ``-Dvar:STRING=value``, which are then transformed into CMake "
":command:`set` commands with the ``FORCE`` option used. These ``set()`` "
"commands are written to a pre-load script which is then applied using the "
":manual:`cmake -C <cmake(1)>` command line option."
msgstr ""
"这是指定缓存变量的替代方法，其中命令行长度问题可能成为问题。参数应采用“-Dvar:STRING=value”的形式，然后使用“FORCE”选项将其转换为"
" CMake:command:`set` 命令。这些 ``set()`` 命令被写入预加载脚本，然后使用 :manual:`cmake -C "
"<cmake(1)>` 命令行选项应用该脚本。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:562
msgid "``CMAKE_CACHE_DEFAULT_ARGS <arg>...``"
msgstr "``CMAKE_CACHE_DEFAULT_ARGS <arg>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:552
msgid ""
"This is the same as the ``CMAKE_CACHE_ARGS`` option except the ``set()`` "
"commands do not include the ``FORCE`` keyword. This means the values act "
"as initial defaults only and will not override any variables already set "
"from a previous run. Use this option with care, as it can lead to "
"different behavior depending on whether the build starts from a fresh "
"build directory or re-uses previous build contents."
msgstr ""
"这与 ``CMAKE_CACHE_ARGS`` 选项相同，只是 ``set()`` 命令不包含 ``FORCE`` "
"关键字。这意味着这些值仅用作初始默认值，不会覆盖上一次运行时已设置的任何变量。请谨慎使用此选项，因为它会导致不同的行为，具体取决于构建是从新的构建目录开始还是重新使用以前的构建内容。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:559
msgid ""
"If the CMake generator is the ``Green Hills MULTI`` and not overridden, "
"the original project's settings for the GHS toolset and target system "
"customization cache variables are propagated into the external project."
msgstr ""
"如果 CMake 生成器是 ``Green Hills MULTI`` 且未被覆盖，则 GHS "
"工具集和目标系统自定义缓存变量的原始项目设置将传播到外部项目。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:577
msgid "``SOURCE_SUBDIR <dir>``"
msgstr "``SOURCE_SUBDIR <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:567
msgid ""
"When no ``CONFIGURE_COMMAND`` option is specified, the configure step "
"assumes the external project has a ``CMakeLists.txt`` file at the top of "
"its source tree (i.e. in ``SOURCE_DIR``). The ``SOURCE_SUBDIR`` option can"
" be used to point to an alternative directory within the source tree to "
"use as the top of the CMake source tree instead. This must be a relative "
"path and it will be interpreted as being relative to ``SOURCE_DIR``."
msgstr ""
"当没有指定 ``CONFIGURE_COMMAND`` 选项时，配置步骤假定外部项目在其源代码树的顶部有一个 ``CMakeLists.txt`` "
"文件（即在 ``SOURCE_DIR`` 中）。 ``SOURCE_SUBDIR`` 选项可用于指向源代码树中的替代目录，以用作 CMake "
"源代码树的顶部。这必须是一个相对路径，它将被解释为相对于 ``SOURCE_DIR``。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:575
msgid ""
"When ``BUILD_IN_SOURCE`` option is enabled, the ``BUILD_COMMAND`` is used "
"to point to an alternative directory within the source tree."
msgstr "当启用“BUILD_IN_SOURCE”选项时，“BUILD_COMMAND”用于指向源代码树中的替代目录。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:589
msgid "``CONFIGURE_HANDLED_BY_BUILD <bool>``"
msgstr "``CONFIGURE_HANDLED_BY_BUILD <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:582
msgid ""
"Enabling this option relaxes the dependencies of the configure step on "
"other external projects to order-only. This means the configure step will "
"be executed after its external project dependencies are built but it will "
"not be marked dirty when one of its external project dependencies is "
"rebuilt. This option can be enabled when the build step is smart enough to"
" figure out if the configure step needs to be rerun. CMake and Meson are "
"examples of build systems whose build step is smart enough to know if the "
"configure step needs to be rerun."
msgstr ""
"启用此选项可将配置步骤对其他外部项目的依赖性放宽为仅排序。这意味着配置步骤将在构建其外部项目依赖项后执行，但在重建其外部项目依赖项之一时不会将其标记为脏。当构建步骤足够智能以确定是否需要重新运行配置步骤时，可以启用此选项。"
" CMake 和 Meson 是构建系统的示例，它们的构建步骤足够智能，可以知道是否需要重新运行配置步骤。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:644
msgid "**Build Step Options:**"
msgstr "**构建步骤选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:592
msgid ""
"If the configure step assumed the external project uses CMake as its build"
" system, the build step will also. Otherwise, the build step will assume a"
" Makefile-based build and simply run ``make`` with no arguments as the "
"default build step. This can be overridden with custom build commands if "
"required."
msgstr ""
"如果配置步骤假定外部项目使用 CMake 作为其构建系统，则构建步骤也将如此。否则，构建步骤将假定基于 Makefile "
"的构建，并简单地运行不带参数的“make”作为默认构建步骤。如果需要，可以使用自定义构建命令覆盖它。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:598
msgid ""
"If both the main project and the external project use make as their build "
"tool, the build step of the external project is invoked as a recursive "
"make using ``$(MAKE)``.  This will communicate some build tool settings "
"from the main project to the external project.  If either the main project"
" or external project is not using make, no build tool settings will be "
"passed to the external project other than those established by the "
"configure step (i.e. running ``ninja -v`` in the main project will not "
"pass ``-v`` to the external project's build step, even if it also uses "
"``ninja`` as its build tool)."
msgstr ""
"如果主项目和外部项目都使用 make 作为它们的构建工具，则外部项目的构建步骤将作为使用 $(MAKE) 的递归 make "
"调用。这会将一些构建工具设置从主项目传递到外部项目。如果主项目或外部项目没有使用 "
"make，除了配置步骤建立的那些之外，没有构建工具设置将传递给外部项目（即在主项目中运行 ``ninja -v`` 将不会传递 ` `-v`` "
"到外部项目的构建步骤，即使它也使用 ``ninja`` 作为其构建工具）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:616
msgid "``BUILD_COMMAND <cmd>...``"
msgstr "``BUILD_COMMAND <cmd>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:609
msgid ""
"Overrides the default build command (:manual:`generator expressions "
"<cmake-generator-expressions(7)>` are supported). If this option is not "
"given, the default build command will be chosen to integrate with the main"
" build in the most appropriate way (e.g. using recursive ``make`` for "
"Makefile generators or :option:`cmake --build` if the project uses a CMake"
" build). This option can be specified with an empty string as the command "
"to make the build step do nothing."
msgstr ""
"覆盖默认构建命令（支持 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`）。如果未给出此选项，将选择默认构建命令以最合适的方式与主构建集成（例如，对 Makefile 生成器使用递归 "
"``make`` 或:option:`cmake --build` 如果项目使用 CMake "
"构建）。可以使用空字符串指定此选项作为使构建步骤不执行任何操作的命令。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:623
msgid "``BUILD_IN_SOURCE <bool>``"
msgstr "``BUILD_IN_SOURCE <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:619
msgid ""
"When this option is enabled, the build will be done directly within the "
"external project's source tree. This should generally be avoided, the use "
"of a separate build directory is usually preferred, but it can be useful "
"when the external project assumes an in-source build. The ``BINARY_DIR`` "
"option should not be specified if building in-source."
msgstr ""
"启用此选项后，构建将直接在外部项目的源代码树中完成。通常应该避免这种情况，通常首选使用单独的构建目录，但当外部项目采用源代码构建时，它会很有用。如果在源代码中构建，则不应指定"
" ``BINARY_DIR`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:633
msgid "``BUILD_ALWAYS <bool>``"
msgstr "``BUILD_ALWAYS <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:626
msgid ""
"Enabling this option forces the build step to always be run. This can be "
"the easiest way to robustly ensure that the external project's own build "
"dependencies are evaluated rather than relying on the default success "
"timestamp-based method. This option is not normally needed unless "
"developers are expected to modify something the external project's build "
"depends on in a way that is not detectable via the step target "
"dependencies (e.g. ``SOURCE_DIR`` is used without a download method and "
"developers might modify the sources in ``SOURCE_DIR``)."
msgstr ""
"启用此选项会强制构建步骤始终运行。这可能是稳健地确保评估外部项目自己的构建依赖项而不是依赖默认的基于成功时间戳的方法的最简单方法。通常不需要此选项，除非希望开发人员以通过步骤目标依赖项无法检测到的方式修改外部项目构建所依赖的某些内容（例如，在没有下载方法的情况下使用"
" ``SOURCE_DIR``，并且开发人员可能会修改源代码在 ``SOURCE_DIR`` 中）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:644
msgid "``BUILD_BYPRODUCTS <file>...``"
msgstr "``BUILD_BYPRODUCTS <文件>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:638
msgid ""
"Specifies files that will be generated by the build command but which "
"might or might not have their modification time updated by subsequent "
"builds. This may also be required to explicitly declare dependencies when "
"using the :generator:`Ninja` generator. These ultimately get passed "
"through as ``BYPRODUCTS`` to the build step's own underlying call to "
":command:`add_custom_command`, which has additional documentation."
msgstr ""
"指定将由构建命令生成但可能会或可能不会由后续构建更新其修改时间的文件。在使用 Ninja "
"生成器时，也可能需要显式声明依赖项。这些最终作为“BYPRODUCTS”传递给构建步骤自己对 add_custom_command "
"的底层调用，它有额外的文档。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:692
msgid "**Install Step Options:**"
msgstr "**安装步骤选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:647
msgid ""
"If the configure step assumed the external project uses CMake as its build"
" system, the install step will also. Otherwise, the install step will "
"assume a Makefile-based build and simply run ``make install`` as the "
"default build step. This can be overridden with custom install commands if"
" required."
msgstr ""
"如果配置步骤假定外部项目使用 CMake 作为其构建系统，则安装步骤也将如此。否则，安装步骤将采用基于 Makefile "
"的构建，并简单地运行“make install”作为默认构建步骤。如果需要，可以使用自定义安装命令覆盖它。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:665
msgid "``INSTALL_COMMAND <cmd>...``"
msgstr "``INSTALL_COMMAND <cmd>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:653
msgid ""
"The external project's own install step is invoked as part of the main "
"project's *build*. It is done after the external project's build step and "
"may be before or after the external project's test step (see the "
"``TEST_BEFORE_INSTALL`` option below). The external project's install "
"rules are not part of the main project's install rules, so if anything "
"from the external project should be installed as part of the main build, "
"these need to be specified in the main build as additional "
":command:`install` commands. The default install step builds the "
"``install`` target of the external project, but this can be overridden "
"with a custom command using this option (:manual:`generator expressions "
"<cmake-generator-expressions(7)>` are supported). Passing an empty string "
"as the ``<cmd>`` makes the install step do nothing."
msgstr ""
"外部项目自己的安装步骤作为主项目*build* 的一部分被调用。它在外部项目的构建步骤之后完成，可能在外部项目的测试步骤之前或之后完成（请参阅下面的"
" ``TEST_BEFORE_INSTALL`` "
"选项）。外部项目的安装规则不是主项目安装规则的一部分，所以如果外部项目的任何东西应该作为主构建的一部分安装，这些需要在主构建中指定为额外的 "
":command:`install` "
"命令.默认安装步骤构建外部项目的“install”目标，但可以使用此选项使用自定义命令覆盖它（支持:manual:`generator "
"expressions <cmake-generator-expressions(7)>`） .传递空字符串作为 ``<cmd>`` "
"会使安装步骤不执行任何操作。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:676
msgid "``INSTALL_BYPRODUCTS <file>...``"
msgstr "``INSTALL_BYPRODUCTS <文件>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:670
msgid ""
"Specifies files that will be generated by the install command but which "
"might or might not have their modification time updated by subsequent "
"installs. This may also be required to explicitly declare dependencies "
"when using the :generator:`Ninja` generator. These ultimately get passed "
"through as ``BYPRODUCTS`` to the install step's own underlying call to "
":command:`add_custom_command`, which has additional documentation."
msgstr ""
"指定将由安装命令生成但可能会或可能不会由后续安装更新其修改时间的文件。在使用 Ninja "
"生成器时，也可能需要显式声明依赖项。这些最终作为“BYPRODUCTS”传递给安装步骤自己对 add_custom_command "
"的底层调用，它有额外的文档。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:679
msgid ""
"If the :envvar:`CMAKE_INSTALL_MODE` environment variable is set when the "
"main project is built, it will only have an effect if the following "
"conditions are met:"
msgstr "如果在构建主工程时设置了 :envvar:`CMAKE_INSTALL_MODE` 环境变量，只有满足以下条件才会生效："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:683
msgid ""
"The main project's configure step assumed the external project uses CMake "
"as its build system."
msgstr "主项目的配置步骤假定外部项目使用 CMake 作为其构建系统。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:685
msgid ""
"The external project's install command actually runs. Note that due to the"
" way ``ExternalProject`` may use timestamps internally, if nothing the "
"install step depends on needs to be re-executed, the install command might"
" also not need to run."
msgstr ""
"外部项目的安装命令实际运行。请注意，由于 ExternalProject "
"可能在内部使用时间戳的方式，如果不需要重新执行安装步骤所依赖的任何内容，则安装命令也可能不需要运行。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:690
msgid ""
"Note also that ``ExternalProject`` does not check whether the "
":envvar:`CMAKE_INSTALL_MODE` environment variable changes from one run to "
"another."
msgstr ""
"另请注意，``ExternalProject`` 不会检查 :envvar:`CMAKE_INSTALL_MODE` "
"环境变量是否从一次运行更改为另一次运行。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:728
msgid "**Test Step Options:**"
msgstr "**测试步骤选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:695
msgid ""
"The test step is only defined if at least one of the following "
"``TEST_...`` options are provided."
msgstr "仅当至少提供以下“TEST_...”选项之一时才定义测试步骤。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:707
msgid "``TEST_COMMAND <cmd>...``"
msgstr "``TEST_COMMAND <cmd> ...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:699
msgid ""
"Overrides the default test command (:manual:`generator expressions <cmake-"
"generator-expressions(7)>` are supported). If this option is not given, "
"the default behavior of the test step is to build the external project's "
"own ``test`` target. This option can be specified with ``<cmd>`` as an "
"empty string, which allows the test step to still be defined, but it will "
"do nothing. Do not specify any of the other ``TEST_...`` options if "
"providing an empty string as the test command, but prefer to omit all "
"``TEST_...`` options altogether if the test step target is not needed."
msgstr ""
"覆盖默认测试命令（支持 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`）。如果未给出此选项，则测试步骤的默认行为是构建外部项目自己的“测试”目标。此选项可以用 ``<cmd>`` "
"指定为空字符串，这允许仍然定义测试步骤，但它什么都不做。如果提供空字符串作为测试命令，请不要指定任何其他 ``TEST_...`` "
"选项，但如果不需要测试步骤目标，则最好完全省略所有 ``TEST_...`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:712
msgid "``TEST_BEFORE_INSTALL <bool>``"
msgstr "``TEST_BEFORE_INSTALL <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:710
msgid ""
"When this option is enabled, the test step will be executed before the "
"install step. The default behavior is for the test step to run after the "
"install step."
msgstr "启用此选项后，测试步骤将在安装步骤之前执行。默认行为是在安装步骤之后运行测试步骤。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:719
msgid "``TEST_AFTER_INSTALL <bool>``"
msgstr "``TEST_AFTER_INSTALL <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:715
msgid ""
"This option is mainly useful as a way to indicate that the test step is "
"desired but all default behavior is sufficient. Specifying this option "
"with a boolean true value ensures the test step is defined and that it "
"comes after the install step. If both ``TEST_BEFORE_INSTALL`` and "
"``TEST_AFTER_INSTALL`` are enabled, the latter is silently ignored."
msgstr ""
"此选项主要用作指示需要测试步骤但所有默认行为都足够的方式。使用布尔真值指定此选项可确保定义测试步骤并且它在安装步骤之后进行。如果同时启用了 "
"``TEST_BEFORE_INSTALL`` 和 ``TEST_AFTER_INSTALL``，后者将被静默忽略。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:728
msgid "``TEST_EXCLUDE_FROM_MAIN <bool>``"
msgstr "``TEST_EXCLUDE_FROM_MAIN <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:724
msgid ""
"If enabled, the main build's default ALL target will not depend on the "
"test step. This can be a useful way of ensuring the test step is defined "
"but only gets invoked when manually requested. This may cause a step "
"target to be created automatically for either the ``install`` or ``build``"
" step.  See policy :policy:`CMP0114`."
msgstr ""
"如果启用，主构建的默认 ALL "
"目标将不依赖于测试步骤。这可能是确保测试步骤已定义但仅在手动请求时才被调用的有用方法。这可能会导致为“安装”或“构建”步骤自动创建一个步骤目标。请参阅政策:policy:`CMP0114`。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:773
msgid "**Output Logging Options:**"
msgstr "**输出记录选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:731
msgid ""
"Each of the following ``LOG_...`` options can be used to wrap the relevant"
" step in a script to capture its output to files. The log files will be "
"created in ``LOG_DIR`` if supplied or otherwise the ``STAMP_DIR`` "
"directory with step-specific file names."
msgstr ""
"以下每个 ``LOG_...`` 选项都可用于将相关步骤包装在脚本中以将其输出捕获到文件中。如果提供，日志文件将在 ``LOG_DIR`` "
"中创建，否则将在具有特定步骤文件名的 ``STAMP_DIR`` 目录中创建。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:737
msgid "``LOG_DOWNLOAD <bool>``"
msgstr "``LOG_DOWNLOAD <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:737
msgid "When enabled, the output of the download step is logged to files."
msgstr "启用后，下载步骤的输出将记录到文件中。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:740
msgid "``LOG_UPDATE <bool>``"
msgstr "``LOG_UPDATE <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:740
msgid "When enabled, the output of the update step is logged to files."
msgstr "启用后，更新步骤的输出将记录到文件中。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:745
msgid "``LOG_PATCH <bool>``"
msgstr "``LOG_PATCH <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:745
msgid "When enabled, the output of the patch step is logged to files."
msgstr "启用后，补丁步骤的输出将记录到文件中。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:748
msgid "``LOG_CONFIGURE <bool>``"
msgstr "``LOG_CONFIGURE <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:748
msgid "When enabled, the output of the configure step is logged to files."
msgstr "启用后，配置步骤的输出将记录到文件中。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:751
msgid "``LOG_BUILD <bool>``"
msgstr "``LOG_BUILD <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:751
msgid "When enabled, the output of the build step is logged to files."
msgstr "启用后，构建步骤的输出将记录到文件中。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:754
msgid "``LOG_INSTALL <bool>``"
msgstr "``LOG_INSTALL <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:754
msgid "When enabled, the output of the install step is logged to files."
msgstr "启用后，安装步骤的输出将记录到文件中。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:757
msgid "``LOG_TEST <bool>``"
msgstr "``LOG_TEST <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:757
msgid "When enabled, the output of the test step is logged to files."
msgstr "启用后，测试步骤的输出将记录到文件中。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:763
msgid "``LOG_MERGED_STDOUTERR <bool>``"
msgstr "``LOG_MERGED_STDOUTERR <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:762
msgid ""
"When enabled, stdout and stderr will be merged for any step whose output "
"is being logged to files."
msgstr "启用后，stdout 和 stderr 将合并到输出被记录到文件的任何步骤。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:773
msgid "``LOG_OUTPUT_ON_FAILURE <bool>``"
msgstr "``LOG_OUTPUT_ON_FAILURE <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:768
msgid ""
"This option only has an effect if at least one of the other ``LOG_<step>``"
" options is enabled.  If an error occurs for a step which has logging to "
"file enabled, that step's output will be printed to the console if "
"``LOG_OUTPUT_ON_FAILURE`` is set to true.  For cases where a large amount "
"of output is recorded, just the end of that output may be printed to the "
"console."
msgstr ""
"此选项仅在至少启用其他 ``LOG_<step>`` 选项之一时才有效。如果启用了记录到文件的步骤发生错误，如果 "
"``LOG_OUTPUT_ON_FAILURE`` 设置为 "
"true，则该步骤的输出将打印到控制台。对于记录大量输出的情况，可能只将输出的末尾打印到控制台。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:806
msgid "**Terminal Access Options:**"
msgstr "**终端访问选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:778
msgid ""
"Steps can be given direct access to the terminal in some cases. Giving a "
"step access to the terminal may allow it to receive terminal input if "
"required, such as for authentication details not provided by other "
"options. With the :generator:`Ninja` generator, these options place the "
"steps in the ``console`` :prop_gbl:`job pool <JOB_POOLS>`. Each step can "
"be given access to the terminal individually via the following options:"
msgstr ""
"在某些情况下，步骤可以直接访问终端。授予对终端的步骤访问权限可以允许它在需要时接收终端输入，例如其他选项未提供的身份验证详细信息。使用 "
":generator:`Ninja` 生成器，这些选项将步骤放在 ``console`` :prop_gbl:`job pool "
"<JOB_POOLS>` 中。每个步骤都可以通过以下选项单独访问终端："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:786
msgid "``USES_TERMINAL_DOWNLOAD <bool>``"
msgstr "``USES_TERMINAL_DOWNLOAD <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:786
msgid "Give the download step access to the terminal."
msgstr "授予下载步骤访问终端的权限。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:789
msgid "``USES_TERMINAL_UPDATE <bool>``"
msgstr "``USES_TERMINAL_UPDATE <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:789
msgid "Give the update step access to the terminal."
msgstr "授予更新步骤访问终端的权限。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:794
msgid "``USES_TERMINAL_PATCH <bool>``"
msgstr "``USES_TERMINAL_PATCH <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:794
msgid "Give the patch step access to the terminal."
msgstr "授予补丁步骤对终端的访问权限。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:797
msgid "``USES_TERMINAL_CONFIGURE <bool>``"
msgstr "``USES_TERMINAL_CONFIGURE <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:797
msgid "Give the configure step access to the terminal."
msgstr "授予配置步骤对终端的访问权限。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:800
msgid "``USES_TERMINAL_BUILD <bool>``"
msgstr "``USES_TERMINAL_BUILD <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:800
msgid "Give the build step access to the terminal."
msgstr "授予构建步骤对终端的访问权限。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:803
msgid "``USES_TERMINAL_INSTALL <bool>``"
msgstr "``USES_TERMINAL_INSTALL <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:803
msgid "Give the install step access to the terminal."
msgstr "授予安装步骤对终端的访问权限。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:806
msgid "``USES_TERMINAL_TEST <bool>``"
msgstr "``USES_TERMINAL_TEST <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:806
msgid "Give the test step access to the terminal."
msgstr "授予测试步骤访问终端的权限。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:843
msgid "**Target Options:**"
msgstr "**目标选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:817
msgid "``DEPENDS <targets>...``"
msgstr "``取决于 <目标>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:810
msgid ""
"Specify other targets on which the external project depends. The other "
"targets will be brought up to date before any of the external project's "
"steps are executed. Because the external project uses additional custom "
"targets internally for each step, the ``DEPENDS`` option is the most "
"convenient way to ensure all of those steps depend on the other targets. "
"Simply doing :command:`add_dependencies(\\<name\\> \\<targets\\>) "
"<add_dependencies>` will not make any of the steps dependent on "
"``<targets>``."
msgstr ""
"指定外部项目依赖的其他目标。在执行任何外部项目的步骤之前，其他目标将被更新。因为外部项目在内部为每个步骤使用额外的自定义目标，所以 "
"``DEPENDS`` 选项是确保所有这些步骤都依赖于其他目标的最方便的方法。简单地执行 "
":command:`add_dependencies(\\<name\\> \\<targets\\>) <add_dependencies>` "
"不会使任何步骤依赖于 ``<targets>``。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:821
msgid "``EXCLUDE_FROM_ALL <bool>``"
msgstr "``EXCLUDE_FROM_ALL <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:820
msgid ""
"When enabled, this option excludes the external project from the default "
"ALL target of the main build."
msgstr "启用后，此选项会从主构建的默认 ALL 目标中排除外部项目。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:829
msgid "``STEP_TARGETS <step-target>...``"
msgstr "``STEP_TARGETS <step-target>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:824
msgid ""
"Generate custom targets for the specified steps. This is required if the "
"steps need to be triggered manually or if they need to be used as "
"dependencies of other targets. If this option is not specified, the "
"default value is taken from the ``EP_STEP_TARGETS`` directory property. "
"See :command:`ExternalProject_Add_StepTargets` below for further "
"discussion of the effects of this option."
msgstr ""
"为指定步骤生成自定义目标。如果需要手动触发这些步骤，或者如果它们需要用作其他目标的依赖项，则这是必需的。如果未指定此选项，则默认值取自 "
"``EP_STEP_TARGETS`` 目录属性。有关此选项的影响的进一步讨论，请参阅下面的 "
"ExternalProject_Add_StepTargets。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:843
msgid "``INDEPENDENT_STEP_TARGETS <step-target>...``"
msgstr "``INDEPENDENT_STEP_TARGETS <step-target>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:832
msgid ""
"This is allowed only if policy :policy:`CMP0114` is not set to ``NEW``."
msgstr "仅当政策:policy:`CMP0114` 未设置为``NEW`` 时才允许这样做。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:835
msgid ""
"Generates custom targets for the specified steps and prevent these targets"
" from having the usual dependencies applied to them. If this option is not"
" specified, the default value is taken from the "
"``EP_INDEPENDENT_STEP_TARGETS`` directory property. This option is mostly "
"useful for allowing individual steps to be driven independently, such as "
"for a CDash setup where each step should be initiated and reported "
"individually rather than as one whole build. See "
":command:`ExternalProject_Add_StepTargets` below for further discussion of"
" the effects of this option."
msgstr ""
"为指定步骤生成自定义目标并防止这些目标应用通常的依赖项。如果未指定此选项，则默认值取自 "
"``EP_INDEPENDENT_STEP_TARGETS`` 目录属性。此选项最适用于允许独立驱动各个步骤，例如对于 CDash "
"设置，其中每个步骤都应单独启动和报告，而不是作为一个整体构建。有关此选项的影响的进一步讨论，请参阅下面的 "
"ExternalProject_Add_StepTargets。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:867
msgid "**Miscellaneous Options:**"
msgstr "**杂项选项：**"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:851
msgid "``LIST_SEPARATOR <sep>``"
msgstr "``LIST_SEPARATOR <sep>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:847
msgid ""
"For any of the various ``..._COMMAND`` options, and ``CMAKE_ARGS``, "
"replace ``;`` with ``<sep>`` in the specified command lines. This can be "
"useful where list variables may be given in commands where they should end"
" up as space-separated arguments (``<sep>`` would be a single space "
"character string in this case)."
msgstr ""
"对于各种“..._COMMAND”选项和“CMAKE_ARGS”中的任何一个，在指定的命令行中将“;”替换为“<sep>”。这在命令中给出列表变量时很有用，它们应该以空格分隔的参数结尾（在这种情况下，``<sep>``"
" 将是单个空格字符串）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:867
#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:925
msgid "``COMMAND <cmd>...``"
msgstr "``命令 <cmd>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:854
msgid ""
"Any of the other ``..._COMMAND`` options can have additional commands "
"appended to them by following them with as many ``COMMAND ...`` options as"
" needed (:manual:`generator expressions <cmake-generator-expressions(7)>` "
"are supported). For example:"
msgstr ""
"任何其他 ``..._COMMAND`` 选项都可以根据需要在它们后面加上尽可能多的 ``COMMAND ...`` "
"选项来附加额外的命令（ :manual:`generator expressions <cmake-generator-expressions "
"(7)>` 被支持）。例如："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:869
msgid ""
"It should also be noted that each build step is created via a call to "
":command:`ExternalProject_Add_Step`. See that command's documentation for "
"the automatic substitutions that are supported for some options."
msgstr ""
"还应注意，每个构建步骤都是通过调用 ExternalProject_Add_Step 来创建的。有关某些选项支持的自动替换，请参阅该命令的文档。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:874
msgid "Obtaining Project Properties"
msgstr "获取项目属性"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:878
msgid ""
"The ``ExternalProject_Get_Property()`` function retrieves external project"
" target properties:"
msgstr "``ExternalProject_Get_Property()`` 函数检索外部项目目标属性："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:885
msgid ""
"The function stores property values in variables of the same name. "
"Property names correspond to the keyword argument names of "
"``ExternalProject_Add()``. For example, the source directory might be "
"retrieved like so:"
msgstr ""
"该函数将属性值存储在同名变量中。属性名称对应于 ``ExternalProject_Add()`` 的关键字参数名称。例如，可以像这样检索源目录："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:895
msgid "Explicit Step Management"
msgstr "显式步骤管理"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:897
msgid ""
"The ``ExternalProject_Add()`` function on its own is often sufficient for "
"incorporating an external project into the main build. Certain scenarios "
"require additional work to implement desired behavior, such as adding in a"
" custom step or making steps available as manually triggerable targets. "
"The ``ExternalProject_Add_Step()``, ``ExternalProject_Add_StepTargets()`` "
"and ``ExternalProject_Add_StepDependencies`` functions provide the lower "
"level control needed to implement such step-level capabilities."
msgstr ""
"``ExternalProject_Add()`` "
"函数本身通常足以将外部项目合并到主构建中。某些场景需要额外的工作来实现所需的行为，例如添加自定义步骤或使步骤可用作可手动触发的目标。 "
"``ExternalProject_Add_Step()``、``ExternalProject_Add_StepTargets()`` 和 "
"``ExternalProject_Add_StepDependencies`` 函数提供了实现这种步级功能所需的较低级别的控制。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:907
msgid ""
"The ``ExternalProject_Add_Step()`` function specifies an additional custom"
" step for an external project defined by an earlier call to "
":command:`ExternalProject_Add`:"
msgstr ""
"``ExternalProject_Add_Step()`` 函数为之前调用 ExternalProject_Add "
"定义的外部项目指定了一个额外的自定义步骤："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:915
msgid ""
"``<name>`` is the same as the name passed to the original call to "
":command:`ExternalProject_Add`. The specified ``<step>`` must not be one "
"of the pre-defined steps (``mkdir``, ``download``, ``update``, ``patch``, "
"``configure``, ``build``, ``install`` or ``test``). The supported options "
"are:"
msgstr ""
"``<name>`` 与传递给 ExternalProject_Add 的原始调用的名称相同。指定的 ``<step>`` "
"不能是预定义的步骤之一（``mkdir``、``download``、``update``、``patch``、``configure``、 "
"``build``、``install`` 或 ``test``）。支持的选项是："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:922
msgid ""
"The command line to be executed by this custom step (:manual:`generator "
"expressions <cmake-generator-expressions(7)>` are supported). This option "
"can be repeated multiple times to specify multiple commands to be executed"
" in order."
msgstr ""
"此自定义步骤要执行的命令行（支持 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`）。该选项可以重复多次以指定要按顺序执行的多个命令。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:928
msgid "``COMMENT \"<text>...\"``"
msgstr "``评论“<文本> ...”``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:928
msgid "Text to be printed when the custom step executes."
msgstr "执行自定义步骤时要打印的文本。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:931
msgid "``DEPENDEES <step>...``"
msgstr "``DEPENDEES <step>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:931
msgid "Other steps (custom or pre-defined) on which this step depends."
msgstr "此步骤所依赖的其他步骤（自定义或预定义）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:934
msgid "``DEPENDERS <step>...``"
msgstr "``DEPENDERS <step>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:934
msgid ""
"Other steps (custom or pre-defined) that depend on this new custom step."
msgstr "依赖于此新自定义步骤的其他步骤（自定义或预定义）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:937
msgid "``DEPENDS <file>...``"
msgstr "``取决于 <文件>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:937
msgid "Files on which this custom step depends."
msgstr "此自定义步骤所依赖的文件。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:954
msgid "``INDEPENDENT <bool>``"
msgstr "``独立 <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:942
msgid ""
"Specifies whether this step is independent of the external dependencies "
"specified by the :command:`ExternalProject_Add`'s ``DEPENDS`` option. The "
"default is ``FALSE``.  Steps marked as independent may depend only on "
"other steps marked independent.  See policy :policy:`CMP0114`."
msgstr ""
"指定此步骤是否独立于由 :command:`ExternalProject_Add` 的 ``DEPENDS`` "
"选项指定的外部依赖项。默认值为“假”。标记为独立的步骤可能仅依赖于其他标记为独立的步骤。请参阅政策:policy:`CMP0114`。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:947
msgid ""
"Note that this use of the term \"independent\" refers only to independence"
" from external targets specified by the ``DEPENDS`` option and is "
"orthogonal to a step's dependencies on other steps."
msgstr "请注意，术语“独立”的使用仅指独立于“DEPENDS”选项指定的外部目标，并且与一个步骤对其他步骤的依赖关系是正交的。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:951
msgid ""
"If a step target is created for an independent step by the "
":command:`ExternalProject_Add` ``STEP_TARGETS`` option or by the "
":command:`ExternalProject_Add_StepTargets` function, it will not depend on"
" the external targets, but may depend on targets for other steps."
msgstr ""
"如果通过 :command:`ExternalProject_Add` ``STEP_TARGETS`` 选项或 "
":command:`ExternalProject_Add_StepTargets` "
"函数为独立步骤创建步骤目标，它将不依赖于外部目标，但可能依赖于目标其他步骤。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:965
msgid "``BYPRODUCTS <file>...``"
msgstr "``副产品 <文件>...``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:959
msgid ""
"Files that will be generated by this custom step but which might or might "
"not have their modification time updated by subsequent builds. This may "
"also be required to explicitly declare dependencies when using the "
":generator:`Ninja` generator. This list of files will ultimately be passed"
" through as the ``BYPRODUCTS`` option to the :command:`add_custom_command`"
" used to implement the custom step internally, which has additional "
"documentation."
msgstr ""
"将由此自定义步骤生成的文件，但其修改时间可能会或可能不会被后续构建更新。在使用 Ninja 生成器时，也可能需要显式声明依赖项。此文件列表最终将作为"
" ``BYPRODUCTS`` 选项传递给 :command:`add_custom_command` 用于在内部实现自定义步骤，它有额外的文档。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:969
msgid "``ALWAYS <bool>``"
msgstr "``总是 <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:968
msgid ""
"When enabled, this option specifies that the custom step should always be "
"run (i.e. that it is always considered out of date)."
msgstr "启用后，此选项指定应始终运行自定义步骤（即它始终被视为过时）。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:975
msgid "``EXCLUDE_FROM_MAIN <bool>``"
msgstr "``EXCLUDE_FROM_MAIN <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:972
msgid ""
"When enabled, this option specifies that the external project's main "
"target does not depend on the custom step. This may cause step targets to "
"be created automatically for the steps on which this step depends.  See "
"policy :policy:`CMP0114`."
msgstr ""
"启用时，此选项指定外部项目的主要目标不依赖于自定义步骤。这可能会导致为该步骤所依赖的步骤自动创建步骤目标。请参阅政策:policy:`CMP0114`。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:981
msgid "``WORKING_DIRECTORY <dir>``"
msgstr "``WORKING_DIRECTORY <目录>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:978
msgid ""
"Specifies the working directory to set before running the custom step's "
"command. If this option is not specified, the directory will be the value "
"of the :variable:`CMAKE_CURRENT_BINARY_DIR` at the point where "
"``ExternalProject_Add_Step()`` was called."
msgstr ""
"指定在运行自定义步骤的命令之前要设置的工作目录。如果未指定此选项，则目录将是调用 ExternalProject_Add_Step() 时 "
"CMAKE_CURRENT_BINARY_DIR 的值。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:985
msgid "``LOG <bool>``"
msgstr "``日志 <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:984
msgid ""
"If set, this causes the output from the custom step to be captured to "
"files in the external project's ``LOG_DIR`` if supplied or ``STAMP_DIR``."
msgstr "如果设置，这会导致自定义步骤的输出被捕获到外部项目的“LOG_DIR”（如果提供）或“STAMP_DIR”中的文件。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:989
msgid "``USES_TERMINAL <bool>``"
msgstr "``USES_TERMINAL <bool>``"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:988
msgid ""
"If enabled, this gives the custom step direct access to the terminal if "
"possible."
msgstr "如果启用，这将允许自定义步骤在可能的情况下直接访问终端。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:991
msgid ""
"The command line, comment, working directory and byproducts of every "
"standard and custom step are processed to replace the tokens "
"``<SOURCE_DIR>``, ``<SOURCE_SUBDIR>``, ``<BINARY_DIR>``, ``<INSTALL_DIR>``"
" ``<TMP_DIR>``, ``<DOWNLOAD_DIR>`` and ``<DOWNLOADED_FILE>`` with their "
"corresponding property values defined in the original call to "
":command:`ExternalProject_Add`."
msgstr ""
"处理每个标准和自定义步骤的命令行、注释、工作目录和副产品以替换标记``<SOURCE_DIR>``、``<SOURCE_SUBDIR>``、``<BINARY_DIR>``、``<INSTALL_DIR"
" >`` ``<TMP_DIR>``、``<DOWNLOAD_DIR>`` 和 ``<DOWNLOADED_FILE>`` 及其在对 "
":command:`ExternalProject_Add` 的原始调用中定义的相应属性值。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:998
msgid "Token replacement is extended to byproducts."
msgstr "令牌替换扩展到副产品。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1001
msgid "The ``<DOWNLOAD_DIR>`` substitution token."
msgstr "``<DOWNLOAD_DIR>`` 替换标记。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1006
msgid ""
"The ``ExternalProject_Add_StepTargets()`` function generates targets for "
"the steps listed. The name of each created target will be of the form "
"``<name>-<step>``:"
msgstr ""
"``ExternalProject_Add_StepTargets()`` "
"函数为列出的步骤生成目标。每个创建的目标的名称将采用“<name>-<step>”的形式："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1014
msgid ""
"Creating a target for a step allows it to be used as a dependency of "
"another target or to be triggered manually. Having targets for specific "
"steps also allows them to be driven independently of each other by "
"specifying targets on build command lines. For example, you may be "
"submitting to a sub-project based dashboard where you want to drive the "
"configure portion of the build, then submit to the dashboard, followed by "
"the build portion, followed by tests. If you invoke a custom target that "
"depends on a step halfway through the step dependency chain, then all the "
"previous steps will also run to ensure everything is up to date."
msgstr ""
"为步骤创建目标允许它用作另一个目标的依赖项或手动触发。拥有特定步骤的目标还允许通过在构建命令行上指定目标来相互独立地驱动它们。例如，您可能正在提交到一个基于子项目的仪表板，您希望在其中驱动构建的配置部分，然后提交到仪表板，然后是构建部分，然后是测试。如果您调用一个自定义目标，该目标依赖于步骤依赖链中途的一个步骤，那么所有先前的步骤也将运行以确保一切都是最新的。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1024
msgid ""
"Internally, :command:`ExternalProject_Add` calls "
":command:`ExternalProject_Add_Step` to create each step. If any "
"``STEP_TARGETS`` were specified, then "
"``ExternalProject_Add_StepTargets()`` will also be called after "
":command:`ExternalProject_Add_Step`.  Even if a step is not mentioned in "
"the ``STEP_TARGETS`` option, ``ExternalProject_Add_StepTargets()`` can "
"still be called later to manually define a target for the step."
msgstr ""
"在内部， :command:`ExternalProject_Add` 调用 :command:`ExternalProject_Add_Step` "
"来创建每个步骤。如果指定了任何“STEP_TARGETS”，那么“ExternalProject_Add_StepTargets()”也会在 "
"ExternalProject_Add_Step 之后被调用。即使在 ``STEP_TARGETS`` 选项中未提及某个步骤，稍后仍然可以调用 "
"``ExternalProject_Add_StepTargets()`` 来手动定义该步骤的目标。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1032
msgid ""
"The ``STEP_TARGETS`` option for :command:`ExternalProject_Add` is "
"generally the easiest way to ensure targets are created for specific steps"
" of interest. For custom steps, ``ExternalProject_Add_StepTargets()`` must"
" be called explicitly if a target should also be created for that custom "
"step. An alternative to these two options is to populate the "
"``EP_STEP_TARGETS`` directory property.  It acts as a default for the step"
" target options and can save having to repeatedly specify the same set of "
"step targets when multiple external projects are being defined."
msgstr ""
"ExternalProject_Add 的 STEP_TARGETS "
"选项通常是确保为感兴趣的特定步骤创建目标的最简单方法。对于自定义步骤，如果还应为该自定义步骤创建目标，则必须显式调用“ExternalProject_Add_StepTargets()”。这两个选项的替代方法是填充"
" ``EP_STEP_TARGETS`` 目录属性。它充当步骤目标选项的默认值，并且可以避免在定义多个外部项目时重复指定同一组步骤目标。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1041
msgid ""
"If :policy:`CMP0114` is set to ``NEW``, step targets are fully responsible"
" for holding the custom commands implementing their steps.  The primary "
"target created by ``ExternalProject_Add`` depends on the step targets, and"
" the step targets depend on each other.  The target-level dependencies "
"match the file-level dependencies used by the custom commands for each "
"step. The targets for steps created with "
":command:`ExternalProject_Add_Step`'s ``INDEPENDENT`` option do not depend"
" on the external targets specified by :command:`ExternalProject_Add`'s "
"``DEPENDS`` option.  The predefined steps ``mkdir``, ``download``, "
"``update``, and ``patch`` are independent."
msgstr ""
"如果 :policy:`CMP0114` 设置为 ``NEW``，步骤目标完全负责保存实现其步骤的自定义命令。 "
"``ExternalProject_Add`` "
"创建的主要目标依赖于步骤目标，步骤目标相互依赖。目标级依赖项与每个步骤的自定义命令使用的文件级依赖项相匹配。使用 "
":command:`ExternalProject_Add_Step` 的 ``INDEPENDENT`` 选项创建的步骤的目标不依赖于 "
":command:`ExternalProject_Add` 的 ``DEPENDS`` "
"选项指定的外部目标。预定义的步骤“mkdir”、“download”、“update”和“patch”是独立的。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1052
msgid ""
"If :policy:`CMP0114` is not ``NEW``, the following deprecated behavior is "
"available:"
msgstr "如果 :policy:`CMP0114` 不是 ``NEW``，则可以使用以下已弃用的行为："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1055
msgid ""
"A deprecated ``NO_DEPENDS`` option may be specified immediately after the "
"``<name>`` and before the first step. If the ``NO_DEPENDS`` option is "
"specified, the step target will not depend on the dependencies of the "
"external project (i.e. on any dependencies of the ``<name>`` custom target"
" created by :command:`ExternalProject_Add`). This is usually safe for the "
"``download``, ``update`` and ``patch`` steps, since they do not typically "
"require that the dependencies are updated and built. Using ``NO_DEPENDS`` "
"for any of the other pre-defined steps, however, may break parallel "
"builds. Only use ``NO_DEPENDS`` where it is certain that the named steps "
"genuinely do not have dependencies. For custom steps, consider whether or "
"not the custom commands require the dependencies to be configured, built "
"and installed."
msgstr ""
"可以在 <name> 之后和第一步之前立即指定已弃用的 NO_DEPENDS 选项。如果指定了 ``NO_DEPENDS`` "
"选项，则步骤目标将不依赖于外部项目的依赖项（即依赖于由 :command:`ExternalProject_Add` 创建的 ``<name>`` "
"自定义目标的任何依赖项）。这对于“下载”、“更新”和“补丁”步骤通常是安全的，因为它们通常不需要更新和构建依赖项。但是，对任何其他预定义步骤使用“NO_DEPENDS”可能会破坏并行构建。仅在确定命名步骤真正没有依赖性的情况下使用"
" ``NO_DEPENDS``。对于自定义步骤，请考虑自定义命令是否需要配置、构建和安装依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1068
msgid ""
"The ``INDEPENDENT_STEP_TARGETS`` option for "
":command:`ExternalProject_Add`, or the ``EP_INDEPENDENT_STEP_TARGETS`` "
"directory property, tells the function to call "
"``ExternalProject_Add_StepTargets()`` internally using the ``NO_DEPENDS`` "
"option for the specified steps."
msgstr ""
":command:`ExternalProject_Add` 的 ``INDEPENDENT_STEP_TARGETS`` 选项，或 "
"``EP_INDEPENDENT_STEP_TARGETS`` 目录属性，告诉函数使用 ``NO_DEPENDS`` 选项在内部调用 "
"``ExternalProject_Add_StepTargets()`` 指定步骤."

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1077
msgid ""
"The ``ExternalProject_Add_StepDependencies()`` function can be used to add"
" dependencies to a step. The dependencies added must be targets CMake "
"already knows about (these can be ordinary executable or library targets, "
"custom targets or even step targets of another external project):"
msgstr ""
"``ExternalProject_Add_StepDependencies()`` 函数可用于向步骤添加依赖项。添加的依赖项必须是 CMake "
"已知的目标（这些可以是普通的可执行文件或库目标、自定义目标甚至是另一个外部项目的步骤目标）："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1086
msgid ""
"This function takes care to set both target and file level dependencies "
"and will ensure that parallel builds will not break. It should be used "
"instead of :command:`add_dependencies` whenever adding a dependency for "
"some of the step targets generated by the ``ExternalProject`` module."
msgstr ""
"此函数负责设置目标和文件级别的依赖关系，并将确保并行构建不会中断。每当为 ``ExternalProject`` "
"模块生成的某些步骤目标添加依赖项时，都应该使用它而不是 add_dependencies 。"

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1094
msgid ""
"The following example shows how to download and build a hypothetical "
"project called *FooBar* from github:"
msgstr "以下示例展示了如何从 github 下载并构建一个名为 *FooBar* 的假设项目："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1105
msgid ""
"For the sake of the example, also define a second hypothetical external "
"project called *SecretSauce*, which is downloaded from a web server. Two "
"URLs are given to take advantage of a faster internal network if "
"available, with a fallback to a slower external server. The project is a "
"typical ``Makefile`` project with no configure step, so some of the "
"default commands are overridden. The build is only required to build the "
"*sauce* target:"
msgstr ""
"为了示例，还定义了第二个假设的外部项目，称为 *SecretSauce*，它是从 Web 服务器下载的。提供了两个 URL "
"以利用更快的内部网络（如果可用），并回退到速度较慢的外部服务器。该项目是一个典型的“Makefile”项目，没有配置步骤，因此一些默认命令被覆盖。构建只需要构建"
" *sauce* 目标："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1123
msgid ""
"Suppose the build step of ``secretsauce`` requires that ``foobar`` must "
"already be built. This could be enforced like so:"
msgstr "假设 ``secretsauce`` 的构建步骤要求必须已经构建了 ``foobar``。这可以像这样强制执行："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1130
msgid ""
"Another alternative would be to create a custom target for ``foobar``'s "
"build step and make ``secretsauce`` depend on that rather than the whole "
"``foobar`` project. This would mean ``foobar`` only needs to be built, it "
"doesn't need to run its install or test steps before ``secretsauce`` can "
"be built. The dependency can also be defined along with the "
"``secretsauce`` project:"
msgstr ""
"另一种选择是为“foobar”的构建步骤创建一个自定义目标，并使“secretsauce”依赖于该目标而不是整个“foobar”项目。这意味着 "
"``foobar`` 只需要构建，在构建 ``secretsauce`` "
"之前不需要运行它的安装或测试步骤。依赖项也可以与“secretsauce”项目一起定义："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1148
msgid ""
"Instead of calling :command:`ExternalProject_Add_StepTargets`, the target "
"could be defined along with the ``foobar`` project itself:"
msgstr ""
"除了调用 :command:`ExternalProject_Add_StepTargets`，目标可以与 ``foobar`` 项目本身一起定义："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1159
msgid ""
"If many external projects should have the same set of step targets, "
"setting a directory property may be more convenient. The ``build`` step "
"target could be created automatically by setting the ``EP_STEP_TARGETS`` "
"directory property before creating the external projects with "
":command:`ExternalProject_Add`:"
msgstr ""
"如果许多外部项目应该有相同的步骤目标集，设置目录属性可能更方便。在使用 :command:`ExternalProject_Add` "
"创建外部项目之前，可以通过设置 `EP_STEP_TARGETS`` 目录属性来自动创建 ``build`` 步骤目标："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1168
msgid ""
"Lastly, suppose that ``secretsauce`` provides a script called ``makedoc`` "
"which can be used to generate its own documentation. Further suppose that "
"the script expects the output directory to be provided as the only "
"parameter and that it should be run from the ``secretsauce`` source "
"directory. A custom step and a custom target to trigger the script can be "
"defined like so:"
msgstr ""
"最后，假设“secretsauce”提供了一个名为“makedoc”的脚本，可用于生成自己的文档。进一步假设脚本期望输出目录作为唯一参数提供，并且它应该从“secretsauce”源目录运行。可以像这样定义一个自定义步骤和一个自定义目标来触发脚本："

#: ../../cmake-prefix/src/cmake/Modules/ExternalProject.cmake:1185
msgid ""
"The custom step could then be triggered from the main build like so::"
msgstr "然后可以从主构建中触发自定义步骤，如下所示："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:6
msgid "FeatureSummary"
msgstr "功能概要"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:8
msgid "Functions for generating a summary of enabled/disabled features."
msgstr "生成启用/禁用功能摘要的函数。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:10
msgid ""
"These functions can be used to generate a summary of enabled and disabled "
"packages and/or feature for a build tree such as::"
msgstr "这些函数可用于为构建树生成启用和禁用包和/或功能的摘要，例如："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:25
msgid "Global Properties"
msgstr "全球资产"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:29
msgid ""
"The global property :variable:`FeatureSummary_PKG_TYPES` defines the type "
"of packages used by `FeatureSummary`."
msgstr ""
"全局属性 :variable:`FeatureSummary_PKG_TYPES` 定义了 `FeatureSummary` 使用的包类型。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:32
msgid ""
"The order in this list is important, the first package type in the list is"
" the least important, the last is the most important. the of a package can"
" only be changed to higher types."
msgstr "此列表中的顺序很重要，列表中第一个包类型最不重要，最后一个最重要。包的只能更改为更高类型。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:36
msgid ""
"The default package types are , ``RUNTIME``, ``OPTIONAL``, ``RECOMMENDED``"
" and ``REQUIRED``, and their importance is ``RUNTIME < OPTIONAL < "
"RECOMMENDED < REQUIRED``."
msgstr ""
"默认的包类型是，``RUNTIME``，``OPTIONAL``，``RECOMMENDED`` "
"和``REQUIRED``，它们的重要性是``RUNTIME < OPTIONAL < RECOMMENDED < REQUIRED``。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:43
msgid ""
"The global property :variable:`FeatureSummary_REQUIRED_PKG_TYPES` defines "
"which package types are required."
msgstr "全局属性 :variable:`FeatureSummary_REQUIRED_PKG_TYPES` 定义需要哪些包类型。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:46
msgid ""
"If one or more package in this categories has not been found, CMake will "
"abort when calling :command:`feature_summary` with the "
"'FATAL_ON_MISSING_REQUIRED_PACKAGES' option enabled."
msgstr ""
"如果未找到此类别中的一个或多个包，CMake 将在启用“FATAL_ON_MISSING_REQUIRED_PACKAGES”选项的情况下调用 "
":command:`feature_summary` 时中止。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:50
msgid "The default value for this global property is ``REQUIRED``."
msgstr "此全局属性的默认值为“REQUIRED”。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:55
msgid ""
"The global property :variable:`FeatureSummary_DEFAULT_PKG_TYPE` defines "
"which package type is the default one. When calling "
":command:`feature_summary`, if the user did not set the package type "
"explicitly, the package will be assigned to this category."
msgstr ""
"全局属性 :variable:`FeatureSummary_DEFAULT_PKG_TYPE` 定义了哪种包类型是默认类型。在调用 "
":command:`feature_summary` 时，如果用户没有明确设置包类型，包将被分配到这个类别。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:60
msgid ""
"This value must be one of the types defined in the "
":variable:`FeatureSummary_PKG_TYPES` global property unless the package "
"type is set for all the packages."
msgstr "该值必须是 FeatureSummary_PKG_TYPES 全局属性中定义的类型之一，除非为所有包都设置了包类型。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:64
msgid "The default value for this global property is ``OPTIONAL``."
msgstr "此全局属性的默认值为 ``OPTIONAL``。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:71
msgid ""
"The global property :variable:`FeatureSummary_<TYPE>_DESCRIPTION` can be "
"defined for each type to replace the type name with the specified string "
"whenever the package type is used in an output string."
msgstr ""
"可以为每种类型定义全局属性 :variable:`FeatureSummary_<TYPE>_DESCRIPTION`，以便在输出字符串中使用包类型时将类型名称替换为指定的字符串。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:75
msgid "If not set, the string \"``<TYPE>`` packages\" is used."
msgstr "如果未设置，则使用字符串“``<TYPE>`` packages”。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:98
#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:59
msgid "Functions"
msgstr "功能"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:217
msgid ""
"The ``feature_summary()`` macro can be used to print information about "
"enabled or disabled packages or features of a project.  By default, only "
"the names of the features/packages will be printed and their required "
"version when one was specified.  Use ``set_package_properties()`` to add "
"more useful information, like e.g.  a download URL for the respective "
"package or their purpose in the project."
msgstr ""
"``feature_summary()`` "
"宏可用于打印有关启用或禁用的包或项目功能的信息。默认情况下，仅打印功能/包的名称以及指定时所需的版本。使用 "
"``set_package_properties()`` 添加更多有用的信息，例如各个包的下载 URL 或它们在项目中的用途。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:224
msgid ""
"The ``WHAT`` option is the only mandatory option.  Here you specify what "
"information will be printed:"
msgstr "``WHAT`` 选项是唯一的强制选项。您可以在此处指定要打印的信息："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:227
msgid "``ALL``"
msgstr "``全部``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:228
msgid "print everything"
msgstr "打印一切"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:229
msgid "``ENABLED_FEATURES``"
msgstr "``ENABLED_FEATURES``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:230
msgid "the list of all features which are enabled"
msgstr "已启用的所有功能的列表"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:231
msgid "``DISABLED_FEATURES``"
msgstr "``DISABLED_FEATURES``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:232
msgid "the list of all features which are disabled"
msgstr "禁用的所有功能的列表"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:233
msgid "``PACKAGES_FOUND``"
msgstr "``PACKAGES_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:234
msgid "the list of all packages which have been found"
msgstr "已找到的所有包的列表"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:236
msgid "``PACKAGES_NOT_FOUND``"
msgstr "``PACKAGES_NOT_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:236
msgid "the list of all packages which have not been found"
msgstr "未找到的所有包的列表"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:238
msgid ""
"For each package type ``<TYPE>`` defined by the "
":variable:`FeatureSummary_PKG_TYPES` global property, the following "
"information can also be used:"
msgstr "对于由 :variable:`FeatureSummary_PKG_TYPES` 全局属性定义的每个包类型``<TYPE>``，还可以使用以下信息："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:242
msgid "``<TYPE>_PACKAGES_FOUND``"
msgstr "``<TYPE>_PACKAGES_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:243
msgid "only those packages which have been found which have the type <TYPE>"
msgstr "仅那些已找到类型为 <TYPE> 的包"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:245
msgid "``<TYPE>_PACKAGES_NOT_FOUND``"
msgstr "``<TYPE>_PACKAGES_NOT_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:245
msgid ""
"only those packages which have not been found which have the type <TYPE>"
msgstr "仅那些尚未找到类型为 <TYPE> 的包"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:247
msgid ""
"With the exception of the ``ALL`` value, these values can be combined in "
"order to customize the output. For example:"
msgstr "除了 ``ALL`` 值之外，可以组合这些值以自定义输出。例如："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:255
msgid ""
"If a ``FILENAME`` is given, the information is printed into this file.  If"
" ``APPEND`` is used, it is appended to this file, otherwise the file is "
"overwritten if it already existed.  If the VAR option is used, the "
"information is \"printed\" into the specified variable.  If ``FILENAME`` "
"is not used, the information is printed to the terminal.  Using the "
"``DESCRIPTION`` option a description or headline can be set which will be "
"printed above the actual content.  If only one type of package was "
"requested, no title is printed, unless it is explicitly set using either "
"``DESCRIPTION`` to use a custom string, or ``DEFAULT_DESCRIPTION`` to use "
"a default title for the requested type. If ``INCLUDE_QUIET_PACKAGES`` is "
"given, packages which have been searched with ``find_package(... QUIET)`` "
"will also be listed. By default they are skipped. If "
"``FATAL_ON_MISSING_REQUIRED_PACKAGES`` is given, CMake will abort if a "
"package which is marked as one of the package types listed in the "
":variable:`FeatureSummary_REQUIRED_PKG_TYPES` global property has not been"
" found. The default value for the "
":variable:`FeatureSummary_REQUIRED_PKG_TYPES` global property is "
"``REQUIRED``."
msgstr ""
"如果给出了 ``FILENAME``，信息将被打印到这个文件中。如果使用 APPEND "
"，则将其追加到该文件，否则如果该文件已经存在则将被覆盖。如果使用 VAR 选项，信息将被“打印”到指定的变量中。如果不使用 "
"``FILENAME``，信息将打印到终端。使用 ``DESCRIPTION`` "
"选项可以设置描述或标题，这些描述或标题将打印在实际内容之上。如果只请求了一种类型的包，则不会打印标题，除非使用“DESCRIPTION”显式设置以使用自定义字符串，或“DEFAULT_DESCRIPTION”使用请求类型的默认标题。如果给出了"
" ``INCLUDE_QUIET_PACKAGES``，则还将列出使用 ``find_package(... QUIET)`` "
"搜索过的包。默认情况下它们被跳过。如果给出了 ``FATAL_ON_MISSING_REQUIRED_PACKAGES``，如果未找到被标记为 "
"FeatureSummary_REQUIRED_PKG_TYPES` 全局属性中列出的包类型之一的包，CMake 将中止。 "
":variable:`FeatureSummary_REQUIRED_PKG_TYPES` 全局属性的默认值为 ``REQUIRED``。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:274
msgid "The ``DEFAULT_DESCRIPTION`` option."
msgstr "``DEFAULT_DESCRIPTION`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:277
msgid ""
"The :variable:`FeatureSummary_DEFAULT_PKG_TYPE` global property can be "
"modified to change the default package type assigned when not explicitly "
"assigned by the user."
msgstr ""
":variable:`FeatureSummary_DEFAULT_PKG_TYPE` 全局属性可以修改，以更改在用户未明确指定时指定的默认包类型。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:281
msgid ""
"If the ``QUIET_ON_EMPTY`` option is used, if only one type of package was "
"requested, and no packages belonging to that category were found, then no "
"output (including the ``DESCRIPTION``) is printed or added to the ``VAR`` "
"variable."
msgstr ""
"如果使用 ``QUIET_ON_EMPTY`` 选项，如果只请求了一种类型的包，并且没有找到属于该类别的包，则没有输出（包括 "
"``DESCRIPTION``）被打印或添加到 `` VAR``变量。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:287
msgid "Example 1, append everything to a file:"
msgstr "示例 1，将所有内容附加到文件："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:295
msgid ""
"Example 2, print the enabled features into the variable "
"enabledFeaturesText, including QUIET packages:"
msgstr "示例 2，将启用的功能打印到变量 enabledFeaturesText 中，包括 QUIET 包："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:307
msgid ""
"Example 3, change default package types and print only the categories that"
" are not empty:"
msgstr "示例 3，更改默认包类型并仅打印不为空的类别："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:481
msgid ""
"Use this macro to set up information about the named package, which can "
"then be displayed via FEATURE_SUMMARY().  This can be done either directly"
" in the Find-module or in the project which uses the module after the "
"find_package() call.  The features for which information can be set are "
"added automatically by the find_package() command."
msgstr ""
"使用此宏设置有关命名包的信息，然后可以通过 FEATURE_SUMMARY() 显示这些信息。这可以直接在查找模块中完成，也可以在调用 "
"find_package() 之后使用该模块的项目中完成。可以设置信息的特性由 find_package() 命令自动添加。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:489
msgid "``URL <url>``"
msgstr "``网址<网址>``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:488
msgid ""
"This should be the homepage of the package, or something similar. Ideally "
"this is set already directly in the Find-module."
msgstr "这应该是包的主页，或类似的东西。理想情况下，这已直接在查找模块中设置。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:493
msgid "``DESCRIPTION <description>``"
msgstr "``描述<描述>``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:492
msgid ""
"A short description what that package is, at most one sentence. Ideally "
"this is set already directly in the Find-module."
msgstr "简短描述那个包是什么，最多一句话。理想情况下，这已直接在查找模块中设置。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:514
msgid "``TYPE <type>``"
msgstr "``类型<类型>``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:496
msgid ""
"What type of dependency has the using project on that package. Default is "
"``OPTIONAL``.  In this case it is a package which can be used by the "
"project when available at buildtime, but it also work without. "
"``RECOMMENDED`` is similar to ``OPTIONAL``, i.e.  the project will build "
"if the package is not present, but the functionality of the resulting "
"binaries will be severely limited.  If a ``REQUIRED`` package is not "
"available at buildtime, the project may not even build.  This can be "
"combined with the ``FATAL_ON_MISSING_REQUIRED_PACKAGES`` argument for "
"``feature_summary()``.  Last, a ``RUNTIME`` package is a package which is "
"actually not used at all during the build, but which is required for "
"actually running the resulting binaries.  So if such a package is missing,"
" the project can still be built, but it may not work later on. If "
"``set_package_properties()`` is called multiple times for the same package"
" with different TYPEs, the ``TYPE`` is only changed to higher TYPEs "
"(``RUNTIME < OPTIONAL < RECOMMENDED < REQUIRED``), lower TYPEs are "
"ignored.  The ``TYPE`` property is project-specific, so it cannot be set "
"by the Find-module, but must be set in the project. Type accepted can be "
"changed by setting the :variable:`FeatureSummary_PKG_TYPES` global "
"property."
msgstr ""
"什么类型的依赖项在该包上有使用项目。默认为“可选”。在这种情况下，它是一个包，在构建时可用时可供项目使用，但它也可以在没有时使用。 "
"``RECOMMENDED`` 类似于 "
"``OPTIONAL``，即如果包不存在，项目将构建，但生成的二进制文件的功能将受到严重限制。如果在构建时“REQUIRED”包不可用，项目甚至可能无法构建。这可以与"
" ``feature_summary()`` 的 ``FATAL_ON_MISSING_REQUIRED_PACKAGES`` "
"参数结合使用。最后，``RUNTIME`` "
"包是在构建过程中实际上根本不使用的包，但实际运行生成的二进制文件是必需的。所以如果缺少这样的包，项目仍然可以构建，但以后可能无法运行。如果 "
"``set_package_properties()`` 对具有不同类型的同一个包多次调用，``TYPE`` "
"只会更改为更高的类型（``RUNTIME < OPTIONAL < RECOMMENDED < REQUIRED``），较低的类型将被忽略. "
"``TYPE`` 属性是项目特定的，因此不能通过 Find-module 设置，但必须在项目中设置。可以通过设置 "
"FeatureSummary_PKG_TYPES 全局属性来更改接受的类型。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:523
msgid "``PURPOSE <purpose>``"
msgstr "``目的<目的>``"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:517
msgid ""
"This describes which features this package enables in the project, i.e.  "
"it tells the user what functionality he gets in the resulting binaries.  "
"If set_package_properties() is called multiple times for a package, all "
"PURPOSE properties are appended to a list of purposes of the package in "
"the project.  As the TYPE property, also the PURPOSE property is project-"
"specific, so it cannot be set by the Find-module, but must be set in the "
"project."
msgstr ""
"这描述了这个包在项目中启用了哪些功能，即它告诉用户他在生成的二进制文件中获得了哪些功能。如果为包多次调用 "
"set_package_properties()，所有 PURPOSE 属性将附加到项目中包的用途列表。与 TYPE 属性一样，PURPOSE "
"属性也是项目特定的，因此不能由 Find-module 设置，但必须在项目中设置。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:525
msgid "Example for setting the info for a package:"
msgstr "设置包信息的示例："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:620
msgid ""
"Use this macro to add information about a feature with the given "
"``<name>``. ``<enabled>`` contains whether this feature is enabled or not."
" It can be a variable or a list of conditions. ``<description>`` is a text"
" describing the feature.  The information can be displayed using "
"``feature_summary()`` for ``ENABLED_FEATURES`` and ``DISABLED_FEATURES`` "
"respectively."
msgstr ""
"使用此宏添加有关具有给定的“<name>”的功能的信息。 ``<enabled>`` 包含此功能是否启用。它可以是变量或条件列表。 "
"``<description>`` 是描述特征的文本。可以分别使用 ``feature_summary()`` 为 "
"`ENABLED_FEATURES`` 和 ``DISABLED_FEATURES`` 显示信息。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:627
msgid "``<enabled>`` can be a list of conditions."
msgstr "``<enabled>`` 可以是条件列表。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:630
msgid "Example for setting the info for a feature:"
msgstr "设置功能信息的示例："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:661
msgid "Legacy Macros"
msgstr "遗留宏"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:663
msgid ""
"The following macros are provided for compatibility with previous CMake "
"versions:"
msgstr "提供以下宏是为了与以前的 CMake 版本兼容："

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:672
msgid ""
"Use this macro to set up information about the named package, which can "
"then be displayed via ``feature_summary()``.  This can be done either "
"directly in the Find-module or in the project which uses the module after "
"the :command:`find_package` call.  The features for which information can "
"be set are added automatically by the ``find_package()`` command."
msgstr ""
"使用此宏设置有关命名包的信息，然后可以通过 ``feature_summary()`` 显示这些信息。这可以直接在查找模块中完成，也可以在 "
"find_package 调用后使用该模块的项目中完成。可以设置信息的功能由 find_package() 命令自动添加。"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:704
msgid "Does the same as::"
msgstr "与 ::相同"

#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:720
#: ../../cmake-prefix/src/cmake/Modules/FeatureSummary.cmake:739
msgid "Does the same as"
msgstr "和一样"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:6
msgid "FetchContent"
msgstr "获取内容"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:14
msgid ""
"The :guide:`Using Dependencies Guide` provides a high-level introduction "
"to this general topic. It provides a broader overview of where the "
"``FetchContent`` module fits into the bigger picture, including its "
"relationship to the :command:`find_package` command. The guide is "
"recommended pre-reading before moving on to the details below."
msgstr ""
":guide:`Using Dependencies Guide` 提供了对此一般主题的高级介绍。它更广泛地概述了``FetchContent`` "
"模块在更大范围内的位置，包括它与 :command:`find_package` 命令的关系。建议在继续阅读以下详细信息之前先阅读该指南。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:21
msgid "Overview"
msgstr "概述"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:23
msgid ""
"This module enables populating content at configure time via any method "
"supported by the :module:`ExternalProject` module.  Whereas "
":command:`ExternalProject_Add` downloads at build time, the "
"``FetchContent`` module makes content available immediately, allowing the "
"configure step to use the content in commands like "
":command:`add_subdirectory`, :command:`include` or :command:`file` "
"operations."
msgstr ""
"该模块允许在配置时通过 ExternalProject 模块支持的任何方法填充内容。鉴于 "
":command:`ExternalProject_Add` 在构建时下载，``FetchContent`` "
"模块使内容立即可用，允许配置步骤使用命令中的内容，如 :command:`add_subdirectory`、 :command:`include` "
"或 :command:`文件`操作。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:30
msgid ""
"Content population details should be defined separately from the command "
"that performs the actual population.  This separation ensures that all the"
" dependency details are defined before anything might try to use them to "
"populate content.  This is particularly important in more complex project "
"hierarchies where dependencies may be shared between multiple projects."
msgstr ""
"内容填充详细信息应与执行实际填充的命令分开定义。这种分离可确保在任何尝试使用它们来填充内容之前定义所有依赖项详细信息。这在更复杂的项目层次结构中尤为重要，在这些层次结构中，依赖关系可能在多个项目之间共享。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:36
msgid ""
"The following shows a typical example of declaring content details for "
"some dependencies and then ensuring they are populated with a separate "
"call:"
msgstr "下面显示了声明某些依赖项的内容详细信息然后确保使用单独的调用填充它们的典型示例："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:54
msgid ""
"The :command:`FetchContent_MakeAvailable` command ensures the named "
"dependencies have been populated, either by an earlier call or by "
"populating them itself.  When performing the population, it will also add "
"them to the main build, if possible, so that the main build can use the "
"populated projects' targets, etc.  See the command's documentation for how"
" these steps are performed."
msgstr ""
":command:`FetchContent_MakeAvailable` "
"命令确保指定的依赖项已被填充，无论是通过较早的调用还是通过自己填充它们。执行填充时，如果可能的话，它还会将它们添加到主构建中，以便主构建可以使用填充项目的目标等。有关如何执行这些步骤的信息，请参阅命令的文档。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:61
msgid ""
"When using a hierarchical project arrangement, projects at higher levels "
"in the hierarchy are able to override the declared details of content "
"specified anywhere lower in the project hierarchy.  The first details to "
"be declared for a given dependency take precedence, regardless of where in"
" the project hierarchy that occurs.  Similarly, the first call that tries "
"to populate a dependency \"wins\", with subsequent populations reusing the"
" result of the first instead of repeating the population again. See the "
":ref:`Examples <fetch-content-examples>` which demonstrate this scenario."
msgstr ""
"使用分层项目安排时，层次结构中较高级别的项目能够覆盖项目层次结构中任何较低级别指定的内容的声明详细信息。无论发生在项目层次结构中的哪个位置，为给定依赖项声明的第一个细节优先。类似地，尝试填充依赖项的第一个调用“获胜”，随后的填充将重用第一个的结果而不是再次重复填充。请参阅演示此场景的"
" :ref:`Examples <fetch-content-examples>`。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:71
msgid ""
"In some cases, the main project may need to have more precise control over"
" the population, or it may be required to explicitly define the population"
" steps in a way that cannot be captured by the declared details alone. For"
" such situations, the lower level :command:`FetchContent_GetProperties` "
"and :command:`FetchContent_Populate` commands can be used.  These lack the"
" richer features provided by :command:`FetchContent_MakeAvailable` though,"
" so their direct use should be considered a last resort.  The typical "
"pattern of such custom steps looks like this:"
msgstr ""
"在某些情况下，主项目可能需要对填充进行更精确的控制，或者可能需要以一种仅通过声明的细节无法捕获的方式明确定义填充步骤。对于这种情况，可以使用较低级别的"
" FetchContent_GetProperties 和 FetchContent_Populate 命令。但是，它们缺少 "
":command:`FetchContent_MakeAvailable` "
"提供的更丰富的功能，因此直接使用它们应该被视为最后的手段。此类自定义步骤的典型模式如下所示："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:98
msgid ""
"The ``FetchContent`` module also supports defining and populating content "
"in a single call, with no check for whether the content has been populated"
" elsewhere already.  This should not be done in projects, but may be "
"appropriate for populating content in CMake's script mode. See "
":command:`FetchContent_Populate` for details."
msgstr ""
"``FetchContent`` 模块还支持在单个调用中定义和填充内容，而不检查内容是否已在其他地方填充。这不应该在项目中完成，但可能适合在 "
"CMake 的脚本模式下填充内容。有关详细信息，请参阅 :command:`FetchContent_Populate`。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:119
msgid ""
"The ``FetchContent_Declare()`` function records the options that describe "
"how to populate the specified content.  If such details have already been "
"recorded earlier in this project (regardless of where in the project "
"hierarchy), this and all later calls for the same content ``<name>`` are "
"ignored.  This \"first to record, wins\" approach is what allows "
"hierarchical projects to have parent projects override content details of "
"child projects."
msgstr ""
"``FetchContent_Declare()`` "
"函数记录描述如何填充指定内容的选项。如果此类详细信息已在该项目的早期记录（无论在项目层次结构中的何处），则忽略此内容和所有以后对相同内容“<name>”的调用。这种“先记录者获胜”的方法允许分层项目让父项目覆盖子项目的内容细节。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:126
msgid ""
"The content ``<name>`` can be any string without spaces, but good practice"
" would be to use only letters, numbers and underscores.  The name will be "
"treated case-insensitively and it should be obvious for the content it "
"represents, often being the name of the child project or the value given "
"to its top level :command:`project` command (if it is a CMake project). "
"For well-known public projects, the name should generally be the official "
"name of the project.  Choosing an unusual name makes it unlikely that "
"other projects needing that same content will use the same name, leading "
"to the content being populated multiple times."
msgstr ""
"内容 ``<name>`` "
"可以是任何不带空格的字符串，但最好只使用字母、数字和下划线。该名称将不区分大小写处理，并且它所代表的内容应该是显而易见的，通常是子项目的名称或其顶级"
" :command:`project` 命令的值（如果它是 CMake 项目） "
".对于知名的公共项目，名称一般应为项目的正式名称。选择一个不寻常的名称使得需要相同内容的其他项目不太可能使用相同的名称，从而导致内容被多次填充。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:136
msgid ""
"The ``<contentOptions>`` can be any of the download, update or patch "
"options that the :command:`ExternalProject_Add` command understands.  The "
"configure, build, install and test steps are explicitly disabled and "
"therefore options related to them will be ignored.  The ``SOURCE_SUBDIR`` "
"option is an exception, see :command:`FetchContent_MakeAvailable` for "
"details on how that affects behavior."
msgstr ""
"``<contentOptions>`` 可以是 :command:`ExternalProject_Add` "
"命令可以理解的任何下载、更新或补丁选项。配置、构建、安装和测试步骤被明确禁用，因此与它们相关的选项将被忽略。 ``SOURCE_SUBDIR`` "
"选项是一个例外，请参阅 :command:`FetchContent_MakeAvailable` 了解它如何影响行为的详细信息。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:143
msgid ""
"In most cases, ``<contentOptions>`` will just be a couple of options "
"defining the download method and method-specific details like a commit tag"
" or archive hash.  For example:"
msgstr ""
"在大多数情况下，``<contentOptions>`` 只是几个定义下载方法和特定于方法的详细信息（如提交标记或存档哈希）的选项。例如："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:167
msgid ""
"Where contents are being fetched from a remote location and you do not "
"control that server, it is advisable to use a hash for ``GIT_TAG`` rather "
"than a branch or tag name.  A commit hash is more secure and helps to "
"confirm that the downloaded contents are what you expected."
msgstr ""
"在从远程位置获取内容并且您不控制该服务器的情况下，建议对 ``GIT_TAG`` "
"使用散列而不是分支或标签名称。提交哈希更安全，有助于确认下载的内容是否符合您的预期。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:172
msgid ""
"Commands for the download, update or patch steps can access the terminal. "
"This may be needed for things like password prompts or real-time display "
"of command progress."
msgstr "下载、更新或补丁步骤的命令可以访问终端。对于密码提示或命令进度的实时显示之类的事情，可能需要这样做。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:177
msgid ""
"The :variable:`CMAKE_TLS_VERIFY`, :variable:`CMAKE_TLS_CAINFO`, "
":variable:`CMAKE_NETRC` and :variable:`CMAKE_NETRC_FILE` variables now "
"provide the defaults for their corresponding content options, just like "
"they do for :command:`ExternalProject_Add`. Previously, these variables "
"were ignored by the ``FetchContent`` module."
msgstr ""
":variable:`CMAKE_TLS_VERIFY`、 :variable:`CMAKE_TLS_CAINFO`、 :variable:`CMAKE_NETRC`"
" 和 :variable:`CMAKE_NETRC_FILE` 变量现在为其相应的内容选项提供默认值，就像它们为 "
":command:`ExternalProject_Add` 所做的一样.以前，这些变量被“FetchContent”模块忽略。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:213
msgid "``FIND_PACKAGE_ARGS``"
msgstr "``FIND_PACKAGE_ARGS``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:187
msgid ""
"This option is for scenarios where the "
":command:`FetchContent_MakeAvailable` command may first try a call to "
":command:`find_package` to satisfy the dependency for ``<name>``. By "
"default, such a call would be simply ``find_package(<name>)``, but "
"``FIND_PACKAGE_ARGS`` can be used to provide additional arguments to be "
"appended after the ``<name>``.  ``FIND_PACKAGE_ARGS`` can also be given "
"with nothing after it, which indicates that :command:`find_package` can "
"still be called if :variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` is set "
"to ``OPT_IN`` or is not set."
msgstr ""
"此选项适用于以下情况 :command:`FetchContent_MakeAvailable` 命令可能首先尝试调用 :command:`find_package` "
"以满足``<name>`` "
"的依赖性。默认情况下，这样的调用将只是``find_package(<name>)``，但是``FIND_PACKAGE_ARGS`` "
"可用于提供附加参数以附加在``<name>`` 之后。 ``FIND_PACKAGE_ARGS`` "
"也可以不带任何内容给出，这表明:command:`find_package` "
"如果:variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` 设置为 ``OPT_IN`` "
"或未设置，仍然可以调用。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:197
msgid ""
"Everything after the ``FIND_PACKAGE_ARGS`` keyword is appended to the "
":command:`find_package` call, so all other ``<contentOptions>`` must come "
"before the ``FIND_PACKAGE_ARGS`` keyword.  If the "
":variable:`CMAKE_FIND_PACKAGE_TARGETS_GLOBAL` variable is set to true at "
"the time ``FetchContent_Declare()`` is called, a ``GLOBAL`` keyword will "
"be appended to the :command:`find_package` arguments if it was not already"
" specified.  It will also be appended if ``FIND_PACKAGE_ARGS`` was not "
"given, but :variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` was set to "
"``ALWAYS``."
msgstr ""
"``FIND_PACKAGE_ARGS`` 关键字之后的所有内容都附加到 :command:`find_package` 调用，因此所有其他 "
"``<contentOptions>`` 必须位于 ``FIND_PACKAGE_ARGS`` 关键字之前。如果 "
":variable:`CMAKE_FIND_PACKAGE_TARGETS_GLOBAL` 变量在调用 "
"``FetchContent_Declare()`` 时设置为 true，则 ``GLOBAL`` 关键字将附加到 "
":command:`find_package` 参数中指定的。如果未给出 ``FIND_PACKAGE_ARGS``，但 "
":variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` 设置为 ``ALWAYS``，它也会被附加。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:207
msgid ""
"``OVERRIDE_FIND_PACKAGE`` cannot be used when ``FIND_PACKAGE_ARGS`` is "
"given."
msgstr "当给出 ``FIND_PACKAGE_ARGS`` 时，不能使用 `OVERRIDE_FIND_PACKAGE``。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:210
msgid ""
":ref:`dependency_providers` discusses another way that "
":command:`FetchContent_MakeAvailable` calls can be redirected. "
"``FIND_PACKAGE_ARGS`` is intended for project control, whereas dependency "
"providers allow users to override project behavior."
msgstr ""
":ref:`dependency_providers` 讨论了另一种可以重定向 "
":command:`FetchContent_MakeAvailable` 调用的方法。 ``FIND_PACKAGE_ARGS`` "
"用于项目控制，而依赖项提供程序允许用户覆盖项目行为。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:230
msgid "``OVERRIDE_FIND_PACKAGE``"
msgstr "``OVERRIDE_FIND_PACKAGE``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:216
msgid ""
"When a ``FetchContent_Declare(<name> ...)`` call includes this option, "
"subsequent calls to ``find_package(<name> ...)`` will ensure that "
"``FetchContent_MakeAvailable(<name>)`` has been called, then use the "
"config package files in the :variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` "
"directory (which are usually created by ``FetchContent_MakeAvailable()``)."
" This effectively makes :command:`FetchContent_MakeAvailable` override "
":command:`find_package` for the named dependency, allowing the former to "
"satisfy the package requirements of the latter.  ``FIND_PACKAGE_ARGS`` "
"cannot be used when ``OVERRIDE_FIND_PACKAGE`` is given."
msgstr ""
"当 ``FetchContent_Declare(<name> ...)`` 调用包含此选项时，后续调用 ``find_package(<name>"
" ...)`` 将确保 ``FetchContent_MakeAvailable(<name>)`` 具有被调用，然后使用 "
":variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` 目录中的配置包文件（通常由 "
"``FetchContent_MakeAvailable()`` 创建）。这有效地使 "
":command:`FetchContent_MakeAvailable` 覆盖 :command:`find_package` "
"用于指定的依赖项，允许前者满足后者的包要求。当给出 `OVERRIDE_FIND_PACKAGE`` 时，不能使用 "
"``FIND_PACKAGE_ARGS``。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:226
msgid ""
"If a :ref:`dependency provider <dependency_providers>` has been set and "
"the project calls :command:`find_package` for the ``<name>`` dependency, "
"``OVERRIDE_FIND_PACKAGE`` will not prevent the provider from seeing that "
"call.  Dependency providers always have the opportunity to intercept any "
"direct call to :command:`find_package`, except if that call contains the "
"``BYPASS_PROVIDER`` option."
msgstr ""
"如果 :ref:`dependency provider <dependency_providers>` 已经设置并且项目为``<name>`` "
"依赖调用 :command:`find_package`，``OVERRIDE_FIND_PACKAGE`` "
"不会阻止提供者看到那个调用.依赖提供者总是有机会拦截对 :command:`find_package` 的任何直接调用，除非该调用包含 "
"``BYPASS_PROVIDER`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:240
msgid "``SYSTEM``"
msgstr "``系统``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:236
msgid ""
"If the ``SYSTEM`` argument is provided, the :prop_dir:`SYSTEM` directory "
"property of a subdirectory added by :command:`FetchContent_MakeAvailable` "
"will be set to true.  This will affect non-imported targets created as "
"part of that command. See the :prop_tgt:`SYSTEM` target property "
"documentation for a more detailed discussion of the effects."
msgstr ""
"如果提供了 ``SYSTEM`` 参数，则由 :command:`FetchContent_MakeAvailable` 添加的子目录的 "
":prop_dir:`SYSTEM` 目录属性将设置为 true。这将影响作为该命令的一部分创建的非导入目标。有关效果的更详细讨论，请参阅 "
":prop_tgt:`SYSTEM` 目标属性文档。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:251
msgid ""
"This command ensures that each of the named dependencies are made "
"available to the project by the time it returns.  There must have been a "
"call to :command:`FetchContent_Declare` for each dependency, and the first"
" such call will control how that dependency will be made available, as "
"described below."
msgstr ""
"此命令确保每个命名的依赖项在返回时都可供项目使用。必须为每个依赖调用 "
":command:`FetchContent_Declare`，并且第一个这样的调用将控制如何使该依赖可用，如下所述。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:256
msgid "If ``<lowercaseName>_SOURCE_DIR`` is not set:"
msgstr "如果未设置 ``<lowercaseName>_SOURCE_DIR``："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:260
msgid ""
"If a :ref:`dependency provider <dependency_providers>` is set, call the "
"provider's command with ``FETCHCONTENT_MAKEAVAILABLE_SERIAL`` as the first"
" argument, followed by the arguments of the first call to "
":command:`FetchContent_Declare` for ``<name>``.  If ``SOURCE_DIR`` or "
"``BINARY_DIR`` were not part of the original declared arguments, they will"
" be added with their default values. If "
":variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` was set to ``NEVER`` when "
"the details were declared, any ``FIND_PACKAGE_ARGS`` will be omitted.  The"
" ``OVERRIDE_FIND_PACKAGE`` keyword is also always omitted. If the provider"
" fulfilled the request, ``FetchContent_MakeAvailable()`` will consider "
"that dependency handled, skip the remaining steps below and move on to the"
" next dependency in the list."
msgstr ""
"如果 :ref:`依赖提供者 <dependency_providers>` "
"被设置，以``FETCHCONTENT_MAKEAVAILABLE_SERIAL`` 作为第一个参数调用提供者的命令，然后是第一次调用 "
":command:`FetchContent_Declare` for ``<name 的参数>``。如果 ``SOURCE_DIR`` 或 "
"``BINARY_DIR`` "
"不是原始声明参数的一部分，它们将被添加为默认值。如果 :variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` "
"在声明详细信息时设置为 ``NEVER``，则将省略任何 ``FIND_PACKAGE_ARGS``。 "
"``OVERRIDE_FIND_PACKAGE`` "
"关键字也总是被省略。如果提供者满足了请求，``FetchContent_MakeAvailable()`` "
"将认为该依赖项已处理，跳过下面剩余的步骤并转到列表中的下一个依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:275
msgid ""
"If permitted, :command:`find_package(<name> [<args>...]) <find_package>` "
"will be called, where ``<args>...`` may be provided by the "
"``FIND_PACKAGE_ARGS`` option in :command:`FetchContent_Declare`. The value"
" of the :variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` variable at the "
"time :command:`FetchContent_Declare` was called determines whether "
"``FetchContent_MakeAvailable()`` can call :command:`find_package`. If the "
":variable:`CMAKE_FIND_PACKAGE_TARGETS_GLOBAL` variable is set to true when"
" ``FetchContent_MakeAvailable()`` is called, it still affects any imported"
" targets created when that in turn calls :command:`find_package`, even if "
"that variable was false when the corresponding details were declared."
msgstr ""
"如果允许，将调用 :command:`find_package(<name> [<args>...]) <find_package>`，其中 "
"``<args>...`` 可能由 ``FIND_PACKAGE_ARGS`` 提供 :command:`FetchContent_Declare` "
"中的选项。调用 FetchContent_Declare 时 FETCHCONTENT_TRY_FIND_PACKAGE_MODE 变量的值决定了 "
"FetchContent_MakeAvailable() 是否可以调用 find_package。如果 "
":variable:`CMAKE_FIND_PACKAGE_TARGETS_GLOBAL` 变量在调用 "
"``FetchContent_MakeAvailable()`` 时设置为 true，它仍然会影响在依次调用 "
":command:`find_package` 时创建的任何导入目标，即使该变量在以下情况下为 false公布了相应的细节。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:287
msgid ""
"If the dependency was not satisfied by a provider or a "
":command:`find_package` call, ``FetchContent_MakeAvailable()`` then uses "
"the following logic to make the dependency available:"
msgstr ""
"如果提供者或 :command:`find_package` 调用不满足依赖关系，则 "
"``FetchContent_MakeAvailable()`` 会使用以下逻辑使依赖关系可用："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:291
msgid ""
"If the dependency has already been populated earlier in this run, set the "
"``<lowercaseName>_POPULATED``, ``<lowercaseName>_SOURCE_DIR`` and "
"``<lowercaseName>_BINARY_DIR`` variables in the same way as a call to "
":command:`FetchContent_GetProperties`, then skip the remaining steps below"
" and move on to the next dependency in the list."
msgstr ""
"如果在本次运行的早期已经填充了依赖项，请以与调用相同的方式设置 "
"``<lowercaseName>_POPULATED``、``<lowercaseName>_SOURCE_DIR`` 和 "
"``<lowercaseName>_BINARY_DIR`` 变量： "
"command:`FetchContent_GetProperties`，然后跳过下面剩余的步骤并转到列表中的下一个依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:297
msgid ""
"Call :command:`FetchContent_Populate` to populate the dependency using the"
" details recorded by an earlier call to :command:`FetchContent_Declare`. "
"Halt with a fatal error if no such details have been recorded. "
":variable:`FETCHCONTENT_SOURCE_DIR_<uppercaseName>` can be used to "
"override the declared details and use content provided at the specified "
"location instead."
msgstr ""
"调用 FetchContent_Populate 以使用之前调用 FetchContent_Declare "
"记录的详细信息填充依赖项。如果没有记录此类详细信息，则会因致命错误而停止。 "
":variable:`FETCHCONTENT_SOURCE_DIR_<uppercaseName>` "
"可用于覆盖声明的详细信息并改用在指定位置提供的内容。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:306
msgid ""
"Ensure the :variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` directory contains"
" a ``<lowercaseName>-config.cmake`` and a ``<lowercaseName>-config-"
"version.cmake`` file (or equivalently ``<name>Config.cmake`` and "
"``<name>ConfigVersion.cmake``). The directory that the "
":variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` variable points to is cleared"
" at the start of every CMake run. If no config file exists when "
":command:`FetchContent_Populate` returns, a minimal one will be written "
"which :command:`includes <include>` any ``<lowercaseName>-extra.cmake`` or"
" ``<name>Extra.cmake`` file with the ``OPTIONAL`` flag (so the files can "
"be missing and won't generate a warning).  Similarly, if no config version"
" file exists, a very simple one will be written which sets "
"``PACKAGE_VERSION_COMPATIBLE`` and ``PACKAGE_VERSION_EXACT`` to true.  "
"This ensures all future calls to :command:`find_package()` for the "
"dependency will use the redirected config file, regardless of any version "
"requirements. CMake cannot automatically determine an arbitrary "
"dependency's version, so it cannot set ``PACKAGE_VERSION``. When a "
"dependency is pulled in via :command:`add_subdirectory` in the next step, "
"it may choose to overwrite the generated config version file in "
":variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` with one that also sets "
"``PACKAGE_VERSION``. The dependency may also write a "
"``<lowercaseName>-extra.cmake`` or ``<name>Extra.cmake`` file to perform "
"custom processing or define any variables that their normal (installed) "
"package config file would otherwise usually define (many projects don't do"
" any custom processing or set any variables and therefore have no need to "
"do this). If required, the main project can write these files instead if "
"the dependency project doesn't do so.  This allows the main project to add"
" missing details from older dependencies that haven't or can't be updated "
"to support this functionality. See `Integrating With find_package()`_ for "
"examples."
msgstr ""
"确保 :variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` "
"目录包含一个``<lowercaseName>-config.cmake`` 和一个``<lowercaseName>-config-"
"version.cmake`` 文件（或等效的``<name>Config.cmake` ` 和 "
"``<name>ConfigVersion.cmake``）。 "
":variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` 变量指向的目录在每次 CMake 运行开始时被清除。如果 "
":command:`FetchContent_Populate` 返回时不存在配置文件，将写入一个最小的配置文件，其中 "
":command:`includes <include>` 任何 ``<lowercaseName>-extra.cmake`` 或 "
"``<name>Extra。带有 ``OPTIONAL`` 标志的 cmake`` "
"文件（因此文件可能会丢失并且不会生成警告）。同样，如果不存在配置版本文件，将编写一个非常简单的文件，将“PACKAGE_VERSION_COMPATIBLE”和“PACKAGE_VERSION_EXACT”设置为"
" true。这确保了所有未来对 :command:`find_package()` 的调用都将使用重定向的配置文件，无论任何版本要求如何。 "
"CMake 无法自动确定任意依赖项的版本，因此它无法设置“PACKAGE_VERSION”。当在下一步中通过 add_subdirectory "
"引入依赖项时，它可能会选择在 CMAKE_FIND_PACKAGE_REDIRECTS_DIR 中覆盖生成的配置版本文件，其中也设置了 "
"`PACKAGE_VERSION``。依赖项还可以编写一个``<lowercaseName>-extra.cmake`` "
"或``<name>Extra.cmake`` "
"文件来执行自定义处理或定义其正常（已安装）包配置文件通常定义的任何变量（许多项目不做任何自定义处理或设置任何变量，因此不需要这样做）。如果需要，如果依赖项目不这样做，主项目可以编写这些文件。这允许主项目添加旧依赖项中缺少的详细信息，这些依赖项尚未或无法更新以支持此功能。有关示例，请参阅“与"
" find_package() 集成”。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:338
msgid ""
"If the top directory of the populated content contains a "
"``CMakeLists.txt`` file, call :command:`add_subdirectory` to add it to the"
" main build. It is not an error for there to be no ``CMakeLists.txt`` "
"file, which allows the command to be used for dependencies that make "
"downloaded content available at a known location, but which do not need or"
" support being added directly to the build."
msgstr ""
"如果填充内容的顶级目录包含一个 CMakeLists.txt 文件，请调用 add_subdirectory 将其添加到主构建中。没有 "
"CMakeLists.txt 文件不是错误，它允许命令用于依赖项，这些依赖项使下载的内容在已知位置可用，但不需要或不支持直接添加到建造。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:345
msgid ""
"The ``SOURCE_SUBDIR`` option can be given in the declared details to look "
"somewhere below the top directory instead (i.e. the same way that "
"``SOURCE_SUBDIR`` is used by the :command:`ExternalProject_Add` command)."
"  The path provided with ``SOURCE_SUBDIR`` must be relative and will be "
"treated as relative to the top directory.  It can also point to a "
"directory that does not contain a ``CMakeLists.txt`` file or even to a "
"directory that doesn't exist.  This can be used to avoid adding a project "
"that contains a ``CMakeLists.txt`` file in its top directory."
msgstr ""
"可以在声明的详细信息中给出 ``SOURCE_SUBDIR`` 选项，以查看顶层目录下方的某个位置（即 "
":command:`ExternalProject_Add` 命令使用 ``SOURCE_SUBDIR`` 的方式相同）。 "
"``SOURCE_SUBDIR`` "
"提供的路径必须是相对的，并且将被视为相对于顶级目录。它还可以指向不包含“CMakeLists.txt”文件的目录，甚至指向不存在的目录。这可用于避免在其顶级目录中添加包含"
" CMakeLists.txt 文件的项目。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:356
msgid ""
"If the ``SYSTEM`` keyword was included in the call to "
":command:`FetchContent_Declare`, the ``SYSTEM`` keyword will be added to "
"the :command:`add_subdirectory` command as well."
msgstr ""
"如果``SYSTEM`` 关键字包含在对 :command:`FetchContent_Declare` 的调用中，则``SYSTEM`` "
"关键字也将添加到 :command:`add_subdirectory` 命令中。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:361
msgid ""
"Projects should aim to declare the details of all dependencies they might "
"use before they call ``FetchContent_MakeAvailable()`` for any of them. "
"This ensures that if any of the dependencies are also sub-dependencies of "
"one or more of the others, the main project still controls the details "
"that will be used (because it will declare them first before the "
"dependencies get a chance to).  In the following code samples, assume that"
" the ``uses_other`` dependency also uses ``FetchContent`` to add the "
"``other`` dependency internally:"
msgstr ""
"项目应该旨在声明他们可能使用的所有依赖项的详细信息，然后再为它们中的任何一个调用“FetchContent_MakeAvailable()”。这确保如果任何依赖项也是一个或多个其他依赖项的子依赖项，主项目仍然控制将使用的细节（因为它会在依赖项有机会之前首先声明它们）。在以下代码示例中，假设"
" ``uses_other`` 依赖项也使用 ``FetchContent`` 在内部添加 ``other`` 依赖项："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:386
msgid ""
"Note that :variable:`CMAKE_VERIFY_INTERFACE_HEADER_SETS` is explicitly set"
" to false upon entry to ``FetchContent_MakeAvailable()``, and is restored "
"to its original value before the command returns.  Developers typically "
"only want to verify header sets from the main project, not those from any "
"dependencies.  This local manipulation of the "
":variable:`CMAKE_VERIFY_INTERFACE_HEADER_SETS` variable provides that "
"intuitive behavior.  You can use variables like "
":variable:`CMAKE_PROJECT_INCLUDE` or :variable:`CMAKE_PROJECT_<PROJECT-"
"NAME>_INCLUDE` to turn verification back on for all or some dependencies."
"  You can also set the :prop_tgt:`VERIFY_INTERFACE_HEADER_SETS` property "
"of individual targets."
msgstr ""
"请注意 :variable:`CMAKE_VERIFY_INTERFACE_HEADER_SETS` "
"在进入``FetchContent_MakeAvailable()`` 时明确设置为 "
"false，并在命令返回之前恢复为原始值。开发人员通常只想验证来自主项目的标头集，而不是来自任何依赖项的标头集。 "
"CMAKE_VERIFY_INTERFACE_HEADER_SETS 变量的这种本地操作提供了这种直观的行为。您可以使用 "
":variable:`CMAKE_PROJECT_INCLUDE` 或 :variable:`CMAKE_PROJECT_<PROJECT-"
"NAME>_INCLUDE` 等变量为所有或部分依赖项重新打开验证。您还可以设置单个目标的 "
":prop_tgt:`VERIFY_INTERFACE_HEADER_SETS` 属性。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:401
msgid ""
"Where possible, prefer to use :command:`FetchContent_MakeAvailable` "
"instead of implementing population manually with this command."
msgstr "在可能的情况下，更喜欢使用 FetchContent_MakeAvailable 而不是使用此命令手动实现填充。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:408
msgid ""
"In most cases, the only argument given to ``FetchContent_Populate()`` is "
"the ``<name>``.  When used this way, the command assumes the content "
"details have been recorded by an earlier call to "
":command:`FetchContent_Declare`.  The details are stored in a global "
"property, so they are unaffected by things like variable or directory "
"scope.  Therefore, it doesn't matter where in the project the details were"
" previously declared, as long as they have been declared before the call "
"to ``FetchContent_Populate()``.  Those saved details are then used to "
"construct a call to :command:`ExternalProject_Add` in a private sub-build "
"to perform the content population immediately.  The implementation of "
"``ExternalProject_Add()`` ensures that if the content has already been "
"populated in a previous CMake run, that content will be reused rather than"
" repopulating them again.  For the common case where population involves "
"downloading content, the cost of the download is only paid once."
msgstr ""
"在大多数情况下，提供给 ``FetchContent_Populate()`` 的唯一参数是 "
"``<name>``。以这种方式使用时，该命令假定内容详细信息已通过先前调用 FetchContent_Declare "
"记录。详细信息存储在全局属性中，因此它们不受变量或目录范围之类的影响。因此，只要在调用 FetchContent_Populate() "
"之前声明了详细信息，那么之前在项目中的哪个位置声明都没有关系。然后使用这些保存的详细信息在私有子构建中构造对 ExternalProject_Add"
" 的调用，以立即执行内容填充。 ``ExternalProject_Add()`` 的实现确保如果内容已经在之前的 CMake "
"运行中填充，该内容将被重用而不是再次重新填充它们。对于人口涉及下载内容的常见情况，下载费用仅支付一次。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:422
msgid ""
"An internal global property records when a particular content population "
"request has been processed.  If ``FetchContent_Populate()`` is called more"
" than once for the same content name within a configure run, the second "
"call will halt with an error.  Projects can and should check whether "
"content population has already been processed with the "
":command:`FetchContent_GetProperties` command before calling "
"``FetchContent_Populate()``."
msgstr ""
"内部全局属性记录何时处理了特定的内容填充请求。如果在配置运行中多次调用 FetchContent_Populate() "
"以获取相同的内容名称，则第二次调用将因错误而停止。项目可以而且应该在调用 ``FetchContent_Populate()`` "
"之前检查是否已经使用 FetchContent_GetProperties 命令处理了内容填充。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:430
msgid ""
"``FetchContent_Populate()`` will set three variables in the scope of the "
"caller:"
msgstr "``FetchContent_Populate()`` 将在调用者的范围内设置三个变量："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:434
msgid "``<lowercaseName>_POPULATED``"
msgstr "``<lowercaseName>_POPULATED``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:434
msgid "This will always be set to ``TRUE`` by the call."
msgstr "这将始终被调用设置为“真”。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:437
msgid "``<lowercaseName>_SOURCE_DIR``"
msgstr "``<lowercaseName>_SOURCE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:437
msgid "The location where the populated content can be found upon return."
msgstr "返回时可以找到填充内容的位置。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:440
msgid "``<lowercaseName>_BINARY_DIR``"
msgstr "``<lowercaseName>_BINARY_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:440
msgid "A directory intended for use as a corresponding build directory."
msgstr "旨在用作相应构建目录的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:442
msgid ""
"The main use case for the ``<lowercaseName>_SOURCE_DIR`` and "
"``<lowercaseName>_BINARY_DIR`` variables is to call "
":command:`add_subdirectory` immediately after population:"
msgstr ""
"``<lowercaseName>_SOURCE_DIR`` 和 ``<lowercaseName>_BINARY_DIR`` "
"变量的主要用例是在填充后立即调用:command:`add_subdirectory`："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:451
msgid ""
"The values of the three variables can also be retrieved from anywhere in "
"the project hierarchy using the :command:`FetchContent_GetProperties` "
"command."
msgstr "也可以使用 FetchContent_GetProperties 命令从项目层次结构中的任何位置检索这三个变量的值。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:454
msgid ""
"The ``FetchContent_Populate()`` command also supports a syntax allowing "
"the content details to be specified directly rather than using any saved "
"details.  This is more low-level and use of this form is generally to be "
"avoided in favor of using saved content details as outlined above. "
"Nevertheless, in certain situations it can be useful to invoke the content"
" population as an isolated operation (typically as part of implementing "
"some other higher level feature or when using CMake in script mode):"
msgstr ""
"``FetchContent_Populate()`` "
"命令还支持允许直接指定内容详细信息而不是使用任何保存的详细信息的语法。这是较低级别的，通常应避免使用此表单，以支持使用上面概述的已保存内容详细信息。然而，在某些情况下，将内容填充作为一个独立的操作调用可能很有用（通常作为实现其他一些更高级别功能的一部分或在脚本模式下使用"
" CMake 时）："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:473
msgid ""
"This form has a number of key differences to that where only ``<name>`` is"
" provided:"
msgstr "这种形式与仅提供 ``<name>`` 的形式有许多关键区别："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:476
msgid ""
"All required population details are assumed to have been provided directly"
" in the call to ``FetchContent_Populate()``. Any saved details for "
"``<name>`` are ignored."
msgstr ""
"假定已在调用“FetchContent_Populate()”时直接提供了所有必需的填充详细信息。 ``<name>`` "
"的任何已保存详细信息都将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:479
msgid ""
"No check is made for whether content for ``<name>`` has already been "
"populated."
msgstr "不检查 ``<name>`` 的内容是否已经被填充。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:481
msgid ""
"No global property is set to record that the population has occurred."
msgstr "没有设置全局属性来记录人口已经发生。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:482
msgid ""
"No global properties record the source or binary directories used for the "
"populated content."
msgstr "没有全局属性记录用于填充内容的源目录或二进制目录。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:484
msgid ""
"The ``FETCHCONTENT_FULLY_DISCONNECTED`` and "
"``FETCHCONTENT_UPDATES_DISCONNECTED`` cache variables are ignored."
msgstr ""
"``FETCHCONTENT_FULLY_DISCONNECTED`` 和 "
"``FETCHCONTENT_UPDATES_DISCONNECTED`` 缓存变量被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:487
msgid ""
"The ``<lowercaseName>_SOURCE_DIR`` and ``<lowercaseName>_BINARY_DIR`` "
"variables are still returned to the caller, but since these locations are "
"not stored as global properties when this form is used, they are only "
"available to the calling scope and below rather than the entire project "
"hierarchy.  No ``<lowercaseName>_POPULATED`` variable is set in the "
"caller's scope with this form."
msgstr ""
"``<lowercaseName>_SOURCE_DIR`` 和 ``<lowercaseName>_BINARY_DIR`` "
"变量仍然返回给调用者，但是由于在使用这种形式时这些位置没有存储为全局属性，它们只对调用范围可用和下面而不是整个项目层次结构。使用这种形式在调用者的作用域中没有设置"
" ``<lowercaseName>_POPULATED`` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:494
msgid ""
"The supported options for ``FetchContent_Populate()`` are the same as "
"those for :command:`FetchContent_Declare()`.  Those few options shown just"
" above are either specific to ``FetchContent_Populate()`` or their "
"behavior is slightly modified from how :command:`ExternalProject_Add` "
"treats them:"
msgstr ""
"``FetchContent_Populate()`` 支持的选项与 :command:`FetchContent_Declare()` "
"的选项相同。上面显示的那几个选项要么特定于“FetchContent_Populate()”，要么它们的行为与 "
"ExternalProject_Add 对待它们的方式略有修改："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:500
msgid ""
"The ``QUIET`` option can be given to hide the output associated with "
"populating the specified content.  If the population fails, the output "
"will be shown regardless of whether this option was given or not so that "
"the cause of the failure can be diagnosed.  The global "
"``FETCHCONTENT_QUIET`` cache variable has no effect on "
"``FetchContent_Populate()`` calls where the content details are provided "
"directly."
msgstr ""
"可以给出 ``QUIET`` "
"选项来隐藏与填充指定内容相关的输出。如果填充失败，无论是否给出此选项，都会显示输出，以便可以诊断失败的原因。全局“FETCHCONTENT_QUIET”缓存变量对直接提供内容详细信息的“FetchContent_Populate()”调用没有影响。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:514
msgid "``SUBBUILD_DIR``"
msgstr "``SUBBUILD_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:508
msgid ""
"The ``SUBBUILD_DIR`` argument can be provided to change the location of "
"the sub-build created to perform the population.  The default value is "
"``${CMAKE_CURRENT_BINARY_DIR}/<lowercaseName>-subbuild`` and it would be "
"unusual to need to override this default.  If a relative path is "
"specified, it will be interpreted as relative to "
":variable:`CMAKE_CURRENT_BINARY_DIR`. This option should not be confused "
"with the ``SOURCE_SUBDIR`` option which only affects the "
":command:`FetchContent_MakeAvailable` command."
msgstr ""
"可以提供 ``SUBBUILD_DIR`` 参数来更改为执行填充而创建的子构建的位置。默认值为 "
"``${CMAKE_CURRENT_BINARY_DIR}/<lowercaseName>-subbuild`` "
"并且通常不需要覆盖此默认值。如果指定了相对路径，它将被解释为相对于 "
":variable:`CMAKE_CURRENT_BINARY_DIR`。此选项不应与仅影响 FetchContent_MakeAvailable "
"命令的 ``SOURCE_SUBDIR`` 选项混淆。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:523
msgid "``SOURCE_DIR``, ``BINARY_DIR``"
msgstr "``SOURCE_DIR``，``BINARY_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:517
msgid ""
"The ``SOURCE_DIR`` and ``BINARY_DIR`` arguments are supported by "
":command:`ExternalProject_Add`, but different default values are used by "
"``FetchContent_Populate()``.  ``SOURCE_DIR`` defaults to "
"``${CMAKE_CURRENT_BINARY_DIR}/<lowercaseName>-src`` and ``BINARY_DIR`` "
"defaults to ``${CMAKE_CURRENT_BINARY_DIR}/<lowercaseName>-build``. If a "
"relative path is specified, it will be interpreted as relative to "
":variable:`CMAKE_CURRENT_BINARY_DIR`."
msgstr ""
":command:`ExternalProject_Add` 支持 ``SOURCE_DIR`` 和 ``BINARY_DIR`` 参数，但 "
"``FetchContent_Populate()`` 使用不同的默认值。 ``SOURCE_DIR`` "
"默认为``${CMAKE_CURRENT_BINARY_DIR}/<lowercaseName>-src`` ``BINARY_DIR`` "
"默认为``${CMAKE_CURRENT_BINARY_DIR}/<lowercaseName>-build``。如果指定了相对路径，它将被解释为相对于"
" :variable:`CMAKE_CURRENT_BINARY_DIR`。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:525
msgid ""
"In addition to the above explicit options, any other unrecognized options "
"are passed through unmodified to :command:`ExternalProject_Add` to perform"
" the download, patch and update steps.  The following options are "
"explicitly prohibited (they are disabled by the "
"``FetchContent_Populate()`` command):"
msgstr ""
"除了上述显式选项外，任何其他无法识别的选项都将不加修改地传递给 :command:`ExternalProject_Add` "
"以执行下载、修补和更新步骤。以下选项被明确禁止（它们被 ``FetchContent_Populate()`` 命令禁用）："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:530
msgid "``CONFIGURE_COMMAND``"
msgstr "``CONFIGURE_COMMAND``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:531
msgid "``BUILD_COMMAND``"
msgstr "``构建命令``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:532
msgid "``INSTALL_COMMAND``"
msgstr "``安装命令``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:533
msgid "``TEST_COMMAND``"
msgstr "``测试命令``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:535
msgid ""
"If using ``FetchContent_Populate()`` within CMake's script mode, be aware "
"that the implementation sets up a sub-build which therefore requires a "
"CMake generator and build tool to be available. If these cannot be found "
"by default, then the :variable:`CMAKE_GENERATOR` and/or "
":variable:`CMAKE_MAKE_PROGRAM` variables will need to be set appropriately"
" on the command line invoking the script."
msgstr ""
"如果在 CMake 的脚本模式下使用“FetchContent_Populate()”，请注意该实现设置了一个子构建，因此需要 CMake "
"生成器和构建工具可用。如果默认情况下找不到这些变量，则需要在调用脚本的命令行上适当设置 CMAKE_GENERATOR 和/或 "
"CMAKE_MAKE_PROGRAM 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:542
msgid "Added support for the ``DOWNLOAD_NO_EXTRACT`` option."
msgstr "添加了对 ``DOWNLOAD_NO_EXTRACT`` 选项的支持。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:547
msgid ""
"When using saved content details, a call to "
":command:`FetchContent_MakeAvailable` or :command:`FetchContent_Populate` "
"records information in global properties which can be queried at any time."
" This information may include the source and binary directories associated"
" with the content and also whether or not the content population has been "
"processed during the current configure run."
msgstr ""
"使用保存的内容详细信息时，调用 FetchContent_MakeAvailable 或 FetchContent_Populate "
"会在全局属性中记录可以随时查询的信息。此信息可能包括与内容关联的源目录和二进制目录，以及内容填充是否已在当前配置运行期间得到处理。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:563
msgid ""
"The ``SOURCE_DIR``, ``BINARY_DIR`` and ``POPULATED`` options can be used "
"to specify which properties should be retrieved.  Each option accepts a "
"value which is the name of the variable in which to store that property.  "
"Most of the time though, only ``<name>`` is given, in which case the call "
"will then set the same variables as a call to "
":command:`FetchContent_MakeAvailable(name) <FetchContent_MakeAvailable>` "
"or :command:`FetchContent_Populate(name) <FetchContent_Populate>`. Note "
"that the ``SOURCE_DIR`` and ``BINARY_DIR`` values can be empty if the call"
" is fulfilled by a :ref:`dependency provider <dependency_providers>`."
msgstr ""
"``SOURCE_DIR``、``BINARY_DIR`` 和 ``POPULATED`` "
"选项可用于指定应检索哪些属性。每个选项都接受一个值，该值是存储该属性的变量的名称。不过大多数时候，只给出了``<name>``，在这种情况下，调用将设置与调用"
" FetchContent_MakeAvailable(name) <FetchContent_MakeAvailable>` 或 "
":command:`FetchContent_Populate "
"相同的变量（名称）<FetchContent_Populate>`。请注意，如果调用由依赖提供者 <dependency_providers> "
"完成，则 ``SOURCE_DIR`` 和 ``BINARY_DIR`` 的值可以为空。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:573
msgid ""
"This command is rarely needed when using "
":command:`FetchContent_MakeAvailable`.  It is more commonly used as part "
"of implementing the following pattern with "
":command:`FetchContent_Populate`, which ensures that the relevant "
"variables will always be defined regardless of whether or not the "
"population has been performed elsewhere in the project already:"
msgstr ""
"使用 FetchContent_MakeAvailable "
"时很少需要此命令。它更常被用作以下模式的一部分:command:`FetchContent_Populate`，它确保相关变量将始终被定义，无论是否已经在项目的其他地方执行了填充："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:600
msgid ""
"This command should only be called by :ref:`dependency providers "
"<dependency_providers>`.  Calling it in any other context is unsupported "
"and future CMake versions may halt with a fatal error in such cases."
msgstr ""
"此命令只能由 :ref:`dependency providers <dependency_providers>` "
"调用。不支持在任何其他上下文中调用它，在这种情况下，未来的 CMake 版本可能会因致命错误而停止。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:613
msgid ""
"If a provider command fulfills a ``FETCHCONTENT_MAKEAVAILABLE_SERIAL`` "
"request, it must call this function before returning.  The ``SOURCE_DIR`` "
"and ``BINARY_DIR`` arguments can be used to specify the values that "
":command:`FetchContent_GetProperties` should return for its corresponding "
"arguments.  Only provide ``SOURCE_DIR`` and ``BINARY_DIR`` if they have "
"the same meaning as if they had been populated by the built-in "
":command:`FetchContent_MakeAvailable` implementation."
msgstr ""
"如果一个提供者命令完成一个``FETCHCONTENT_MAKEAVAILABLE_SERIAL`` 请求，它必须在返回之前调用这个函数。 "
"``SOURCE_DIR`` 和 ``BINARY_DIR`` 参数可用于指定 :command:`FetchContent_GetProperties` "
"应为其相应参数返回的值。仅提供 ``SOURCE_DIR`` 和 ``BINARY_DIR`` 如果它们具有与内置 "
"FetchContent_MakeAvailable 实现填充相同的含义。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:625
msgid ""
"A number of cache variables can influence the behavior where details from "
"a :command:`FetchContent_Declare` call are used to populate content."
msgstr "许多缓存变量会影响使用 :command:`FetchContent_Declare` 调用的详细信息来填充内容的行为。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:629
msgid ""
"All of these variables are intended for the developer to customize "
"behavior. They should not normally be set by the project."
msgstr "所有这些变量都旨在供开发人员自定义行为。它们通常不应由项目设置。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:634
msgid ""
"In most cases, the saved details do not specify any options relating to "
"the directories to use for the internal sub-build, final source and build "
"areas. It is generally best to leave these decisions up to the "
"``FetchContent`` module to handle on the project's behalf.  The "
"``FETCHCONTENT_BASE_DIR`` cache variable controls the point under which "
"all content population directories are collected, but in most cases, "
"developers would not need to change this.  The default location is "
"``${CMAKE_BINARY_DIR}/_deps``, but if developers change this value, they "
"should aim to keep the path short and just below the top level of the "
"build tree to avoid running into path length problems on Windows."
msgstr ""
"在大多数情况下，保存的详细信息不会指定与用于内部子构建、最终源和构建区域的目录相关的任何选项。通常最好将这些决定留给“FetchContent”模块代表项目处理。"
" ``FETCHCONTENT_BASE_DIR`` 缓存变量控制收集所有内容填充目录的点，但在大多数情况下，开发人员不需要更改它。默认位置是 "
"``${CMAKE_BINARY_DIR}/_deps``，但如果开发人员更改此值，他们应该力求保持路径短且刚好低于构建树的顶层，以避免在 "
"Windows 上遇到路径长度问题。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:647
msgid ""
"The logging output during population can be quite verbose, making the "
"configure stage quite noisy.  This cache option (``ON`` by default) hides "
"all population output unless an error is encountered.  If experiencing "
"problems with hung downloads, temporarily switching this option off may "
"help diagnose which content population is causing the issue."
msgstr ""
"填充期间的日志输出可能非常冗长，使配置阶段非常嘈杂。此缓存选项（默认情况下为“ON”）隐藏所有填充输出，除非遇到错误。如果遇到挂起下载问题，暂时关闭此选项可能有助于诊断导致问题的内容群体。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:655
msgid ""
"When this option is enabled, no attempt is made to download or update any "
"content.  It is assumed that all content has already been populated in a "
"previous run or the source directories have been pointed at existing "
"contents the developer has provided manually (using options described "
"further below).  When the developer knows that no changes have been made "
"to any content details, turning this option ``ON`` can significantly speed"
" up the configure stage.  It is ``OFF`` by default."
msgstr ""
"启用此选项后，不会尝试下载或更新任何内容。假定所有内容都已在之前的运行中填充，或者源目录已指向开发人员手动提供的现有内容（使用下面进一步描述的选项）。当开发人员知道没有对任何内容细节进行更改时，将此选项“打开”可以显着加快配置阶段。默认情况下为“关闭”。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:665
msgid ""
"This is a less severe download/update control compared to "
":variable:`FETCHCONTENT_FULLY_DISCONNECTED`.  Instead of bypassing all "
"download and update logic, ``FETCHCONTENT_UPDATES_DISCONNECTED`` only "
"disables the update stage.  Therefore, if content has not been downloaded "
"previously, it will still be downloaded when this option is enabled. This "
"can speed up the configure stage, but not as much as "
":variable:`FETCHCONTENT_FULLY_DISCONNECTED`.  It is ``OFF`` by default."
msgstr ""
"与 FETCHCONTENT_FULLY_DISCONNECTED 相比，这是一个不太严格的下载/更新控制。 "
"``FETCHCONTENT_UPDATES_DISCONNECTED`` "
"不是绕过所有下载和更新逻辑，而是仅禁用更新阶段。因此，如果之前没有下载过内容，启用此选项后仍会下载内容。这可以加快配置阶段，但不如 "
"FETCHCONTENT_FULLY_DISCONNECTED 快。默认情况下为“关闭”。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:677
msgid ""
"This variable modifies the details that :command:`FetchContent_Declare` "
"records for a given dependency.  While it ultimately controls the behavior"
" of :command:`FetchContent_MakeAvailable`, it is the variable's value when"
" :command:`FetchContent_Declare` is called that gets used.  It makes no "
"difference what the variable is set to when "
":command:`FetchContent_MakeAvailable` is called.  Since the variable "
"should only be set by the user and not by projects directly, it will "
"typically have the same value throughout anyway, so this distinction is "
"not usually noticeable."
msgstr ""
"此变量修改 :command:`FetchContent_Declare` 记录给定依赖项的详细信息。虽然它最终控制了 "
"FetchContent_MakeAvailable 的行为，但使用的是调用 FetchContent_Declare 时变量的值。调用 "
"FetchContent_MakeAvailable "
"时变量设置为什么没有区别。由于变量只能由用户设置而不是由项目直接设置，因此它通常始终具有相同的值，因此这种区别通常不会引人注意。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:687
msgid ""
"``FETCHCONTENT_TRY_FIND_PACKAGE_MODE`` ultimately controls whether "
":command:`FetchContent_MakeAvailable` is allowed to call "
":command:`find_package` to satisfy a dependency.  The variable can be set "
"to one of the following values:"
msgstr ""
"``FETCHCONTENT_TRY_FIND_PACKAGE_MODE`` 最终控制是否允许 FetchContent_MakeAvailable"
" 调用 :command:`find_package` 来满足依赖性。该变量可以设置为以下值之一："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:696
msgid "``OPT_IN``"
msgstr "``OPT_IN``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:693
msgid ""
":command:`FetchContent_MakeAvailable` will only call "
":command:`find_package` if the :command:`FetchContent_Declare` call "
"included a ``FIND_PACKAGE_ARGS`` keyword.  This is also the default "
"behavior if ``FETCHCONTENT_TRY_FIND_PACKAGE_MODE`` is not set."
msgstr ""
":command:`FetchContent_MakeAvailable` 只会调用 :command:`find_package` 如果 "
":command:`FetchContent_Declare` 调用包含 ``FIND_PACKAGE_ARGS`` "
"关键字。如果未设置“FETCHCONTENT_TRY_FIND_PACKAGE_MODE”，这也是默认行为。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:704
msgid "``ALWAYS``"
msgstr "``总是``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:699
msgid ""
":command:`find_package` can be called by "
":command:`FetchContent_MakeAvailable` regardless of whether the "
":command:`FetchContent_Declare` call included a ``FIND_PACKAGE_ARGS`` "
"keyword or not.  If no ``FIND_PACKAGE_ARGS`` keyword was given, the "
"behavior will be as though ``FIND_PACKAGE_ARGS`` had been provided, with "
"no additional arguments after it."
msgstr ""
":command:`find_package` 可以由 :command:`FetchContent_MakeAvailable` 调用，无论 "
":command:`FetchContent_Declare` 调用是否包含 ``FIND_PACKAGE_ARGS`` 关键字。如果没有给出 "
"``FIND_PACKAGE_ARGS`` 关键字，其行为就像提供了 ``FIND_PACKAGE_ARGS`` 一样，后面没有其他参数。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:709
msgid "``NEVER``"
msgstr "``从来没有``"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:707
msgid ""
":command:`FetchContent_MakeAvailable` will not call "
":command:`find_package`.  Any ``FIND_PACKAGE_ARGS`` given to the "
":command:`FetchContent_Declare` call will be ignored."
msgstr ""
":command:`FetchContent_MakeAvailable` 不会调用 :command:`find_package`。任何提供给 "
"FetchContent_Declare 调用的 ``FIND_PACKAGE_ARGS`` 都将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:711
msgid ""
"As a special case, if the "
":variable:`FETCHCONTENT_SOURCE_DIR_<uppercaseName>` variable has a non-"
"empty value for a dependency, it is assumed that the user is overriding "
"all other methods of making that dependency available. "
"``FETCHCONTENT_TRY_FIND_PACKAGE_MODE`` will have no effect on that "
"dependency and :command:`FetchContent_MakeAvailable` will not try to call "
":command:`find_package` for it."
msgstr ""
"作为一种特殊情况，如果 :variable:`FETCHCONTENT_SOURCE_DIR_<uppercaseName>` "
"变量的依赖项具有非空值，则假定用户正在覆盖使该依赖项可用的所有其他方法。 "
"``FETCHCONTENT_TRY_FIND_PACKAGE_MODE`` 将对该依赖项没有影响，并且 "
"FetchContent_MakeAvailable 不会尝试为其调用 :command:`find_package`。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:718
msgid ""
"In addition to the above, the following variables are also defined for "
"each content name:"
msgstr "除了上述之外，还为每个内容名称定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:723
msgid ""
"If this is set, no download or update steps are performed for the "
"specified content and the ``<lowercaseName>_SOURCE_DIR`` variable returned"
" to the caller is pointed at this location.  This gives developers a way "
"to have a separate checkout of the content that they can modify freely "
"without interference from the build.  The build simply uses that existing "
"source, but it still defines ``<lowercaseName>_BINARY_DIR`` to point "
"inside its own build area.  Developers are strongly encouraged to use this"
" mechanism rather than editing the sources populated in the default "
"location, as changes to sources in the default location can be lost when "
"content population details are changed by the project."
msgstr ""
"如果已设置，则不会对指定内容执行任何下载或更新步骤，并且返回给调用者的 ``<lowercaseName>_SOURCE_DIR`` "
"变量指向此位置。这为开发人员提供了一种单独检查内容的方法，他们可以在不受构建干扰的情况下自由修改这些内容。构建只是使用现有的源，但它仍然定义了``<lowercaseName>_BINARY_DIR``"
" 以指向它自己的构建区域。强烈建议开发人员使用此机制而不是编辑默认位置中填充的源，因为当项目更改内容填充详细信息时，对默认位置中源的更改可能会丢失。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:736
msgid ""
"This is the per-content equivalent of "
":variable:`FETCHCONTENT_UPDATES_DISCONNECTED`.  If the global option or "
"this option is ``ON``, then updates will be disabled for the named "
"content. Disabling updates for individual content can be useful for "
"content whose details rarely change, while still leaving other frequently "
"changing content with updates enabled."
msgstr ""
"这是每个内容等效于 :variable:`FETCHCONTENT_UPDATES_DISCONNECTED`。如果全局选项或此选项为“ON”，则将禁用指定内容的更新。禁用个别内容的更新对于细节很少更改的内容很有用，同时仍然保留其他频繁更改的内容启用更新。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:749
msgid "Typical Case"
msgstr "典型"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:751
msgid ""
"This first fairly straightforward example ensures that some popular "
"testing frameworks are available to the main build:"
msgstr "第一个相当简单的示例确保一些流行的测试框架可用于主构建："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:775
msgid "Integrating With find_package()"
msgstr "与 find_package() 集成"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:777
msgid ""
"For the previous example, if the user wanted to try to find ``googletest``"
" and ``Catch2`` via :command:`find_package` first before trying to "
"download and build them from source, they could set the "
":variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` variable to ``ALWAYS``. "
"This would also affect any other calls to :command:`FetchContent_Declare` "
"throughout the project, which might not be acceptable.  The behavior can "
"be enabled for just these two dependencies instead by adding "
"``FIND_PACKAGE_ARGS`` to the declared details and leaving "
":variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` unset, or set to "
"``OPT_IN``:"
msgstr ""
"对于前面的示例，如果用户想在尝试从源代码下载和构建它们之前首先尝试通过 find_package 找到 ``googletest`` 和 "
"``Catch2``，他们可以设置:variable:` FETCHCONTENT_TRY_FIND_PACKAGE_MODE 变量为 "
"``ALWAYS``。这也会影响整个项目中对 :command:`FetchContent_Declare` "
"的任何其他调用，这可能是不可接受的。可以只为这两个依赖项启用该行为，而不是通过将 ``FIND_PACKAGE_ARGS`` "
"添加到声明的详细信息并保留 :variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` 未设置，或设置为 ``OPT_IN``："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:806
msgid ""
"For ``Catch2``, no additional arguments to :command:`find_package` are "
"needed, so no additional arguments are provided after the "
"``FIND_PACKAGE_ARGS`` keyword.  For ``googletest``, its package is more "
"commonly called ``GTest``, so arguments are added to support it being "
"found by that name."
msgstr ""
"对于 ``Catch2``， :command:`find_package` 不需要额外的参数，因此在 ``FIND_PACKAGE_ARGS`` "
"关键字后没有提供额外的参数。对于 ``googletest``，它的包通常称为 ``GTest``，因此添加参数以支持通过该名称找到它。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:811
msgid ""
"If the user wanted to disable :command:`FetchContent_MakeAvailable` from "
"calling :command:`find_package` for any dependency, even if it provided "
"``FIND_PACKAGE_ARGS`` in its declared details, they could set "
":variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` to ``NEVER``."
msgstr ""
"如果用户想禁止 FetchContent_MakeAvailable 调用任何依赖项的 find_package，即使它在声明的细节中提供了 "
"FIND_PACKAGE_ARGS，他们可以将 FETCHCONTENT_TRY_FIND_PACKAGE_MODE 设置为 ``从来没有``。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:816
msgid ""
"If the project wanted to indicate that these two dependencies should be "
"downloaded and built from source and that :command:`find_package` calls "
"should be redirected to use the built dependencies, the "
"``OVERRIDE_FIND_PACKAGE`` option should be used when declaring the content"
" details:"
msgstr ""
"如果项目想要指示应该从源下载和构建这两个依赖项，并且应该重定向 :command:`find_package` "
"调用以使用构建的依赖项，那么在声明内容详细信息时应该使用 ``OVERRIDE_FIND_PACKAGE`` 选项 :"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:842
msgid ""
"CMake provides a FindGTest module which defines some variables that older "
"projects may use instead of linking to the imported targets.  To support "
"those cases, we can provide an extra file.  In keeping with the \"first to"
" define, wins\" philosophy of ``FetchContent``, we only write out that "
"file if something else hasn't already done so."
msgstr ""
"CMake 提供了一个 FindGTest "
"模块，它定义了一些旧项目可能使用的变量，而不是链接到导入的目标。为了支持这些情况，我们可以提供一个额外的文件。为了与 "
"``FetchContent`` 的“先定义者获胜”理念保持一致，我们只在其他文件尚未完成时才写出该文件。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:868
msgid ""
"Projects will also likely be using ``find_package(GTest)`` rather than "
"``find_package(googletest)``, but it is possible to make use of the "
":variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` area to pull in the latter as"
" a dependency of the former.  This is likely to be sufficient to satisfy a"
" typical ``find_package(GTest)`` call."
msgstr ""
"项目也可能会使用``find_package(GTest)`` "
"而不是``find_package(googletest)``，但可以使用 :variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR`"
" 区域将后者作为前者。这可能足以满足典型的“find_package(GTest)”调用。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:899
msgid "Overriding Where To Find CMakeLists.txt"
msgstr "覆盖在哪里可以找到 CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:901
msgid ""
"If the sub-project's ``CMakeLists.txt`` file is not at the top level of "
"its source tree, the ``SOURCE_SUBDIR`` option can be used to tell "
"``FetchContent`` where to find it.  The following example shows how to use"
" that option, and it also sets a variable which is meaningful to the "
"subproject before pulling it into the main build (set as an ``INTERNAL`` "
"cache variable to avoid problems with policy :policy:`CMP0077`):"
msgstr ""
"如果子项目的 ``CMakeLists.txt`` 文件不在其源代码树的顶层，则可以使用 ``SOURCE_SUBDIR`` 选项告诉 "
"``FetchContent`` "
"在哪里可以找到它。下面的示例展示了如何使用该选项，它还在将子项目拉入主构建之前设置了一个对子项目有意义的变量（设置为 ``INTERNAL`` "
"缓存变量以避免策略问题:policy:`CMP0077 `):"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:921
msgid "Complex Dependency Hierarchies"
msgstr "复杂的依赖层次结构"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:923
msgid ""
"In more complex project hierarchies, the dependency relationships can be "
"more complicated.  Consider a hierarchy where ``projA`` is the top level "
"project and it depends directly on projects ``projB`` and ``projC``.  Both"
" ``projB`` and ``projC`` can be built standalone and they also both depend"
" on another project ``projD``.  ``projB`` additionally depends on "
"``projE``.  This example assumes that all five projects are available on a"
" company git server.  The ``CMakeLists.txt`` of each project might have "
"sections like the following:"
msgstr ""
"在更复杂的项目层次结构中，依赖关系可能更复杂。考虑一个层次结构，其中 ``projA`` 是顶级项目，它直接依赖于项目 ``projB`` 和 "
"``projC``。 ``projB`` 和 ``projC`` 都可以独立构建，它们也都依赖于另一个项目 ``projD``。 ``projB``"
" 还依赖于 ``projE``。此示例假定所有五个项目都在公司 git 服务器上可用。每个项目的 ``CMakeLists.txt`` "
"可能包含如下部分："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:931
msgid "*projA*"
msgstr "*项目*"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:960
msgid "*projB*"
msgstr "*项目B*"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:978
msgid "*projC*"
msgstr "*项目*"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:999
msgid "A few key points should be noted in the above:"
msgstr "上面需要注意几个关键点："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1001
msgid ""
"``projB`` and ``projC`` define different content details for ``projD``, "
"but ``projA`` also defines a set of content details for ``projD``. Because"
" ``projA`` will define them first, the details from ``projB`` and "
"``projC`` will not be used.  The override details defined by ``projA`` are"
" not required to match either of those from ``projB`` or ``projC``, but it"
" is up to the higher level project to ensure that the details it does "
"define still make sense for the child projects."
msgstr ""
"``projB`` 和``projC`` 为``projD`` 定义了不同的内容细节，但是``projA`` 也为``projD`` "
"定义了一组内容细节。因为 ``projA`` 将首先定义它们，所以不会使用 ``projB`` 和 ``projC`` 的细节。 ``projA``"
" 定义的覆盖细节不需要与 ``projB`` 或 ``projC`` "
"中的任何一个相匹配，但要由更高级别的项目来确保它定义的细节仍然使对子项目有意义。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1008
msgid ""
"In the ``projA`` call to :command:`FetchContent_MakeAvailable`, ``projD`` "
"is listed ahead of ``projB`` and ``projC`` to ensure that ``projA`` is in "
"control of how ``projD`` is populated."
msgstr ""
"在调用 FetchContent_MakeAvailable 的 ``projA`` 中，``projD`` 列在 ``projB`` 和 "
"``projC`` 之前，以确保 ``projA`` 控制如何 ` `projD`` 已填充。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1011
msgid ""
"While ``projA`` defines content details for ``projE``, it does not need to"
" explicitly call ``FetchContent_MakeAvailable(projE)`` or "
"``FetchContent_Populate(projD)`` itself.  Instead, it leaves that to the "
"child ``projB``.  For higher level projects, it is often enough to just "
"define the override content details and leave the actual population to the"
" child projects.  This saves repeating the same thing at each level of the"
" project hierarchy unnecessarily."
msgstr ""
"虽然 ``projA`` 定义了 ``projE`` 的内容细节，但它不需要显式调用 "
"``FetchContent_MakeAvailable(projE)`` 或 ``FetchContent_Populate(projD)`` "
"本身。相反，它把它留给了孩子 "
"``projB``。对于更高级别的项目，通常只定义覆盖内容详细信息并将实际填充留给子项目就足够了。这样可以避免在项目层次结构的每个级别不必要地重复相同的事情。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1020
msgid "Populating Content Without Adding It To The Build"
msgstr "填充内容而不将其添加到构建中"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1022
msgid ""
"Projects don't always need to add the populated content to the build. "
"Sometimes the project just wants to make the downloaded content available "
"at a predictable location.  The next example ensures that a set of "
"standard company toolchain files (and potentially even the toolchain "
"binaries themselves) is available early enough to be used for that same "
"build."
msgstr ""
"项目并不总是需要将填充的内容添加到构建中。有时，项目只是想让下载的内容在可预测的位置可用。下一个示例确保一组标准的公司工具链文件（甚至可能是工具链二进制文件本身）足够早地可用以用于相同的构建。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1041
msgid ""
"The project could be configured to use one of the downloaded toolchains "
"like so:"
msgstr "该项目可以配置为使用下载的工具链之一，如下所示："

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1048
msgid ""
"When CMake processes the ``CMakeLists.txt`` file, it will download and "
"unpack the tarball into ``_deps/mycompany_toolchains-src`` relative to the"
" build directory.  The :variable:`CMAKE_TOOLCHAIN_FILE` variable is not "
"used until the :command:`project` command is reached, at which point CMake"
" looks for the named toolchain file relative to the build directory.  "
"Because the tarball has already been downloaded and unpacked by then, the "
"toolchain file will be in place, even the very first time that "
":program:`cmake` is run in the build directory."
msgstr ""
"当 CMake 处理 ``CMakeLists.txt`` 文件时，它会下载 tarball 并将其解压缩到相对于构建目录的 "
"``_deps/mycompany_toolchains-src`` 中。 :variable:`CMAKE_TOOLCHAIN_FILE` "
"变量在到达 :command:`project` 命令之前不会被使用，此时 CMake 会查找相对于构建目录的命名工具链文件。因为那时 "
"tarball 已经下载并解压，所以工具链文件将就位，即使是第一次在构建目录中运行 :program:`cmake` 也是如此。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1057
msgid "Populating Content In CMake Script Mode"
msgstr "在 CMake 脚本模式下填充内容"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1059
msgid ""
"This last example demonstrates how one might download and unpack a "
"firmware tarball using CMake's :manual:`script mode <cmake(1)>`.  The call"
" to :command:`FetchContent_Populate` specifies all the content details and"
" the unpacked firmware will be placed in a ``firmware`` directory below "
"the current working directory."
msgstr ""
"最后一个示例演示了如何使用 CMake 的 :manual:`script mode <cmake(1)>` 下载和解压缩固件 tarball。调用"
" :command:`FetchContent_Populate` 指定所有内容详细信息，解压后的固件将放置在当前工作目录下的 "
"``firmware`` 目录中。"

#: ../../cmake-prefix/src/cmake/Modules/FetchContent.cmake:1065
msgid ":file:`getFirmware.cmake`"
msgstr ":file:`getFirmware.cmake`"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:6
msgid "FindALSA"
msgstr "查找ALSA"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:8
msgid "Find Advanced Linux Sound Architecture (ALSA)"
msgstr "查找高级 Linux 声音架构 (ALSA)"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:10
msgid "Find the alsa libraries (``asound``)"
msgstr "找到 alsa 库（``asound``）"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:14
#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:12
#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindOpenCL.cmake:16
#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:207
#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:11
msgid "IMPORTED Targets"
msgstr "进口目标"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:17
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``ALSA::ALSA``, if ALSA "
"has been found."
msgstr "如果找到 ALSA，此模块定义 :prop_tgt:`IMPORTED` 目标 ``ALSA::ALSA``。"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:68
#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:40
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:377
#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:60
#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:17
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:69
#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/FindOpenCL.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:47
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:64
#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:106
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:93
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:107
#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:286
#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:113
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:16
msgid "Result Variables"
msgstr "结果变量"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:70
#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:12
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:71
#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:115
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:21
msgid "This module defines the following variables:"
msgstr "该模块定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:26
msgid "``ALSA_FOUND``"
msgstr "``ALSA_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:26
msgid "True if ALSA_INCLUDE_DIR & ALSA_LIBRARY are found"
msgstr "如果找到 ALSA_INCLUDE_DIR & ALSA_LIBRARY 则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:29
msgid "``ALSA_LIBRARIES``"
msgstr "``ALSA_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:29
msgid "List of libraries when using ALSA."
msgstr "使用 ALSA 时的库列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:32
msgid "``ALSA_INCLUDE_DIRS``"
msgstr "``ALSA_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:32
msgid "Where to find the ALSA headers."
msgstr "在哪里可以找到 ALSA 标头。"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:101
#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:65
#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:76
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:54
#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:37
msgid "Cache variables"
msgstr "缓存变量"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:67
#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:54
#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:47
#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:78
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:51
#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:39
msgid "The following cache variables may also be set:"
msgstr "还可以设置以下缓存变量："

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:40
msgid "``ALSA_INCLUDE_DIR``"
msgstr "``ALSA_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:40
msgid "the ALSA include directory"
msgstr "ALSA 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:76
msgid "``ALSA_LIBRARY``"
msgstr "``ALSA_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindALSA.cmake:43
msgid "the absolute path of the asound library"
msgstr "asound库的绝对路径"

#: ../../cmake-prefix/src/cmake/Modules/FindASPELL.cmake:6
msgid "FindASPELL"
msgstr "查找ASPELL"

#: ../../cmake-prefix/src/cmake/Modules/FindASPELL.cmake:8
msgid "Try to find ASPELL"
msgstr "尝试找到 ASPELL"

#: ../../cmake-prefix/src/cmake/Modules/FindASPELL.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindGnuplot.cmake:12
#: ../../cmake-prefix/src/cmake/Modules/FindHSPELL.cmake:10
msgid "Once done this will define"
msgstr "一旦完成，这将定义"

#: ../../cmake-prefix/src/cmake/Modules/FindAVIFile.cmake:6
msgid "FindAVIFile"
msgstr "查找 AVI 文件"

#: ../../cmake-prefix/src/cmake/Modules/FindAVIFile.cmake:8
msgid "Locate AVIFILE library and include paths"
msgstr "找到 AVIFILE 库并包含路径"

#: ../../cmake-prefix/src/cmake/Modules/FindAVIFile.cmake:10
msgid ""
"AVIFILE (https://avifile.sourceforge.net/) is a set of libraries for i386 "
"machines to use various AVI codecs.  Support is limited beyond Linux.  "
"Windows provides native AVI support, and so doesn't need this library.  "
"This module defines"
msgstr ""
"AVIFILE (https://avifile.sourceforge.net/) 是一组供 i386 机器使用各种 AVI "
"编解码器的库。支持仅限于 Linux。 Windows 提供本机 AVI 支持，因此不需要此库。这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindArmadillo.cmake:6
msgid "FindArmadillo"
msgstr "寻找犰狳"

#: ../../cmake-prefix/src/cmake/Modules/FindArmadillo.cmake:8
msgid ""
"Find the Armadillo C++ library. Armadillo is a library for linear algebra "
"& scientific computing."
msgstr "找到 Armadillo C++ 库。 Armadillo 是一个用于线性代数和科学计算的库。"

#: ../../cmake-prefix/src/cmake/Modules/FindArmadillo.cmake:11
msgid ""
"Support for linking wrapped libraries directly "
"(``ARMA_DONT_USE_WRAPPER``)."
msgstr "支持直接链接包装库（``ARMA_DONT_USE_WRAPPER``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindArmadillo.cmake:14
msgid "Using Armadillo:"
msgstr "使用犰狳："

#: ../../cmake-prefix/src/cmake/Modules/FindArmadillo.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:49
msgid "This module sets the following variables:"
msgstr "该模块设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:6
msgid "FindBISON"
msgstr "寻找野牛"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:8
msgid ""
"Find ``bison`` executable and provide a macro to generate custom build "
"rules."
msgstr "找到 ``bison`` 可执行文件并提供一个宏来生成自定义构建规则。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindCVS.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:8
#: ../../cmake-prefix/src/cmake/Modules/FindHg.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindLibArchive.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:10
msgid "The module defines the following variables:"
msgstr "该模块定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:13
msgid "``BISON_EXECUTABLE``"
msgstr "``BISON_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:13
msgid "path to the ``bison`` program"
msgstr "``bison`` 程序的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:16
msgid "``BISON_VERSION``"
msgstr "``BISON_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:16
msgid "version of ``bison``"
msgstr "``野牛``的版本"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:19
msgid "``BISON_FOUND``"
msgstr "``BISON_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:19
msgid "\"True\" if the program was found"
msgstr "如果找到程序则为“真”"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:21
msgid ""
"The minimum required version of ``bison`` can be specified using the "
"standard CMake syntax, e.g.  :command:`find_package(BISON 2.1.3)`."
msgstr "可以使用标准 CMake 语法指定“bison”的最低要求版本，例如 :command:`find_package（BISON 2.1.3）`。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:24
msgid "If ``bison`` is found, the module defines the macro::"
msgstr "如果找到 ``bison``，则模块定义宏：："

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:33
msgid ""
"which will create a custom rule to generate a parser.  ``<YaccInput>`` is "
"the path to a yacc file.  ``<CodeOutput>`` is the name of the source file "
"generated by bison.  A header file is also be generated, and contains the "
"token list."
msgstr ""
"这将创建一个自定义规则来生成一个解析器。 ``<YaccInput>`` 是 yacc 文件的路径。 ``<CodeOutput>`` 是 "
"bison 生成的源文件的名称。还会生成一个头文件，其中包含令牌列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:38
msgid ""
"When :policy:`CMP0088` is set to ``NEW``, ``bison`` runs in the "
":variable:`CMAKE_CURRENT_BINARY_DIR` directory."
msgstr "当 CMP0088 设置为 NEW 时，bison 在 CMAKE_CURRENT_BINARY_DIR 目录中运行。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:45
msgid "``COMPILE_FLAGS <flags>``"
msgstr "``COMPILE_FLAGS <标志>``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:45
msgid "Specify flags to be added to the ``bison`` command line."
msgstr "指定要添加到 ``bison`` 命令行的标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:50
msgid "``DEFINES_FILE <file>``"
msgstr "``DEFINES_FILE <文件>``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:50
msgid ""
"Specify a non-default header ``<file>`` to be generated by ``bison``."
msgstr "指定由 ``bison`` 生成的非默认标头 ``<file>``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:58
msgid "``VERBOSE [<file>]``"
msgstr "``详细 [<文件>]``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:53
msgid "Tell ``bison`` to write a report file of the grammar and parser."
msgstr "告诉 ``bison`` 编写语法和解析器的报告文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:55
msgid ""
"If ``<file>`` is given, it specifies path the report file is copied to. "
"``[<file>]`` is left for backward compatibility of this module. Use "
"``VERBOSE REPORT_FILE <file>``."
msgstr ""
"如果给出了``<file>``，它指定了报告文件复制到的路径。 ``[<file>]`` 是为了这个模块的向后兼容而保留的。使用 ``VERBOSE"
" REPORT_FILE <file>``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:63
msgid "``REPORT_FILE <file>``"
msgstr "``REPORT_FILE <文件>``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:63
msgid "Specify a non-default report ``<file>``, if generated."
msgstr "如果生成，请指定一个非默认报告 ``<file>``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:65
#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:53
msgid "The macro defines the following variables:"
msgstr "该宏定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:68
msgid "``BISON_<Name>_DEFINED``"
msgstr "``BISON_<名称>_DEFINED``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:68
msgid "``True`` is the macro ran successfully"
msgstr "``True`` 是宏运行成功"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:71
msgid "``BISON_<Name>_INPUT``"
msgstr "``BISON_<名称>_INPUT``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:71
msgid "The input source file, an alias for <YaccInput>"
msgstr "输入源文件，<YaccInput> 的别名"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:74
msgid "``BISON_<Name>_OUTPUT_SOURCE``"
msgstr "``BISON_<名称>_OUTPUT_SOURCE``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:74
msgid "The source file generated by bison"
msgstr "bison生成的源文件"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:77
msgid "``BISON_<Name>_OUTPUT_HEADER``"
msgstr "``BISON_<名称>_OUTPUT_HEADER``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:77
msgid "The header file generated by bison"
msgstr "bison生成的头文件"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:80
msgid "``BISON_<Name>_OUTPUTS``"
msgstr "``BISON_<名称>_OUTPUTS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:80
msgid ""
"All files generated by bison including the source, the header and the "
"report"
msgstr "bison 生成的所有文件，包括源文件、标题和报告"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:83
msgid "``BISON_<Name>_COMPILE_FLAGS``"
msgstr "``BISON_<名称>_COMPILE_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:83
msgid "Options used in the ``bison`` command line"
msgstr "``bison`` 命令行中使用的选项"

#: ../../cmake-prefix/src/cmake/Modules/FindBISON.cmake:85
#: ../../cmake-prefix/src/cmake/Modules/FindCVS.cmake:17
#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/FindHg.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:58
msgid "Example usage:"
msgstr "用法示例："

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:6
msgid "FindBLAS"
msgstr "查找BLAS"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:8
msgid "Find Basic Linear Algebra Subprograms (BLAS) library"
msgstr "查找基本线性代数子程序 (BLAS) 库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:10
msgid ""
"This module finds an installed Fortran library that implements the `BLAS "
"linear-algebra interface`_."
msgstr "该模块找到一个已安装的 Fortran 库，该库实现了“BLAS 线性代数接口”_。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:13
msgid ""
"At least one of the ``C``, ``CXX``, or ``Fortran`` languages must be "
"enabled."
msgstr "至少必须启用 ``C``、``CXX`` 或 ``Fortran`` 语言中的一种。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:66
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:66
msgid "Input Variables"
msgstr "输入变量"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:20
#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:20
msgid ""
"The following variables may be set to influence this module's behavior:"
msgstr "可以设置以下变量来影响此模块的行为："

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:23
msgid "``BLA_STATIC``"
msgstr "``BLA_STATIC``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:23
msgid "if ``ON`` use static linkage"
msgstr "如果 ``ON`` 使用静态链接"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:27
msgid "``BLA_VENDOR``"
msgstr "``BLA_VENDOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:26
msgid ""
"Set to one of the :ref:`BLAS/LAPACK Vendors` to search for BLAS only from "
"the specified vendor.  If not set, all vendors are considered."
msgstr "设置为 :ref:`BLAS/LAPACK Vendors` 之一以仅从指定供应商搜索 BLAS。如果未设置，则考虑所有供应商。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:30
msgid "``BLA_F95``"
msgstr "``BLA_F95``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:30
msgid "if ``ON`` tries to find the BLAS95 interfaces"
msgstr "如果 ``ON`` 试图找到 BLAS95 接口"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:36
msgid "``BLA_PREFER_PKGCONFIG``"
msgstr "``BLA_PREFER_PKGCONFIG``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:35
msgid ""
"if set ``pkg-config`` will be used to search for a BLAS library first and "
"if one is found that is preferred"
msgstr "如果设置 ``pkg-config`` 将首先用于搜索 BLAS 库，如果找到一个是首选"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:42
msgid "``BLA_PKGCONFIG_BLAS``"
msgstr "``BLA_PKGCONFIG_BLAS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:41
msgid ""
"If set, the ``pkg-config`` method will look for this module name instead "
"of just ``blas``."
msgstr "如果设置，``pkg-config`` 方法将查找此模块名称，而不仅仅是 ``blas``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:56
msgid "``BLA_SIZEOF_INTEGER``"
msgstr "``BLA_SIZEOF_INTEGER``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:47
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:48
msgid "Specify the BLAS/LAPACK library integer size:"
msgstr "指定 BLAS/LAPACK 库整数大小："

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:50
msgid "``4``"
msgstr "``4``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:51
msgid "Search for a BLAS/LAPACK with 32-bit integer interfaces."
msgstr "搜索具有 32 位整数接口的 BLAS/LAPACK。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:51
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:52
msgid "``8``"
msgstr "``8``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:53
msgid "Search for a BLAS/LAPACK with 64-bit integer interfaces."
msgstr "搜索具有 64 位整数接口的 BLAS/LAPACK。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:56
msgid "``ANY``"
msgstr "``任何``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:54
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:55
msgid ""
"Search for any BLAS/LAPACK. Most likely, a BLAS/LAPACK with 32-bit integer"
" interfaces will be found."
msgstr "搜索任何 BLAS/LAPACK。很可能会找到具有 32 位整数接口的 BLAS/LAPACK。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:102
#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:14
#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:14
#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:105
#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:12
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:13
msgid "Imported targets"
msgstr "导入目标"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:60
#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:170
#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:16
#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:16
#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:47
#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:109
#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:17
msgid "This module defines the following :prop_tgt:`IMPORTED` targets:"
msgstr "该模块定义了以下 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:65
msgid "``BLAS::BLAS``"
msgstr "``BLAS::BLAS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:65
msgid "The libraries to use for BLAS, if found."
msgstr "用于 BLAS 的库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:72
msgid "``BLAS_FOUND``"
msgstr "``BLAS_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:73
msgid "library implementing the BLAS interface is found"
msgstr "找到实现 BLAS 接口的库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:74
msgid "``BLAS_LINKER_FLAGS``"
msgstr "``BLAS_LINKER_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:75
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:76
msgid ""
"uncached list of required linker flags (excluding ``-l`` and ``-L``)."
msgstr "所需链接器标志的未缓存列表（不包括“-l”和“-L”）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:77
msgid "``BLAS_LIBRARIES``"
msgstr "``BLAS_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:77
msgid ""
"uncached list of libraries (using full path name) to link against to use "
"BLAS (may be empty if compiler implicitly links BLAS)"
msgstr "未缓存的库列表（使用完整路径名）链接以使用 BLAS（如果编译器隐式链接 BLAS，则可能为空）"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:80
msgid "``BLAS95_LIBRARIES``"
msgstr "``BLAS95_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:80
msgid ""
"uncached list of libraries (using full path name) to link against to use "
"BLAS95 interface"
msgstr "未缓存的库列表（使用完整路径名）链接以使用 BLAS95 接口"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:83
msgid "``BLAS95_FOUND``"
msgstr "``BLAS95_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:83
msgid "library implementing the BLAS95 interface is found"
msgstr "找到实现 BLAS95 接口的库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:88
msgid "BLAS/LAPACK Vendors"
msgstr "BLAS/LAPACK 供应商"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:91
msgid "``Generic``"
msgstr "``通用``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:91
msgid "Generic reference implementation"
msgstr "通用参考实现"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:94
msgid "``ACML``, ``ACML_MP``, ``ACML_GPU``"
msgstr "``ACML``、``ACML_MP``、``ACML_GPU``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:94
msgid "AMD Core Math Library"
msgstr "AMD 核心数学库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:97
msgid "``Apple``, ``NAS``"
msgstr "``苹果``，``NAS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:97
msgid "Apple BLAS (Accelerate), and Apple NAS (vecLib)"
msgstr "Apple BLAS（加速）和 Apple NAS（vecLib）"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:102
msgid "``Arm``, ``Arm_mp``, ``Arm_ilp64``, ``Arm_ilp64_mp``"
msgstr "``Arm``，``Arm_mp``，``Arm_ilp64``，``Arm_ilp64_mp``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:102
msgid "Arm Performance Libraries"
msgstr "手臂性能库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:105
msgid "``ATLAS``"
msgstr "``地图集``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:105
msgid "Automatically Tuned Linear Algebra Software"
msgstr "自动调整的线性代数软件"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:108
msgid "``CXML``, ``DXML``"
msgstr "``CXML``，``DXML``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:108
msgid "Compaq/Digital Extended Math Library"
msgstr "Compaq/数字扩展数学库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:113
msgid "``EML``, ``EML_mt``"
msgstr "``EML``，``EML_mt``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:113
msgid "Elbrus Math Library"
msgstr "厄尔布鲁士数学图书馆"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:118
msgid "``FLAME``"
msgstr "``火焰``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:118
msgid "BLIS Framework"
msgstr "BLIS 框架"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:121
msgid "``FlexiBLAS``"
msgstr "``FlexiBLAS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:126
msgid ""
"``Fujitsu_SSL2``, ``Fujitsu_SSL2BLAMP``, ``Fujitsu_SSL2SVE``, "
"``Fujitsu_SSL2BLAMPSVE``"
msgstr ""
"``Fujitsu_SSL2``、``Fujitsu_SSL2BLAMP``、``Fujitsu_SSL2SVE``、``Fujitsu_SSL2BLAMPSVE``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:126
msgid "Fujitsu SSL2 serial and parallel blas/lapack with SVE instructions"
msgstr "带有 SVE 指令的富士通 SSL2 串行和并行 blas/lapack"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:129
msgid "``Goto``"
msgstr "``转到``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:129
msgid "GotoBLAS"
msgstr "转到BLAS"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:131
msgid "``IBMESSL``, ``IBMESSL_SMP``"
msgstr "``IBMESSL``，``IBMESSL_SMP``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:133
msgid "IBM Engineering and Scientific Subroutine Library"
msgstr "IBM 工程和科学子程序库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:136
msgid "``Intel``"
msgstr "``英特尔``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:136
msgid "Intel MKL 32 bit and 64 bit obsolete versions"
msgstr "Intel MKL 32 位和 64 位过时版本"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:139
msgid "``Intel10_32``"
msgstr "``Intel10_32``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:139
msgid "Intel MKL v10 32 bit, threaded code"
msgstr "Intel MKL v10 32 位，线程代码"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:142
msgid "``Intel10_64lp``"
msgstr "``Intel10_64lp``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:142
msgid "Intel MKL v10+ 64 bit, threaded code, lp64 model"
msgstr "Intel MKL v10+ 64 位，线程代码，lp64 模型"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:145
msgid "``Intel10_64lp_seq``"
msgstr "``Intel10_64lp_seq``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:145
msgid "Intel MKL v10+ 64 bit, sequential code, lp64 model"
msgstr "Intel MKL v10+ 64 位，顺序代码，lp64 模型"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:150
msgid "``Intel10_64ilp``"
msgstr "``Intel10_64ilp``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:150
msgid "Intel MKL v10+ 64 bit, threaded code, ilp64 model"
msgstr "Intel MKL v10+ 64 位，线程代码，ilp64 模型"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:155
msgid "``Intel10_64ilp_seq``"
msgstr "``Intel10_64ilp_seq``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:155
msgid "Intel MKL v10+ 64 bit, sequential code, ilp64 model"
msgstr "Intel MKL v10+ 64 位，顺序代码，ilp64 模型"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:160
msgid "``Intel10_64_dyn``"
msgstr "``Intel10_64_dyn``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:160
msgid "Intel MKL v10+ 64 bit, single dynamic library"
msgstr "Intel MKL v10+ 64 位，单个动态库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:165
msgid "``NVHPC``"
msgstr "``NVHPC``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:165
msgid "NVIDIA HPC SDK"
msgstr "NVIDIA 高性能计算软件开发工具包"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:168
msgid "``OpenBLAS``"
msgstr "``OpenBLAS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:171
msgid "``PhiPACK``"
msgstr "``PhiPACK``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:171
msgid "Portable High Performance ANSI C (PHiPAC)"
msgstr "便携式高性能 ANSI C (PHiPAC)"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:174
msgid "``SCSL``, ``SCSL_mp``"
msgstr "``SCSL``，``SCSL_mp``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:174
msgid "Scientific Computing Software Library"
msgstr "科学计算软件库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:177
msgid "``SGIMATH``"
msgstr "``SGIMATH``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:177
msgid "SGI Scientific Mathematical Library"
msgstr "SGI科学数学图书馆"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:180
msgid "``SunPerf``"
msgstr "``SunPerf``"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:180
msgid "Sun Performance Library"
msgstr "Sun 性能库"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:185
#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:87
msgid "Intel MKL"
msgstr "英特尔 MKL"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:187
msgid ""
"To use the Intel MKL implementation of BLAS, a project must enable at "
"least one of the ``C`` or ``CXX`` languages.  Set ``BLA_VENDOR`` to an "
"Intel MKL variant either on the command-line as "
"``-DBLA_VENDOR=Intel10_64lp`` or in project code:"
msgstr ""
"要使用 BLAS 的英特尔 MKL 实现，项目必须至少启用“C”或“CXX”语言中的一种。在命令行上将“BLA_VENDOR”设置为英特尔 MKL "
"变体，如“-DBLA_VENDOR=Intel10_64lp”或在项目代码中："

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:197
msgid ""
"In order to build a project using Intel MKL, and end user must first "
"establish an Intel MKL environment:"
msgstr "为了使用英特尔 MKL 构建项目，最终用户必须首先建立英特尔 MKL 环境："

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:211
msgid "Intel oneAPI"
msgstr "英特尔oneAPI"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:201
#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:214
msgid "Source the full Intel environment script:"
msgstr "获取完整的英特尔环境脚本："

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:207
#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:220
msgid "Or, source the MKL component environment script:"
msgstr "或者，获取 MKL 组件环境脚本："

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:224
msgid "Intel Classic"
msgstr "英特尔经典"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:226
msgid ""
"The above environment scripts set the ``MKLROOT`` environment variable to "
"the top of the MKL installation.  They also add the location of the "
"runtime libraries to the dynamic library loader environment variable for "
"your platform (e.g. ``LD_LIBRARY_PATH``).  This is necessary for programs "
"linked against MKL to run."
msgstr ""
"上述环境脚本将 ``MKLROOT`` 环境变量设置为 MKL 安装的顶部。他们还将运行时库的位置添加到您平台的动态库加载程序环境变量中（例如 "
"``LD_LIBRARY_PATH``）。这是链接到 MKL 的程序运行所必需的。"

#: ../../cmake-prefix/src/cmake/Modules/FindBLAS.cmake:234
msgid ""
"As of Intel oneAPI 2021.2, loading only the MKL component does not make "
"all of its dependencies available.  In particular, the ``iomp5`` library "
"must be available separately, or provided by also loading the compiler "
"component environment:"
msgstr ""
"从英特尔 oneAPI 2021.2 开始，仅加载 MKL 组件不会使其所有依赖项都可用。特别是，``iomp5`` "
"库必须单独可用，或者通过同时加载编译器组件环境来提供："

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:6
msgid "FindBZip2"
msgstr "查找BZip2"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:8
msgid "Try to find BZip2"
msgstr "尝试找到 BZip2"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:15
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``BZip2::BZip2``, if BZip2"
" has been found."
msgstr "此模块定义 :prop_tgt:`IMPORTED` 目标 ``BZip2::BZip2``，如果已找到 BZip2。"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:23
msgid "``BZIP2_FOUND``"
msgstr "``BZIP2_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:24
msgid "system has BZip2"
msgstr "系统有 BZip2"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:26
msgid "``BZIP2_INCLUDE_DIRS``"
msgstr "``BZIP2_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:26
msgid "the BZip2 include directories"
msgstr "BZip2 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:28
msgid "``BZIP2_LIBRARIES``"
msgstr "``BZIP2_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:29
msgid "Link these to use BZip2"
msgstr "链接这些以使用 BZip2"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:30
msgid "``BZIP2_NEED_PREFIX``"
msgstr "``BZIP2_NEED_PREFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:31
msgid "this is set if the functions are prefixed with ``BZ2_``"
msgstr "如果函数以“BZ2_”为前缀，则设置此设置"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:36
msgid "``BZIP2_VERSION``"
msgstr "``BZIP2_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:52
msgid "the version of BZip2 found."
msgstr "找到的 BZip2 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:36
msgid "See also legacy variable ``BZIP2_VERSION_STRING``."
msgstr "另见遗留变量“BZIP2_VERSION_STRING”。"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:44
msgid "``BZIP2_INCLUDE_DIR``"
msgstr "``BZIP2_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:44
msgid "the BZip2 include directory"
msgstr "BZip2 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:47
#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:39
msgid "Legacy Variables"
msgstr "遗留变量"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:49
#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:41
msgid "The following variables are provided for backward compatibility:"
msgstr "提供以下变量是为了向后兼容："

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:122
msgid "``BZIP2_VERSION_STRING``"
msgstr "``BZIP2_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindBZip2.cmake:54
msgid "Superseded by ``BZIP2_VERSION``."
msgstr "被“BZIP2_VERSION”取代。"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:6
msgid "FindBacktrace"
msgstr "查找回溯"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:8
msgid ""
"Find provider for `backtrace(3) <https://man7.org/linux/man-"
"pages/man3/backtrace.3.html>`__."
msgstr ""
"查找 `backtrace(3) <https://man7.org/linux/man-"
"pages/man3/backtrace.3.html>`__ 的提供者。"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:10
msgid ""
"Checks if OS supports ``backtrace(3)`` via either ``libc`` or custom "
"library. This module defines the following variables:"
msgstr "通过 ``libc`` 或自定义库检查操作系统是否支持 ``backtrace(3)``。该模块定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:14
msgid "``Backtrace_HEADER``"
msgstr "``Backtrace_HEADER``"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:14
msgid ""
"The header file needed for ``backtrace(3)``. Cached. Could be forcibly set"
" by user."
msgstr "``backtrace(3)`` 所需的头文件。缓存。可以由用户强制设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:16
msgid "``Backtrace_INCLUDE_DIRS``"
msgstr "``Backtrace_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:17
msgid "The include directories needed to use ``backtrace(3)`` header."
msgstr "使用 ``backtrace(3)`` 标头所需的包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:18
msgid "``Backtrace_LIBRARIES``"
msgstr "``Backtrace_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:19
msgid "The libraries (linker flags) needed to use ``backtrace(3)``, if any."
msgstr "库（链接器标志）需要使用 ``backtrace(3)``，如果有的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:21
msgid "``Backtrace_FOUND``"
msgstr "``Backtrace_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:21
msgid "Is set if and only if ``backtrace(3)`` support detected."
msgstr "当且仅当检测到 ``backtrace(3)`` 支持时设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:85
#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:69
msgid "The following cache variables are also available to set or use:"
msgstr "以下缓存变量也可用于设置或使用："

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:25
msgid "``Backtrace_LIBRARY``"
msgstr "``Backtrace_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:26
msgid "The external library providing backtrace, if any."
msgstr "提供回溯的外部库，如果有的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:28
msgid "``Backtrace_INCLUDE_DIR``"
msgstr "``Backtrace_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:28
msgid "The directory holding the ``backtrace(3)`` header."
msgstr "保存 ``backtrace(3)`` 标头的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:30
msgid ""
"Typical usage is to generate of header file using "
":command:`configure_file` with the contents like the following::"
msgstr "典型用法是使用 :command:`configure_file` 生成头文件，其内容如下："

#: ../../cmake-prefix/src/cmake/Modules/FindBacktrace.cmake:38
msgid "And then reference that generated header file in actual source."
msgstr "然后在实际源代码中引用生成的头文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:6
msgid "FindBoost"
msgstr "查找提升"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:8
msgid "Find Boost include dirs and libraries"
msgstr "查找 Boost 包括目录和库"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:10
msgid "Use this module by invoking :command:`find_package` with the form:"
msgstr "通过使用以下形式调用 :command:`find_package` 来使用此模块："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:23
msgid ""
"This module finds headers and requested component libraries OR a CMake "
"package configuration file provided by a \"Boost CMake\" build.  For the "
"latter case skip to the :ref:`Boost CMake` section below."
msgstr ""
"此模块查找标头和请求的组件库或由“Boost CMake”构建提供的 CMake 包配置文件。对于后一种情况，请跳至下面的 :ref:`Boost "
"CMake` 部分。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:27
msgid "``bzip2`` and ``zlib`` components (Windows only)."
msgstr "``bzip2`` 和 ``zlib`` 组件（仅限 Windows）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:30
msgid "The ``OPTIONAL_COMPONENTS`` option."
msgstr "``OPTIONAL_COMPONENTS`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:33
msgid "``stacktrace_*`` components."
msgstr "``stacktrace_*`` 组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:36
msgid "``bzip2`` and ``zlib`` components on all platforms."
msgstr "所有平台上的``bzip2`` 和``zlib`` 组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:45
msgid "``Boost_FOUND``"
msgstr "``Boost_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:45
msgid "True if headers and requested libraries were found."
msgstr "如果找到标头和请求的库，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:48
msgid "``Boost_INCLUDE_DIRS``"
msgstr "``Boost_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:48
msgid "Boost include directories."
msgstr "提升包括目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:51
msgid "``Boost_LIBRARY_DIRS``"
msgstr "``Boost_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:51
msgid "Link directories for Boost libraries."
msgstr "Boost 库的链接目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:54
msgid "``Boost_LIBRARIES``"
msgstr "``Boost_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:54
msgid "Boost component libraries to be linked."
msgstr "Boost 组件库被链接。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:57
msgid "``Boost_<COMPONENT>_FOUND``"
msgstr "``Boost_<COMPONENT>_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:57
msgid ""
"True if component ``<COMPONENT>`` was found (``<COMPONENT>`` name is "
"upper-case)."
msgstr "如果找到组件 ``<COMPONENT>`` 则为真（``<COMPONENT>`` 名称为大写）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:61
msgid "``Boost_<COMPONENT>_LIBRARY``"
msgstr "``Boost_<COMPONENT>_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:60
msgid ""
"Libraries to link for component ``<COMPONENT>`` (may include "
":command:`target_link_libraries` debug/optimized keywords)."
msgstr ""
"链接组件``<COMPONENT>`` 的库（可能包括:command:`target_link_libraries` 调试/优化关键字）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:64
msgid "``Boost_VERSION_MACRO``"
msgstr "``Boost_VERSION_MACRO``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:64
msgid "``BOOST_VERSION`` value from ``boost/version.hpp``."
msgstr "``BOOST_VERSION`` 来自``boost/version.hpp`` 的值。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:67
msgid "``Boost_VERSION_STRING``"
msgstr "``Boost_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:67
msgid "Boost version number in ``X.Y.Z`` format."
msgstr "以 ``X.Y.Z`` 格式提升版本号。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:75
msgid "``Boost_VERSION``"
msgstr "``Boost_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:70
msgid ""
"Boost version number in ``X.Y.Z`` format (same as "
"``Boost_VERSION_STRING``)."
msgstr "以 ``X.Y.Z`` 格式提升版本号（与 ``Boost_VERSION_STRING`` 相同）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:72
msgid ""
"In previous CMake versions, this variable used the raw version string from"
" the Boost header (same as ``Boost_VERSION_MACRO``). See policy "
":policy:`CMP0093`."
msgstr ""
"在以前的 CMake 版本中，此变量使用来自 Boost "
"标头的原始版本字符串（与“Boost_VERSION_MACRO”相同）。请参阅政策:policy:`CMP0093`。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:78
msgid "``Boost_LIB_VERSION``"
msgstr "``Boost_LIB_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:78
msgid "Version string appended to library filenames."
msgstr "附加到库文件名的版本字符串。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:81
msgid "``Boost_VERSION_MAJOR``, ``Boost_MAJOR_VERSION``"
msgstr "``Boost_VERSION_MAJOR``，``Boost_MAJOR_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:81
msgid "Boost major version number (``X`` in ``X.Y.Z``)."
msgstr "提升主要版本号（``X.Y.Z`` 中的``X``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:84
msgid "``Boost_VERSION_MINOR``, ``Boost_MINOR_VERSION``"
msgstr "``Boost_VERSION_MINOR``，``Boost_MINOR_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:84
msgid "Boost minor version number (``Y`` in ``X.Y.Z``)."
msgstr "提升次要版本号（``X.Y.Z`` 中的``Y``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:87
msgid "``Boost_VERSION_PATCH``, ``Boost_SUBMINOR_VERSION``"
msgstr "``Boost_VERSION_PATCH``，``Boost_SUBMINOR_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:87
msgid "Boost subminor version number (``Z`` in ``X.Y.Z``)."
msgstr "提升次要版本号（``X.Y.Z`` 中的``Z``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:90
msgid "``Boost_VERSION_COUNT``"
msgstr "``Boost_VERSION_COUNT``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:90
msgid "Amount of version components (3)."
msgstr "版本组件的数量 (3)。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:95
msgid "``Boost_LIB_DIAGNOSTIC_DEFINITIONS`` (Windows-specific)"
msgstr "``Boost_LIB_DIAGNOSTIC_DEFINITIONS``（特定于 Windows）"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:93
msgid ""
"Pass to :command:`add_definitions` to have diagnostic information about "
"Boost's automatic linking displayed during compilation"
msgstr "传递给 :command:`add_definitions` 以在编译期间显示有关 Boost 自动链接的诊断信息"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:97
msgid "The ``Boost_VERSION_<PART>`` variables."
msgstr "``Boost_VERSION_<PART>`` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:103
msgid "Search results are saved persistently in CMake cache entries:"
msgstr "搜索结果永久保存在 CMake 缓存条目中："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:106
msgid "``Boost_INCLUDE_DIR``"
msgstr "``Boost_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:106
msgid "Directory containing Boost headers."
msgstr "包含 Boost 标头的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:109
msgid "``Boost_LIBRARY_DIR_RELEASE``"
msgstr "``Boost_LIBRARY_DIR_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:109
msgid "Directory containing release Boost libraries."
msgstr "包含发布 Boost 库的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:112
msgid "``Boost_LIBRARY_DIR_DEBUG``"
msgstr "``Boost_LIBRARY_DIR_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:112
msgid "Directory containing debug Boost libraries."
msgstr "包含调试 Boost 库的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:115
msgid "``Boost_<COMPONENT>_LIBRARY_DEBUG``"
msgstr "``Boost_<COMPONENT>_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:115
msgid "Component ``<COMPONENT>`` library debug variant."
msgstr "组件``<COMPONENT>`` 库调试变体。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:118
msgid "``Boost_<COMPONENT>_LIBRARY_RELEASE``"
msgstr "``Boost_<COMPONENT>_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:118
msgid "Component ``<COMPONENT>`` library release variant."
msgstr "组件 ``<COMPONENT>`` 库版本变体。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:120
msgid ""
"Per-configuration variables ``Boost_LIBRARY_DIR_RELEASE`` and "
"``Boost_LIBRARY_DIR_DEBUG``."
msgstr "每个配置变量“Boost_LIBRARY_DIR_RELEASE”和“Boost_LIBRARY_DIR_DEBUG”。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:125
#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:137
#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:16
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:91
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:261
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:207
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:263
#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:70
#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:210
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:76
msgid "Hints"
msgstr "提示"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:127
msgid "This module reads hints about search locations from variables:"
msgstr "该模块从变量中读取有关搜索位置的提示："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:130
msgid "``BOOST_ROOT``, ``BOOSTROOT``"
msgstr "``BOOST_ROOT``，``BOOSTROOT``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:130
msgid "Preferred installation prefix."
msgstr "首选安装前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:133
msgid "``BOOST_INCLUDEDIR``"
msgstr "``BOOST_INCLUDEDIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:133
msgid "Preferred include directory e.g. ``<prefix>/include``."
msgstr "首选包含目录，例如``<前缀>/include``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:136
msgid "``BOOST_LIBRARYDIR``"
msgstr "``BOOST_LIBRARYDIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:136
msgid "Preferred library directory e.g. ``<prefix>/lib``."
msgstr "首选图书馆目录，例如``<前缀>/lib``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:140
msgid "``Boost_NO_SYSTEM_PATHS``"
msgstr "``Boost_NO_SYSTEM_PATHS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:139
msgid ""
"Set to ``ON`` to disable searching in locations not specified by these "
"hint variables. Default is ``OFF``."
msgstr "设置为 ``ON`` 以禁用在这些提示变量未指定的位置进行搜索。默认为“关闭”。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:144
msgid "``Boost_ADDITIONAL_VERSIONS``"
msgstr "``Boost_ADDITIONAL_VERSIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:143
msgid ""
"List of Boost versions not known to this module. (Boost install locations "
"may contain the version)."
msgstr "此模块未知的 Boost 版本列表。 （提升安装位置可能包含版本）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:146
msgid ""
"Users may set these hints or results as ``CACHE`` entries.  Projects "
"should not read these entries directly but instead use the above result "
"variables.  Note that some hint names start in upper-case ``BOOST``.  One "
"may specify these as environment variables if they are not specified as "
"CMake variables or cache entries."
msgstr ""
"用户可以将这些提示或结果设置为“CACHE”条目。项目不应直接读取这些条目，而应使用上述结果变量。请注意，一些提示名称以大写“BOOST”开头。如果未将它们指定为"
" CMake 变量或缓存条目，则可以将它们指定为环境变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:152
msgid ""
"This module first searches for the Boost header files using the above hint"
" variables (excluding ``BOOST_LIBRARYDIR``) and saves the result in "
"``Boost_INCLUDE_DIR``.  Then it searches for requested component libraries"
" using the above hints (excluding ``BOOST_INCLUDEDIR`` and "
"``Boost_ADDITIONAL_VERSIONS``), \"lib\" directories near "
"``Boost_INCLUDE_DIR``, and the library name configuration settings below."
"  It saves the library directories in ``Boost_LIBRARY_DIR_DEBUG`` and "
"``Boost_LIBRARY_DIR_RELEASE`` and individual library locations in "
"``Boost_<COMPONENT>_LIBRARY_DEBUG`` and "
"``Boost_<COMPONENT>_LIBRARY_RELEASE``. When one changes settings used by "
"previous searches in the same build tree (excluding environment variables)"
" this module discards previous search results affected by the changes and "
"searches again."
msgstr ""
"该模块首先使用上述提示变量（不包括 ``BOOST_LIBRARYDIR``）搜索 Boost 头文件，并将结果保存在 "
"``Boost_INCLUDE_DIR`` 中。然后它使用上述提示（不包括 ``BOOST_INCLUDEDIR`` 和 "
"``Boost_ADDITIONAL_VERSIONS``）、``Boost_INCLUDE_DIR`` "
"附近的“lib”目录和下面的库名称配置设置搜索请求的组件库。它将库目录保存在“Boost_LIBRARY_DIR_DEBUG”和“Boost_LIBRARY_DIR_RELEASE”中，并将各个库位置保存在“Boost_<COMPONENT>_LIBRARY_DEBUG”和“Boost_<COMPONENT>_LIBRARY_RELEASE”中。当一个人更改同一构建树中先前搜索使用的设置（不包括环境变量）时，此模块会丢弃受更改影响的先前搜索结果并再次搜索。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:166
#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:12
#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:17
#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:20
#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:12
#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:71
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:65
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:72
#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:11
msgid "Imported Targets"
msgstr "进口目标"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:173
msgid "``Boost::boost``"
msgstr "``升压 ::升压``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:173
msgid "Target for header-only dependencies. (Boost include directory)."
msgstr "仅标头依赖项的目标。 （提升包括目录）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:177
msgid "``Boost::headers``"
msgstr "``Boost::headers``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:176
msgid "Alias for ``Boost::boost``."
msgstr "``Boost::boost`` 的别名。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:181
msgid "``Boost::<component>``"
msgstr "``提升 ::<组件>``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:180
msgid ""
"Target for specific component dependency (shared or static library); "
"``<component>`` name is lower-case."
msgstr "针对特定组件依赖项（共享或静态库）的目标； ``<component>`` 名字是小写的。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:185
msgid "``Boost::diagnostic_definitions``"
msgstr "``Boost::diagnostic_definitions``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:184
msgid ""
"Interface target to enable diagnostic information about Boost's automatic "
"linking during compilation (adds ``-DBOOST_LIB_DIAGNOSTIC``)."
msgstr "在编译期间启用有关 Boost 自动链接的诊断信息的接口目标（添加“-DBOOST_LIB_DIAGNOSTIC”）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:189
msgid "``Boost::disable_autolinking``"
msgstr "``Boost::disable_autolinking``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:188
msgid ""
"Interface target to disable automatic linking with MSVC (adds "
"``-DBOOST_ALL_NO_LIB``)."
msgstr "禁用与 MSVC 自动链接的接口目标（添加“-DBOOST_ALL_NO_LIB”）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:193
msgid "``Boost::dynamic_linking``"
msgstr "``Boost::dynamic_linking``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:192
msgid ""
"Interface target to enable dynamic linking with MSVC (adds "
"``-DBOOST_ALL_DYN_LINK``)."
msgstr "启用与 MSVC 动态链接的接口目标（添加“-DBOOST_ALL_DYN_LINK”）。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:195
msgid ""
"Implicit dependencies such as ``Boost::filesystem`` requiring "
"``Boost::system`` will be automatically detected and satisfied, even if "
"system is not specified when using :command:`find_package` and if "
"``Boost::system`` is not added to :command:`target_link_libraries`.  If "
"using ``Boost::thread``, then ``Threads::Threads`` will also be added "
"automatically."
msgstr ""
"隐式依赖关系，例如需要 ``Boost::system`` 的 ``Boost::filesystem`` 将被自动检测和满足，即使在使用 "
":command:`find_package` 时未指定系统，并且如果 ``Boost::system `` 未添加到 "
":command:`target_link_libraries`。如果使用``Boost::thread``，那么``Threads::Threads``也会被自动添加。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:201
msgid ""
"It is important to note that the imported targets behave differently than "
"variables created by this module: multiple calls to "
":command:`find_package(Boost)` in the same directory or sub-directories "
"with different options (e.g. static or shared) will not override the "
"values of the targets created by the first call."
msgstr ""
"重要的是要注意导入的目标与此模块创建的变量的行为不同：在同一目录或具有不同选项（例如静态或共享）的子目录中多次调用 "
":command:`find_package(Boost)` 不会覆盖第一次调用创建的目标的值。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:208
msgid "Other Variables"
msgstr "其他变量"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:210
msgid ""
"Boost libraries come in many variants encoded in their file name. Users or"
" projects may tell this module which variant to find by setting variables:"
msgstr "Boost 库有许多在文件名中编码的变体。用户或项目可以通过设置变量来告诉该模块要查找哪个变体："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:218
msgid "``Boost_USE_DEBUG_LIBS``"
msgstr "``Boost_USE_DEBUG_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:217
msgid ""
"Set to ``ON`` or ``OFF`` to specify whether to search and use the debug "
"libraries.  Default is ``ON``."
msgstr "设置为 ``ON`` 或 ``OFF`` 以指定是否搜索和使用调试库。默认为``ON``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:224
msgid "``Boost_USE_RELEASE_LIBS``"
msgstr "``Boost_USE_RELEASE_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:223
msgid ""
"Set to ``ON`` or ``OFF`` to specify whether to search and use the release "
"libraries.  Default is ``ON``."
msgstr "设置为 ``ON`` 或 ``OFF`` 以指定是否搜索和使用发布库。默认为``ON``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:228
msgid "``Boost_USE_MULTITHREADED``"
msgstr "``Boost_USE_MULTITHREADED``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:227
msgid ""
"Set to OFF to use the non-multithreaded libraries (\"mt\" tag). Default is"
" ``ON``."
msgstr "设置为 OFF 以使用非多线程库（“mt”标签）。默认为``ON``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:231
msgid "``Boost_USE_STATIC_LIBS``"
msgstr "``Boost_USE_STATIC_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:231
msgid ""
"Set to ON to force the use of the static libraries.  Default is ``OFF``."
msgstr "设置为 ON 以强制使用静态库。默认为“关闭”。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:235
msgid "``Boost_USE_STATIC_RUNTIME``"
msgstr "``Boost_USE_STATIC_RUNTIME``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:234
msgid ""
"Set to ``ON`` or ``OFF`` to specify whether to use libraries linked "
"statically to the C++ runtime (\"s\" tag).  Default is platform dependent."
msgstr "设置为 ``ON`` 或 ``OFF`` 以指定是否使用静态链接到 C++ 运行时的库（“s”标签）。默认值取决于平台。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:239
msgid "``Boost_USE_DEBUG_RUNTIME``"
msgstr "``Boost_USE_DEBUG_RUNTIME``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:238
msgid ""
"Set to ``ON`` or ``OFF`` to specify whether to use libraries linked to the"
" MS debug C++ runtime (\"g\" tag).  Default is ``ON``."
msgstr "设置为“ON”或“OFF”以指定是否使用链接到 MS 调试 C++ 运行时（“g”标签）的库。默认为``ON``。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:243
msgid "``Boost_USE_DEBUG_PYTHON``"
msgstr "``Boost_USE_DEBUG_PYTHON``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:242
msgid ""
"Set to ``ON`` to use libraries compiled with a debug Python build (\"y\" "
"tag).  Default is ``OFF``."
msgstr "设置为 ``ON`` 以使用使用调试 Python 构建（“y”标签）编译的库。默认为“关闭”。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:247
msgid "``Boost_USE_STLPORT``"
msgstr "``Boost_USE_STLPORT``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:246
msgid ""
"Set to ``ON`` to use libraries compiled with STLPort (\"p\" tag). Default "
"is ``OFF``."
msgstr "设置为 ``ON`` 以使用使用 STLPort（“p”标签）编译的库。默认为“关闭”。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:251
msgid "``Boost_USE_STLPORT_DEPRECATED_NATIVE_IOSTREAMS``"
msgstr "``Boost_USE_STLPORT_DEPRECATED_NATIVE_IOSTREAMS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:250
msgid ""
"Set to ON to use libraries compiled with STLPort deprecated \"native "
"iostreams\" (\"n\" tag).  Default is ``OFF``."
msgstr "设置为 ON 以使用使用 STLPort 弃用的“本地 iostreams”（“n”标签）编译的库。默认为“关闭”。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:259
msgid "``Boost_COMPILER``"
msgstr "``Boost_COMPILER``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:254
msgid ""
"Set to the compiler-specific library suffix (e.g. ``-gcc43``).  Default is"
" auto-computed for the C++ compiler in use."
msgstr "设置为特定于编译器的库后缀（例如 ``-gcc43``）。默认值是为正在使用的 C++ 编译器自动计算的。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:257
msgid ""
"A list may be used if multiple compatible suffixes should be tested for, "
"in decreasing order of preference."
msgstr "如果应测试多个兼容的后缀，则可以使用一个列表，按优先顺序降序排列。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:266
msgid "``Boost_LIB_PREFIX``"
msgstr "``Boost_LIB_PREFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:264
msgid ""
"Set to the platform-specific library name prefix (e.g. ``lib``) used by "
"Boost static libs.  This is needed only on platforms where CMake does not "
"know the prefix by default."
msgstr ""
"设置为 Boost 静态库使用的特定于平台的库名称前缀（例如 ``lib``）。这仅在 CMake 默认情况下不知道前缀的平台上才需要。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:272
msgid "``Boost_ARCHITECTURE``"
msgstr "``Boost_ARCHITECTURE``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:271
msgid ""
"Set to the architecture-specific library suffix (e.g. ``-x64``). Default "
"is auto-computed for the C++ compiler in use."
msgstr "设置为特定于体系结构的库后缀（例如“-x64”）。默认值是为正在使用的 C++ 编译器自动计算的。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:276
msgid "``Boost_THREADAPI``"
msgstr "``Boost_THREADAPI``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:275
msgid ""
"Suffix for ``thread`` component library name, such as ``pthread`` or "
"``win32``.  Names with and without this suffix will both be tried."
msgstr "``thread`` 组件库名称的后缀，例如 ``pthread`` 或 ``win32``。有和没有这个后缀的名字都会被尝试。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:280
msgid "``Boost_NAMESPACE``"
msgstr "``Boost_NAMESPACE``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:279
msgid ""
"Alternate namespace used to build boost with e.g. if set to ``myboost``, "
"will search for ``myboost_thread`` instead of ``boost_thread``."
msgstr ""
"用于构建 boost 的备用命名空间，例如如果设置为“myboost”，将搜索“myboost_thread”而不是“boost_thread”。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:282
msgid "Other variables one may set to control this module are:"
msgstr "可以设置以控制此模块的其他变量是："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:286
msgid "``Boost_DEBUG``"
msgstr "``Boost_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:285
msgid ""
"Set to ``ON`` to enable debug output from ``FindBoost``. Please enable "
"this before filing any bug report."
msgstr "设置为“ON”以启用“FindBoost”的调试输出。请在提交任何错误报告之前启用此功能。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:293
msgid "``Boost_REALPATH``"
msgstr "``Boost_REALPATH``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:289
msgid ""
"Set to ``ON`` to resolve symlinks for discovered libraries to assist with "
"packaging.  For example, the \"system\" component library may be resolved "
"to ``/usr/lib/libboost_system.so.1.67.0`` instead of "
"``/usr/lib/libboost_system.so``.  This does not affect linking and should "
"not be enabled unless the user needs this information."
msgstr ""
"设置为 ``ON`` "
"以解析已发现库的符号链接以协助打包。例如，“系统”组件库可能会解析为“/usr/lib/libboost_system.so.1.67.0”而不是“/usr/lib/libboost_system.so”。这不会影响链接，除非用户需要此信息，否则不应启用。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:297
msgid "``Boost_LIBRARY_DIR``"
msgstr "``Boost_LIBRARY_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:296
msgid ""
"Default value for ``Boost_LIBRARY_DIR_RELEASE`` and "
"``Boost_LIBRARY_DIR_DEBUG``."
msgstr "``Boost_LIBRARY_DIR_RELEASE`` 和 ``Boost_LIBRARY_DIR_DEBUG`` 的默认值。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:303
msgid "``Boost_NO_WARN_NEW_VERSIONS``"
msgstr "``Boost_NO_WARN_NEW_VERSIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:302
msgid ""
"Set to ``ON`` to suppress the warning about unknown dependencies for new "
"Boost versions."
msgstr "设置为 ``ON`` 以抑制有关新 Boost 版本的未知依赖项的警告。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:305
msgid ""
"On Visual Studio and Borland compilers Boost headers request automatic "
"linking to corresponding libraries.  This requires matching libraries to "
"be linked explicitly or available in the link library search path. In this"
" case setting ``Boost_USE_STATIC_LIBS`` to ``OFF`` may not achieve dynamic"
" linking.  Boost automatic linking typically requests static libraries "
"with a few exceptions (such as ``Boost.Python``).  Use:"
msgstr ""
"在 Visual Studio 和 Borland 编译器上，Boost "
"标头请求自动链接到相应的库。这需要匹配的库明确链接或在链接库搜索路径中可用。在这种情况下，将 ``Boost_USE_STATIC_LIBS`` "
"设置为 ``OFF`` 可能无法实现动态链接。 Boost 自动链接通常请求静态库，但有少数例外（例如“Boost.Python”）。使用："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:316
msgid "to ask Boost to report information about automatic linking requests."
msgstr "要求 Boost 报告有关自动链接请求的信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:321
msgid "Find Boost headers only:"
msgstr "仅查找 Boost 标头："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:331
msgid "Find Boost libraries and use imported targets:"
msgstr "查找 Boost 库并使用导入的目标："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:341
msgid "Find Boost Python 3.6 libraries and use imported targets:"
msgstr "查找 Boost Python 3.6 库并使用导入的目标："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:350
msgid "Find Boost headers and some *static* (release only) libraries:"
msgstr "查找 Boost 标头和一些 *static* （仅发布）库："

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:369
msgid "Boost CMake"
msgstr "提升CMake"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:371
msgid ""
"If Boost was built using the boost-cmake project or from Boost 1.70.0 on "
"it provides a package configuration file for use with find_package's "
"config mode. This module looks for the package configuration file called "
"``BoostConfig.cmake`` or ``boost-config.cmake`` and stores the result in "
"``CACHE`` entry ``Boost_DIR``.  If found, the package configuration file "
"is loaded and this module returns with no further action.  See "
"documentation of the Boost CMake package configuration for details on what"
" it provides."
msgstr ""
"如果 Boost 是使用 boost-cmake 项目或从 Boost 1.70.0 构建的，它会提供一个包配置文件以用于 find_package"
" 的配置模式。该模块查找名为“BoostConfig.cmake”或“boost-"
"config.cmake”的包配置文件，并将结果存储在“CACHE”条目“Boost_DIR”中。如果找到，则加载包配置文件，并且此模块返回而不执行进一步操作。有关它提供的内容的详细信息，请参阅"
" Boost CMake 包配置的文档。"

#: ../../cmake-prefix/src/cmake/Modules/FindBoost.cmake:379
msgid ""
"Set ``Boost_NO_BOOST_CMAKE`` to ``ON``, to disable the search for boost-"
"cmake."
msgstr "将“Boost_NO_BOOST_CMAKE”设置为“ON”，以禁用对 boost-cmake 的搜索。"

#: ../../cmake-prefix/src/cmake/Modules/FindBullet.cmake:6
msgid "FindBullet"
msgstr "查找子弹"

#: ../../cmake-prefix/src/cmake/Modules/FindBullet.cmake:8
msgid "Try to find the Bullet physics engine"
msgstr "尝试找到 Bullet 物理引擎"

#: ../../cmake-prefix/src/cmake/Modules/FindCABLE.cmake:6
msgid "FindCABLE"
msgstr "查找CABLE"

#: ../../cmake-prefix/src/cmake/Modules/FindCABLE.cmake:8
msgid "Find CABLE"
msgstr "查找电缆"

#: ../../cmake-prefix/src/cmake/Modules/FindCABLE.cmake:10
msgid ""
"This module finds if CABLE is installed and determines where the include "
"files and libraries are.  This code sets the following variables:"
msgstr "该模块查找是否安装了 CABLE 并确定包含文件和库的位置。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindCABLE.cmake:22
msgid ""
"To build Tcl wrappers, you should add shared library and link it to "
"${CABLE_TCL_LIBRARY}.  You should also add ${CABLE_INCLUDE_DIR} as an "
"include directory."
msgstr ""
"要构建 Tcl 包装器，您应该添加共享库并将其链接到 ${CABLE_TCL_LIBRARY}。您还应该添加 "
"${CABLE_INCLUDE_DIR} 作为包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:3
msgid "FindCUDA"
msgstr "查找CUDA"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:5
msgid "*Deprecated since version 3.10.*"
msgstr "*自版本 3.10 起已弃用。*"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:7
msgid ""
"It is no longer necessary to use this module or call "
"``find_package(CUDA)`` for compiling CUDA code. Instead, list ``CUDA`` "
"among the languages named in the top-level call to the :command:`project` "
"command, or call the :command:`enable_language` command with ``CUDA``. "
"Then one can add CUDA (``.cu``) sources directly to targets similar to "
"other languages."
msgstr ""
"不再需要使用此模块或调用``find_package(CUDA)`` 来编译 CUDA 代码。相反，在对 :command:`project` "
"命令的顶级调用中命名的语言中列出 ``CUDA``，或者使用 ``CUDA`` 调用 :command:`enable_language` "
"命令。然后可以将 CUDA (``.cu``) 源直接添加到类似于其他语言的目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:14
msgid ""
"To find and use the CUDA toolkit libraries manually, use the "
":module:`FindCUDAToolkit` module instead.  It works regardless of the "
"``CUDA`` language being enabled."
msgstr ""
"要手动查找和使用 CUDA 工具包库，请改用 FindCUDAToolkit 模块。无论是否启用 ``CUDA`` 语言，它都能正常工作。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:20
msgid "Documentation of Deprecated Usage"
msgstr "不推荐使用的文档"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:22
msgid "Tools for building CUDA C files: libraries and build dependencies."
msgstr "用于构建 CUDA C 文件的工具：库和构建依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:24
msgid ""
"This script locates the NVIDIA CUDA C tools.  It should work on Linux, "
"Windows, and macOS and should be reasonably up to date with CUDA C "
"releases."
msgstr ""
"此脚本定位 NVIDIA CUDA C 工具。它应该可以在 Linux、Windows 和 macOS 上运行，并且应该与 CUDA C "
"版本保持同步。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:14
msgid "QNX support."
msgstr "QNX 支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:31
msgid ""
"This script makes use of the standard :command:`find_package` arguments of"
" ``<VERSION>``, ``REQUIRED`` and ``QUIET``.  ``CUDA_FOUND`` will report if"
" an acceptable version of CUDA was found."
msgstr ""
"此脚本使用标准的 :command:`find_package` 参数``<VERSION>``、``REQUIRED`` 和``QUIET``。 "
"``CUDA_FOUND`` 将报告是否找到了可接受的 CUDA 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:35
msgid ""
"The script will prompt the user to specify ``CUDA_TOOLKIT_ROOT_DIR`` if "
"the prefix cannot be determined by the location of nvcc in the system path"
" and ``REQUIRED`` is specified to :command:`find_package`.  To use a "
"different installed version of the toolkit set the environment variable "
"``CUDA_BIN_PATH`` before running cmake (e.g. "
"``CUDA_BIN_PATH=/usr/local/cuda1.0`` instead of the default "
"``/usr/local/cuda``) or set ``CUDA_TOOLKIT_ROOT_DIR`` after configuring.  "
"If you change the value of ``CUDA_TOOLKIT_ROOT_DIR``, various components "
"that depend on the path will be relocated."
msgstr ""
"如果系统路径中 nvcc 的位置无法确定前缀，并且 REQUIRED 被指定为 find_package，脚本将提示用户指定 "
"CUDA_TOOLKIT_ROOT_DIR。要使用不同安装版本的工具包，请在运行 cmake 之前设置环境变量 "
"``CUDA_BIN_PATH``（例如 ``CUDA_BIN_PATH=/usr/local/cuda1.0`` 而不是默认的 "
"``/usr/local/cuda` `) 或在配置后设置 ``CUDA_TOOLKIT_ROOT_DIR``。如果更改 "
"``CUDA_TOOLKIT_ROOT_DIR`` 的值，依赖于该路径的各种组件将被重新定位。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:45
msgid ""
"It might be necessary to set ``CUDA_TOOLKIT_ROOT_DIR`` manually on certain"
" platforms, or to use a CUDA runtime not installed in the default "
"location.  In newer versions of the toolkit the CUDA library is included "
"with the graphics driver -- be sure that the driver version matches what "
"is needed by the CUDA runtime version."
msgstr ""
"可能需要在某些平台上手动设置 ``CUDA_TOOLKIT_ROOT_DIR``，或者使用未安装在默认位置的 CUDA "
"运行时。在较新版本的工具包中，CUDA 库包含在图形驱动程序中——确保驱动程序版本与 CUDA 运行时版本所需的相匹配。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:54
msgid ""
"The following variables affect the behavior of the macros in the script "
"(in alphabetical order).  Note that any of these flags can be changed "
"multiple times in the same directory before calling "
"``cuda_add_executable()``, ``cuda_add_library()``, ``cuda_compile()``, "
"``cuda_compile_ptx()``, ``cuda_compile_fatbin()``, "
"``cuda_compile_cubin()`` or ``cuda_wrap_srcs()``:"
msgstr ""
"以下变量影响脚本中宏的行为（按字母顺序排列）。请注意，在调用“cuda_add_executable()”、“cuda_add_library()”、“cuda_compile()”、“cuda_compile_ptx()”、“"
" `cuda_compile_fatbin()``、``cuda_compile_cubin()`` 或 ``cuda_wrap_srcs()``："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:66
msgid "``CUDA_64_BIT_DEVICE_CODE`` (Default: host bit size)"
msgstr "``CUDA_64_BIT_DEVICE_CODE``（默认值：主机位大小）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:62
msgid ""
"Set to ``ON`` to compile for 64 bit device code, OFF for 32 bit device "
"code. Note that making this different from the host code when generating "
"object or C files from CUDA code just won't work, because size_t gets "
"defined by nvcc in the generated source.  If you compile to PTX and then "
"load the file yourself, you can mix bit sizes between device and host."
msgstr ""
"设置为 ``ON`` 编译 64 位设备代码，OFF 编译 32 位设备代码。请注意，在从 CUDA 代码生成对象或 C "
"文件时，将其与主机代码不同是行不通的，因为 size_t 由 nvcc 在生成的源代码中定义。如果编译为 PTX "
"然后自己加载文件，则可以在设备和主机之间混合位大小。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:83
msgid "``CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE`` (Default: ``ON``)"
msgstr "``CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE``（默认值：``ON``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:69
msgid ""
"Set to ``ON`` if you want the custom build rule to be attached to the "
"source file in Visual Studio.  Turn OFF if you add the same cuda file to "
"multiple targets."
msgstr ""
"如果您希望将自定义生成规则附加到 Visual Studio 中的源文件，请设置为“ON”。如果将相同的 cuda 文件添加到多个目标，请关闭。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:73
msgid ""
"This allows the user to build the target from the CUDA file; however, bad "
"things can happen if the CUDA source file is added to multiple targets. "
"When performing parallel builds it is possible for the custom build "
"command to be run more than once and in parallel causing cryptic build "
"errors.  VS runs the rules for every source file in the target, and a "
"source can have only one rule no matter how many projects it is added to. "
"When the rule is run from multiple targets race conditions can occur on "
"the generated file.  Eventually everything will get built, but if the user"
" is unaware of this behavior, there may be confusion.  It would be nice if"
" this script could detect the reuse of source files across multiple "
"targets and turn the option off for the user, but no good solution could "
"be found."
msgstr ""
"这允许用户从 CUDA 文件构建目标；但是，如果将 CUDA "
"源文件添加到多个目标，可能会发生不好的事情。执行并行构建时，自定义构建命令可能会并行运行多次并导致神秘的构建错误。 VS "
"为目标中的每个源文件运行规则，一个源无论添加到多少个项目都只能有一个规则。当规则从多个目标运行时，竞争条件可能会出现在生成的文件上。最终一切都会构建起来，但如果用户没有意识到这种行为，可能会造成混淆。如果此脚本能够检测跨多个目标的源文件重用并为用户关闭该选项，那就太好了，但是找不到好的解决方案。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:88
msgid "``CUDA_BUILD_CUBIN`` (Default: ``OFF``)"
msgstr "``CUDA_BUILD_CUBIN``（默认值：``OFF``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:86
msgid ""
"Set to ``ON`` to enable and extra compilation pass with the ``-cubin`` "
"option in Device mode. The output is parsed and register, shared memory "
"usage is printed during build."
msgstr ""
"设置为 ``ON`` 以在设备模式下使用 ``-cubin`` 选项启用和额外的编译传递。解析和注册输出，在构建期间打印共享内存使用情况。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:92
msgid "``CUDA_BUILD_EMULATION`` (Default: ``OFF`` for device mode)"
msgstr "``CUDA_BUILD_EMULATION``（默认：设备模式为``OFF``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:91
msgid ""
"Set to ``ON`` for Emulation mode. ``-D_DEVICEEMU`` is defined for CUDA C "
"files when ``CUDA_BUILD_EMULATION`` is ``TRUE``."
msgstr ""
"为仿真模式设置为“开”。当 CUDA_BUILD_EMULATION 为 TRUE 时，-D_DEVICEEMU 是为 CUDA C 文件定义的。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:101
msgid "``CUDA_LINK_LIBRARIES_KEYWORD`` (Default: ``\"\"``)"
msgstr "``CUDA_LINK_LIBRARIES_KEYWORD``（默认值：``\"\"``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:97
msgid ""
"The ``<PRIVATE|PUBLIC|INTERFACE>`` keyword to use for internal "
":command:`target_link_libraries` calls. The default is to use no keyword "
"which uses the old \"plain\" form of :command:`target_link_libraries`. "
"Note that is matters because whatever is used inside the ``FindCUDA`` "
"module must also be used outside - the two forms of "
":command:`target_link_libraries` cannot be mixed."
msgstr ""
"``<PRIVATE|PUBLIC|INTERFACE>`` 关键字用于内部 :command:`target_link_libraries` "
"调用。默认是不使用使用旧的“普通”形式的 :command:`target_link_libraries` "
"的关键字。请注意，这很重要，因为在``FindCUDA`` 模块内部使用的任何内容都必须在外部使用 - "
":command:`target_link_libraries` 的两种形式不能混合使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:107
msgid ""
"``CUDA_GENERATED_OUTPUT_DIR`` (Default: "
":variable:`CMAKE_CURRENT_BINARY_DIR`)"
msgstr "``CUDA_GENERATED_OUTPUT_DIR``（默认值： :variable:`CMAKE_CURRENT_BINARY_DIR`）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:104
msgid ""
"Set to the path you wish to have the generated files placed.  If it is "
"blank output files will be placed in :variable:`CMAKE_CURRENT_BINARY_DIR`."
" Intermediate files will always be placed in "
"``CMAKE_CURRENT_BINARY_DIR/CMakeFiles``."
msgstr ""
"设置为您希望放置生成的文件的路径。如果它是空白输出文件将被放置在 :variable:`CMAKE_CURRENT_BINARY_DIR`。中间文件将始终放在“CMAKE_CURRENT_BINARY_DIR/CMakeFiles”中。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:110
msgid "``CUDA_HOST_COMPILATION_CPP`` (Default: ``ON``)"
msgstr "``CUDA_HOST_COMPILATION_CPP``（默认值：``ON``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:110
msgid "Set to ``OFF`` for C compilation of host code."
msgstr "为主机代码的 C 编译设置为 ``OFF``。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:122
msgid "``CUDA_HOST_COMPILER`` (Default: ``CMAKE_C_COMPILER``)"
msgstr "``CUDA_HOST_COMPILER``（默认值：``CMAKE_C_COMPILER``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:113
msgid ""
"Set the host compiler to be used by nvcc.  Ignored if ``-ccbin`` or "
"``--compiler-bindir`` is already present in the ``CUDA_NVCC_FLAGS`` or "
"``CUDA_NVCC_FLAGS_<CONFIG>`` variables.  For Visual Studio targets, the "
"host compiler is constructed with one or more visual studio macros such as"
" ``$(VCInstallDir)``, that expands out to the path when the command is run"
" from within VS."
msgstr ""
"设置 nvcc 使用的主机编译器。如果 ``-ccbin`` 或 ``--compiler-bindir`` 已经存在于 "
"``CUDA_NVCC_FLAGS`` 或 ``CUDA_NVCC_FLAGS_<CONFIG>`` 变量中，则忽略。对于 Visual "
"Studio 目标，主机编译器由一个或多个 visual studio 宏构建，例如 ``$(VCInstallDir)``，当从 VS "
"中运行命令时，它会扩展到路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:120
msgid ""
"If the :envvar:`CUDAHOSTCXX` environment variable is set it will be used "
"as the default."
msgstr "如果设置了 CUDAHOSTCXX 环境变量，它将被用作默认值。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:130
msgid "``CUDA_NVCC_FLAGS``, ``CUDA_NVCC_FLAGS_<CONFIG>``"
msgstr "``CUDA_NVCC_FLAGS``，``CUDA_NVCC_FLAGS_<CONFIG>``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:125
msgid ""
"Additional NVCC command line arguments.  NOTE: multiple arguments must be "
"semi-colon delimited (e.g. ``--compiler-options;-Wall``)"
msgstr "其他 NVCC 命令行参数。注意：多个参数必须以分号分隔（例如``--compiler-options;-Wall``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:128
msgid ""
"Contents of these variables may use :manual:`generator expressions <cmake-"
"generator-expressions(7)>`."
msgstr ""
"这些变量的内容可以使用 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:141
msgid "``CUDA_PROPAGATE_HOST_FLAGS`` (Default: ``ON``)"
msgstr "``CUDA_PROPAGATE_HOST_FLAGS``（默认值：``ON``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:133
msgid ""
"Set to ``ON`` to propagate :variable:`CMAKE_{C,CXX}_FLAGS "
"<CMAKE_<LANG>_FLAGS>` and their configuration dependent counterparts (e.g."
" ``CMAKE_C_FLAGS_DEBUG``) automatically to the host compiler through "
"nvcc's ``-Xcompiler`` flag.  This helps make the generated host code match"
" the rest of the system better.  Sometimes certain flags give nvcc "
"problems, and this will help you turn the flag propagation off.  This does"
" not affect the flags supplied directly to nvcc via ``CUDA_NVCC_FLAGS`` or"
" through the ``OPTION`` flags specified through ``cuda_add_library()``, "
"``cuda_add_executable()``, or ``cuda_wrap_srcs()``.  Flags used for shared"
" library compilation are not affected by this flag."
msgstr ""
"设置为 ``ON`` 以通过 nvcc 的 `` 将 :variable:`CMAKE_{C,CXX}_FLAGS "
"<CMAKE_<LANG>_FLAGS>` 及其依赖于配置的对应项（例如 ``CMAKE_C_FLAGS_DEBUG``）自动传播到主机编译器-"
"Xcompiler`` 标志。这有助于使生成的主机代码更好地匹配系统的其余部分。有时某些标志会给 nvcc "
"带来问题，这将帮助您关闭标志传播。这不会影响通过 ``CUDA_NVCC_FLAGS`` 或通过 "
"``cuda_add_library()``、``cuda_add_executable()`` 或 ``cuda_wrap_srcs()` 指定的"
" ``OPTION`` 标志直接提供给 nvcc 的标志`。用于共享库编译的标志不受此标志的影响。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:148
msgid "``CUDA_SEPARABLE_COMPILATION`` (Default: ``OFF``)"
msgstr "``CUDA_SEPARABLE_COMPILATION``（默认值：``OFF``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:144
msgid ""
"If set this will enable separable compilation for all CUDA runtime object "
"files.  If used outside of ``cuda_add_executable()`` and "
"``cuda_add_library()`` (e.g. calling ``cuda_wrap_srcs()`` directly), "
"``cuda_compute_separable_compilation_object_file_name()`` and "
"``cuda_link_separable_compilation_objects()`` should be called."
msgstr ""
"如果设置这将为所有 CUDA 运行时对象文件启用可分离的编译。如果在 ``cuda_add_executable()`` 和 "
"``cuda_add_library()`` 之外使用（例如直接调用 "
"``cuda_wrap_srcs()``），``cuda_compute_separable_compilation_object_file_name()``"
" 和 ``cuda_link_separable_compilation_objects()`` 应该被调用."

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:157
msgid "``CUDA_SOURCE_PROPERTY_FORMAT``"
msgstr "``CUDA_SOURCE_PROPERTY_FORMAT``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:153
msgid ""
"If this source file property is set, it can override the format specified "
"to ``cuda_wrap_srcs()`` (``OBJ``, ``PTX``, ``CUBIN``, or ``FATBIN``).  If "
"an input source file is not a ``.cu`` file, setting this file will cause "
"it to be treated as a ``.cu`` file. See documentation for "
"set_source_files_properties on how to set this property."
msgstr ""
"如果设置了此源文件属性，它可以覆盖指定给 ``cuda_wrap_srcs()`` 的格式（``OBJ``、``PTX``、``CUBIN`` 或 "
"``FATBIN``）。如果输入源文件不是 .cu 文件，设置此文件将导致它被视为 .cu 文件。有关如何设置此属性的信息，请参阅 "
"set_source_files_properties 的文档。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:164
msgid "``CUDA_USE_STATIC_CUDA_RUNTIME`` (Default: ``ON``)"
msgstr "``CUDA_USE_STATIC_CUDA_RUNTIME``（默认值：``ON``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:162
msgid ""
"When enabled the static version of the CUDA runtime library will be used "
"in ``CUDA_LIBRARIES``.  If the version of CUDA configured doesn't support "
"this option, then it will be silently disabled."
msgstr ""
"启用后，CUDA 运行时库的静态版本将在 CUDA_LIBRARIES 中使用。如果配置的 CUDA 版本不支持这个选项，那么它将被静默禁用。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:170
msgid "``CUDA_VERBOSE_BUILD`` (Default: ``OFF``)"
msgstr "``CUDA_VERBOSE_BUILD``（默认值：``OFF``）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:167
msgid ""
"Set to ``ON`` to see all the commands used when building the CUDA file.  "
"When using a Makefile generator the value defaults to ``VERBOSE`` (run "
"``make VERBOSE=1`` to see output), although setting ``CUDA_VERBOSE_BUILD``"
" to ``ON`` will always print the output."
msgstr ""
"设置为 ``ON`` 以查看构建 CUDA 文件时使用的所有命令。当使用 Makefile 生成器时，该值默认为 ``VERBOSE``（运行 "
"``make VERBOSE=1`` 以查看输出），尽管将 ``CUDA_VERBOSE_BUILD`` 设置为 ``ON`` 将始终打印输出。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:175
msgid ""
"The script creates the following functions and macros (in alphabetical "
"order):"
msgstr "该脚本创建以下函数和宏（按字母顺序排列）："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:181
msgid ""
"Adds the cufft library to the target (can be any target).  Handles whether"
" you are in emulation mode or not."
msgstr "将 cufft 库添加到目标（可以是任何目标）。处理您是否处于仿真模式。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:188
msgid ""
"Adds the cublas library to the target (can be any target).  Handles "
"whether you are in emulation mode or not."
msgstr "将 cublas 库添加到目标（可以是任何目标）。处理您是否处于仿真模式。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:196
msgid ""
"Creates an executable ``<cuda_target>`` which is made up of the files "
"specified.  All of the non CUDA C files are compiled using the standard "
"build rules specified by CMake and the CUDA files are compiled to object "
"files using nvcc and the host compiler.  In addition ``CUDA_INCLUDE_DIRS``"
" is added automatically to :command:`include_directories`.  Some standard "
"CMake target calls can be used on the target after calling this macro "
"(e.g. :command:`set_target_properties` and "
":command:`target_link_libraries`), but setting properties that adjust "
"compilation flags will not affect code compiled by nvcc.  Such flags "
"should be modified before calling ``cuda_add_executable()``, "
"``cuda_add_library()`` or ``cuda_wrap_srcs()``."
msgstr ""
"创建一个由指定文件组成的可执行文件``<cuda_target>``。所有非 CUDA C 文件都使用 CMake "
"指定的标准构建规则进行编译，CUDA 文件使用 nvcc 和主机编译器编译为目标文件。此外，``CUDA_INCLUDE_DIRS`` 会自动添加到"
" :command:`include_directories`。调用此宏后，可以在目标上使用一些标准的 CMake "
"目标调用（例如:command:`set_target_properties` "
"和:command:`target_link_libraries`），但设置调整编译标志的属性不会影响 nvcc 编译的代码。此类标志应在调用 "
"``cuda_add_executable()``、``cuda_add_library()`` 或 ``cuda_wrap_srcs()`` "
"之前修改。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:212
msgid "Same as ``cuda_add_executable()`` except that a library is created."
msgstr "与 ``cuda_add_executable()`` 相同，只是创建了一个库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:218
msgid ""
"Creates a convenience target that deletes all the dependency files "
"generated.  You should make clean after running this target to ensure the "
"dependency files get regenerated."
msgstr "创建一个删除所有生成的依赖文件的便利目标。您应该在运行此目标后进行清理以确保重新生成依赖文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:227
msgid ""
"Returns a list of generated files from the input source files to be used "
"with :command:`add_library` or :command:`add_executable`."
msgstr ""
"返回从输入源文件生成的文件列表，这些文件将与 :command:`add_library` 或 :command:`add_executable` "
"一起使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:234
msgid ""
"Returns a list of ``PTX`` files generated from the input source files."
msgstr "返回从输入源文件生成的“PTX”文件列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:242
msgid ""
"Returns a list of ``FATBIN`` files generated from the input source files."
msgstr "返回从输入源文件生成的 ``FATBIN`` 文件列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:250
msgid ""
"Returns a list of ``CUBIN`` files generated from the input source files."
msgstr "返回从输入源文件生成的 ``CUBIN`` 文件列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:258
msgid ""
"Compute the name of the intermediate link file used for separable "
"compilation.  This file name is typically passed into "
"``CUDA_LINK_SEPARABLE_COMPILATION_OBJECTS``.  output_file_var is produced "
"based on cuda_target the list of objects files that need separable "
"compilation as specified by ``<object_files>``.  If the ``<object_files>``"
" list is empty, then ``<output_file_var>`` will be empty.  This function "
"is called automatically for ``cuda_add_library()`` and "
"``cuda_add_executable()``.  Note that this is a function and not a macro."
msgstr ""
"计算用于可分离编译的中间链接文件的名称。此文件名通常传递到 ``CUDA_LINK_SEPARABLE_COMPILATION_OBJECTS``。"
" output_file_var 是基于 cuda_target 生成的，需要按 <object_files> 指定的可分离编译的目标文件列表。如果"
" ``<object_files>`` 列表为空，则 ``<output_file_var>`` 将为空。此函数会自动为 "
"``cuda_add_library()`` 和 ``cuda_add_executable()`` 调用。请注意，这是一个函数而不是宏。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:271
msgid ""
"Sets the directories that should be passed to nvcc (e.g. ``nvcc -Ipath0 "
"-Ipath1 ...``). These paths usually contain other ``.cu`` files."
msgstr ""
"设置应该传递给 nvcc 的目录（例如``nvcc -Ipath0 -Ipath1 ...``）。这些路径通常包含其他 ``.cu`` 文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:280
msgid ""
"Generates the link object required by separable compilation from the given"
" object files.  This is called automatically for ``cuda_add_executable()``"
" and ``cuda_add_library()``, but can be called manually when using "
"``cuda_wrap_srcs()`` directly.  When called from ``cuda_add_library()`` or"
" ``cuda_add_executable()`` the ``<nvcc_flags>`` passed in are the same as "
"the flags passed in via the ``OPTIONS`` argument.  The only nvcc flag "
"added automatically is the bitness flag as specified by "
"``CUDA_64_BIT_DEVICE_CODE``.  Note that this is a function instead of a "
"macro."
msgstr ""
"从给定的目标文件生成可分离编译所需的链接对象。这是为 ``cuda_add_executable()`` 和 "
"``cuda_add_library()`` 自动调用的，但可以在直接使用 ``cuda_wrap_srcs()`` "
"时手动调用。当从“cuda_add_library()”或“cuda_add_executable()”调用时，传入的“<nvcc_flags>”与通过“OPTIONS”参数传入的标志相同。唯一自动添加的"
" nvcc 标志是由 ``CUDA_64_BIT_DEVICE_CODE`` 指定的位数标志。请注意，这是一个函数而不是宏。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:293
msgid ""
"Selects GPU arch flags for nvcc based on ``target_CUDA_architecture``."
msgstr "基于“target_CUDA_architecture”为 nvcc 选择 GPU 架构标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:295
msgid "Values for ``target_CUDA_architecture``:"
msgstr "``target_CUDA_architecture`` 的值："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:297
msgid "``Auto``: detects local machine GPU compute arch at runtime."
msgstr "``Auto``：在运行时检测本地机器 GPU 计算架构。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:298
msgid ""
"``Common`` and ``All``: cover common and entire subsets of architectures."
msgstr "``Common`` 和 ``All``：涵盖架构的通用和整个子集。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:299
msgid ""
"``<name>``: one of ``Fermi``, ``Kepler``, ``Maxwell``, ``Kepler+Tegra``, "
"``Kepler+Tesla``, ``Maxwell+Tegra``, ``Pascal``."
msgstr ""
"``<name>``: ``Fermi``, ``Kepler``, ``Maxwell``, ``Kepler+Tegra``, "
"``Kepler+Tesla``, ``Maxwell+Tegra` 之一`，``帕斯卡``。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:300
msgid ""
"``<ver>``, ``<ver>(<ver>)``, ``<ver>+PTX``, where ``<ver>`` is one of "
"``2.0``, ``2.1``, ``3.0``, ``3.2``, ``3.5``, ``3.7``, ``5.0``, ``5.2``, "
"``5.3``, ``6.0``, ``6.2``."
msgstr ""
"``<ver>``, ``<ver>(<ver>)``, ``<ver>+PTX``, 其中 ``<ver>`` 是 ``2.0``, `` "
"2.1``, ``3.0``, ``3.2``, ``3.5``, ``3.7``, ``5.0``, ``5.2``, ``5.3``, "
"``6.0` `，``6.2``。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:303
msgid ""
"Returns list of flags to be added to ``CUDA_NVCC_FLAGS`` in "
"``<out_variable>``. Additionally, sets ``<out_variable>_readable`` to the "
"resulting numeric list."
msgstr ""
"返回要添加到 ``<out_variable>`` 中的 ``CUDA_NVCC_FLAGS`` 的标志列表。此外，将 "
"``<out_variable>_readable`` 设置为结果数字列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:311
msgid ""
"More info on CUDA architectures: https://en.wikipedia.org/wiki/CUDA. Note "
"that this is a function instead of a macro."
msgstr "有关 CUDA 架构的更多信息:https://en.wikipedia.org/wiki/CUDA。请注意，这是一个函数而不是宏。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:319
msgid ""
"This is where all the magic happens.  ``cuda_add_executable()``, "
"``cuda_add_library()``, ``cuda_compile()``, and ``cuda_compile_ptx()`` all"
" call this function under the hood."
msgstr ""
"这就是所有魔法发生的地方。 "
"``cuda_add_executable()``、``cuda_add_library()``、``cuda_compile()`` 和 "
"``cuda_compile_ptx()`` 都在后台调用这个函数。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:323
msgid ""
"Given the list of files ``<file>...`` this macro generates custom commands"
" that generate either PTX or linkable objects (use ``PTX`` or ``OBJ`` for "
"the ``<format>`` argument to switch).  Files that don't end with ``.cu`` "
"or have the ``HEADER_FILE_ONLY`` property are ignored."
msgstr ""
"给定文件列表 ``<file>...`` 该宏生成自定义命令，生成 PTX 或可链接对象（使用 ``PTX`` 或 ``OBJ`` 作为 "
"``<format>`` 参数换成）。不以 .cu 结尾或具有 HEADER_FILE_ONLY 属性的文件将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:328
msgid ""
"The arguments passed in after ``OPTIONS`` are extra command line options "
"to give to nvcc.  You can also specify per configuration options by "
"specifying the name of the configuration followed by the options.  General"
" options must precede configuration specific options.  Not all "
"configurations need to be specified, only the ones provided will be used. "
"For example:"
msgstr ""
"在 ``OPTIONS`` 之后传入的参数是提供给 nvcc "
"的额外命令行选项。您还可以通过指定配置名称后跟选项来指定每个配置选项。通用选项必须先于配置特定选项。不需要指定所有配置，只会使用提供的配置。例如："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:344
msgid ""
"For certain configurations (namely VS generating object files with "
"``CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE`` set to ``ON``), no generated "
"file will be produced for the given cuda file.  This is because when you "
"add the cuda file to Visual Studio it knows that this file produces an "
"object file and will link in the resulting object file automatically."
msgstr ""
"对于某些配置（即 VS 生成目标文件并将 ``CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE`` 设置为 "
"``ON``），不会为给定的 cuda 文件生成生成的文件。这是因为当您将 cuda 文件添加到 Visual Studio "
"时，它知道该文件会生成一个目标文件并将自动链接到生成的目标文件中。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:350
msgid ""
"This script will also generate a separate cmake script that is used at "
"build time to invoke nvcc.  This is for several reasons:"
msgstr "此脚本还将生成一个单独的 cmake 脚本，用于在构建时调用 nvcc。这是出于以下几个原因："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:353
msgid ""
"nvcc can return negative numbers as return values which confuses Visual "
"Studio into thinking that the command succeeded.  The script now checks "
"the error codes and produces errors when there was a problem."
msgstr "nvcc 可以返回负数作为返回值，这会使 Visual Studio 误以为命令已成功。该脚本现在检查错误代码并在出现问题时产生错误。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:357
msgid ""
"nvcc has been known to not delete incomplete results when it encounters "
"problems.  This confuses build systems into thinking the target was "
"generated when in fact an unusable file exists.  The script now deletes "
"the output files if there was an error."
msgstr ""
"众所周知，nvcc "
"在遇到问题时不会删除不完整的结果。这会使构建系统误认为目标是在实际上存在不可用文件时生成的。如果出现错误，脚本现在会删除输出文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:362
msgid ""
"By putting all the options that affect the build into a file and then make"
" the build rule dependent on the file, the output files will be "
"regenerated when the options change."
msgstr "通过将影响构建的所有选项放入一个文件，然后使构建规则依赖于该文件，当选项更改时将重新生成输出文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:366
msgid ""
"This script also looks at optional arguments ``STATIC``, ``SHARED``, or "
"``MODULE`` to determine when to target the object compilation for a shared"
" library. :variable:`BUILD_SHARED_LIBS` is ignored in "
"``cuda_wrap_srcs()``, but it is respected in ``cuda_add_library()``.  On "
"some systems special flags are added for building objects intended for "
"shared libraries.  A preprocessor macro, ``<target_name>_EXPORTS`` is "
"defined when a shared library compilation is detected."
msgstr ""
"此脚本还会查看可选参数“STATIC”、“SHARED”或“MODULE”以确定何时针对共享库进行对象编译。 "
":variable:`BUILD_SHARED_LIBS` 在 ``cuda_wrap_srcs()`` 中被忽略，但在 "
"``cuda_add_library()`` "
"中受到尊重。在某些系统上，添加了特殊标志以用于构建用于共享库的对象。当检测到共享库编译时，会定义预处理器宏“<target_name>_EXPORTS”。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:374
msgid ""
"Flags passed into add_definitions with ``-D`` or ``/D`` are passed along "
"to nvcc."
msgstr "使用“-D”或“/D”传递到 add_definitions 的标志被传递到 nvcc。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:379
msgid "The script defines the following variables:"
msgstr "该脚本定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:382
msgid "``CUDA_VERSION_MAJOR``"
msgstr "``CUDA_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:382
msgid "The major version of cuda as reported by nvcc."
msgstr "nvcc 报告的 cuda 的主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:385
msgid "``CUDA_VERSION_MINOR``"
msgstr "``CUDA_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:385
msgid "The minor version."
msgstr "小版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:388
msgid "``CUDA_VERSION``, ``CUDA_VERSION_STRING``"
msgstr "``CUDA_VERSION``，``CUDA_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:388
msgid "Full version in the ``X.Y`` format."
msgstr "``X.Y`` 格式的完整版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:392
msgid "``CUDA_HAS_FP16``"
msgstr "``CUDA_HAS_FP16``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:391
msgid "Whether a short float (``float16``, ``fp16``) is supported."
msgstr "是否支持短浮点数（``float16``、``fp16``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:395
msgid "``CUDA_TOOLKIT_ROOT_DIR``"
msgstr "``CUDA_TOOLKIT_ROOT_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:395
msgid "Path to the CUDA Toolkit (defined if not set)."
msgstr "CUDA 工具包的路径（如果未设置则定义）。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:403
msgid "``CUDA_SDK_ROOT_DIR``"
msgstr "``CUDA_SDK_ROOT_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:398
msgid ""
"Path to the CUDA SDK.  Use this to find files in the SDK.  This script "
"will not directly support finding specific libraries or headers, as that "
"isn't supported by NVIDIA.  If you want to change libraries when the path "
"changes see the ``FindCUDA.cmake`` script for an example of how to clear "
"these variables.  There are also examples of how to use the "
"``CUDA_SDK_ROOT_DIR`` to locate headers or libraries, if you so choose (at"
" your own risk)."
msgstr ""
"CUDA SDK 的路径。使用它来查找 SDK 中的文件。此脚本将不直接支持查找特定库或标头，因为 NVIDIA "
"不支持。如果您想在路径更改时更改库，请参阅“FindCUDA.cmake”脚本以获取有关如何清除这些变量的示例。还有一些示例说明如何使用 "
"``CUDA_SDK_ROOT_DIR`` 来定位标头或库，如果您愿意（风险自负）。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:407
msgid "``CUDA_INCLUDE_DIRS``"
msgstr "``CUDA_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:406
msgid ""
"Include directory for cuda headers.  Added automatically for "
"``cuda_add_executable()`` and ``cuda_add_library()``."
msgstr ""
"包含 cuda 标头的目录。为 ``cuda_add_executable()`` 和 ``cuda_add_library()`` 自动添加。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:410
msgid "``CUDA_LIBRARIES``"
msgstr "``CUDA_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:410
msgid "Cuda RT library."
msgstr "Cuda RT 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:414
msgid "``CUDA_CUFFT_LIBRARIES``"
msgstr "``CUDA_CUFFT_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:413
msgid ""
"Device or emulation library for the Cuda FFT implementation (alternative "
"to ``cuda_add_cufft_to_target()`` macro)"
msgstr "用于 Cuda FFT 实现的设备或仿真库（替代 ``cuda_add_cufft_to_target()`` 宏）"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:418
msgid "``CUDA_CUBLAS_LIBRARIES``"
msgstr "``CUDA_CUBLAS_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:417
msgid ""
"Device or emulation library for the Cuda BLAS implementation (alternative "
"to ``cuda_add_cublas_to_target()`` macro)."
msgstr "用于 Cuda BLAS 实现的设备或仿真库（替代 ``cuda_add_cublas_to_target()`` 宏）。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:422
msgid "``CUDA_cudart_static_LIBRARY``"
msgstr "``CUDA_cudart_static_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:421
msgid ""
"Statically linkable cuda runtime library. Only available for CUDA version "
"5.5+."
msgstr "静态可链接的 cuda 运行时库。仅适用于 CUDA 版本 5.5+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:426
msgid "``CUDA_cudadevrt_LIBRARY``"
msgstr "``CUDA_cudadevrt_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:425
msgid "Device runtime library.  Required for separable compilation."
msgstr "设备运行时库。可分离编译需要。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:430
msgid "``CUDA_cupti_LIBRARY``"
msgstr "``CUDA_cupti_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:429
msgid ""
"CUDA Profiling Tools Interface library. Only available for CUDA version "
"4.0+."
msgstr "CUDA 分析工具接口库。仅适用于 CUDA 版本 4.0+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:434
msgid "``CUDA_curand_LIBRARY``"
msgstr "``CUDA_curand_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:433
msgid ""
"CUDA Random Number Generation library. Only available for CUDA version "
"3.2+."
msgstr "CUDA 随机数生成库。仅适用于 CUDA 版本 3.2+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:439
msgid "``CUDA_cusolver_LIBRARY``"
msgstr "``CUDA_cusolver_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:437
msgid "CUDA Direct Solver library. Only available for CUDA version 7.0+."
msgstr "CUDA 直接求解器库。仅适用于 CUDA 版本 7.0+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:443
msgid "``CUDA_cusparse_LIBRARY``"
msgstr "``CUDA_cusparse_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:442
msgid "CUDA Sparse Matrix library. Only available for CUDA version 3.2+."
msgstr "CUDA 稀疏矩阵库。仅适用于 CUDA 版本 3.2+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:447
msgid "``CUDA_npp_LIBRARY``"
msgstr "``CUDA_npp_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:446
msgid ""
"NVIDIA Performance Primitives lib. Only available for CUDA version 4.0+."
msgstr "NVIDIA 性能基元库。仅适用于 CUDA 版本 4.0+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:451
msgid "``CUDA_nppc_LIBRARY``"
msgstr "``CUDA_nppc_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:450
msgid ""
"NVIDIA Performance Primitives lib (core). Only available for CUDA version "
"5.5+."
msgstr "NVIDIA Performance Primitives 库（核心）。仅适用于 CUDA 版本 5.5+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:455
msgid "``CUDA_nppi_LIBRARY``"
msgstr "``CUDA_nppi_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:454
msgid ""
"NVIDIA Performance Primitives lib (image processing). Only available for "
"CUDA version 5.5 - 8.0."
msgstr "NVIDIA Performance Primitives 库（图像处理）。仅适用于 CUDA 版本 5.5 - 8.0。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:459
msgid "``CUDA_nppial_LIBRARY``"
msgstr "``CUDA_nppial_LI​​BRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:458
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:462
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:471
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:475
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:479
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:483
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:487
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:491
#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:495
msgid ""
"NVIDIA Performance Primitives lib (image processing). Only available for "
"CUDA version 9.0."
msgstr "NVIDIA Performance Primitives 库（图像处理）。仅适用于 CUDA 版本 9.0。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:463
msgid "``CUDA_nppicc_LIBRARY``"
msgstr "``CUDA_nppicc_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:468
msgid "``CUDA_nppicom_LIBRARY``"
msgstr "``CUDA_nppicom_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:466
msgid ""
"NVIDIA Performance Primitives lib (image processing). Only available for "
"CUDA version 9.0 - 10.2. Replaced by nvjpeg."
msgstr ""
"NVIDIA Performance Primitives 库（图像处理）。仅适用于 CUDA 版本 9.0 - 10.2。替换为 nvjpeg。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:472
msgid "``CUDA_nppidei_LIBRARY``"
msgstr "``CUDA_nppidei_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:476
msgid "``CUDA_nppif_LIBRARY``"
msgstr "``CUDA_nppif_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:480
msgid "``CUDA_nppig_LIBRARY``"
msgstr "``CUDA_nppig_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:484
msgid "``CUDA_nppim_LIBRARY``"
msgstr "``CUDA_nppim_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:488
msgid "``CUDA_nppist_LIBRARY``"
msgstr "``CUDA_nppist_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:492
msgid "``CUDA_nppisu_LIBRARY``"
msgstr "``CUDA_nppisu_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:496
msgid "``CUDA_nppitc_LIBRARY``"
msgstr "``CUDA_nppitc_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:500
msgid "``CUDA_npps_LIBRARY``"
msgstr "``CUDA_npps_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:499
msgid ""
"NVIDIA Performance Primitives lib (signal processing). Only available for "
"CUDA version 5.5+."
msgstr "NVIDIA Performance Primitives 库（信号处理）。仅适用于 CUDA 版本 5.5+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:505
msgid "``CUDA_nvcuvenc_LIBRARY``"
msgstr "``CUDA_nvcuvenc_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:503
msgid ""
"CUDA Video Encoder library. Only available for CUDA version 3.2+. Windows "
"only."
msgstr "CUDA 视频编码器库。仅适用于 CUDA 版本 3.2+。仅限窗户。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:510
msgid "``CUDA_nvcuvid_LIBRARY``"
msgstr "``CUDA_nvcuvid_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:508
msgid ""
"CUDA Video Decoder library. Only available for CUDA version 3.2+. Windows "
"only."
msgstr "CUDA 视频解码器库。仅适用于 CUDA 版本 3.2+。仅限窗户。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:515
msgid "``CUDA_nvToolsExt_LIBRARY``"
msgstr "``CUDA_nvToolsExt_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:513
msgid "NVIDA CUDA Tools Extension library. Available for CUDA version 5+."
msgstr "NVIDIA CUDA 工具扩展库。适用于 CUDA 版本 5+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:2176
msgid "``CUDA_OpenCL_LIBRARY``"
msgstr "``CUDA_OpenCL_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDA.cmake:518
msgid "NVIDA CUDA OpenCL library. Available for CUDA version 5+."
msgstr "NVIDIA CUDA OpenCL 库。适用于 CUDA 版本 5+。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:6
msgid "FindCUDAToolkit"
msgstr "找到CUDA工具包"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:10
msgid ""
"This script locates the NVIDIA CUDA toolkit and the associated libraries, "
"but does not require the ``CUDA`` language be enabled for a given project."
" This module does not search for the NVIDIA CUDA Samples."
msgstr ""
"此脚本定位 NVIDIA CUDA 工具包和相关库，但不需要为给定项目启用 ``CUDA`` 语言。此模块不搜索 NVIDIA CUDA 示例。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:18
msgid "Search Behavior"
msgstr "搜索行为"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:20
msgid "The CUDA Toolkit search behavior uses the following order:"
msgstr "CUDA 工具包搜索行为使用以下顺序："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:22
msgid ""
"If the ``CUDA`` language has been enabled we will use the directory "
"containing the compiler as the first search location for ``nvcc``."
msgstr "如果启用了 ``CUDA`` 语言，我们将使用包含编译器的目录作为 ``nvcc`` 的第一个搜索位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:25
msgid ""
"If the ``CUDAToolkit_ROOT`` cmake configuration variable (e.g., "
"``-DCUDAToolkit_ROOT=/some/path``) *or* environment variable is defined, "
"it will be searched.  If both an environment variable **and** a "
"configuration variable are specified, the *configuration* variable takes "
"precedence."
msgstr ""
"如果定义了 ``CUDAToolkit_ROOT`` cmake "
"配置变量（例如，``-DCUDAToolkit_ROOT=/some/path``）*或*环境变量，它将被搜索。如果同时指定了环境变量 ** 和 "
"** 配置变量，则 *configuration* 变量优先。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:31
msgid ""
"The directory specified here must be such that the executable ``nvcc`` or "
"the appropriate ``version.txt`` or ``version.json`` file can be found "
"underneath the specified directory."
msgstr ""
"此处指定的目录必须能够在指定目录下找到可执行的 ``nvcc`` 或适当的 ``version.txt`` 或 ``version.json`` "
"文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:35
msgid ""
"If the CUDA_PATH environment variable is defined, it will be searched for "
"``nvcc``."
msgstr "如果定义了 CUDA_PATH 环境变量，则会搜索“nvcc”。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:38
msgid ""
"The user's path is searched for ``nvcc`` using :command:`find_program`.  "
"If this is found, no subsequent search attempts are performed.  Users are "
"responsible for ensuring that the first ``nvcc`` to show up in the path is"
" the desired path in the event that multiple CUDA Toolkits are installed."
msgstr ""
"使用 :command:`find_program` 在用户路径中搜索 ``nvcc``。如果找到，则不会执行后续搜索尝试。如果安装了多个 CUDA"
" 工具包，用户有责任确保出现在路径中的第一个 ``nvcc`` 是所需的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:43
msgid ""
"On Unix systems, if the symbolic link ``/usr/local/cuda`` exists, this is "
"used.  No subsequent search attempts are performed.  No default symbolic "
"link location exists for the Windows platform."
msgstr ""
"在 Unix 系统上，如果符号链接“/usr/local/cuda”存在，则使用它。不会执行后续搜索尝试。 Windows "
"平台不存在默认符号链接位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:47
msgid ""
"The platform specific default install locations are searched.  If exactly "
"one candidate is found, this is used.  The default CUDA Toolkit install "
"locations searched are:"
msgstr "搜索特定于平台的默认安装位置。如果恰好找到一个候选者，则使用它。搜索的默认 CUDA 工具包安装位置是："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:52
msgid "Platform"
msgstr "平台"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:52
msgid "Search Pattern"
msgstr "搜索模式"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:54
msgid "macOS"
msgstr "苹果系统"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:54
msgid "``/Developer/NVIDIA/CUDA-X.Y``"
msgstr "``/Developer/NVIDIA/CUDA-X.Y``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:56
msgid "Other Unix"
msgstr "其他Unix"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:56
msgid "``/usr/local/cuda-X.Y``"
msgstr "``/usr/local/cuda-X.Y``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:58
msgid "Windows"
msgstr "视窗"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:58
msgid "``C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\vX.Y``"
msgstr "``C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\vX.Y``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:61
msgid ""
"Where ``X.Y`` would be a specific version of the CUDA Toolkit, such as "
"``/usr/local/cuda-9.0`` or ``C:\\Program Files\\NVIDIA GPU Computing "
"Toolkit\\CUDA\\v9.0``"
msgstr ""
"其中 ``X.Y`` 是 CUDA 工具包的特定版本，例如 ``/usr/local/cuda-9.0`` 或 ``C:\\Program "
"Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.0` `"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:67
msgid ""
"When multiple CUDA Toolkits are installed in the default location of a "
"system (e.g., both ``/usr/local/cuda-9.0`` and ``/usr/local/cuda-10.0`` "
"exist but the ``/usr/local/cuda`` symbolic link does **not** exist), this "
"package is marked as **not** found."
msgstr ""
"当多个 CUDA 工具包安装在系统的默认位置时（例如，``/usr/local/cuda-9.0`` "
"和``/usr/local/cuda-10.0`` 都存在，但``/usr/ local/cuda`` "
"符号链接**不**存在），此包被标记为**未**找到。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:72
msgid ""
"There are too many factors involved in making an automatic decision in the"
" presence of multiple CUDA Toolkits being installed.  In this situation, "
"users are encouraged to either (1) set ``CUDAToolkit_ROOT`` or (2) ensure "
"that the correct ``nvcc`` executable shows up in ``$PATH`` for "
":command:`find_program` to find."
msgstr ""
"在安装多个 CUDA 工具包的情况下，做出自动决策涉及的因素太多。在这种情况下，鼓励用户 (1) 设置 ``CUDAToolkit_ROOT`` 或"
" (2) 确保正确的 ``nvcc`` 可执行文件出现在 ``$PATH`` 中，以便 :command:`find_program` 找到."

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:79
msgid "Arguments"
msgstr "参数"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:84
msgid "``[<version>]``"
msgstr "``[<版本>]``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:82
msgid ""
"The ``[<version>]`` argument requests a version with which the package "
"found should be compatible. See :ref:`find_package version format "
"<FIND_PACKAGE_VERSION_FORMAT>` for more details."
msgstr ""
"``[<version>]`` 参数请求找到的包应该兼容的版本。有关详细信息，请参阅 :ref:`find_package 版本格式 "
"<FIND_PACKAGE_VERSION_FORMAT>`。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:87
msgid "Options"
msgstr "选项"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:90
msgid ""
"If specified, configuration will error if a suitable CUDA Toolkit is not "
"found."
msgstr "如果指定，如果找不到合适的 CUDA 工具包，配置将出错。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:94
msgid ""
"If specified, the search for a suitable CUDA Toolkit will not produce any "
"messages."
msgstr "如果指定，搜索合适的 CUDA 工具包将不会产生任何消息。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:99
msgid "``EXACT``"
msgstr "``精确``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:98
msgid ""
"If specified, the CUDA Toolkit is considered found only if the exact "
"``VERSION`` specified is recovered."
msgstr "如果指定，则只有在恢复指定的确切“VERSION”时，才认为找到了 CUDA 工具包。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:104
msgid ""
"An :ref:`imported target <Imported targets>` named ``CUDA::toolkit`` is "
"provided."
msgstr ""
"提供了名为 ``CUDA::toolkit`` 的 :ref:`imported target <Imported targets>`。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:106
msgid ""
"This module defines :prop_tgt:`IMPORTED` targets for each of the following"
" libraries that are part of the CUDAToolkit:"
msgstr "该模块为以下属于 CUDAToolkit 的每个库定义 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:109
msgid ":ref:`CUDA Runtime Library<cuda_toolkit_rt_lib>`"
msgstr ":ref:`CUDA 运行时库 <cuda_toolkit_rt_lib>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:110
msgid ":ref:`CUDA Driver Library<cuda_toolkit_driver_lib>`"
msgstr ":ref:`CUDA 驱动程序库 <cuda_toolkit_driver_lib>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:111
msgid ":ref:`cuBLAS<cuda_toolkit_cuBLAS>`"
msgstr ":ref:`cuBLAS<cuda_toolkit_cuBLAS>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:112
msgid ":ref:`cuFile<cuda_toolkit_cuFile>`"
msgstr ":ref:`cuFile<cuda_toolkit_cuFile>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:113
msgid ":ref:`cuFFT<cuda_toolkit_cuFFT>`"
msgstr ":ref:`cuFFT<cuda_toolkit_cuFFT>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:114
msgid ":ref:`cuRAND<cuda_toolkit_cuRAND>`"
msgstr ":ref:`cuRAND<cuda_toolkit_cuRAND>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:115
msgid ":ref:`cuSOLVER<cuda_toolkit_cuSOLVER>`"
msgstr ":ref:`cuSOLVER<cuda_toolkit_cuSOLVER>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:116
msgid ":ref:`cuSPARSE<cuda_toolkit_cuSPARSE>`"
msgstr ":ref:`cuSPARSE<cuda_toolkit_cuSPARSE>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:117
msgid ":ref:`cuPTI<cuda_toolkit_cupti>`"
msgstr ":ref:`cuPTI<cuda_toolkit_cupti>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:118
msgid ":ref:`NPP<cuda_toolkit_NPP>`"
msgstr ":ref:`NPP<cuda_toolkit_NPP>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:119
msgid ":ref:`nvBLAS<cuda_toolkit_nvBLAS>`"
msgstr ":ref:`nvBLAS<cuda_toolkit_nvBLAS>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:120
msgid ":ref:`nvGRAPH<cuda_toolkit_nvGRAPH>`"
msgstr ":ref:`nvGRAPH<cuda_toolkit_nvGRAPH>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:121
msgid ":ref:`nvJPEG<cuda_toolkit_nvJPEG>`"
msgstr ":ref:`nvJPEG<cuda_toolkit_nvJPEG>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:122
msgid ":ref:`nvidia-ML<cuda_toolkit_nvML>`"
msgstr ":ref:`nvidia-ML<cuda_toolkit_nvML>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:123
msgid ":ref:`nvPTX Compiler<cuda_toolkit_nvptx>`"
msgstr ":ref:`nvPTX 编译器<cuda_toolkit_nvptx>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:124
msgid ":ref:`nvRTC<cuda_toolkit_nvRTC>`"
msgstr ":ref:`nvRTC<cuda_toolkit_nvRTC>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:125
msgid ":ref:`nvToolsExt<cuda_toolkit_nvToolsExt>`"
msgstr ":ref:`nvToolsExt<cuda_toolkit_nvToolsExt>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:126
msgid ":ref:`nvtx3<cuda_toolkit_nvtx3>`"
msgstr ":ref:`nvtx3<cuda_toolkit_nvtx3>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:127
msgid ":ref:`OpenCL<cuda_toolkit_opencl>`"
msgstr ":ref:`OpenCL<cuda_toolkit_opencl>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:128
msgid ":ref:`cuLIBOS<cuda_toolkit_cuLIBOS>`"
msgstr ":ref:`cuLIBOS<cuda_toolkit_cuLIBOS>`"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:133
msgid "CUDA Runtime Library"
msgstr "CUDA 运行库"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:135
msgid ""
"The CUDA Runtime library (cudart) are what most applications will "
"typically need to link against to make any calls such as `cudaMalloc`, and"
" `cudaFree`."
msgstr ""
"大多数应用程序通常需要链接 CUDA 运行时库 (cudart) 以进行任何调用，例如 `cudaMalloc` 和 `cudaFree`。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:138
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:151
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:162
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:178
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:192
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:205
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:217
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:229
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:241
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:253
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:324
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:336
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:350
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:367
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:379
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:396
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:409
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:423
#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:449
msgid "Targets Created:"
msgstr "目标创建："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:140
msgid "``CUDA::cudart``"
msgstr "``CUDA::cudart``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:141
msgid "``CUDA::cudart_static``"
msgstr "``CUDA::cudart_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:146
msgid "CUDA Driver Library"
msgstr "CUDA 驱动程序库"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:148
msgid ""
"The CUDA Driver library (cuda) are used by applications that use calls "
"such as `cuMemAlloc`, and `cuMemFree`."
msgstr "CUDA 驱动程序库 (cuda) 由使用“cuMemAlloc”和“cuMemFree”等调用的应用程序使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:153
msgid "``CUDA::cuda_driver``"
msgstr "``CUDA::cuda_driver``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:158
msgid "cuBLAS"
msgstr "立方体"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:160
msgid ""
"The `cuBLAS <https://docs.nvidia.com/cuda/cublas/index.html>`_ library."
msgstr "`cuBLAS <https://docs.nvidia.com/cuda/cublas/index.html>`_ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:164
msgid "``CUDA::cublas``"
msgstr "``CUDA::cublas``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:165
msgid "``CUDA::cublas_static``"
msgstr "``CUDA::cublas_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:166
msgid "``CUDA::cublasLt`` starting in CUDA 10.1"
msgstr "``CUDA::cublasLt`` 从 CUDA 10.1 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:167
msgid "``CUDA::cublasLt_static`` starting in CUDA 10.1"
msgstr "``CUDA::cublasLt_static`` 从 CUDA 10.1 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:172
msgid "cuFile"
msgstr "文件"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:176
msgid ""
"The NVIDIA GPUDirect Storage `cuFile <https://docs.nvidia.com/cuda/cufile-"
"api/index.html>`_ library."
msgstr ""
"NVIDIA GPUDirect Storage `cuFile <https://docs.nvidia.com/cuda/cufile-"
"api/index.html>`_ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:180
msgid "``CUDA::cuFile`` starting in CUDA 11.4"
msgstr "``CUDA::cuFile`` 从 CUDA 11.4 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:181
msgid "``CUDA::cuFile_static`` starting in CUDA 11.4"
msgstr "``CUDA::cuFile_static`` 从 CUDA 11.4 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:182
msgid "``CUDA::cuFile_rdma`` starting in CUDA 11.4"
msgstr "``CUDA::cuFile_rdma`` 从 CUDA 11.4 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:183
msgid "``CUDA::cuFile_rdma_static`` starting in CUDA 11.4"
msgstr "``CUDA::cuFile_rdma_static`` 从 CUDA 11.4 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:188
msgid "cuFFT"
msgstr "快速傅里叶变换"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:190
msgid ""
"The `cuFFT <https://docs.nvidia.com/cuda/cufft/index.html>`_ library."
msgstr "`cuFFT <https://docs.nvidia.com/cuda/cufft/index.html>`_ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:194
msgid "``CUDA::cufft``"
msgstr "``CUDA::cufft``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:195
msgid "``CUDA::cufftw``"
msgstr "``CUDA::cufftw``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:196
msgid "``CUDA::cufft_static``"
msgstr "``CUDA::cufft_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:197
msgid ""
"``CUDA::cufft_static_nocallback`` starting in CUDA 9.2, requires CMake "
"3.23+"
msgstr "``CUDA::cufft_static_nocallback`` 从 CUDA 9.2 开始，需要 CMake 3.23+"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:198
msgid "``CUDA::cufftw_static``"
msgstr "``CUDA::cufftw_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:201
msgid "cuRAND"
msgstr "curRAND"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:203
msgid ""
"The `cuRAND <https://docs.nvidia.com/cuda/curand/index.html>`_ library."
msgstr "`cuRAND <https://docs.nvidia.com/cuda/curand/index.html>`_ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:207
msgid "``CUDA::curand``"
msgstr "``CUDA::curand``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:208
msgid "``CUDA::curand_static``"
msgstr "``CUDA::curand_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:213
msgid "cuSOLVER"
msgstr "求解器"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:215
msgid ""
"The `cuSOLVER <https://docs.nvidia.com/cuda/cusolver/index.html>`_ "
"library."
msgstr "`cuSOLVER <https://docs.nvidia.com/cuda/cusolver/index.html>`_ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:219
msgid "``CUDA::cusolver``"
msgstr "``CUDA::cusolver``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:220
msgid "``CUDA::cusolver_static``"
msgstr "``CUDA::cusolver_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:225
msgid "cuSPARSE"
msgstr "cuSPARSE"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:227
msgid ""
"The `cuSPARSE <https://docs.nvidia.com/cuda/cusparse/index.html>`_ "
"library."
msgstr "`cuSPARSE <https://docs.nvidia.com/cuda/cusparse/index.html>`_ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:231
msgid "``CUDA::cusparse``"
msgstr "``CUDA::cusparse``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:232
msgid "``CUDA::cusparse_static``"
msgstr "``CUDA::cusparse_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:237
msgid "cupti"
msgstr "杯子"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:239
msgid ""
"The `NVIDIA CUDA Profiling Tools Interface "
"<https://developer.nvidia.com/CUPTI>`_."
msgstr "`NVIDIA CUDA 分析工具界面 <https://developer.nvidia.com/CUPTI>`_。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:243
msgid "``CUDA::cupti``"
msgstr "``CUDA::cupti``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:244
msgid "``CUDA::cupti_static``"
msgstr "``CUDA::cupti_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:249
msgid "NPP"
msgstr "核电厂"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:251
msgid "The `NPP <https://docs.nvidia.com/cuda/npp/index.html>`_ libraries."
msgstr "`NPP <https://docs.nvidia.com/cuda/npp/index.html>`_ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:255
msgid "`nppc`:"
msgstr "`nppc`："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:257
msgid "``CUDA::nppc``"
msgstr "``CUDA::nppc``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:258
msgid "``CUDA::nppc_static``"
msgstr "``CUDA::nppc_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:260
msgid ""
"`nppial`: Arithmetic and logical operation functions in "
"`nppi_arithmetic_and_logical_operations.h`"
msgstr "`nppial`：`nppi_arithmetic_and_logical_operations.h`中的算术和逻辑运算函数"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:262
msgid "``CUDA::nppial``"
msgstr "``CUDA::nppial``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:263
msgid "``CUDA::nppial_static``"
msgstr "``CUDA::nppial_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:265
msgid ""
"`nppicc`: Color conversion and sampling functions in "
"`nppi_color_conversion.h`"
msgstr "`nppicc`：`nppi_color_conversion.h`中的颜色转换和采样函数"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:267
msgid "``CUDA::nppicc``"
msgstr "``CUDA::nppicc``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:268
msgid "``CUDA::nppicc_static``"
msgstr "``CUDA::nppicc_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:270
msgid ""
"`nppicom`: JPEG compression and decompression functions in "
"`nppi_compression_functions.h` Removed starting in CUDA 11.0, use "
":ref:`nvJPEG<cuda_toolkit_nvJPEG>` instead."
msgstr ""
"`nppicom`：`nppi_compression_functions.h` 中的 JPEG 压缩和解压缩函数从 CUDA 11.0 "
"开始删除，改用 :ref:`nvJPEG<cuda_toolkit_nvJPEG>`。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:273
msgid "``CUDA::nppicom``"
msgstr "``CUDA::nppicom``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:274
msgid "``CUDA::nppicom_static``"
msgstr "``CUDA::nppicom_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:276
msgid ""
"`nppidei`: Data exchange and initialization functions in "
"`nppi_data_exchange_and_initialization.h`"
msgstr "`nppidei`：`nppi_data_exchange_and_initialization.h` 中的数据交换和初始化函数"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:278
msgid "``CUDA::nppidei``"
msgstr "``CUDA::nppidei``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:279
msgid "``CUDA::nppidei_static``"
msgstr "``CUDA::nppidei_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:281
msgid ""
"`nppif`: Filtering and computer vision functions in "
"`nppi_filter_functions.h`"
msgstr "`nppif`：`nppi_filter_functions.h` 中的过滤和计算机视觉功能"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:283
msgid "``CUDA::nppif``"
msgstr "``CUDA::nppif``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:284
msgid "``CUDA::nppif_static``"
msgstr "``CUDA::nppif_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:286
msgid ""
"`nppig`: Geometry transformation functions found in "
"`nppi_geometry_transforms.h`"
msgstr "`nppig`：在 `nppi_geometry_transforms.h` 中找到的几何变换函数"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:288
msgid "``CUDA::nppig``"
msgstr "``CUDA::nppig``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:289
msgid "``CUDA::nppig_static``"
msgstr "``CUDA::nppig_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:291
msgid ""
"`nppim`: Morphological operation functions found in "
"`nppi_morphological_operations.h`"
msgstr "`nppim`：在 `nppi_morphological_operations.h` 中找到的形态学操作函数"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:293
msgid "``CUDA::nppim``"
msgstr "``CUDA::nppim``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:294
msgid "``CUDA::nppim_static``"
msgstr "``CUDA::nppim_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:296
msgid ""
"`nppist`: Statistics and linear transform in `nppi_statistics_functions.h`"
" and `nppi_linear_transforms.h`"
msgstr ""
"`nppist`：`nppi_statistics_functions.h` 和 `nppi_linear_transforms.h` "
"中的统计和线性变换"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:298
msgid "``CUDA::nppist``"
msgstr "``CUDA::nppist``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:299
msgid "``CUDA::nppist_static``"
msgstr "``CUDA::nppist_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:301
msgid "`nppisu`: Memory support functions in `nppi_support_functions.h`"
msgstr "`nppisu`：`nppi_support_functions.h` 中的内存支持函数"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:303
msgid "``CUDA::nppisu``"
msgstr "``CUDA::nppisu``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:304
msgid "``CUDA::nppisu_static``"
msgstr "``CUDA::nppisu_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:306
msgid ""
"`nppitc`: Threshold and compare operation functions in "
"`nppi_threshold_and_compare_operations.h`"
msgstr "`nppitc`：`nppi_threshold_and_compare_operations.h`中的阈值和比较操作函数"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:308
msgid "``CUDA::nppitc``"
msgstr "``CUDA::nppitc``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:309
msgid "``CUDA::nppitc_static``"
msgstr "``CUDA::nppitc_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:311
msgid "`npps`:"
msgstr "`npps`："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:313
msgid "``CUDA::npps``"
msgstr "``CUDA::npps``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:314
msgid "``CUDA::npps_static``"
msgstr "``CUDA::npps_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:319
msgid "nvBLAS"
msgstr "nvBLAS"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:321
msgid ""
"The `nvBLAS <https://docs.nvidia.com/cuda/nvblas/index.html>`_ libraries. "
"This is a shared library only."
msgstr ""
"`nvBLAS <https://docs.nvidia.com/cuda/nvblas/index.html>`_ 库。这只是一个共享库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:326
msgid "``CUDA::nvblas``"
msgstr "``CUDA::nvblas``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:331
msgid "nvGRAPH"
msgstr "图表"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:333
msgid ""
"The `nvGRAPH <https://docs.nvidia.com/cuda/nvgraph/index.html>`_ library. "
"Removed starting in CUDA 11.0"
msgstr ""
"`nvGRAPH <https://docs.nvidia.com/cuda/nvgraph/index.html>`_ 库。从 CUDA 11.0"
" 开始删除"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:338
msgid "``CUDA::nvgraph``"
msgstr "``CUDA::nvgraph``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:339
msgid "``CUDA::nvgraph_static``"
msgstr "``CUDA::nvgraph_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:345
msgid "nvJPEG"
msgstr "nvJPEG格式"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:347
msgid ""
"The `nvJPEG <https://docs.nvidia.com/cuda/nvjpeg/index.html>`_ library. "
"Introduced in CUDA 10."
msgstr ""
"`nvJPEG <https://docs.nvidia.com/cuda/nvjpeg/index.html>`_ 库。在 CUDA 10 "
"中引入。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:352
msgid "``CUDA::nvjpeg``"
msgstr "``CUDA::nvjpeg``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:353
msgid "``CUDA::nvjpeg_static``"
msgstr "``CUDA::nvjpeg_static``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:358
msgid "nvPTX Compiler"
msgstr "nvPTX 编译器"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:362
msgid ""
"The `nvPTX <https://docs.nvidia.com/cuda/ptx-compiler-api/index.html>`_ "
"(PTX Compilation) library. The PTX Compiler APIs are a set of APIs which "
"can be used to compile a PTX program into GPU assembly code. Introduced in"
" CUDA 11.1 This is a static library only."
msgstr ""
"`nvPTX <https://docs.nvidia.com/cuda/ptx-compiler-api/index.html>`_（PTX "
"编译）库。 PTX 编译器 API 是一组 API，可用于将 PTX 程序编译为 GPU 汇编代码。在 CUDA 11.1 中引入 "
"这只是一个静态库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:369
msgid "``CUDA::nvptxcompiler_static`` starting in CUDA 11.1"
msgstr "``CUDA::nvptxcompiler_static`` 从 CUDA 11.1 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:374
msgid "nvRTC"
msgstr "nvRTC"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:376
msgid ""
"The `nvRTC <https://docs.nvidia.com/cuda/nvrtc/index.html>`_ (Runtime "
"Compilation) library. This is a shared library only."
msgstr ""
"`nvRTC <https://docs.nvidia.com/cuda/nvrtc/index.html>`_（运行时编译）库。这只是一个共享库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:381
msgid "``CUDA::nvrtc``"
msgstr "``CUDA::nvrtc``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:385
msgid "``CUDA::nvrtc_builtins``"
msgstr "``CUDA::nvrtc_builtins``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:386
msgid "``CUDA::nvrtc_static`` starting in CUDA 11.5"
msgstr "``CUDA::nvrtc_static`` 从 CUDA 11.5 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:387
msgid "``CUDA::nvrtc_builtins_static`` starting in CUDA 11.5"
msgstr "``CUDA::nvrtc_builtins_static`` 从 CUDA 11.5 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:392
msgid "nvJitLink"
msgstr "nvJitLink"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:394
msgid ""
"The `nvJItLink <https://docs.nvidia.com/cuda/>`_ (Runtime LTO Linking) "
"library."
msgstr "`nvJItLink <https://docs.nvidia.com/cuda/>`_（运行时 LTO 链接）库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:398
msgid "``CUDA::nvJitLink`` starting in CUDA 12.0"
msgstr "``CUDA::nvJitLink`` 从 CUDA 12.0 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:399
msgid "``CUDA::nvJitLink_static``  starting in CUDA 12.0"
msgstr "``CUDA::nvJitLink_static`` 从 CUDA 12.0 开始"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:404
msgid "nvidia-ML"
msgstr "nvidia-ML"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:406
msgid ""
"The `NVIDIA Management Library <https://developer.nvidia.com/nvidia-"
"management-library-nvml>`_. This is a shared library only."
msgstr ""
"`NVIDIA 管理库 <https://developer.nvidia.com/nvidia-management-library-"
"nvml>`_。这只是一个共享库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:411
msgid "``CUDA::nvml``"
msgstr "``CUDA::nvml``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:416
msgid "nvToolsExt"
msgstr "nvToolsExt"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:418
msgid "With CUDA 10.0+, use :ref:`nvtx3 <cuda_toolkit_nvtx3>`."
msgstr "对于 CUDA 10.0+，使用 :ref:`nvtx3 <cuda_toolkit_nvtx3>`。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:420
msgid ""
"The `NVIDIA Tools Extension "
"<https://docs.nvidia.com/gameworks/content/gameworkslibrary/nvtx/nvidia_tools_extension_library_nvtx.htm>`_."
" This is a shared library only."
msgstr ""
"`NVIDIA 工具扩展 "
"<https://docs.nvidia.com/gameworks/content/gameworkslibrary/nvtx/nvidia_tools_extension_library_nvtx.htm>`_。这只是一个共享库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:425
msgid "``CUDA::nvToolsExt``"
msgstr "``CUDA::nvToolsExt``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:430
msgid "nvtx3"
msgstr "nvtx3"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:434
msgid ""
"The header-only `NVIDIA Tools Extension Library "
"<https://nvidia.github.io/NVTX/doxygen/index.html>`_. Introduced in CUDA "
"10.0."
msgstr ""
"仅标头的`NVIDIA 工具扩展库 <https://nvidia.github.io/NVTX/doxygen/index.html>`_。在 "
"CUDA 10.0 中引入。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:437
msgid "Targets created:"
msgstr "创建的目标："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:439
msgid "``CUDA::nvtx3``"
msgstr "``CUDA::nvtx3``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:444
msgid "OpenCL"
msgstr "OpenCL"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:446
msgid ""
"The `NVIDIA OpenCL Library <https://developer.nvidia.com/opencl>`_. This "
"is a shared library only."
msgstr "`NVIDIA OpenCL 库 <https://developer.nvidia.com/opencl>`_。这只是一个共享库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:451
msgid "``CUDA::OpenCL``"
msgstr "``CUDA::OpenCL``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:456
msgid "cuLIBOS"
msgstr "cuLIBOS"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:458
msgid ""
"The cuLIBOS library is a backend thread abstraction layer library which is"
" static only.  The ``CUDA::cublas_static``, ``CUDA::cusparse_static``, "
"``CUDA::cufft_static``, ``CUDA::curand_static``, and (when implemented) "
"NPP libraries all automatically have this dependency linked."
msgstr ""
"cuLIBOS 库是一个后端线程抽象层库，它只是静态的。 "
"``CUDA::cublas_static``、``CUDA::cusparse_static``、``CUDA::cufft_static``、``CUDA::curand_static``"
" 和（在实现时）NPP 库都会自动链接此依赖项."

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:463
msgid "Target Created:"
msgstr "目标创建："

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:465
msgid "``CUDA::culibos``"
msgstr "``CUDA::culibos``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:467
msgid ""
"**Note**: direct usage of this target by consumers should not be "
"necessary."
msgstr "**注意**：消费者没有必要直接使用这个目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:474
#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:19
#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:20
#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:135
#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:20
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:35
#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:23
msgid "Result variables"
msgstr "结果变量"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:477
msgid "``CUDAToolkit_FOUND``"
msgstr "``CUDAToolkit_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:477
msgid "A boolean specifying whether or not the CUDA Toolkit was found."
msgstr "指定是否找到 CUDA 工具包的布尔值。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:481
msgid "``CUDAToolkit_VERSION``"
msgstr "``CUDAToolkit_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:480
msgid ""
"The exact version of the CUDA Toolkit found (as reported by ``nvcc "
"--version``, ``version.txt``, or ``version.json``)."
msgstr ""
"找到的 CUDA 工具包的确切版本（由 ``nvcc --version``、``version.txt`` 或 ``version.json`` "
"报告）。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:484
msgid "``CUDAToolkit_VERSION_MAJOR``"
msgstr "``CUDAToolkit _VERSION_ MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:484
msgid "The major version of the CUDA Toolkit."
msgstr "CUDA 工具包的主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:487
msgid "``CUDAToolkit_VERSION_MINOR``"
msgstr "``CUDAToolkit _VERSION_ MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:487
msgid "The minor version of the CUDA Toolkit."
msgstr "CUDA 工具包的次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:490
msgid "``CUDAToolkit_VERSION_PATCH``"
msgstr "``CUDAToolkit _VERSION_ PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:490
msgid "The patch version of the CUDA Toolkit."
msgstr "CUDA 工具包的补丁版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:494
msgid "``CUDAToolkit_BIN_DIR``"
msgstr "``CUDAToolkit_BIN_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:493
msgid ""
"The path to the CUDA Toolkit library directory that contains the CUDA "
"executable ``nvcc``."
msgstr "包含 CUDA 可执行文件“nvcc”的 CUDA 工具包库目录的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:498
msgid "``CUDAToolkit_INCLUDE_DIRS``"
msgstr "``CUDAToolkit_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:497
msgid ""
"The path to the CUDA Toolkit ``include`` folder containing the header "
"files required to compile a project linking against CUDA."
msgstr "CUDA Toolkit ``include`` 文件夹的路径，其中包含编译链接到 CUDA 的项目所需的头文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:502
msgid "``CUDAToolkit_LIBRARY_DIR``"
msgstr "``CUDAToolkit_LIBRARY_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:501
msgid ""
"The path to the CUDA Toolkit library directory that contains the CUDA "
"Runtime library ``cudart``."
msgstr "包含 CUDA 运行时库“cudart”的 CUDA 工具包库目录的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:508
msgid "``CUDAToolkit_LIBRARY_ROOT``"
msgstr "``CUDAToolkit_LIBRARY_ROOT``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:507
msgid ""
"The path to the CUDA Toolkit directory containing the nvvm directory and "
"either version.txt or version.json."
msgstr "包含 nvvm 目录和 version.txt 或 version.json 的 CUDA 工具包目录的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:513
msgid "``CUDAToolkit_TARGET_DIR``"
msgstr "``CUDAToolkit_TARGET_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:511
msgid ""
"The path to the CUDA Toolkit directory including the target architecture "
"when cross-compiling. When not cross-compiling this will be equivalent to "
"the parent directory of ``CUDAToolkit_BIN_DIR``."
msgstr ""
"CUDA 工具包目录的路径，包括交叉编译时的目标体系结构。当不交叉编译时，这将等同于 ``CUDAToolkit_BIN_DIR`` 的父目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:1211
msgid "``CUDAToolkit_NVCC_EXECUTABLE``"
msgstr "``CUDAToolkit_NVCC_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindCUDAToolkit.cmake:516
msgid ""
"The path to the NVIDIA CUDA compiler ``nvcc``.  Note that this path may "
"**not** be the same as :variable:`CMAKE_CUDA_COMPILER "
"<CMAKE_<LANG>_COMPILER>`.  ``nvcc`` must be found to determine the CUDA "
"Toolkit version as well as determining other features of the Toolkit.  "
"This variable is set for the convenience of modules that depend on this "
"one."
msgstr ""
"NVIDIA CUDA 编译器“nvcc”的路径。请注意，此路径可能**不**与 :variable:`CMAKE_CUDA_COMPILER "
"<CMAKE_<LANG>_COMPILER>` 相同。必须找到 ``nvcc`` 以确定 CUDA "
"工具包版本以及确定工具包的其他功能。设置此变量是为了方便依赖于此变量的模块。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:6
msgid "FindCURL"
msgstr "查找CURL"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:8
msgid "Find the native CURL headers and libraries."
msgstr "查找本机 CURL 标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:10
msgid ""
"This module accept optional COMPONENTS to check supported features and "
"protocols:"
msgstr "该模块接受可选组件以检查支持的功能和协议："

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:26
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``CURL::libcurl``, if curl"
" has been found."
msgstr "如果找到 curl，此模块定义 :prop_tgt:`IMPORTED` 目标 ``CURL::libcurl``。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:35
msgid "``CURL_FOUND``"
msgstr "``CURL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:35
msgid "\"True\" if ``curl`` found."
msgstr "如果找到``curl``，则为“真”。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:38
msgid "``CURL_INCLUDE_DIRS``"
msgstr "``CURL_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:38
msgid "where to find ``curl``/``curl.h``, etc."
msgstr "在哪里可以找到``curl``/``curl.h``等。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:41
msgid "``CURL_LIBRARIES``"
msgstr "``CURL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:41
msgid "List of libraries when using ``curl``."
msgstr "使用“curl”时的库列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:44
msgid "``CURL_VERSION_STRING``"
msgstr "``CURL_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:44
msgid "The version of ``curl`` found."
msgstr "找到“curl”的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:40
#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:60
#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:64
#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:35
msgid "Debug and Release variants are found separately."
msgstr "调试和发布变体是分开找到的。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:50
msgid "CURL CMake"
msgstr "卷曲CMake"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:54
msgid ""
"If CURL was built using the CMake buildsystem then it provides its own "
"``CURLConfig.cmake`` file for use with the :command:`find_package` "
"command's config mode. This module looks for this file and, if found, "
"returns its results with no further action."
msgstr ""
"如果 CURL 是使用 CMake 构建系统构建的，那么它会提供自己的 ``CURLConfig.cmake`` 文件，用于 "
":command:`find_package` 命令的配置模式。此模块查找此文件，如果找到，则返回其结果而不采取进一步操作。"

#: ../../cmake-prefix/src/cmake/Modules/FindCURL.cmake:59
msgid "Set ``CURL_NO_CURL_CMAKE`` to ``ON`` to disable this search."
msgstr "将“CURL_NO_CURL_CMAKE”设置为“ON”以禁用此搜索。"

#: ../../cmake-prefix/src/cmake/Modules/FindCVS.cmake:6
msgid "FindCVS"
msgstr "查找CVS"

#: ../../cmake-prefix/src/cmake/Modules/FindCVS.cmake:8
msgid "Find the Concurrent Versions System (CVS)."
msgstr "查找并发版本系统 (CVS)。"

#: ../../cmake-prefix/src/cmake/Modules/FindCoin3D.cmake:6
msgid "FindCoin3D"
msgstr "FindCoin3D"

#: ../../cmake-prefix/src/cmake/Modules/FindCoin3D.cmake:8
msgid "Find Coin3D (Open Inventor)"
msgstr "查找 Coin3D（Open Inventor）"

#: ../../cmake-prefix/src/cmake/Modules/FindCoin3D.cmake:10
msgid ""
"Coin3D is an implementation of the Open Inventor API.  It provides data "
"structures and algorithms for 3D visualization."
msgstr "Coin3D 是 Open Inventor API 的一个实现。它为 3D 可视化提供数据结构和算法。"

#: ../../cmake-prefix/src/cmake/Modules/FindCoin3D.cmake:13
msgid "This module defines the following variables"
msgstr "该模块定义了以下变量"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:6
msgid "FindCups"
msgstr "找杯子"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:8
msgid "Find the Common UNIX Printing System (CUPS)."
msgstr "查找通用 UNIX 打印系统 (CUPS)。"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:10
msgid ""
"Set ``CUPS_REQUIRE_IPP_DELETE_ATTRIBUTE`` to ``TRUE`` if you need a "
"version which features this function (i.e. at least ``1.1.19``)"
msgstr ""
"如果您需要具有此功能的版本（即至少 ``1.1.19``），请将 ``CUPS_REQUIRE_IPP_DELETE_ATTRIBUTE`` 设置为"
" ``TRUE``"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:18
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``Cups::Cups``, if Cups "
"has been found."
msgstr "如果已找到 Cups，此模块定义 :prop_tgt:`IMPORTED` 目标 ``Cups::Cups``。"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:55
#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:66
#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:24
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:25
msgid "This module will set the following variables in your project:"
msgstr "该模块将在您的项目中设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:26
msgid "``CUPS_FOUND``"
msgstr "``CUPS_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:27
msgid "true if CUPS headers and libraries were found"
msgstr "如果找到 CUPS 标头和库，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:28
msgid "``CUPS_INCLUDE_DIRS``"
msgstr "``CUPS_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:41
msgid "the directory containing the Cups headers"
msgstr "包含 Cups 标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:30
msgid "``CUPS_LIBRARIES``"
msgstr "``CUPS_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:31
msgid "the libraries to link against to use CUPS."
msgstr "要链接的库以使用 CUPS。"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:33
msgid "``CUPS_VERSION_STRING``"
msgstr "``CUPS_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:33
msgid "the version of CUPS found (since CMake 2.8.8)"
msgstr "找到的 CUPS 版本（自 CMake 2.8.8 起）"

#: ../../cmake-prefix/src/cmake/Modules/FindCups.cmake:100
msgid "``CUPS_INCLUDE_DIR``"
msgstr "``CUPS_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:6
msgid "FindCurses"
msgstr "找诅咒"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:8
msgid "Find the curses or ncurses include file and library."
msgstr "找到 curses 或 ncurses 包含文件和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:15
msgid "``CURSES_FOUND``"
msgstr "``CURSES_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:16
msgid "True if Curses is found."
msgstr "如果找到 Curses，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:17
msgid "``CURSES_INCLUDE_DIRS``"
msgstr "``CURSES_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:18
msgid "The include directories needed to use Curses."
msgstr "使用 Curses 所需的包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:19
msgid "``CURSES_LIBRARIES``"
msgstr "``CURSES_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:20
msgid "The libraries needed to use Curses."
msgstr "使用 Curses 所需的库。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:23
msgid "``CURSES_CFLAGS``"
msgstr "``CURSES_CFLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:24
msgid ""
"Parameters which ought be given to C/C++ compilers when using Curses."
msgstr "使用 Curses 时应提供给 C/C++ 编译器的参数。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:25
msgid "``CURSES_HAVE_CURSES_H``"
msgstr "``CURSES_HAVE_CURSES_H``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:26
msgid "True if curses.h is available."
msgstr "如果 curses.h 可用则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:27
msgid "``CURSES_HAVE_NCURSES_H``"
msgstr "``CURSES_HAVE_NCURSES_H``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:28
msgid "True if ncurses.h is available."
msgstr "如果 ncurses.h 可用则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:29
msgid "``CURSES_HAVE_NCURSES_NCURSES_H``"
msgstr "``CURSES_HAVE_NCURSES_NCURSES_H``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:30
msgid "True if ``ncurses/ncurses.h`` is available."
msgstr "如果 ``ncurses/ncurses.h`` 可用则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:32
msgid "``CURSES_HAVE_NCURSES_CURSES_H``"
msgstr "``CURSES_HAVE_NCURSES_CURSES_H``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:32
msgid "True if ``ncurses/curses.h`` is available."
msgstr "如果 ``ncurses/curses.h`` 可用则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:34
msgid ""
"Set ``CURSES_NEED_NCURSES`` to ``TRUE`` before the "
"``find_package(Curses)`` call if NCurses functionality is required."
msgstr ""
"如果需要 NCurses "
"功能，请在调用“find_package(Curses)”之前将“CURSES_NEED_NCURSES”设置为“TRUE”。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:37
msgid ""
"Set ``CURSES_NEED_WIDE`` to ``TRUE`` before the ``find_package(Curses)`` "
"call if unicode functionality is required."
msgstr ""
"如果需要 unicode 功能，请在调用 find_package(Curses) 之前将 CURSES_NEED_WIDE 设置为 TRUE。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:242
msgid "Backward Compatibility"
msgstr "向后兼容性"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:44
msgid "The following variable are provided for backward compatibility:"
msgstr "提供以下变量是为了向后兼容："

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:46
msgid "``CURSES_INCLUDE_DIR``"
msgstr "``CURSES_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:47
msgid "Path to Curses include.  Use ``CURSES_INCLUDE_DIRS`` instead."
msgstr "诅咒之路包括。请改用 ``CURSES_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:276
msgid "``CURSES_LIBRARY``"
msgstr "``CURSES_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindCurses.cmake:49
msgid "Path to Curses library.  Use ``CURSES_LIBRARIES`` instead."
msgstr "Curses 库的路径。请改用 ``CURSES_LIBRARIES``。"

#: ../../cmake-prefix/src/cmake/Modules/FindCxxTest.cmake:6
msgid "FindCxxTest"
msgstr "查找Cxx测试"

#: ../../cmake-prefix/src/cmake/Modules/FindCxxTest.cmake:8
msgid "Find CxxTest unit testing framework."
msgstr "查找 CxxTest 单元测试框架。"

#: ../../cmake-prefix/src/cmake/Modules/FindCxxTest.cmake:10
msgid ""
"Find the CxxTest suite and declare a helper macro for creating unit tests "
"and integrating them with CTest.  For more details on CxxTest see "
"https://cxxtest.com"
msgstr ""
"找到 CxxTest 套件并声明一个辅助宏，用于创建单元测试并将它们与 CTest 集成。有关 CxxTest 的更多详细信息，请参阅 "
"https://cxxtest.com"

#: ../../cmake-prefix/src/cmake/Modules/FindCxxTest.cmake:14
msgid "INPUT Variables"
msgstr "输入变量"

#: ../../cmake-prefix/src/cmake/Modules/FindCxxTest.cmake:45
msgid "OUTPUT Variables"
msgstr "输出变量"

#: ../../cmake-prefix/src/cmake/Modules/FindCxxTest.cmake:66
msgid "MACROS for optional use by CMake users:"
msgstr "供 CMake 用户选择使用的 MACROS："

#: ../../cmake-prefix/src/cmake/Modules/FindCygwin.cmake:6
msgid "FindCygwin"
msgstr "找到Cygwin"

#: ../../cmake-prefix/src/cmake/Modules/FindCygwin.cmake:8
msgid ""
"Find Cygwin, a POSIX-compatible environment that runs natively on "
"Microsoft Windows"
msgstr "查找 Cygwin，这是一个在 Microsoft Windows 上本地运行的 POSIX 兼容环境"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:6
msgid "FindDCMTK"
msgstr "查找DCMTK"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:8
msgid "Find DICOM ToolKit (DCMTK) libraries and applications"
msgstr "查找 DICOM 工具包 (DCMTK) 库和应用程序"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:10
msgid "The module defines the following variables::"
msgstr "该模块定义了以下变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:18
msgid "Compatibility"
msgstr "兼容性"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:20
msgid ""
"This module is able to find a version of DCMTK that does or does not "
"export a ``DCMTKConfig.cmake`` file. It applies a two step process:"
msgstr "该模块能够找到导出或不导出“DCMTKConfig.cmake”文件的 DCMTK 版本。它应用两步过程："

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:23
msgid ""
"Step 1:  Attempt to find DCMTK version providing a ``DCMTKConfig.cmake`` "
"file."
msgstr "第 1 步：尝试查找提供“DCMTKConfig.cmake”文件的 DCMTK 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:24
msgid ""
"Step 2:  If step 1 failed, rely on ``FindDCMTK.cmake`` to set ``DCMTK_*`` "
"variables details below."
msgstr "第 2 步：如果第 1 步失败，请依靠 ``FindDCMTK.cmake`` 来设置 ``DCMTK_*`` 变量详情如下。"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:28
msgid ""
"`Recent DCMTK "
"<https://git.dcmtk.org/?p=dcmtk.git;a=commit;h=662ae187c493c6b9a73dd5e3875372cebd0c11fe>`_"
" provides a ``DCMTKConfig.cmake`` :manual:`package configuration file "
"<cmake-packages(7)>`. To exclusively use the package configuration file "
"(recommended when possible), pass the `NO_MODULE` option to "
":command:`find_package`. For example, `find_package(DCMTK NO_MODULE)`. "
"This requires official DCMTK snapshot *3.6.1_20140617* or newer."
msgstr ""
"`最近的DCMTK "
"<https://git.dcmtk.org/?p=dcmtk.git;a=commit;h=662ae187c493c6b9a73dd5e3875372cebd0c11fe>`_提供了一个``DCMTKConfig.cmake``:manual:`包配置文件<cmake-包（7）>`。要独占使用包配置文件（尽可能推荐），将"
" `NO_MODULE` 选项传递给:command:`find_package`。例如，`find_package(DCMTK "
"NO_MODULE)`。这需要官方 DCMTK 快照 *3.6.1_20140617* 或更新版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:37
msgid ""
"Until all clients update to the more recent DCMTK, build systems will need"
" to support different versions of DCMTK."
msgstr "在所有客户端都更新到更新的 DCMTK 之前，构建系统将需要支持不同版本的 DCMTK。"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:40
msgid ""
"On any given system, the following combinations of DCMTK versions could be"
" considered:"
msgstr "在任何给定系统上，可以考虑以下 DCMTK 版本组合："

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:44
msgid "SYSTEM DCMTK"
msgstr "系统DCMTK"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:44
msgid "LOCAL DCMTK"
msgstr "本地DCMTK"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:44
msgid "Supported ?"
msgstr "支持的 ？"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:46
msgid "Case A"
msgstr "案例一"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:52
msgid "NA"
msgstr "北美"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:54
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:58
msgid "[ ] DCMTKConfig"
msgstr "[] DCMTK配置"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:50
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:60
msgid "YES"
msgstr "是的"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:48
msgid "Case B"
msgstr "案例二"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:52
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:60
msgid "[X] DCMTKConfig"
msgstr "[X] DCMTK配置"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:50
msgid "Case C"
msgstr "案例C"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:52
msgid "Case D"
msgstr "案例四"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:54
msgid "Case E"
msgstr "案例E"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:54
msgid "YES (*)"
msgstr "是的 （*）"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:56
msgid "Case F"
msgstr "案例F"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:56
msgid "NO"
msgstr "不"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:58
msgid "Case G"
msgstr "案例 G"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:60
msgid "Case H"
msgstr "案例H"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:63
msgid "(*) See Troubleshooting section."
msgstr "(*) 请参阅故障排除部分。"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:65
msgid "Legend:"
msgstr "传奇："

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:67
msgid "NA ...............: Means that no System or Local DCMTK is available"
msgstr "NA ...............: 表示没有可用的系统或本地 DCMTK"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:69
msgid ""
"[ ] DCMTKConfig ..: Means that the version of DCMTK does NOT export a "
"DCMTKConfig.cmake file."
msgstr "[ ] DCMTKConfig ..：表示 DCMTK 版本不导出 DCMTKConfig.cmake 文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:71
msgid ""
"[X] DCMTKConfig ..: Means that the version of DCMTK exports a "
"DCMTKConfig.cmake file."
msgstr "[X] DCMTKConfig ..：表示DCMTK版本导出一个DCMTKConfig.cmake文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:75
msgid "Troubleshooting"
msgstr "故障排除"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:77
msgid "What to do if my project finds a different version of DCMTK?"
msgstr "如果我的项目发现不同版本的 DCMTK 怎么办？"

#: ../../cmake-prefix/src/cmake/Modules/FindDCMTK.cmake:79
msgid ""
"Remove DCMTK entry from the CMake cache per :command:`find_package` "
"documentation."
msgstr "根据 :command:`find_package` 文档从 CMake 缓存中删除 DCMTK 条目。"

#: ../../cmake-prefix/src/cmake/Modules/FindDart.cmake:6
msgid "FindDart"
msgstr "找镖"

#: ../../cmake-prefix/src/cmake/Modules/FindDart.cmake:8
msgid "Find DART"
msgstr "寻找飞镖"

#: ../../cmake-prefix/src/cmake/Modules/FindDart.cmake:10
msgid ""
"This module looks for the dart testing software and sets DART_ROOT to "
"point to where it found it."
msgstr "该模块查找 dart 测试软件并将 DART_ROOT 设置为指向找到它的位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:6
msgid "FindDevIL"
msgstr "找魔鬼"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:10
msgid ""
"This module locates the developer's image library. "
"https://openil.sourceforge.net/"
msgstr "该模块定位开发者的图片库。 https://openil.sourceforge.net/"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:29
msgid "This module defines the :prop_tgt:`IMPORTED` targets:"
msgstr "该模块定义了 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:21
msgid "``DevIL::IL``"
msgstr "``DevIL::IL``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:21
msgid "Defined if the system has DevIL."
msgstr "定义系统是否具有 DevIL。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:24
msgid "``DevIL::ILU``"
msgstr "``DevIL::ILU``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:24
msgid "Defined if the system has DevIL Utilities."
msgstr "定义系统是否具有 DevIL 实用程序。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:27
msgid "``DevIL::ILUT``"
msgstr "``DevIL::ILUT``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:27
msgid "Defined if the system has DevIL Utility Toolkit."
msgstr "定义系统是否具有 DevIL Utility Toolkit。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:32
msgid "This module sets:"
msgstr "该模块设置："

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:37
msgid "``IL_LIBRARIES``"
msgstr "``IL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:35
msgid ""
"The name of the IL library. These include the full path to the core DevIL "
"library. This one has to be linked into the application."
msgstr "IL 库的名称。其中包括核心 DevIL 库的完整路径。这个必须链接到应用程序中。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:43
msgid "``ILU_LIBRARIES``"
msgstr "``ILU_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:40
msgid ""
"The name of the ILU library. Again, the full path. This library is for "
"filters and effects, not actual loading. It doesn't have to be linked if "
"the functionality it provides is not used."
msgstr "ILU 库的名称。再次，完整路径。该库用于过滤器和效果，而不是实际加载。如果不使用它提供的功能，则不必链接它。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:48
msgid "``ILUT_LIBRARIES``"
msgstr "``ILUT_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:46
msgid ""
"The name of the ILUT library. Full path. This part of the library "
"interfaces with OpenGL. It is not strictly needed in applications."
msgstr "ILUT 库的名称。完整路径。库的这一部分与 OpenGL 接口。应用程序中并不严格需要它。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:51
msgid "``IL_INCLUDE_DIR``"
msgstr "``IL_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:51
msgid "where to find the il.h, ilu.h and ilut.h files."
msgstr "在哪里可以找到 il.h、ilu.h 和 ilut.h 文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:58
msgid "``DevIL_FOUND``"
msgstr "``DevIL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:54
msgid ""
"This is set to TRUE if all the above variables were set. This will be set "
"to false if ILU or ILUT are not found, even if they are not needed. In "
"most systems, if one library is found all the others are as well. That's "
"the way the DevIL developers release it."
msgstr ""
"如果设置了上述所有变量，则此设置为 TRUE。如果未找到 ILU 或 ILUT，即使不需要它们，这也将设置为 "
"false。在大多数系统中，如果找到了一个库，则所有其他库也都找到了。这就是 DevIL 开发人员发布它的方式。"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:139
msgid "``DevIL_ILUT_FOUND``"
msgstr "``DevIL_ILUT_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindDevIL.cmake:63
msgid "This is set to TRUE if the ILUT library is found."
msgstr "如果找到 ILUT 库，则此设置为 TRUE。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:6
msgid "FindDoxygen"
msgstr "寻找氧气"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:8
msgid ""
"Doxygen is a documentation generation tool (see https://www.doxygen.nl). "
"This module looks for Doxygen and some optional tools it supports:"
msgstr ""
"Doxygen 是一个文档生成工具（参见 https://www.doxygen.nl）。这个模块寻找 Doxygen 和它支持的一些可选工具："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:12
msgid "``dot``"
msgstr "``点``"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:12
msgid ""
"`Graphviz <https://graphviz.org>`_ ``dot`` utility used to render various "
"graphs."
msgstr "`Graphviz <https://graphviz.org>`_ ``dot`` 实用程序用于呈现各种图形。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:15
msgid "``mscgen``"
msgstr "``mscgen``"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:15
msgid ""
"`Message Chart Generator <https://www.mcternan.me.uk/mscgen/>`_ utility "
"used by Doxygen's ``\\msc`` and ``\\mscfile`` commands."
msgstr ""
"`消息图表生成器<https://www.mcternan.me.uk/mscgen/>`_ Doxygen 的``\\msc`` "
"和``\\mscfile`` 命令使用的实用程序。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:19
msgid "``dia``"
msgstr "``直径``"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:18
msgid ""
"`Dia <https://wiki.gnome.org/Apps/Dia>`_ the diagram editor used by "
"Doxygen's ``\\diafile`` command."
msgstr ""
"`Dia <https://wiki.gnome.org/Apps/Dia>`_ Doxygen 的``\\diafile`` "
"命令使用的图表编辑器。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:21
msgid ""
"These tools are available as components in the :command:`find_package` "
"command. For example:"
msgstr "这些工具可作为 :command:`find_package` 命令中的组件使用。例如："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:32
msgid "The following variables are defined by this module:"
msgstr "该模块定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:36
msgid "True if the ``doxygen`` executable was found."
msgstr "如果找到“doxygen”可执行文件，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:40
msgid "The version reported by ``doxygen --version``."
msgstr "``doxygen --version`` 报告的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:42
msgid ""
"The module defines ``IMPORTED`` targets for Doxygen and each component "
"found. These can be used as part of custom commands, etc. and should be "
"preferred over old-style (and now deprecated) variables like "
"``DOXYGEN_EXECUTABLE``. The following import targets are defined if their "
"corresponding executable could be found (the component import targets will"
" only be defined if that component was requested):"
msgstr ""
"该模块为 Doxygen 和找到的每个组件定义了“IMPORTED”目标。这些可以用作自定义命令等的一部分，并且应该优先于旧式（现在已弃用）变量，如"
" ``DOXYGEN_EXECUTABLE``。如果可以找到相应的可执行文件，则定义以下导入目标（只有在请求该组件时才会定义组件导入目标）："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:65
msgid ""
"This function is intended as a convenience for adding a target for "
"generating documentation with Doxygen. It aims to provide sensible "
"defaults so that projects can generally just provide the input files and "
"directories and that will be sufficient to give sensible results. The "
"function supports the ability to customize the Doxygen configuration used "
"to build the documentation."
msgstr ""
"此功能旨在方便地添加目标以使用 Doxygen "
"生成文档。它旨在提供合理的默认值，以便项目通常可以只提供输入文件和目录，这足以提供合理的结果。该功能支持自定义用于构建文档的 Doxygen "
"配置的能力。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:81
msgid ""
"The function constructs a ``Doxyfile`` and defines a custom target that "
"runs Doxygen on that generated file. The listed files and directories are "
"used as the ``INPUT`` of the generated ``Doxyfile`` and they can contain "
"wildcards. Any files that are listed explicitly will also be added as "
"``SOURCES`` of the custom target so they will show up in an IDE project's "
"source list."
msgstr ""
"该函数构造一个 ``Doxyfile`` 并定义一个在生成的文件上运行 Doxygen 的自定义目标。列出的文件和目录用作生成的 "
"``Doxyfile`` 的``INPUT``，它们可以包含通配符。任何明确列出的文件也将作为自定义目标的“SOURCES”添加，因此它们将显示在 "
"IDE 项目的源列表中。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:87
msgid ""
"So that relative input paths work as expected, by default the working "
"directory of the Doxygen command will be the current source directory "
"(i.e. :variable:`CMAKE_CURRENT_SOURCE_DIR`). This can be overridden with "
"the ``WORKING_DIRECTORY`` option to change the directory used as the "
"relative base point. Note also that Doxygen's default behavior is to strip"
" the working directory from relative paths in the generated documentation "
"(see the ``STRIP_FROM_PATH`` `Doxygen config option "
"<https://www.doxygen.nl/manual/config.html>`_ for details)."
msgstr ""
"为了使相对输入路径按预期工作，默认情况下 Doxygen "
"命令的工作目录将是当前源目录（即 :variable:`CMAKE_CURRENT_SOURCE_DIR`）。这可以用 ``WORKING_DIRECTORY``"
" 选项覆盖，以更改用作相对基点的目录。另请注意，Doxygen "
"的默认行为是从生成的文档中的相对路径中剥离工作目录（请参阅``STRIP_FROM_PATH```Doxygen 配置选项 "
"<https://www.doxygen.nl/manual/config.html>`_详情）。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:96
msgid ""
"If provided, the optional ``comment`` will be passed as the ``COMMENT`` "
"for the :command:`add_custom_target` command used to create the custom "
"target internally."
msgstr ""
"如果提供，可选的 ``comment`` 将作为用于在内部创建自定义目标的 add_custom_target 命令的 ``COMMENT`` "
"传递。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:100
msgid ""
"If ``ALL`` is set, the target will be added to the default build target."
msgstr "如果设置了 ALL ，目标将被添加到默认构建目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:103
msgid ""
"If ``USE_STAMP_FILE`` is set, the custom command defined by this function "
"will create a stamp file with the name ``<targetName>.stamp`` in the "
"current binary directory whenever doxygen is re-run.  With this option "
"present, all items in ``<filesOrDirs>`` must be files (i.e. no "
"directories, symlinks or wildcards) and each of the files must exist at "
"the time ``doxygen_add_docs()`` is called.  An error will be raised if any"
" of the items listed is missing or is not a file when ``USE_STAMP_FILE`` "
"is given. A dependency will be created on each of the files so that "
"doxygen will only be re-run if one of the files is updated.  Without the "
"``USE_STAMP_FILE`` option, doxygen will always be re-run if the "
"``<targetName>`` target is built regardless of whether anything listed in "
"``<filesOrDirs>`` has changed."
msgstr ""
"如果设置了“USE_STAMP_FILE”，则此函数定义的自定义命令将在重新运行 doxygen "
"时在当前二进制目录中创建一个名为“<targetName>.stamp”的标记文件。有了这个选项，``<filesOrDirs>`` "
"中的所有项目都必须是文件（即没有目录、符号链接或通配符）并且每个文件都必须在调用 ``doxygen_add_docs()`` "
"时存在。如果列出的任何项目丢失或在给出“USE_STAMP_FILE”时不是文件，则会引发错误。将在每个文件上创建依赖关系，以便只有在更新其中一个文件时才会重新运行"
" doxygen。如果没有 ``USE_STAMP_FILE`` 选项，如果构建了 ``<targetName>`` 目标，无论 "
"``<filesOrDirs>`` 中列出的任何内容是否已更改，doxygen 将始终重新运行。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:116
msgid ""
"The contents of the generated ``Doxyfile`` can be customized by setting "
"CMake variables before calling ``doxygen_add_docs()``. Any variable with a"
" name of the form ``DOXYGEN_<tag>`` will have its value substituted for "
"the corresponding ``<tag>`` configuration option in the ``Doxyfile``. See "
"the `Doxygen documentation <https://www.doxygen.nl/manual/config.html>`_ "
"for the full list of supported configuration options."
msgstr ""
"生成的 Doxyfile 的内容可以通过在调用 doxygen_add_docs() 之前设置 CMake 变量来定制。任何名称为 "
"``DOXYGEN_<tag>`` 形式的变量都将用其值替换 ``Doxyfile`` 中相应的 ``<tag>`` "
"配置选项。有关支持的配置选项的完整列表，请参阅`Doxygen 文档 "
"<https://www.doxygen.nl/manual/config.html>`_。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:123
msgid ""
"Some of Doxygen's defaults are overridden to provide more appropriate "
"behavior for a CMake project. Each of the following will be explicitly set"
" unless the variable already has a value before ``doxygen_add_docs()`` is "
"called (with some exceptions noted):"
msgstr ""
"Doxygen 的一些默认设置被覆盖，以便为 CMake 项目提供更合适的行为。除非变量在调用 doxygen_add_docs() "
"之前已经有一个值，否则将显式设置以下各项（注意一些例外）："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:130
msgid ""
"Set to ``YES`` if the ``dot`` component was requested and it was found, "
"``NO`` otherwise. Any existing value of ``DOXYGEN_HAVE_DOT`` is ignored."
msgstr "如果请求了“点”组件并且找到了，则设置为“是”，否则设置为“否”。 ``DOXYGEN_HAVE_DOT`` 的任何现有值都将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:135
msgid ""
"Set to ``YES`` by this module (note that this requires a ``dot`` version "
"newer than 1.8.10). This option is only meaningful if ``DOXYGEN_HAVE_DOT``"
" is also set to ``YES``."
msgstr ""
"由该模块设置为“YES”（注意这需要比 1.8.10 更新的“dot”版本）。此选项仅在 ``DOXYGEN_HAVE_DOT`` 也设置为 "
"``YES`` 时才有意义。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:141
msgid "Set to ``NO`` by this module."
msgstr "由这个模块设置为``NO``。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:145
msgid ""
"For Visual Studio based generators, this is set to the form recognized by "
"the Visual Studio IDE: ``$file($line) : $text``. For all other generators,"
" Doxygen's default value is not overridden."
msgstr ""
"对于基于 Visual Studio 的生成器，这被设置为 Visual Studio IDE 识别的形式：``$file($line) : "
"$text``。对于所有其他生成器，不会覆盖 Doxygen 的默认值。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:151
msgid ""
"Populated with the name of the current project (i.e. "
":variable:`PROJECT_NAME`)."
msgstr "填充当前项目的名称（即 :variable:`PROJECT_NAME`）。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:156
msgid ""
"Populated with the version of the current project (i.e. "
":variable:`PROJECT_VERSION`)."
msgstr "填充当前项目的版本（即 :variable:`PROJECT_VERSION`）。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:161
msgid ""
"Populated with the description of the current project (i.e. "
":variable:`PROJECT_DESCRIPTION`)."
msgstr "填充了当前项目的描述（即 :variable:`PROJECT_DESCRIPTION`）。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:166
msgid ""
"Projects should not set this variable. It will be populated with the set "
"of files and directories passed to ``doxygen_add_docs()``, thereby "
"providing consistent behavior with the other built-in commands like "
":command:`add_executable`, :command:`add_library` and "
":command:`add_custom_target`. If a variable named ``DOXYGEN_INPUT`` is set"
" by the project, it will be ignored and a warning will be issued."
msgstr ""
"项目不应设置此变量。它将用传递给 ``doxygen_add_docs()`` 的文件和目录集填充，从而提供与其他内置命令一致的行为，如 "
":command:`add_executable`、 :command:`add_library` 和 :command: "
"`add_custom_target`。如果项目设置了名为 DOXYGEN_INPUT 的变量，它将被忽略并发出警告。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:175
msgid "Set to ``YES`` by this module."
msgstr "由该模块设置为“是”。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:179
msgid ""
"If the set of inputs includes directories, this variable will specify "
"patterns used to exclude files from them. The following patterns are added"
" by ``doxygen_add_docs()`` to ensure CMake-specific files and directories "
"are not included in the input. If the project sets "
"``DOXYGEN_EXCLUDE_PATTERNS``, those contents are merged with these "
"additional patterns rather than replacing them:"
msgstr ""
"如果输入集包括目录，则此变量将指定用于从中排除文件的模式。 ``doxygen_add_docs()`` 添加了以下模式，以确保特定于 CMake "
"的文件和目录不包含在输入中。如果项目设置了 ``DOXYGEN_EXCLUDE_PATTERNS``，这些内容将与这些额外的模式合并而不是替换它们："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:199
msgid ""
"Set to :variable:`CMAKE_CURRENT_BINARY_DIR` by this module. Note that if "
"the project provides its own value for this and it is a relative path, it "
"will be converted to an absolute path relative to the current binary "
"directory. This is necessary because doxygen will normally be run from a "
"directory within the source tree so that relative source paths work as "
"expected. If this directory does not exist, it will be recursively created"
" prior to executing the doxygen commands."
msgstr ""
"由该模块设置为 "
":variable:`CMAKE_CURRENT_BINARY_DIR`。请注意，如果项目为此提供了自己的值并且它是相对路径，它将转换为相对于当前二进制目录的绝对路径。这是必要的，因为"
" doxygen 通常会从源代码树中的目录运行，以便相对源路径按预期工作。如果这个目录不存在，它将在执行 doxygen 命令之前递归创建。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:207
msgid ""
"To change any of these defaults or override any other Doxygen config "
"option, set relevant variables before calling ``doxygen_add_docs()``. For "
"example:"
msgstr ""
"要更改任何这些默认值或覆盖任何其他 Doxygen 配置选项，请在调用 ``doxygen_add_docs()`` 之前设置相关变量。例如："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:221
msgid ""
"A number of Doxygen config options accept lists of values, but Doxygen "
"requires them to be separated by whitespace. CMake variables hold lists as"
" a string with items separated by semi-colons, so a conversion needs to be"
" performed. The ``doxygen_add_docs()`` command specifically checks the "
"following Doxygen config options and will convert their associated CMake "
"variable's contents into the required form if set. CMake variables are "
"named ``DOXYGEN_<name>`` for the Doxygen settings specified here."
msgstr ""
"许多 Doxygen 配置选项接受值列表，但 Doxygen 要求它们以空格分隔。 CMake "
"变量将列表保存为字符串，其中项目以分号分隔，因此需要执行转换。 ``doxygen_add_docs()`` 命令专门检查以下 Doxygen "
"配置选项，并将其关联的 CMake 变量的内容转换为所需的形式（如果已设置）。对于此处指定的 Doxygen 设置，CMake 变量被命名为 "
"``DOXYGEN_<name>``。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:270
msgid ""
"The following single value Doxygen options will be quoted automatically if"
" they contain at least one space:"
msgstr "如果以下单值 Doxygen 选项包含至少一个空格，它们将被自动引用："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:318
msgid ""
"There are situations where it may be undesirable for a particular config "
"option to be automatically quoted by ``doxygen_add_docs()``, such as "
"``ALIASES`` which may need to include its own embedded quoting.  The "
"``DOXYGEN_VERBATIM_VARS`` variable can be used to specify a list of "
"Doxygen variables (including the leading ``DOXYGEN_`` prefix) which should"
" not be quoted.  The project is then responsible for ensuring that those "
"variables' values make sense when placed directly in the Doxygen input "
"file.  In the case of list variables, list items are still separated by "
"spaces, it is only the automatic quoting that is skipped.  For example, "
"the following allows ``doxygen_add_docs()`` to apply quoting to "
"``DOXYGEN_PROJECT_BRIEF``, but not each item in the ``DOXYGEN_ALIASES`` "
"list (:ref:`bracket syntax <Bracket Argument>` can also be used to make "
"working with embedded quotes easier):"
msgstr ""
"在某些情况下，“doxygen_add_docs()”自动引用特定配置选项可能是不可取的，例如“ALIASES”可能需要包含其自己的嵌入式引用。 "
"``DOXYGEN_VERBATIM_VARS`` 变量可用于指定不应被引用的 Doxygen 变量列表（包括前导的 ``DOXYGEN_`` "
"前缀）。然后该项目负责确保这些变量的值在直接放置在 Doxygen "
"输入文件中时有意义。在列表变量的情况下，列表项仍然由空格分隔，只是跳过了自动引用。例如，以下允许 ``doxygen_add_docs()`` "
"将引号应用于 ``DOXYGEN_PROJECT_BRIEF``，但不是 ``DOXYGEN_ALIASES`` "
"列表中的每个项目（ :ref:`bracket syntax <Bracket Argument>` 也可以是用于使使用嵌入式引号更容易）："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:341
msgid "The resultant ``Doxyfile`` will contain the following lines:"
msgstr "生成的 ``Doxyfile`` 将包含以下几行："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:350
msgid "Deprecated Result Variables"
msgstr "弃用的结果变量"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:354
msgid ""
"For compatibility with previous versions of CMake, the following variables"
" are also defined but they are deprecated and should no longer be used:"
msgstr "为了与以前版本的 CMake 兼容，还定义了以下变量，但它们已被弃用，不应再使用："

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:359
msgid ""
"The path to the ``doxygen`` command. If projects need to refer to the "
"``doxygen`` executable directly, they should use the ``Doxygen::doxygen`` "
"import target instead."
msgstr ""
"``doxygen`` 命令的路径。如果项目需要直接引用 ``doxygen`` 可执行文件，他们应该使用 ``Doxygen::doxygen``"
" 导入目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:365
msgid "True if the ``dot`` executable was found."
msgstr "如果找到“点”可执行文件，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:369
msgid ""
"The path to the ``dot`` command. If projects need to refer to the ``dot`` "
"executable directly, they should use the ``Doxygen::dot`` import target "
"instead."
msgstr ""
"``dot`` 命令的路径。如果项目需要直接引用 ``dot`` 可执行文件，他们应该使用 ``Doxygen::dot`` 导入目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:375
msgid ""
"The path to the directory containing the ``dot`` executable as reported in"
" ``DOXYGEN_DOT_EXECUTABLE``. The path may have forward slashes even on "
"Windows and is not suitable for direct substitution into a ``Doxyfile.in``"
" template. If you need this value, get the :prop_tgt:`IMPORTED_LOCATION` "
"property of the ``Doxygen::dot`` target and use "
":command:`get_filename_component` to extract the directory part of that "
"path. You may also want to consider using :command:`file(TO_NATIVE_PATH)` "
"to prepare the path for a Doxygen configuration file."
msgstr ""
"包含在 DOXYGEN_DOT_EXECUTABLE 中报告的 ``dot`` 可执行文件的目录路径。该路径甚至在 Windows "
"上也可能有正斜杠，并且不适合直接替换为 ``Doxyfile.in`` 模板。如果您需要此值，请获取 Doxygen::dot 目标的 "
"IMPORTED_LOCATION 属性，并使用 get_filename_component 提取该路径的目录部分。您可能还想考虑使用 "
":command:`file(TO_NATIVE_PATH)` 为 Doxygen 配置文件准备路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:386
msgid "Deprecated Hint Variables"
msgstr "弃用的提示变量"

#: ../../cmake-prefix/src/cmake/Modules/FindDoxygen.cmake:392
msgid ""
"This variable has no effect for the component form of ``find_package``. In"
" backward compatibility mode (i.e. without components list) it prevents "
"the finder module from searching for Graphviz's ``dot`` utility."
msgstr ""
"此变量对 find_package 的组件形式没有影响。在向后兼容模式下（即没有组件列表），它会阻止 finder 模块搜索 Graphviz "
"的“点”实用程序。"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:6
msgid "FindEXPAT"
msgstr "查找EXPAT"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:8
msgid ""
"Find the native Expat headers and library. Expat is a stream-oriented XML "
"parser library written in C."
msgstr "查找本机 Expat 标头和库。 Expat 是一个用 C 编写的面向流的 XML 解析器库。"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:19
msgid "``EXPAT::EXPAT``"
msgstr "``EXPAT::EXPAT``"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:19
msgid "The Expat ``expat`` library, if found."
msgstr "Expat ``expat`` 库，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:26
msgid "``EXPAT_INCLUDE_DIRS``"
msgstr "``EXPAT_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:27
msgid "where to find expat.h, etc."
msgstr "在哪里可以找到 expat.h 等"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:28
msgid "``EXPAT_LIBRARIES``"
msgstr "``EXPAT_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:29
msgid "the libraries to link against to use Expat."
msgstr "要链接的库以使用 Expat。"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:83
msgid "``EXPAT_FOUND``"
msgstr "``EXPAT_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindEXPAT.cmake:31
msgid "true if the Expat headers and libraries were found."
msgstr "如果找到 Expat 标头和库，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:6
msgid "FindEnvModules"
msgstr "查找环境模块"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:10
msgid ""
"Locate an environment module implementation and make commands available to"
" CMake scripts to use them.  This is compatible with both Lua-based Lmod "
"and TCL-based EnvironmentModules."
msgstr "找到一个环境模块实现并使命令可用于 CMake 脚本以使用它们。这与基于 Lua 的 Lmod 和基于 TCL 的环境模块兼容。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:14
msgid ""
"This module is intended for the use case of setting up the compiler and "
"library environment within a :ref:`CTest Script <CTest Script>` (``ctest "
"-S``).  It can also be used in a :ref:`CMake Script <Script Processing "
"Mode>` (``cmake -P``)."
msgstr ""
"此模块适用于在 CTest Script <CTest Script>` (``ctest -S``) 中设置编译器和库环境的用例。它也可以在 "
":ref:`CMake Script <Script Processing Mode>` (``cmake -P``) 中使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:20
msgid ""
"The loaded environment will not survive past the end of the calling "
"process. Do not use this module in project code (``CMakeLists.txt`` files)"
" to load a compiler environment; it will not be available during the "
"build.  Instead load the environment manually before running CMake or "
"using the generated build system."
msgstr ""
"加载的环境将不会在调用过程结束后继续存在。不要在项目代码（``CMakeLists.txt`` "
"文件）中使用此模块来加载编译环境；在构建期间它将不可用。而是在运行 CMake 或使用生成的构建系统之前手动加载环境。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:76
#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:100
#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:142
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:252
msgid "Example Usage"
msgstr "用法示例"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:58
msgid "``EnvModules_FOUND``"
msgstr "``EnvModules_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:58
msgid "True if a compatible environment modules framework was found."
msgstr "如果找到兼容的环境模块框架，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:83
msgid "Cache Variables"
msgstr "缓存变量"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:63
msgid "The following cache variable will be set:"
msgstr "将设置以下缓存变量："

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:67
msgid "``EnvModules_COMMAND``"
msgstr "``EnvModules_COMMAND``"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:66
msgid ""
"The low level module command to use.  Currently supported implementations "
"are the Lua based Lmod and TCL based EnvironmentModules."
msgstr "要使用的低级模块命令。当前支持的实现是基于 Lua 的 Lmod 和基于 TCL 的 EnvironmentModules。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:70
msgid "Environment Variables"
msgstr "环境变量"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:74
msgid "``ENV{MODULESHOME}``"
msgstr "``ENV{MODULESHOME}``"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:73
msgid ""
"Usually set by the module environment implementation, used as a hint to "
"locate the module command to execute."
msgstr "通常由模块环境实现设置，用作定位要执行的模块命令的提示。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:77
msgid "Provided Functions"
msgstr "提供的功能"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:79
msgid ""
"This defines the following CMake functions for interacting with "
"environment modules:"
msgstr "这定义了以下用于与环境模块交互的 CMake 函数："

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:84
msgid "Execute an aribitrary module command:"
msgstr "执行任意模块命令："

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:99
msgid "``cmd arg1 ... argN``"
msgstr "``cmd arg1 ... argN``"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:98
msgid ""
"The module sub-command and arguments to execute as if they were passed "
"directly to the module command in your shell environment."
msgstr "要执行的模块子命令和参数，就好像它们直接传递给 shell 环境中的模块命令一样。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:102
#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:122
msgid "``OUTPUT_VARIABLE <out-var>``"
msgstr "``OUTPUT_VARIABLE <输出变量>``"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:102
#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:122
msgid "The standard output from executing the module command."
msgstr "执行模块命令的标准输出。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:104
#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:124
msgid "``RESULT_VARIABLE <ret-var>``"
msgstr "``RESULT_VARIABLE <ret-var>``"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:105
#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:125
msgid "The return code from executing the module command."
msgstr "执行模块命令的返回码。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:109
msgid "Swap one module for another:"
msgstr "将一个模块换成另一个："

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:118
msgid ""
"This is functionally equivalent to the ``module swap out_mod in_mod`` "
"shell command.  The options are:"
msgstr "这在功能上等同于 ``module swap out_mod in_mod`` shell 命令。选项是："

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:129
msgid "Retrieve the list of currently loaded modules:"
msgstr "检索当前加载的模块列表："

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:135
msgid ""
"This is functionally equivalent to the ``module list`` shell command. The "
"result is stored in ``<out-var>`` as a properly formatted CMake "
":ref:`semicolon-separated list <CMake Language Lists>` variable."
msgstr ""
"这在功能上等同于 ``module list`` shell 命令。结果存储在``<out-var>`` 作为格式正确的 CMake "
":ref:`分号分隔列表 <CMake Language Lists>` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:141
msgid "Retrieve the list of available modules:"
msgstr "检索可用模块列表："

#: ../../cmake-prefix/src/cmake/Modules/FindEnvModules.cmake:147
msgid ""
"This is functionally equivalent to the ``module avail <mod-prefix>`` shell"
" command.  The result is stored in ``<out-var>`` as a properly formatted "
"CMake :ref:`semicolon-separated list <CMake Language Lists>` variable."
msgstr ""
"这在功能上等同于 ``module avail <mod-prefix>`` shell 命令。结果存储在``<out-var>`` 作为格式正确的"
" CMake :ref:`分号分隔列表 <CMake Language Lists>` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:6
msgid "FindFLEX"
msgstr "查找FLEX"

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:8
msgid ""
"Find Fast Lexical Analyzer (Flex) executable and provides a macro to "
"generate custom build rules"
msgstr "查找快速词法分析器 (Flex) 可执行文件并提供一个宏来生成自定义构建规则"

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:25
msgid ""
"The minimum required version of flex can be specified using the standard "
"syntax, e.g.  :command:`find_package(FLEX 2.5.13)`"
msgstr "可以使用标准语法指定最低要求的 flex 版本，例如 :command:`find_package（FLEX 2.5.13）`"

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:30
msgid "If flex is found on the system, the module provides the macro:"
msgstr "如果在系统上找到 flex，则该模块提供宏："

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:39
msgid ""
"which creates a custom command to generate the ``FlexOutput`` file from "
"the ``FlexInput`` file.  Name is an alias used to get details of this "
"custom command.  If ``COMPILE_FLAGS`` option is specified, the next "
"parameter is added to the flex command line."
msgstr ""
"它创建一个自定义命令以从 ``FlexInput`` 文件生成 ``FlexOutput`` "
"文件。名称是用于获取此自定义命令的详细信息的别名。如果指定了 COMPILE_FLAGS 选项，则将下一个参数添加到 flex 命令行。"

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:44
msgid ""
"If flex is configured to output a header file, the ``DEFINES_FILE`` option"
" may be used to specify its name."
msgstr "如果 flex 配置为输出头文件，则可以使用“DEFINES_FILE”选项来指定其名称。"

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:49
msgid ""
"When :policy:`CMP0098` is set to ``NEW``, ``flex`` runs in the "
":variable:`CMAKE_CURRENT_BINARY_DIR` directory."
msgstr "当 CMP0098 设置为 NEW 时，flex 在 CMAKE_CURRENT_BINARY_DIR 目录中运行。"

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:65
msgid ""
"Flex scanners often use tokens defined by Bison: the code generated by "
"Flex depends of the header generated by Bison.  This module also defines a"
" macro:"
msgstr "Flex 扫描器通常使用 Bison 定义的令牌：Flex 生成的代码取决于 Bison 生成的标头。该模块还定义了一个宏："

#: ../../cmake-prefix/src/cmake/Modules/FindFLEX.cmake:73
msgid ""
"which adds the required dependency between a scanner and a parser where "
"``FlexTarget`` and ``BisonTarget`` are the first parameters of "
"respectively ``FLEX_TARGET`` and ``BISON_TARGET`` macros."
msgstr ""
"它在扫描器和解析器之间添加了所需的依赖关系，其中 ``FlexTarget`` 和 ``BisonTarget`` 分别是 "
"``FLEX_TARGET`` 和 ``BISON_TARGET`` 宏的第一个参数。"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:6
msgid "FindFLTK"
msgstr "查找FLTK"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:8
msgid "Find the Fast Light Toolkit (FLTK) library"
msgstr "查找 Fast Light Toolkit (FLTK) 库"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:13
msgid ""
"By default this module will search for all of the FLTK components and add "
"them to the ``FLTK_LIBRARIES`` variable.  You can limit the components "
"which get placed in ``FLTK_LIBRARIES`` by defining one or more of the "
"following three options:"
msgstr ""
"默认情况下，此模块将搜索所有 FLTK "
"组件并将它们添加到“FLTK_LIBRARIES”变量中。您可以通过定义以下三个选项中的一个或多个来限制放置在“FLTK_LIBRARIES”中的组件："

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:19
msgid "``FLTK_SKIP_OPENGL``"
msgstr "``FLTK_SKIP_OPENGL``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:19
msgid "Set to true to disable searching for the FLTK GL library"
msgstr "设置为 true 以禁用搜索 FLTK GL 库"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:22
msgid "``FLTK_SKIP_FORMS``"
msgstr "``FLTK_SKIP_FORMS``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:22
msgid "Set to true to disable searching for the FLTK Forms library"
msgstr "设置为 true 以禁用搜索 FLTK Forms 库"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:25
msgid "``FLTK_SKIP_IMAGES``"
msgstr "``FLTK_SKIP_IMAGES``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:25
msgid "Set to true to disable searching for the FLTK Images library"
msgstr "设置为 true 以禁用搜索 FLTK 图像库"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:27
msgid ""
"FLTK is composed also by a binary tool. You can set the following option:"
msgstr "FLTK 也是由二进制工具编写的。您可以设置以下选项："

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:30
msgid "``FLTK_SKIP_FLUID``"
msgstr "``FLTK_SKIP_FLUID``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:30
msgid "Set to true to not look for the FLUID binary"
msgstr "设置为 true 以不查找 FLUID 二进制文件"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:35
msgid "The following variables will be defined:"
msgstr "将定义以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:38
msgid "``FLTK_FOUND``"
msgstr "``FLTK_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:38
msgid "True if all components not skipped were found"
msgstr "如果找到所有未跳过的组件，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:41
msgid "``FLTK_INCLUDE_DIR``"
msgstr "``FLTK_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:41
msgid "Path to the include directory for FLTK header files"
msgstr "FLTK 头文件的包含目录的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:44
msgid "``FLTK_LIBRARIES``"
msgstr "``FLTK_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:44
msgid "List of the FLTK libraries found"
msgstr "找到的 FLTK 库列表"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:47
msgid "``FLTK_FLUID_EXECUTABLE``"
msgstr "``FLTK_FLUID_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:47
msgid "Path to the FLUID binary tool"
msgstr "FLUID 二进制工具的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:50
msgid "``FLTK_WRAP_UI``"
msgstr "``FLTK_WRAP_UI``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:50
msgid "True if FLUID is found, used to enable the FLTK_WRAP_UI command"
msgstr "如果找到 FLUID，则为真，用于启用 FLTK_WRAP_UI 命令"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:58
msgid "``FLTK_BASE_LIBRARY_RELEASE``"
msgstr "``FLTK_BASE_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:58
msgid "The FLTK base library (optimized)"
msgstr "FLTK基础库（优化）"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:61
msgid "``FLTK_BASE_LIBRARY_DEBUG``"
msgstr "``FLTK_BASE_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:61
msgid "The FLTK base library (debug)"
msgstr "FLTK 基础库（调试）"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:64
msgid "``FLTK_GL_LIBRARY_RELEASE``"
msgstr "``FLTK_GL_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:64
msgid "The FLTK GL library (optimized)"
msgstr "FLTK GL 库（优化）"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:67
msgid "``FLTK_GL_LIBRARY_DEBUG``"
msgstr "``FLTK_GL_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:67
msgid "The FLTK GL library (debug)"
msgstr "FLTK GL 库（调试）"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:70
msgid "``FLTK_FORMS_LIBRARY_RELEASE``"
msgstr "``FLTK_FORMS_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:70
msgid "The FLTK Forms library (optimized)"
msgstr "FLTK Forms 库（优化）"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:73
msgid "``FLTK_FORMS_LIBRARY_DEBUG``"
msgstr "``FLTK_FORMS_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:73
msgid "The FLTK Forms library (debug)"
msgstr "FLTK 表单库（调试）"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:76
msgid "``FLTK_IMAGES_LIBRARY_RELEASE``"
msgstr "``FLTK_IMAGES_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:76
msgid "The FLTK Images protobuf library (optimized)"
msgstr "FLTK 图像 protobuf 库（优化）"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:79
msgid "``FLTK_IMAGES_LIBRARY_DEBUG``"
msgstr "``FLTK_IMAGES_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:79
msgid "The FLTK Images library (debug)"
msgstr "FLTK 图像库（调试）"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK.cmake:81
msgid ""
"Debug and Release variants are found separately and use per-configuration "
"variables."
msgstr "调试和发布变体是单独找到的，并使用每个配置变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK2.cmake:6
msgid "FindFLTK2"
msgstr "找到FLTK2"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK2.cmake:8
msgid "Find the native FLTK 2.0 includes and library"
msgstr "查找本机 FLTK 2.0 包含和库"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK2.cmake:10
msgid "The following settings are defined"
msgstr "定义了以下设置"

#: ../../cmake-prefix/src/cmake/Modules/FindFLTK2.cmake:20
msgid "The following settings should not be used in general."
msgstr "通常不应使用以下设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:6
msgid "FindFontconfig"
msgstr "查找字体配置"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:10
msgid "Find Fontconfig headers and library."
msgstr "查找 Fontconfig 标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:16
msgid "``Fontconfig::Fontconfig``"
msgstr "``字体配置 ::字体配置``"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:16
msgid "The Fontconfig library, if found."
msgstr "Fontconfig 库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:21
msgid "This will define the following variables in your project:"
msgstr "这将在您的项目中定义以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:23
msgid "``Fontconfig_FOUND``"
msgstr "``Fontconfig_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:24
msgid "true if (the requested version of) Fontconfig is available."
msgstr "如果（请求的版本）Fontconfig 可用，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:25
msgid "``Fontconfig_VERSION``"
msgstr "``Fontconfig_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:26
msgid "the version of Fontconfig."
msgstr "字体配置的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:27
msgid "``Fontconfig_LIBRARIES``"
msgstr "``Fontconfig_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:28
msgid "the libraries to link against to use Fontconfig."
msgstr "要链接的库以使用 Fontconfig。"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:29
msgid "``Fontconfig_INCLUDE_DIRS``"
msgstr "``Fontconfig INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:30
msgid "where to find the Fontconfig headers."
msgstr "在哪里可以找到 Fontconfig 标头。"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:103
msgid "``Fontconfig_COMPILE_OPTIONS``"
msgstr "``Fontconfig_COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindFontconfig.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:32
msgid ""
"this should be passed to target_compile_options(), if the target is not "
"used for linking"
msgstr "如果目标不用于链接，则应将其传递给 target_compile_options()"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:6
msgid "FindFreetype"
msgstr "查找Freetype"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:8
msgid "Find the FreeType font renderer includes and library."
msgstr "找到 FreeType 字体渲染器包含和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:16
#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:16
#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:15
msgid "This module defines the following :prop_tgt:`IMPORTED` target:"
msgstr "该模块定义了以下 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:18
msgid "``Freetype::Freetype``"
msgstr "``自由类型 ::自由类型``"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:18
msgid "The Freetype ``freetype`` library, if found"
msgstr "Freetype ``freetype`` 库，如果找到的话"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:25
msgid "``FREETYPE_FOUND``"
msgstr "``FREETYPE_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:26
msgid "true if the Freetype headers and libraries were found"
msgstr "如果找到 Freetype 标头和库，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:33
msgid "``FREETYPE_INCLUDE_DIRS``"
msgstr "``FREETYPE_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:28
msgid ""
"directories containing the Freetype headers. This is the concatenation of "
"the variables:"
msgstr "包含 Freetype 标头的目录。这是变量的串联："

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:31
msgid "``FREETYPE_INCLUDE_DIR_ft2build``"
msgstr "``FREETYPE_INCLUDE_DIR_ft2build``"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:32
msgid "directory holding the main Freetype API configuration header"
msgstr "包含主要 Freetype API 配置标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:33
msgid "``FREETYPE_INCLUDE_DIR_freetype2``"
msgstr "``FREETYPE_INCLUDE_DIR_freetype2``"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:34
msgid "directory holding Freetype public headers"
msgstr "包含 Freetype 公共标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:35
msgid "``FREETYPE_LIBRARIES``"
msgstr "``FREETYPE_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:36
msgid "the library to link against"
msgstr "要链接的库"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:38
msgid "``FREETYPE_VERSION_STRING``"
msgstr "``FREETYPE_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:38
msgid "the version of freetype found"
msgstr "找到的 freetype 版本"

#: ../../cmake-prefix/src/cmake/Modules/FindFreetype.cmake:46
msgid ""
"The user may set the environment variable ``FREETYPE_DIR`` to the root "
"directory of a Freetype installation."
msgstr "用户可以将环境变量“FREETYPE_DIR”设置为 Freetype 安装的根目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindGCCXML.cmake:6
msgid "FindGCCXML"
msgstr "查找GCCXML"

#: ../../cmake-prefix/src/cmake/Modules/FindGCCXML.cmake:8
msgid "Find the GCC-XML front-end executable."
msgstr "找到 GCC-XML 前端可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindGCCXML.cmake:12
msgid "This module will define the following variables:"
msgstr "该模块将定义以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:6
msgid "FindGDAL"
msgstr "查找GDAL"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:8
msgid "Find Geospatial Data Abstraction Library (GDAL)."
msgstr "查找地理空间数据抽象库 (GDAL)。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:15
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``GDAL::GDAL`` if GDAL has"
" been found."
msgstr "如果已找到 GDAL，则此模块定义:prop_tgt:`IMPORTED` 目标``GDAL::GDAL``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:23
msgid "``GDAL_FOUND``"
msgstr "``GDAL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:24
msgid "True if GDAL is found."
msgstr "如果找到 GDAL，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:25
msgid "``GDAL_INCLUDE_DIRS``"
msgstr "``GDAL_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:26
msgid "Include directories for GDAL headers."
msgstr "包括 GDAL 标头的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:27
msgid "``GDAL_LIBRARIES``"
msgstr "``GDAL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:28
msgid "Libraries to link to GDAL."
msgstr "链接到 GDAL 的库。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:31
msgid "``GDAL_VERSION``"
msgstr "``GDAL_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:30
msgid "The version of GDAL found."
msgstr "找到的 GDAL 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:38
msgid "``GDAL_LIBRARY``"
msgstr "``GDAL_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:39
msgid "The libgdal library file."
msgstr "libgdal 库文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:41
msgid "``GDAL_INCLUDE_DIR``"
msgstr "``GDAL_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:41
msgid "The directory containing ``gdal.h``."
msgstr "包含“gdal.h”的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:46
msgid ""
"Set ``GDAL_DIR`` or ``GDAL_ROOT`` in the environment to specify the GDAL "
"installation prefix."
msgstr "在环境中设置``GDAL_DIR``或``GDAL_ROOT``以指定GDAL安装前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:49
msgid "The following variables may be set to modify the search strategy:"
msgstr "可以设置以下变量来修改搜索策略："

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:53
msgid "``FindGDAL_SKIP_GDAL_CONFIG``"
msgstr "``FindGDAL_SKIP_GDAL_CONFIG``"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:52
msgid ""
"If set, ``gdal-config`` will not be used. This can be useful if there are "
"GDAL libraries built with autotools (which provide the tool) and CMake "
"(which do not) in the same environment."
msgstr ""
"如果设置，将不使用``gdal-config``。如果在同一环境中存在使用 autotools（提供工具）和 CMake（不提供）构建的 GDAL "
"库，这将很有用。"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:199
msgid "``GDAL_ADDITIONAL_LIBRARY_VERSIONS``"
msgstr "``GDAL_ADDITIONAL_LIBRARY_VERSIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGDAL.cmake:56
msgid "Extra versions of library names to search for."
msgstr "要搜索的库名称的额外版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:6
msgid "FindGIF"
msgstr "找动图"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:8
msgid ""
"This finds the Graphics Interchange Format (GIF) library (``giflib``)"
msgstr "这会找到图形交换格式 (GIF) 库 (``giflib``)"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:16
msgid "``GIF::GIF``"
msgstr "``GIF::GIF``"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:16
msgid "The ``giflib`` library, if found."
msgstr "``giflib`` 库，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:23
msgid "``GIF_FOUND``"
msgstr "``GIF_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:24
msgid "If false, do not try to use GIF."
msgstr "如果为 false，请不要尝试使用 GIF。"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:25
msgid "``GIF_INCLUDE_DIRS``"
msgstr "``GIF_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:26
msgid "where to find gif_lib.h, etc."
msgstr "在哪里可以找到 gif_lib.h 等"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:27
msgid "``GIF_LIBRARIES``"
msgstr "``GIF_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:28
msgid "the libraries needed to use GIF."
msgstr "使用 GIF 所需的库。"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:30
msgid "``GIF_VERSION``"
msgstr "``GIF_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:30
msgid "3, 4 or a full version string (eg 5.1.4) for versions >= 4.1.6."
msgstr "3、4 或版本 >= 4.1.6 的完整版本字符串（例如 5.1.4）。"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:37
msgid "``GIF_INCLUDE_DIR``"
msgstr "``GIF_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:38
msgid "where to find the GIF headers."
msgstr "在哪里可以找到 GIF 标题。"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:40
msgid "``GIF_LIBRARY``"
msgstr "``GIF_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:40
msgid "where to find the GIF library."
msgstr "在哪里可以找到 GIF 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindGIF.cmake:45
msgid ""
"``GIF_DIR`` is an environment variable that would correspond to the "
"``./configure --prefix=$GIF_DIR``."
msgstr "``GIF_DIR`` 是一个环境变量，对应于 ``./configure --prefix=$GIF_DIR``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:6
msgid "FindGLEW"
msgstr "寻找GLEW"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:8
msgid "Find the OpenGL Extension Wrangler Library (GLEW)"
msgstr "查找 OpenGL Extension Wrangler 库 (GLEW)"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:16
msgid "``GLEW_USE_STATIC_LIBS``"
msgstr "``GLEW_USE_STATIC_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:16
msgid "to find and create :prop_tgt:`IMPORTED` target for static linkage."
msgstr "为静态链接查找和创建 :prop_tgt:`IMPORTED` 目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:19
msgid "``GLEW_VERBOSE``"
msgstr "``GLEW_VERBOSE``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:19
msgid "to output a detailed log of this module."
msgstr "输出该模块的详细日志。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:26
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:73
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:67
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:74
msgid ""
"This module defines the following :ref:`Imported Targets <Imported "
"Targets>`:"
msgstr "此模块定义以下:ref:`Imported Targets <Imported Targets>`："

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:29
msgid "``GLEW::glew``"
msgstr "``GLEW::glew``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:30
msgid "The GLEW shared library."
msgstr "GLEW 共享库。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:31
msgid "``GLEW::glew_s``"
msgstr "``GLEW::glew_s``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:32
msgid ""
"The GLEW static library, if ``GLEW_USE_STATIC_LIBS`` is set to ``TRUE``."
msgstr "GLEW 静态库，如果``GLEW_USE_STATIC_LIBS`` 设置为``TRUE``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:34
msgid "``GLEW::GLEW``"
msgstr "``GLEW::GLEW``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:34
msgid ""
"Duplicates either ``GLEW::glew`` or ``GLEW::glew_s`` based on "
"availability."
msgstr "根据可用性复制``GLEW::glew`` 或``GLEW::glew_s``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:41
msgid "``GLEW_INCLUDE_DIRS``"
msgstr "``GLEW_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:42
msgid "include directories for GLEW"
msgstr "包含 GLEW 的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:43
msgid "``GLEW_LIBRARIES``"
msgstr "``GLEW_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:44
msgid "libraries to link against GLEW"
msgstr "链接到 GLEW 的库"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:45
msgid "``GLEW_SHARED_LIBRARIES``"
msgstr "``GLEW_SHARED_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:46
msgid "libraries to link against shared GLEW"
msgstr "链接共享 GLEW 的库"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:47
msgid "``GLEW_STATIC_LIBRARIES``"
msgstr "``GLEW_STATIC_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:48
msgid "libraries to link against static GLEW"
msgstr "链接静态 GLEW 的库"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:49
msgid "``GLEW_FOUND``"
msgstr "``GLEW_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:50
msgid "true if GLEW has been found and can be used"
msgstr "如果已找到 GLEW 并且可以使用，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:51
msgid "``GLEW_VERSION``"
msgstr "``GLEW_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:52
msgid "GLEW version"
msgstr "GLEW版本"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:53
msgid "``GLEW_VERSION_MAJOR``"
msgstr "``GLEW_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:54
msgid "GLEW major version"
msgstr "GLEW 主要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:55
msgid "``GLEW_VERSION_MINOR``"
msgstr "``GLEW_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:56
msgid "GLEW minor version"
msgstr "GLEW 次要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:58
msgid "``GLEW_VERSION_MICRO``"
msgstr "``GLEW_VERSION_MICRO``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLEW.cmake:58
msgid "GLEW micro version"
msgstr "GLEW 微型版"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:6
msgid "FindGLUT"
msgstr "查找GLUT"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:8
msgid "Find OpenGL Utility Toolkit (GLUT) library and include files."
msgstr "查找 OpenGL Utility Toolkit (GLUT) 库和包含文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:18
msgid "``GLUT::GLUT``"
msgstr "``过剩 ::过剩``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:18
msgid "Defined if the system has GLUT."
msgstr "定义系统是否有 GLUT。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:26
msgid "``GLUT_FOUND``"
msgstr "``GLUT_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:26
msgid "True if ``glut`` was found."
msgstr "如果发现“过剩”，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:31
msgid "``GLUT_INCLUDE_DIRS``"
msgstr "``GLUT_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:31
msgid "Where to find GL/glut.h, etc."
msgstr "在哪里可以找到 GL/glut.h 等"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:34
msgid "``GLUT_LIBRARIES``"
msgstr "``GLUT_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:34
msgid "List of libraries for using ``glut``."
msgstr "使用 ``glut`` 的库列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:39
msgid ""
"This module may set the following variables depending on platform. These "
"variables may optionally be set to help this module find the correct "
"files, but clients should not use these as results:"
msgstr "该模块可以根据平台设置以下变量。可以选择设置这些变量以帮助此模块找到正确的文件，但客户端不应将这些用作结果："

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:45
#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:242
msgid "``GLUT_INCLUDE_DIR``"
msgstr "``GLUT_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:44
msgid ""
"The full path to the directory containing ``GL/glut.h``, not including "
"``GL/``."
msgstr "包含 ``GL/glut.h`` 的目录的完整路径，不包括 ``GL/``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:48
msgid "``GLUT_glut_LIBRARY``"
msgstr "``GLUT_glut_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:48
msgid "The full path to the glut library."
msgstr "过剩库的完整路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:51
msgid "``GLUT_Xmu_LIBRARY``"
msgstr "``GLUT_Xmu_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:51
msgid "The full path to the Xmu library."
msgstr "Xmu 库的完整路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:54
msgid "``GLUT_Xi_LIBRARY``"
msgstr "``GLUT_Xi_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:54
msgid "The full path to the Xi Library."
msgstr "Xi 图书馆的完整路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:57
msgid "Obsolete Variables"
msgstr "过时的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:59
msgid ""
"The following variables may also be provided, for backwards compatibility:"
msgstr "为了向后兼容，还可以提供以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindGLUT.cmake:62
msgid ""
"This is one of above `Cache Variables`_, but prior to CMake 3.23 was also "
"a result variable.  Prefer to use ``GLUT_INCLUDE_DIRS`` instead in CMake "
"3.23 and above."
msgstr ""
"这是上面的“缓存变量”之一，但在 CMake 3.23 之前也是一个结果变量。在 CMake 3.23 及更高版本中更喜欢使用 "
"``GLUT_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:6
msgid "FindGSL"
msgstr "查找GSL"

#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:10
msgid "Find the native GNU Scientific Library (GSL) includes and libraries."
msgstr "查找本地 GNU 科学图书馆 (GSL) 包含和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:12
msgid ""
"The GNU Scientific Library (GSL) is a numerical library for C and C++ "
"programmers. It is free software under the GNU General Public License."
msgstr ""
"GNU Scientific Library (GSL) 是一个面向 C 和 C++ 程序员的数值库。它是 GNU 通用公共许可证下的免费软件。"

#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:19
msgid ""
"If GSL is found, this module defines the following :prop_tgt:`IMPORTED` "
"targets::"
msgstr "如果找到 GSL，则此模块定义以下 :prop_tgt:`IMPORTED` 目标 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:28
msgid "This module will set the following variables in your project::"
msgstr "该模块将在您的项目中设置以下变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:38
msgid ""
"Set ``GSL_ROOT_DIR`` to a directory that contains a GSL installation."
msgstr "将“GSL_ROOT_DIR”设置为包含 GSL 安装的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:40
msgid ""
"This script expects to find libraries at ``$GSL_ROOT_DIR/lib`` and the GSL"
" headers at ``$GSL_ROOT_DIR/include/gsl``.  The library directory may "
"optionally provide Release and Debug folders. If available, the libraries "
"named ``gsld``, ``gslblasd`` or ``cblasd`` are recognized as debug "
"libraries. For Unix-like systems, this script will use "
"``$GSL_ROOT_DIR/bin/gsl-config`` (if found) to aid in the discovery of "
"GSL."
msgstr ""
"该脚本期望在“$GSL_ROOT_DIR/lib”中找到库，在“$GSL_ROOT_DIR/include/gsl”中找到 GSL "
"标头。库目录可以选择提供 Release 和 Debug "
"文件夹。如果可用，名为“gsld”、“gslblasd”或“cblasd”的库将被识别为调试库。对于类 Unix "
"系统，此脚本将使用“$GSL_ROOT_DIR/bin/gsl-config”（如果找到）来帮助发现 GSL。"

#: ../../cmake-prefix/src/cmake/Modules/FindGSL.cmake:50
msgid ""
"This module may set the following variables depending on platform and type"
" of GSL installation discovered.  These variables may optionally be set to"
" help this module find the correct files::"
msgstr "该模块可能会根据平台和发现的 GSL 安装类型设置以下变量。可以选择设置这些变量以帮助此模块找到正确的文件 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK.cmake:6
msgid "FindGTK"
msgstr "查找GTK"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK.cmake:8
msgid "Find GTK, glib and GTKGLArea"
msgstr "查找 GTK、glib 和 GTKGLArea"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:6
msgid "FindGTK2"
msgstr "找到GTK2"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:8
msgid ""
"Find the GTK2 widget libraries and several of its other optional "
"components like ``gtkmm``, ``glade``, and ``glademm``."
msgstr "找到 GTK2 小部件库和它的几个其他可选组件，如 ``gtkmm``、``glade`` 和 ``glademm``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:11
msgid ""
"Specify one or more of the following components as you call this find "
"module.  See example below."
msgstr "在调用此查找模块时指定以下一个或多个组件。请参见下面的示例。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:14
msgid "``gtk``"
msgstr "``gtk``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:15
msgid "``gtkmm``"
msgstr "``gtkmm``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:16
msgid "``glade``"
msgstr "``林间空地``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:17
msgid "``glademm``"
msgstr "``glademm``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:22
msgid ""
"This module defines the following :prop_tgt:`IMPORTED` targets (subject to"
" component selection):"
msgstr "该模块定义了以下 :prop_tgt:`IMPORTED` 目标（取决于组件选择）："

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:25
msgid ""
"``GTK2::atk``, ``GTK2::atkmm``, ``GTK2::cairo``, ``GTK2::cairomm``, "
"``GTK2::gdk_pixbuf``, ``GTK2::gdk``, ``GTK2::gdkmm``, ``GTK2::gio``, "
"``GTK2::giomm``, ``GTK2::glade``, ``GTK2::glademm``, ``GTK2::glib``, "
"``GTK2::glibmm``, ``GTK2::gmodule``, ``GTK2::gobject``, ``GTK2::gthread``,"
" ``GTK2::gtk``, ``GTK2::gtkmm``, ``GTK2::harfbuzz``, ``GTK2::pango``, "
"``GTK2::pangocairo``, ``GTK2::pangoft2``, ``GTK2::pangomm``, "
"``GTK2::pangoxft``, ``GTK2::sigc``."
msgstr ""
"``GTK2::atk``、``GTK2::atkmm``、``GTK2::cairo``、``GTK2::cairomm``、``GTK2::gdk_pixbuf``、``GTK2::"
" "
"gdk``、``GTK2::gdkmm``、``GTK2::gio``、``GTK2::giomm``、``GTK2::glade``、``GTK2::glademm``、`"
" "
"`GTK2::glib``、``GTK2::glibmm``、``GTK2::gmodule``、``GTK2::gobject``、``GTK2::gthread``、``GTK2::gtk"
" "
"``，``GTK2::gtkmm``，``GTK2::harfbuzz``，``GTK2::pango``，``GTK2::pangocairo``，``GTK2::pangoft2``，``"
" GTK2::pangomm``、``GTK2::pangoxft``、``GTK2::sigc``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:33
msgid "Added the ``GTK2::harfbuzz`` target."
msgstr "添加了 ``GTK2::harfbuzz`` 目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:39
msgid "The following variables will be defined for your use"
msgstr "将定义以下变量供您使用"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:41
msgid "``GTK2_FOUND``"
msgstr "``GTK2_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:42
msgid "Were all of your specified components found?"
msgstr "是否找到了所有指定的组件？"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:43
msgid "``GTK2_INCLUDE_DIRS``"
msgstr "``GTK2_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:44
msgid "All include directories"
msgstr "全部包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:45
msgid "``GTK2_LIBRARIES``"
msgstr "``GTK2_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:46
msgid "All libraries"
msgstr "所有图书馆"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:48
msgid "``GTK2_TARGETS``"
msgstr "``GTK2_TARGETS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:48
msgid "All imported targets"
msgstr "所有导入的目标"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:50
msgid "``GTK2_DEFINITIONS``"
msgstr "``GTK2_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:51
msgid "Additional compiler flags"
msgstr "额外的编译器标志"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:52
msgid "``GTK2_VERSION``"
msgstr "``GTK2_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:53
msgid "The version of GTK2 found (x.y.z)"
msgstr "找到的 GTK2 版本 (x.y.z)"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:54
msgid "``GTK2_MAJOR_VERSION``"
msgstr "``GTK2_MAJOR_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:55
msgid "The major version of GTK2"
msgstr "GTK2 的主要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:56
msgid "``GTK2_MINOR_VERSION``"
msgstr "``GTK2_MINOR_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:57
msgid "The minor version of GTK2"
msgstr "GTK2 的次要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:59
msgid "``GTK2_PATCH_VERSION``"
msgstr "``GTK2_PATCH_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:59
msgid "The patch version of GTK2"
msgstr "GTK2补丁版"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:61
msgid ""
"When ``GTK2_USE_IMPORTED_TARGETS`` is set to ``TRUE``, ``GTK2_LIBRARIES`` "
"will list imported targets instead of library paths."
msgstr ""
"当 ``GTK2_USE_IMPORTED_TARGETS`` 设置为 ``TRUE`` 时，``GTK2_LIBRARIES`` "
"将列出导入的目标而不是库路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:68
msgid "Optional variables you can define prior to calling this module:"
msgstr "您可以在调用此模块之前定义的可选变量："

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:70
msgid "``GTK2_DEBUG``"
msgstr "``GTK2_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:71
msgid "Enables verbose debugging of the module"
msgstr "启用模块的详细调试"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:73
msgid "``GTK2_ADDITIONAL_SUFFIXES``"
msgstr "``GTK2_ADDITIONAL_SUFFIXES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:73
msgid "Allows defining additional directories to search for include files"
msgstr "允许定义额外的目录来搜索包含文件"

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:78
msgid ""
"Call :command:`find_package` once.  Here are some examples to pick from:"
msgstr "调用 :command:`find_package` 一次。以下是一些可供选择的示例："

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:80
msgid "Require GTK 2.6 or later:"
msgstr "需要 GTK 2.6 或更高版本："

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:86
msgid "Require GTK 2.10 or later and Glade:"
msgstr "需要 GTK 2.10 或更高版本和 Glade："

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:92
msgid "Search for GTK/GTKMM 2.8 or later:"
msgstr "搜索 GTK/GTKMM 2.8 或更高版本："

#: ../../cmake-prefix/src/cmake/Modules/FindGTK2.cmake:98
msgid "Use the results:"
msgstr "使用结果："

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:6
msgid "FindGTest"
msgstr "查找GTest"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:8
msgid "Locate the Google C++ Testing Framework."
msgstr "找到 Google C++ 测试框架。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:10
msgid "Upstream ``GTestConfig.cmake`` is used if possible."
msgstr "如果可能，使用上游``GTestConfig.cmake``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:20
msgid "``GTest::gtest``"
msgstr "``GTest::gtest``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:20
#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:38
msgid ""
"The Google Test ``gtest`` library, if found; adds Thread::Thread "
"automatically"
msgstr "Google Test ``gtest`` 库，如果找到的话；自动添加 Thread::Thread"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:23
msgid "``GTest::gtest_main``"
msgstr "``GTest::gtest_main``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:41
msgid "The Google Test ``gtest_main`` library, if found"
msgstr "Google Test ``gtest_main`` 库，如果找到的话"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:28
msgid "``GTest::gmock``"
msgstr "``GTest::gmock``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:28
msgid ""
"The Google Mock ``gmock`` library, if found; adds Thread::Thread "
"automatically"
msgstr "Google Mock ``gmock`` 库，如果找到的话；自动添加 Thread::Thread"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:31
msgid "``GTest::gmock_main``"
msgstr "``GTest::gmock_main``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:31
msgid "The Google Mock ``gmock_main`` library, if found"
msgstr "Google Mock ``gmock_main`` 库，如果找到的话"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:33
msgid ""
"For backwards compatibility, this module defines additionally the "
"following deprecated :prop_tgt:`IMPORTED` targets (available since 3.5):"
msgstr "为了向后兼容，此模块另外定义了以下已弃用的 :prop_tgt:`IMPORTED` 目标（自 3.5 起可用）："

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:38
msgid "``GTest::GTest``"
msgstr "``GTest::GTest``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:41
msgid "``GTest::Main``"
msgstr "``GTest::Main``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:48
msgid "``GTest_FOUND``"
msgstr "``GTest_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:49
msgid "Found the Google Testing framework"
msgstr "找到谷歌测试框架"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:51
msgid "``GTEST_INCLUDE_DIRS``"
msgstr "``GTEST_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:51
msgid "the directory containing the Google Test headers"
msgstr "包含 Google 测试标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:53
msgid ""
"The library variables below are set as normal variables.  These contain "
"debug/optimized keywords when a debugging library is found."
msgstr "下面的库变量设置为普通变量。当找到调试库时，这些包含调试/优化关键字。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:57
msgid "``GTEST_LIBRARIES``"
msgstr "``GTEST_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:57
msgid ""
"The Google Test ``gtest`` library; note it also requires linking with an "
"appropriate thread library"
msgstr "Google Test ``gtest`` 库；请注意，它还需要与适当的线程库链接"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:59
msgid "``GTEST_MAIN_LIBRARIES``"
msgstr "``GTEST_MAIN_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:60
msgid "The Google Test ``gtest_main`` library"
msgstr "Google Test ``gtest_main`` 库"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:62
msgid "``GTEST_BOTH_LIBRARIES``"
msgstr "``GTEST_BOTH_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:62
msgid "Both ``gtest`` and ``gtest_main``"
msgstr "``gtest`` 和 ``gtest_main``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:70
msgid "``GTEST_ROOT``"
msgstr "``GTEST_ROOT``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:70
msgid ""
"The root directory of the Google Test installation (may also be set as an "
"environment variable)"
msgstr "Google Test 安装的根目录（也可以设置为环境变量）"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:75
msgid "``GTEST_MSVC_SEARCH``"
msgstr "``GTEST_MSVC_SEARCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:73
msgid ""
"If compiling with MSVC, this variable can be set to ``MT`` or ``MD`` (the "
"default) to enable searching a GTest build tree"
msgstr "如果使用 MSVC 编译，这个变量可以设置为 ``MT`` 或 ``MD``（默认值）以启用搜索 GTest 构建树"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:78
msgid "Example usage"
msgstr "用法示例"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:92
msgid "Deeper integration with CTest"
msgstr "与 CTest 深度集成"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:94
msgid ""
"See :module:`GoogleTest` for information on the :command:`gtest_add_tests`"
" and :command:`gtest_discover_tests` commands."
msgstr ""
"有关 :command:`gtest_add_tests` 和 :command:`gtest_discover_tests` "
"命令的信息，请参阅:module:`GoogleTest`。"

#: ../../cmake-prefix/src/cmake/Modules/FindGTest.cmake:97
msgid ""
"Previous CMake versions defined :command:`gtest_add_tests` macro in this "
"module."
msgstr "以前的 CMake 版本在此模块中定义了 :command:`gtest_add_tests` 宏。"

#: ../../cmake-prefix/src/cmake/Modules/FindGettext.cmake:6
msgid "FindGettext"
msgstr "查找Gettext"

#: ../../cmake-prefix/src/cmake/Modules/FindGettext.cmake:8
msgid "Find GNU gettext tools"
msgstr "查找 GNU gettext 工具"

#: ../../cmake-prefix/src/cmake/Modules/FindGettext.cmake:10
msgid ""
"This module looks for the GNU gettext tools.  This module defines the "
"following values:"
msgstr "该模块寻找 GNU gettext 工具。该模块定义了以下值："

#: ../../cmake-prefix/src/cmake/Modules/FindGettext.cmake:22
msgid "Additionally it provides the following macros:"
msgstr "此外，它还提供以下宏："

#: ../../cmake-prefix/src/cmake/Modules/FindGettext.cmake:24
msgid "GETTEXT_CREATE_TRANSLATIONS ( outputFile [ALL] file1 ...  fileN )"
msgstr "GETTEXT_CREATE_TRANSLATIONS ( outputFile [ALL] file1 ... fileN )"

#: ../../cmake-prefix/src/cmake/Modules/FindGettext.cmake:33
msgid ""
"GETTEXT_PROCESS_POT_FILE( <potfile> [ALL] [INSTALL_DESTINATION <destdir>] "
"LANGUAGES <lang1> <lang2> ...  )"
msgstr ""
"GETTEXT_PROCESS_POT_FILE( <potfile> [ALL] [INSTALL_DESTINATION <destdir>] "
"LANGUAGES <lang1> <lang2> ... )"

#: ../../cmake-prefix/src/cmake/Modules/FindGettext.cmake:45
msgid ""
"GETTEXT_PROCESS_PO_FILES( <lang> [ALL] [INSTALL_DESTINATION <dir>] "
"PO_FILES <po1> <po2> ...  )"
msgstr ""
"GETTEXT_PROCESS_PO_FILES( <lang> [ALL] [INSTALL_DESTINATION <dir>] "
"PO_FILES <po1> <po2> ... )"

#: ../../cmake-prefix/src/cmake/Modules/FindGettext.cmake:57
msgid ""
"If you wish to use the Gettext library (libintl), use :module:`FindIntl`."
msgstr "如果您想使用 Gettext 库 (libintl)，请使用 FindIntl。"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:6
msgid "FindGit"
msgstr "查找Git"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:10
msgid "``GIT_EXECUTABLE``"
msgstr "``GIT_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:11
msgid "Path to Git command-line client."
msgstr "Git 命令行客户端的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:12
msgid "``Git_FOUND``, ``GIT_FOUND``"
msgstr "``Git_FOUND``，``GIT_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:13
msgid "True if the Git command-line client was found."
msgstr "如果找到 Git 命令行客户端，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:15
msgid "``GIT_VERSION_STRING``"
msgstr "``GIT_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:15
msgid "The version of Git found."
msgstr "找到的 Git 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:17
msgid ""
"The module defines the following ``IMPORTED`` targets (when "
":prop_gbl:`CMAKE_ROLE` is ``PROJECT``):"
msgstr "该模块定义了以下 ``IMPORTED`` 目标（当 :prop_gbl:`CMAKE_ROLE` 为 ``PROJECT`` 时）："

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:22
msgid "``Git::Git``"
msgstr "``Git::Git``"

#: ../../cmake-prefix/src/cmake/Modules/FindGit.cmake:22
msgid "Executable of the Git command-line client."
msgstr "Git 命令行客户端的可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:6
msgid "FindGnuTLS"
msgstr "查找 GnuTLS"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:8
msgid "Find the GNU Transport Layer Security library (gnutls)"
msgstr "查找 GNU 传输层安全库 (gnutls)"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:15
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``GnuTLS::GnuTLS``, if "
"gnutls has been found."
msgstr "如果已找到 gnutls，此模块定义 :prop_tgt:`IMPORTED` 目标 ``GnuTLS::GnuTLS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:21
msgid "``GNUTLS_FOUND``"
msgstr "``GNUTLS_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:22
msgid "System has gnutls"
msgstr "系统有gnutls"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:23
msgid "``GNUTLS_INCLUDE_DIR``"
msgstr "``GNUTLS_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:24
msgid "The gnutls include directory"
msgstr "gnutls 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:25
msgid "``GNUTLS_LIBRARIES``"
msgstr "``GNUTLS_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:26
msgid "The libraries needed to use gnutls"
msgstr "使用 gnutls 所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:27
msgid "``GNUTLS_DEFINITIONS``"
msgstr "``GNUTLS_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:28
msgid "Compiler switches required for using gnutls"
msgstr "使用 gnutls 所需的编译器开关"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:84
msgid "``GNUTLS_VERSION``"
msgstr "``GNUTLS_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuTLS.cmake:30
msgid "version of gnutls."
msgstr "gnutls 的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuplot.cmake:6
msgid "FindGnuplot"
msgstr "查找 Gnuplot"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuplot.cmake:8
msgid "this module looks for gnuplot"
msgstr "这个模块寻找 gnuplot"

#: ../../cmake-prefix/src/cmake/Modules/FindGnuplot.cmake:22
msgid "GNUPLOT_VERSION_STRING will not work for old versions like 3.7.1."
msgstr "GNUPLOT_VERSION_STRING 不适用于 3.7.1 等旧版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:6
msgid "FindHDF5"
msgstr "查找HDF5"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:8
msgid ""
"Find Hierarchical Data Format (HDF5), a library for reading and writing "
"self describing array data."
msgstr "Find Hierarchical Data Format (HDF5)，一个用于读写自描述数组数据的库。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:12
msgid ""
"This module invokes the ``HDF5`` wrapper compiler that should be installed"
" alongside ``HDF5``.  Depending upon the ``HDF5`` Configuration, the "
"wrapper compiler is called either ``h5cc`` or ``h5pcc``.  If this "
"succeeds, the module will then call the compiler with the show argument to"
" see what flags are used when compiling an ``HDF5`` client application."
msgstr ""
"此模块调用应与“HDF5”一起安装的“HDF5”包装器编译器。根据“HDF5”配置，包装器编译器称为“h5cc”或“h5pcc”。如果成功，该模块将使用"
" show 参数调用编译器，以查看在编译“HDF5”客户端应用程序时使用了哪些标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:18
msgid ""
"The module will optionally accept the ``COMPONENTS`` argument.  If no "
"``COMPONENTS`` are specified, then the find module will default to finding"
" only the ``HDF5`` C library.  If one or more ``COMPONENTS`` are "
"specified, the module will attempt to find the language bindings for the "
"specified components.  The valid components are ``C``, ``CXX``, "
"``Fortran``, ``HL``. ``HL`` refers to the \"high-level\" HDF5 functions "
"for C and Fortran. If the ``COMPONENTS`` argument is not given, the module"
" will attempt to find only the C bindings. For example, to use Fortran "
"HDF5 and HDF5-HL functions, do: ``find_package(HDF5 COMPONENTS Fortran "
"HL)``."
msgstr ""
"该模块将选择性地接受 ``COMPONENTS`` 参数。如果未指定 ``COMPONENTS``，则查找模块将默认仅查找 ``HDF5`` C "
"库。如果指定了一个或多个“COMPONENTS”，模块将尝试为指定的组件查找语言绑定。有效的组件是“C”、“CXX”、“Fortran”、“HL”。"
" ``HL`` 指的是 C 和 Fortran 的“高级”HDF5 函数。如果未给出 ``COMPONENTS`` 参数，模块将尝试仅查找 C "
"绑定。例如，要使用 Fortran HDF5 和 HDF5-HL 函数，请执行：``find_package(HDF5 COMPONENTS "
"Fortran HL)``。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:29
msgid ""
"This module will read the variable ``HDF5_USE_STATIC_LIBRARIES`` to "
"determine whether or not to prefer a static link to a dynamic link for "
"``HDF5`` and all of it's dependencies. To use this feature, make sure that"
" the ``HDF5_USE_STATIC_LIBRARIES`` variable is set before the call to "
"find_package."
msgstr ""
"该模块将读取变量 ``HDF5_USE_STATIC_LIBRARIES`` 以确定对于 ``HDF5`` "
"及其所有依赖项是否更喜欢静态链接而不是动态链接。要使用此功能，请确保在调用 find_package 之前设置了 "
"``HDF5_USE_STATIC_LIBRARIES`` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:35
msgid "Support for ``HDF5_USE_STATIC_LIBRARIES`` on Windows."
msgstr "在 Windows 上支持“HDF5_USE_STATIC_LIBRARIES”。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:38
msgid ""
"Both the serial and parallel ``HDF5`` wrappers are considered and the "
"first directory to contain either one will be used.  In the event that "
"both appear in the same directory the serial version is preferentially "
"selected. This behavior can be reversed by setting the variable "
"``HDF5_PREFER_PARALLEL`` to ``TRUE``."
msgstr ""
"串行和并行“HDF5”包装器都被考虑在内，将使用包含其中任何一个的第一个目录。如果两者出现在同一目录中，则优先选择串行版本。可以通过将变量“HDF5_PREFER_PARALLEL”设置为“TRUE”来逆转此行为。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:44
msgid ""
"In addition to finding the includes and libraries required to compile an "
"``HDF5`` client application, this module also makes an effort to find "
"tools that come with the ``HDF5`` distribution that may be useful for "
"regression testing."
msgstr "除了找到编译“HDF5”客户端应用程序所需的包含和库之外，该模块还努力寻找“HDF5”发行版附带的可能对回归测试有用的工具。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:54
msgid "``HDF5_FOUND``"
msgstr "``HDF5_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:55
msgid "HDF5 was found on the system"
msgstr "在系统上发现 HDF5"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:57
msgid "``HDF5_VERSION``"
msgstr "``HDF5_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:57
msgid "HDF5 library version"
msgstr "HDF5库版本"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:59
msgid "``HDF5_INCLUDE_DIRS``"
msgstr "``HDF5_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:60
msgid "Location of the HDF5 header files"
msgstr "HDF5 头文件的位置"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:61
msgid "``HDF5_DEFINITIONS``"
msgstr "``HDF5_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:62
msgid "Required compiler definitions for HDF5"
msgstr "HDF5 所需的编译器定义"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:63
msgid "``HDF5_LIBRARIES``"
msgstr "``HDF5_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:64
msgid "Required libraries for all requested bindings"
msgstr "所有请求的绑定所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:67
msgid "``HDF5_HL_LIBRARIES``"
msgstr "``HDF5_HL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:66
msgid ""
"Required libraries for the HDF5 high level API for all bindings, if the "
"``HL`` component is enabled"
msgstr "如果启用了 ``HL`` 组件，则所有绑定的 HDF5 高级 API 所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:69
msgid ""
"Available components are: ``C`` ``CXX`` ``Fortran`` and ``HL``. For each "
"enabled language binding, a corresponding ``HDF5_${LANG}_LIBRARIES`` "
"variable, and potentially ``HDF5_${LANG}_DEFINITIONS``, will be defined. "
"If the ``HL`` component is enabled, then an ``HDF5_${LANG}_HL_LIBRARIES`` "
"will also be defined.  With all components enabled, the following "
"variables will be defined:"
msgstr ""
"可用的组件是：``C`` ``CXX`` ``Fortran`` 和 "
"``HL``。对于每个启用的语言绑定，将定义相应的``HDF5_${LANG}_LIBRARIES`` "
"变量，以及可能的``HDF5_${LANG}_DEFINITIONS``。如果启用 ``HL`` 组件，则还将定义 "
"``HDF5_${LANG}_HL_LIBRARIES``。启用所有组件后，将定义以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:75
msgid "``HDF5_C_DEFINITIONS``"
msgstr "``HDF5_C_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:76
msgid "Required compiler definitions for HDF5 C bindings"
msgstr "HDF5 C 绑定所需的编译器定义"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:77
msgid "``HDF5_CXX_DEFINITIONS``"
msgstr "``HDF5_CXX_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:78
msgid "Required compiler definitions for HDF5 C++ bindings"
msgstr "HDF5 C++ 绑定所需的编译器定义"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:79
msgid "``HDF5_Fortran_DEFINITIONS``"
msgstr "``HDF5_Fortran_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:80
msgid "Required compiler definitions for HDF5 Fortran bindings"
msgstr "HDF5 Fortran 绑定所需的编译器定义"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:81
msgid "``HDF5_C_INCLUDE_DIRS``"
msgstr "``HDF5_C_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:82
msgid "Required include directories for HDF5 C bindings"
msgstr "HDF5 C 绑定所需的包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:83
msgid "``HDF5_CXX_INCLUDE_DIRS``"
msgstr "``HDF5_CXX_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:84
msgid "Required include directories for HDF5 C++ bindings"
msgstr "HDF5 C++ 绑定所需的包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:85
msgid "``HDF5_Fortran_INCLUDE_DIRS``"
msgstr "``HDF5_Fortran_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:86
msgid "Required include directories for HDF5 Fortran bindings"
msgstr "HDF5 Fortran 绑定所需的包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:87
msgid "``HDF5_C_LIBRARIES``"
msgstr "``HDF5_C_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:88
msgid "Required libraries for the HDF5 C bindings"
msgstr "HDF5 C 绑定所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:89
msgid "``HDF5_CXX_LIBRARIES``"
msgstr "``HDF5_CXX_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:90
msgid "Required libraries for the HDF5 C++ bindings"
msgstr "HDF5 C++ 绑定所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:91
msgid "``HDF5_Fortran_LIBRARIES``"
msgstr "``HDF5_Fortran_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:92
msgid "Required libraries for the HDF5 Fortran bindings"
msgstr "HDF5 Fortran 绑定所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:93
msgid "``HDF5_C_HL_LIBRARIES``"
msgstr "``HDF5_C_HL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:94
msgid "Required libraries for the high level C bindings"
msgstr "高级 C 绑定所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:95
msgid "``HDF5_CXX_HL_LIBRARIES``"
msgstr "``HDF5_CXX_HL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:96
msgid "Required libraries for the high level C++ bindings"
msgstr "高级 C++ 绑定所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:98
msgid "``HDF5_Fortran_HL_LIBRARIES``"
msgstr "``HDF5_Fortran_HL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:98
msgid "Required libraries for the high level Fortran bindings."
msgstr "高级 Fortran 绑定所需的库。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:100
msgid "``HDF5_IS_PARALLEL``"
msgstr "``HDF5_IS_PARALLEL``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:101
msgid "HDF5 library has parallel IO support"
msgstr "HDF5 库具有并行 IO 支持"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:102
msgid "``HDF5_C_COMPILER_EXECUTABLE``"
msgstr "``HDF5_C_COMPILER_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:103
msgid "path to the HDF5 C wrapper compiler"
msgstr "HDF5 C 包装器编译器的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:104
msgid "``HDF5_CXX_COMPILER_EXECUTABLE``"
msgstr "``HDF5_CXX_COMPILER_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:105
msgid "path to the HDF5 C++ wrapper compiler"
msgstr "HDF5 C++ 包装器编译器的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:106
msgid "``HDF5_Fortran_COMPILER_EXECUTABLE``"
msgstr "``HDF5_Fortran_COMPILER_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:107
msgid "path to the HDF5 Fortran wrapper compiler"
msgstr "HDF5 Fortran 包装器编译器的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:108
msgid "``HDF5_C_COMPILER_EXECUTABLE_NO_INTERROGATE``"
msgstr "``HDF5_C_COMPILER_EXECUTABLE_NO_INTERROGATE``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:109
msgid "path to the primary C compiler which is also the HDF5 wrapper"
msgstr "主要 C 编译器的路径，它也是 HDF5 包装器"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:110
msgid "``HDF5_CXX_COMPILER_EXECUTABLE_NO_INTERROGATE``"
msgstr "``HDF5_CXX_COMPILER_EXECUTABLE_NO_INTERROGATE``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:111
msgid "path to the primary C++ compiler which is also the HDF5 wrapper"
msgstr "主要 C++ 编译器的路径，它也是 HDF5 包装器"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:112
msgid "``HDF5_Fortran_COMPILER_EXECUTABLE_NO_INTERROGATE``"
msgstr "``HDF5_Fortran_COMPILER_EXECUTABLE_NO_INTERROGATE``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:113
msgid "path to the primary Fortran compiler which is also the HDF5 wrapper"
msgstr "主要 Fortran 编译器的路径，它也是 HDF5 包装器"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:115
msgid "``HDF5_DIFF_EXECUTABLE``"
msgstr "``HDF5_DIFF_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:115
msgid "path to the HDF5 dataset comparison tool"
msgstr "HDF5 数据集比较工具的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:117
msgid "With all components enabled, the following targets will be defined:"
msgstr "启用所有组件后，将定义以下目标："

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:119
msgid "``HDF5::HDF5``"
msgstr "``HDF5::HDF5``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:120
msgid "All detected ``HDF5_LIBRARIES``."
msgstr "所有检测到的``HDF5_LIBRARIES``。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:121
msgid "``hdf5::hdf5``"
msgstr "``hdf5::hdf5``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:122
msgid "C library."
msgstr "C 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:123
msgid "``hdf5::hdf5_cpp``"
msgstr "``hdf5::hdf5_cpp``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:124
msgid "C++ library."
msgstr "C++ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:125
msgid "``hdf5::hdf5_fortran``"
msgstr "``hdf5::hdf5_fortran``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:126
msgid "Fortran library."
msgstr "Fortran 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:127
msgid "``hdf5::hdf5_hl``"
msgstr "``hdf5::hdf5_hl``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:128
msgid "High-level C library."
msgstr "高级 C 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:129
msgid "``hdf5::hdf5_hl_cpp``"
msgstr "``hdf5::hdf5_hl_cpp``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:130
msgid "High-level C++ library."
msgstr "高级 C++ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:131
msgid "``hdf5::hdf5_hl_fortran``"
msgstr "``hdf5::hdf5_hl_fortran``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:132
msgid "High-level Fortran library."
msgstr "高级 Fortran 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:134
msgid "``hdf5::h5diff``"
msgstr "``hdf5::h5diff``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:134
msgid "``h5diff`` executable."
msgstr "``h5diff`` 可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:139
msgid ""
"The following variables can be set to guide the search for HDF5 libraries "
"and includes:"
msgstr "可以设置以下变量来指导搜索 HDF5 库，包括："

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:144
msgid "``HDF5_PREFER_PARALLEL``"
msgstr "``HDF5_PREFER_PARALLEL``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:144
msgid ""
"set ``true`` to prefer parallel HDF5 (by default, serial is preferred)"
msgstr "设置 ``true`` 以更喜欢并行 HDF5（默认情况下，首选串行）"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:149
msgid "``HDF5_FIND_DEBUG``"
msgstr "``HDF5_FIND_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:149
msgid "Set ``true`` to get extra debugging output."
msgstr "设置 ``true`` 以获得额外的调试输出。"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:1221
msgid "``HDF5_NO_FIND_PACKAGE_CONFIG_FILE``"
msgstr "``HDF5_NO_FIND_PACKAGE_CONFIG_FILE``"

#: ../../cmake-prefix/src/cmake/Modules/FindHDF5.cmake:154
msgid "Set ``true`` to skip trying to find ``hdf5-config.cmake``."
msgstr "设置 ``true`` 以跳过尝试查找 ``hdf5-config.cmake``。"

#: ../../cmake-prefix/src/cmake/Modules/FindHSPELL.cmake:6
msgid "FindHSPELL"
msgstr "查找HSPELL"

#: ../../cmake-prefix/src/cmake/Modules/FindHSPELL.cmake:8
msgid "Try to find Hebrew spell-checker (Hspell) and morphology engine."
msgstr "尝试寻找希伯来语拼写检查器 (Hspell) 和词法引擎。"

#: ../../cmake-prefix/src/cmake/Modules/FindHTMLHelp.cmake:6
msgid "FindHTMLHelp"
msgstr "查找 HTML 帮助"

#: ../../cmake-prefix/src/cmake/Modules/FindHTMLHelp.cmake:8
msgid "This module looks for Microsoft HTML Help Compiler"
msgstr "此模块查找 Microsoft HTML Help Compiler"

#: ../../cmake-prefix/src/cmake/Modules/FindHTMLHelp.cmake:10
msgid "It defines:"
msgstr "它定义："

#: ../../cmake-prefix/src/cmake/Modules/FindHg.cmake:6
msgid "FindHg"
msgstr "寻找汞"

#: ../../cmake-prefix/src/cmake/Modules/FindHg.cmake:8
msgid "Extract information from a mercurial working copy."
msgstr "从 Mercurial 工作副本中提取信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindHg.cmake:18
msgid ""
"If the command line client executable is found the following macro is "
"defined:"
msgstr "如果找到命令行客户端可执行文件，则定义以下宏："

#: ../../cmake-prefix/src/cmake/Modules/FindHg.cmake:25
msgid ""
"Hg_WC_INFO extracts information of a mercurial working copy at a given "
"location.  This macro defines the following variables:"
msgstr "Hg_WC_INFO 在给定位置提取 mercurial 工作副本的信息。该宏定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:6
msgid "FindICU"
msgstr "寻找ICU"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:10
msgid ""
"Find the International Components for Unicode (ICU) libraries and "
"programs."
msgstr "查找 Unicode (ICU) 库和程序的国际组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:13
msgid ""
"This module supports multiple components. Components can include any of: "
"``data``, ``i18n``, ``io``, ``le``, ``lx``, ``test``, ``tu`` and ``uc``."
msgstr ""
"该模块支持多个组件。组件可以包括以下任何一项：``data``、``i18n``、``io``、``le``、``lx``、``test``、``tu``"
" 和 `` uc``。"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:17
msgid ""
"Note that on Windows ``data`` is named ``dt`` and ``i18n`` is named "
"``in``; any of the names may be used, and the appropriate platform-"
"specific library name will be automatically selected."
msgstr ""
"请注意，在 Windows 上，``data`` 被命名为 ``dt`` 而 ``i18n`` 被命名为 "
"``in``；可以使用任何名称，并且将自动选择适当的特定于平台的库名称。"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:21
msgid "Added support for static libraries on Windows."
msgstr "在 Windows 上添加了对静态库的支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:24
msgid ""
"This module reports information about the ICU installation in several "
"variables.  General variables::"
msgstr "该模块以多个变量报告有关 ICU 安装的信息。一般变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:45
msgid "Imported targets::"
msgstr "导入目标 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:36
msgid ""
"Where ``<C>`` is the name of an ICU component, for example ``ICU::i18n``; "
"``<C>`` is lower-case."
msgstr "其中 ``<C>`` 是 ICU 组件的名称，例如 ``ICU::i18n``； ``<C>`` 是小写的。"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:39
msgid "ICU programs are reported in::"
msgstr "ICU 项目报告于："

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:58
msgid "ICU component libraries are reported in::"
msgstr "ICU 组件库在 :: 中报告"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:63
msgid "ICU datafiles are reported in::"
msgstr "ICU 数据文件在 :: 中报告"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:68
#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:120
msgid "This module reads hints about search results from::"
msgstr "该模块从以下位置读取有关搜索结果的提示："

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:72
msgid ""
"The environment variable ``ICU_ROOT`` may also be used; the ICU_ROOT "
"variable takes precedence."
msgstr "也可以使用环境变量“ICU_ROOT”； ICU_ROOT 变量优先。"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:75
#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:134
msgid "The following cache variables may also be set::"
msgstr "还可以设置以下缓存变量："

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:83
msgid ""
"In most cases none of the above variables will require setting, unless "
"multiple ICU versions are available and a specific version is required."
msgstr "在大多数情况下，上述变量都不需要设置，除非有多个 ICU 版本可用并且需要特定版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindICU.cmake:87
#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:157
msgid "Other variables one may set to control this module are::"
msgstr "可以设置以控制此模块的其他变量是："

#: ../../cmake-prefix/src/cmake/Help/module/FindITK.rst:2
msgid "FindITK"
msgstr "查找ITK"

#: ../../cmake-prefix/src/cmake/Help/module/FindITK.rst:4
#: ../../cmake-prefix/src/cmake/Help/module/FindVTK.rst:4
msgid "This module no longer exists."
msgstr "该模块不再存在。"

#: ../../cmake-prefix/src/cmake/Help/module/FindITK.rst:6
msgid ""
"This module existed in versions of CMake prior to 3.1, but became only a "
"thin wrapper around ``find_package(ITK NO_MODULE)`` to provide "
"compatibility for projects using long-outdated conventions. Now "
"``find_package(ITK)`` will search for ``ITKConfig.cmake`` directly."
msgstr ""
"这个模块存在于 3.1 之前的 CMake 版本中，但只是围绕“find_package(ITK "
"NO_MODULE)”的一个薄包装，为使用早已过时的约定的项目提供兼容性。现在``find_package(ITK)`` "
"将直接搜索``ITKConfig.cmake``。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:6
msgid "FindIce"
msgstr "找冰"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:10
msgid ""
"Find the ZeroC Internet Communication Engine (ICE) programs, libraries and"
" datafiles."
msgstr "查找 ZeroC Internet 通信引擎 (ICE) 程序、库和数据文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:13
msgid ""
"This module supports multiple components. Components can include any of: "
"``Freeze``, ``Glacier2``, ``Ice``, ``IceBox``, ``IceDB``, "
"``IceDiscovery``, ``IceGrid``, ``IceLocatorDiscovery``, ``IcePatch``, "
"``IceSSL``, ``IceStorm``, ``IceUtil``, ``IceXML``, or ``Slice``."
msgstr ""
"该模块支持多个组件。组件可以包括以下任何一项：``Freeze``、``Glacier2``、``Ice``、``IceBox``、``IceDB``、``IceDiscovery``、``IceGrid``、``"
" "
"IceLocatorDiscovery``、``IcePatch``、``IceSSL``、``IceStorm``、``IceUtil``、``IceXML``"
" 或``Slice``。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:19
msgid ""
"Ice 3.7 and later also include C++11-specific components: "
"``Glacier2++11``, ``Ice++11``, ``IceBox++11``, ``IceDiscovery++11`` "
"``IceGrid``, ``IceLocatorDiscovery++11``, ``IceSSL++11``, ``IceStorm++11``"
msgstr ""
"Ice 3.7 及更高版本还包括特定于 C++11 "
"的组件：``Glacier2++11``、``Ice++11``、``IceBox++11``、``IceDiscovery++11`` ` "
"`IceGrid``、``IceLocatorDiscovery++11``、``IceSSL++11``、``IceStorm++11``"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:24
msgid "Note that the set of supported components is Ice version-specific."
msgstr "请注意，受支持的组件集是特定于 Ice 版本的。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:26
msgid "Imported targets for components and most ``EXECUTABLE`` variables."
msgstr "组件和大多数“可执行”变量的导入目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:32
msgid ""
"Ice 3.7 support, including new components, programs and the Nuget package."
msgstr "Ice 3.7 支持，包括新组件、程序和 Nuget 包。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:35
msgid ""
"This module reports information about the Ice installation in several "
"variables.  General variables::"
msgstr "这个模块用几个变量报告关于 Ice 安装的信息。一般变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:49
msgid ""
"Where ``<C>`` is the name of an Ice component, for example "
"``Ice::Glacier2`` or ``Ice++11``."
msgstr "其中 ``<C>`` 是 Ice 组件的名称，例如 ``Ice::Glacier2`` 或 ``Ice++11``。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:52
msgid "Ice slice programs are reported in::"
msgstr "冰片程序报告于 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:68
msgid "Variables for ``slice2confluence`` and ``slice2matlab``."
msgstr "``slice2confluence`` 和 ``slice2matlab`` 的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:71
msgid "Ice programs are reported in::"
msgstr "Ice 程序在 :: 中报告"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:94
msgid ""
"Ice db programs (Windows only; standard system versions on all other "
"platforms) are reported in::"
msgstr "Ice db 程序（仅限 Windows；所有其他平台上的标准系统版本）在 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:113
msgid "Ice component libraries are reported in::"
msgstr "Ice 组件库在 :: 中报告"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:118
msgid "Note that ``<C>`` is the uppercased name of the component."
msgstr "请注意，``<C>`` 是组件的大写名称。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:124
msgid ""
"The environment variable ``ICE_HOME`` may also be used; the Ice_HOME "
"variable takes precedence."
msgstr "也可以使用环境变量“ICE_HOME”； Ice_HOME 变量优先。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:128
msgid ""
"On Windows, Ice 3.7.0 and later provide libraries via the NuGet package "
"manager.  Appropriate NuGet packages will be searched for using "
"``CMAKE_PREFIX_PATH``, or alternatively ``Ice_HOME`` may be set to the "
"location of a specific NuGet package to restrict the search."
msgstr ""
"在 Windows 上，Ice 3.7.0 及更高版本通过 NuGet 包管理器提供库。将使用“CMAKE_PREFIX_PATH”搜索适当的 "
"NuGet 包，或者可以将“Ice_HOME”设置为特定 NuGet 包的位置以限制搜索。"

#: ../../cmake-prefix/src/cmake/Modules/FindIce.cmake:144
msgid ""
"In most cases none of the above variables will require setting, unless "
"multiple Ice versions are available and a specific version is required.  "
"On Windows, the most recent version of Ice will be found through the "
"registry.  On Unix, the programs, headers and libraries will usually be in"
" standard locations, but Ice_SLICE_DIRS might not be automatically "
"detected (commonly known locations are searched).  All the other variables"
" are defaulted using Ice_HOME, if set.  It's possible to set Ice_HOME and "
"selectively specify alternative locations for the other components; this "
"might be required for e.g. newer versions of Visual Studio if the "
"heuristics are not sufficient to identify the correct programs and "
"libraries for the specific Visual Studio version."
msgstr ""
"在大多数情况下，上述变量都不需要设置，除非有多个 Ice 版本可用并且需要特定版本。在 Windows 上，可以通过注册表找到最新版本的 Ice。在"
" Unix 上，程序、头文件和库通常位于标准位置，但 Ice_SLICE_DIRS 可能不会被自动检测到（搜索常见的已知位置）。所有其他变量默认使用"
" Ice_HOME（如果已设置）。可以设置 Ice_HOME 并有选择地为其他组件指定替代位置；这可能是必需的，例如如果试探法不足以为特定的 "
"Visual Studio 版本识别正确的程序和库，则使用较新版本的 Visual Studio。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:6
msgid "FindIconv"
msgstr "查找图标"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:10
msgid ""
"This module finds the ``iconv()`` POSIX.1 functions on the system. These "
"functions might be provided in the regular C library or externally in the "
"form of an additional library."
msgstr "该模块在系统上找到 ``iconv()`` POSIX.1 函数。这些函数可能在常规 C 库中提供，也可能以附加库的形式在外部提供。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:14
msgid "The following variables are provided to indicate iconv support:"
msgstr "提供以下变量以指示 iconv 支持："

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:18
msgid "Variable indicating if the iconv support was found."
msgstr "指示是否找到 iconv 支持的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:22
msgid "The directories containing the iconv headers."
msgstr "包含 iconv 标头的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:26
msgid "The iconv libraries to be linked."
msgstr "要链接的 iconv 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:32
msgid "The version of iconv found (x.y)"
msgstr "找到的 iconv 版本 (x.y)"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:38
msgid "The major version of iconv"
msgstr "iconv 的主要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:44
msgid "The minor version of iconv"
msgstr "iconv 的次要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:48
msgid ""
"A variable indicating whether iconv support is stemming from the C library"
" or not. Even if the C library provides `iconv()`, the presence of an "
"external `libiconv` implementation might lead to this being false."
msgstr ""
"指示 iconv 支持是否源自 C 库的变量。即使 C 库提供了 `iconv()`，外部 `libiconv` 实现的存在也可能导致这是错误的。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:52
msgid ""
"Additionally, the following :prop_tgt:`IMPORTED` target is being provided:"
msgstr "此外，还提供了以下 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:56
msgid "Imported target for using iconv."
msgstr "使用 iconv 的导入目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:62
msgid "The directory containing the iconv headers."
msgstr "包含 iconv 标头的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:66
msgid "The iconv library (if not implicitly given in the C library)."
msgstr "iconv 库（如果 C 库中没有隐式给出）。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:69
msgid ""
"On POSIX platforms, iconv might be part of the C library and the cache "
"variables ``Iconv_INCLUDE_DIR`` and ``Iconv_LIBRARY`` might be empty."
msgstr ""
"在 POSIX 平台上，iconv 可能是 C 库的一部分，缓存变量“Iconv_INCLUDE_DIR”和“Iconv_LIBRARY”可能为空。"

#: ../../cmake-prefix/src/cmake/Modules/FindIconv.cmake:73
msgid ""
"Some libiconv implementations don't embed the version number in their "
"header files. In this case the variables ``Iconv_VERSION*`` will be empty."
msgstr "一些 libiconv 实现没有在它们的头文件中嵌入版本号。在这种情况下，变量 ``Iconv_VERSION*`` 将为空。"

#: ../../cmake-prefix/src/cmake/Modules/FindIcotool.cmake:6
msgid "FindIcotool"
msgstr "查找图标工具"

#: ../../cmake-prefix/src/cmake/Modules/FindIcotool.cmake:8
msgid "Find icotool"
msgstr "找icotool"

#: ../../cmake-prefix/src/cmake/Modules/FindIcotool.cmake:10
msgid ""
"This module looks for icotool. Convert and create Win32 icon and cursor "
"files. This module defines the following values:"
msgstr "该模块寻找 icotool。转换和创建 Win32 图标和光标文件。该模块定义了以下值："

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:6
msgid "FindImageMagick"
msgstr "查找图像魔术"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:8
msgid ""
"Find ImageMagick, software suite for displaying, converting and "
"manipulating raster images."
msgstr "查找 ImageMagick，用于显示、转换和操作光栅图像的软件套件。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:12
msgid "Added support for ImageMagick 7."
msgstr "添加了对 ImageMagick 7 的支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:15
msgid ""
"This module will search for a set of ImageMagick tools specified as "
"components in the :command:`find_package` call.  Typical components "
"include, but are not limited to (future versions of ImageMagick might have"
" additional components not listed here):"
msgstr ""
"此模块将搜索一组在 :command:`find_package` 调用中指定为组件的 ImageMagick "
"工具。典型的组件包括但不限于（ImageMagick 的未来版本可能具有此处未列出的其他组件）："

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:20
msgid "``animate``"
msgstr "``动画``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:21
msgid "``compare``"
msgstr "``比较``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:22
msgid "``composite``"
msgstr "``复合``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:23
msgid "``conjure``"
msgstr "``召唤``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:24
msgid "``convert``"
msgstr "``转换``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:25
msgid "``display``"
msgstr "``显示``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:26
msgid "``identify``"
msgstr "``识别``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:27
msgid "``import``"
msgstr "``导入``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:28
msgid "``mogrify``"
msgstr "``移动``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:29
msgid "``montage``"
msgstr "``蒙太奇``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:30
msgid "``stream``"
msgstr "``流``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:32
msgid ""
"If no component is specified in the :command:`find_package` call, then it "
"only searches for the ImageMagick executable directory."
msgstr "如果在 :command:`find_package` 调用中没有指定任何组件，那么它只会搜索 ImageMagick 可执行目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:35
msgid "There are also components for the following ImageMagick APIs:"
msgstr "还有用于以下 ImageMagick API 的组件："

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:37
msgid "``Magick++``: ImageMagick C++ API, if found."
msgstr "``Magick++``：ImageMagick C++ API，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:38
msgid "``MagickWand``: ImageMagick MagickWand C API, if found."
msgstr "``MagickWand``：ImageMagick MagickWand C API，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:39
msgid "``MagickCore``: ImageMagick MagickCore low-level C API, if found."
msgstr "``MagickCore``：ImageMagick MagickCore 低级 C API，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:50
msgid "``ImageMagick::Magick++``"
msgstr "``ImageMagick::Magick++``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:50
msgid "ImageMagick C++ API, if found."
msgstr "ImageMagick C++ API，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:53
msgid "``ImageMagick::MagickWand``"
msgstr "``ImageMagick::MagickWand``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:53
msgid "ImageMagick MagickWand C API, if found."
msgstr "ImageMagick MagickWand C API，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:57
msgid "``ImageMagick::MagickCore``"
msgstr "``ImageMagick::MagickCore``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:56
msgid "ImageMagick MagickCore low-level C API, if found."
msgstr "ImageMagick MagickCore 低级 C API，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:63
msgid "``ImageMagick_FOUND``"
msgstr "``ImageMagick_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:63
msgid "TRUE if all components are found."
msgstr "如果找到所有组件，则为 TRUE。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:66
msgid "``ImageMagick_EXECUTABLE_DIR``"
msgstr "``ImageMagick_EXECUTABLE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:66
msgid "Full path to executables directory."
msgstr "可执行文件目录的完整路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:69
msgid "``ImageMagick_INCLUDE_DIRS``"
msgstr "``ImageMagick_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:69
msgid "Full paths to all include dirs."
msgstr "全部的完整路径包括目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:72
msgid "``ImageMagick_LIBRARIES``"
msgstr "``ImageMagick_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:72
msgid "Full paths to all libraries."
msgstr "所有库的完整路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:75
msgid "``ImageMagick_COMPILE_OPTIONS``"
msgstr "``ImageMagick_COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:75
msgid "Compile options of all libraries."
msgstr "所有库的编译选项。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:79
msgid "``ImageMagick_VERSION_STRING``"
msgstr "``ImageMagick_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:78
msgid ""
"The version of ImageMagick found (since CMake 2.8.8). Will not work for "
"old versions like 5.2.3."
msgstr "找到的 ImageMagick 版本（自 CMake 2.8.8 起）。不适用于 5.2.3 等旧版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:82
msgid "``ImageMagick_<component>_FOUND``"
msgstr "``ImageMagick_<component>_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:82
msgid "TRUE if <component> is found."
msgstr "如果找到 <component> 则为 TRUE。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:85
msgid "``ImageMagick_<component>_EXECUTABLE``"
msgstr "``ImageMagick _<组件>_ 可执行``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:85
msgid "Full path to <component> executable."
msgstr "<component> 可执行文件的完整路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:88
msgid "``ImageMagick_<component>_INCLUDE_DIRS``"
msgstr "``ImageMagick_<component>_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:88
msgid "Full path to <component> include dirs."
msgstr "<component> 的完整路径包括目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:93
msgid "``ImageMagick_<component>_COMPILE_OPTIONS``"
msgstr "``ImageMagick_<component>_COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:93
msgid "Compile options of <component>."
msgstr "<component> 的编译选项。"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:97
msgid "``ImageMagick_<component>_LIBRARIES``"
msgstr "``ImageMagick_<component>_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindImageMagick.cmake:96
msgid "Full path to <component> libraries."
msgstr "<component> 库的完整路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:6
msgid "FindIntl"
msgstr "查找国际"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:10
msgid "Find the Gettext libintl headers and libraries."
msgstr "查找 Gettext libintl 标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:12
msgid ""
"This module reports information about the Gettext libintl installation in "
"several variables."
msgstr "此模块以多个变量报告有关 Gettext libintl 安装的信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:17
msgid "True if libintl is found."
msgstr "如果找到 libintl，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:21
msgid "The directory containing the libintl headers."
msgstr "包含 libintl 标头的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:25
msgid "The intl libraries to be linked."
msgstr "要链接的国际库。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:31
msgid "The version of intl found (x.y.z)"
msgstr "找到的 intl 版本 (x.y.z)"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:37
msgid "The major version of intl"
msgstr "国际主要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:43
msgid "The minor version of intl"
msgstr "intl 的次要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:49
msgid "The patch version of intl"
msgstr "intl补丁版本"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:51
msgid "This module defines :prop_tgt:`IMPORTED` target ``Intl::Intl``."
msgstr "该模块定义 :prop_tgt:`IMPORTED` 目标 ``Intl::Intl``。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:58
msgid "The directory containing the libintl headers"
msgstr "包含 libintl 标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:62
msgid "The libintl library (if any)"
msgstr "libintl 库（如果有的话）"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:68
msgid "whether ``intl`` is a part of the C library."
msgstr "``intl`` 是否是 C 库的一部分。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:71
msgid ""
"On some platforms, such as Linux with GNU libc, the gettext functions are "
"present in the C standard library and libintl is not required.  "
"``Intl_LIBRARIES`` will be empty in this case."
msgstr ""
"在某些平台上，例如带有 GNU libc 的 Linux，gettext 函数存在于 C 标准库中，不需要 "
"libintl。在这种情况下，``Intl_LIBRARIES`` 将是空的。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:77
msgid ""
"Some libintl implementations don't embed the version number in their "
"header files. In this case the variables ``Intl_VERSION*`` will be empty."
msgstr "一些 libintl 实现不在它们的头文件中嵌入版本号。在这种情况下，变量“Intl_VERSION*”将为空。"

#: ../../cmake-prefix/src/cmake/Modules/FindIntl.cmake:81
msgid ""
"If you wish to use the Gettext tools (``msgmerge``, ``msgfmt``, etc.), use"
" :module:`FindGettext`."
msgstr ""
"如果您想使用 Gettext 工具（``msgmerge``、``msgfmt`` 等），请使用:module:`FindGettext`。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:6
msgid "FindJNI"
msgstr "查找JNI"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:8
msgid "Find Java Native Interface (JNI) headers and libraries."
msgstr "查找 Java 本机接口 (JNI) 标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:10
msgid ""
"JNI enables Java code running in a Java Virtual Machine (JVM) or Dalvik "
"Virtual Machine (DVM) on Android to call and be called by native "
"applications and libraries written in other languages such as C and C++."
msgstr ""
"JNI 使在 Android 上的 Java 虚拟机 (JVM) 或 Dalvik 虚拟机 (DVM) 中运行的 Java "
"代码能够调用以其他语言（例如 C 和 C++）编写的本机应用程序和库，并被这些应用程序和库调用。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:14
msgid ""
"This module finds if Java is installed and determines where the include "
"files and libraries are.  It also determines what the name of the library "
"is.  The caller may set variable ``JAVA_HOME`` to specify a Java "
"installation prefix explicitly."
msgstr ""
"该模块查找是否安装了 Java 并确定包含文件和库的位置。它还确定库的名称是什么。调用者可以设置变量“JAVA_HOME”来明确指定 Java "
"安装前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:21
msgid ""
"Added imported targets, components ``AWT``, ``JVM``, and Android NDK "
"support. If no components are specified, the module defaults to an empty "
"components list while targeting Android, and all available components "
"otherwise."
msgstr ""
"添加了导入的目标、组件“AWT”、“JVM”和 Android NDK 支持。如果未指定任何组件，则模块在针对 Android "
"时默认为空组件列表，否则所有可用组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:25
msgid ""
"When using Android NDK, the corresponding package version is reported and "
"a specific release can be requested. At Android API level 31 and above, "
"the additional ``NativeHelper`` component can be requested. "
"``NativeHelper`` is also exposed as an implicit dependency of the ``JVM`` "
"component (only if this does not cause a conflict) which provides a "
"uniform access to JVM functions."
msgstr ""
"使用 Android NDK 时，会报告相应的包版本，并可以请求特定版本。在 Android API 级别 31 "
"及以上，可以请求额外的“NativeHelper”组件。 ``NativeHelper`` 也作为 ``JVM`` "
"组件的隐式依赖项公开（仅当这不会导致冲突时），它提供对 JVM 功能的统一访问。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:37
msgid "``JNI::JNI``"
msgstr "``JNI::JNI``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:37
msgid "Main JNI target, defined only if ``jni.h`` was found."
msgstr "主要 JNI 目标，仅在找到 ``jni.h`` 时定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:41
msgid "``JNI::AWT``"
msgstr "``JNI::AWT``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:40
msgid ""
"Java AWT Native Interface (JAWT) library, defined only if component "
"``AWT`` was found."
msgstr "Java AWT 本机接口 (JAWT) 库，仅在找到组件“AWT”时定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:44
msgid "``JNI::JVM``"
msgstr "``JNI::JVM``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:44
msgid ""
"Java Virtual Machine (JVM) library, defined only if component ``JVM`` was "
"found."
msgstr "Java 虚拟机 (JVM) 库，仅在找到组件“JVM”时定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:49
msgid "``JNI::NativeHelper``"
msgstr "``JNI::NativeHelper``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:47
msgid ""
"When targeting Android API level 31 and above, the import target will "
"provide access to ``libnativehelper.so`` that exposes JVM functions such "
"as ``JNI_CreateJavaVM``."
msgstr ""
"当针对 Android API 级别 31 及更高级别时，导入目标将提供对公开 JVM 函数（例如 JNI_CreateJavaVM）的 "
"libnativehelper.so 的访问。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:54
#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:29
msgid "This module sets the following result variables:"
msgstr "该模块设置以下结果变量："

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:56
msgid "``JNI_INCLUDE_DIRS``"
msgstr "``JNI_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:57
msgid "The include directories to use."
msgstr "要使用的包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:58
msgid "``JNI_LIBRARIES``"
msgstr "``JNI_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:59
msgid "The libraries to use (JAWT and JVM)."
msgstr "要使用的库（JAWT 和 JVM）。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:60
msgid "``JNI_FOUND``"
msgstr "``JNI_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:61
msgid "``TRUE`` if JNI headers and libraries were found."
msgstr "如果找到 JNI 标头和库，则为 TRUE。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:64
msgid "``JNI_<component>_FOUND``"
msgstr "``JNI_<组件>_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:65
msgid "``TRUE`` if ``<component>`` was found."
msgstr "``TRUE`` 如果找到``<component>``。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:67
msgid "``JNI_VERSION``"
msgstr "``JNI_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:67
msgid ""
"Full Android NDK package version (including suffixes such as ``-beta3`` "
"and ``-rc1``) or undefined otherwise."
msgstr "完整的 Android NDK 包版本（包括后缀，例如“-beta3”和“-rc1”）或未定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:71
msgid "``JNI_VERSION_MAJOR``"
msgstr "``JNI_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:72
msgid "Android NDK major version or undefined otherwise."
msgstr "Android NDK 主要版本或未定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:75
msgid "``JNI_VERSION_MINOR``"
msgstr "``JNI_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:76
msgid "Android NDK minor version or undefined otherwise."
msgstr "Android NDK 次要版本或未定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:80
msgid "``JNI_VERSION_PATCH``"
msgstr "``JNI_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:80
msgid "Android NDK patch version or undefined otherwise."
msgstr "Android NDK 补丁版本或未定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:87
msgid "``JAVA_AWT_LIBRARY``"
msgstr "``JAVA_AWT_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:88
msgid "The path to the Java AWT Native Interface (JAWT) library."
msgstr "Java AWT 本机接口 (JAWT) 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:89
msgid "``JAVA_JVM_LIBRARY``"
msgstr "``JAVA_JVM_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:90
msgid "The path to the Java Virtual Machine (JVM) library."
msgstr "Java 虚拟机 (JVM) 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:91
msgid "``JAVA_INCLUDE_PATH``"
msgstr "``JAVA_INCLUDE_PATH``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:92
msgid "The include path to ``jni.h``."
msgstr "``jni.h`` 的包含路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:95
msgid "``JAVA_INCLUDE_PATH2``"
msgstr "``JAVA_INCLUDE_PATH2``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:94
msgid ""
"The include path to machine-dependant headers ``jni_md.h`` and "
"``jniport.h``. The variable is defined only if ``jni.h`` depends on one of"
" these headers. In contrast, Android NDK ``jni.h`` can be typically used "
"standalone."
msgstr ""
"机器相关标头“jni_md.h”和“jniport.h”的包含路径。仅当 ``jni.h`` "
"依赖于这些标头之一时才定义该变量。相比之下，Android NDK ``jni.h`` 通常可以独立使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:672
msgid "``JAVA_AWT_INCLUDE_PATH``"
msgstr "``JAVA_AWT_INCLUDE_PATH``"

#: ../../cmake-prefix/src/cmake/Modules/FindJNI.cmake:98
msgid "The include path to ``jawt.h``."
msgstr "``jawt.h`` 的包含路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:6
msgid "FindJPEG"
msgstr "查找JPEG"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:8
msgid ""
"Find the Joint Photographic Experts Group (JPEG) library (``libjpeg``)"
msgstr "查找联合图像专家组 (JPEG) 库 (``libjpeg``)"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:18
msgid "``JPEG::JPEG``"
msgstr "``JPG::JPEG``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:18
msgid "The JPEG library, if found."
msgstr "JPEG 库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:25
msgid "``JPEG_FOUND``"
msgstr "``JPEG_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:26
msgid "If false, do not try to use JPEG."
msgstr "如果为 false，则不要尝试使用 JPEG。"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:40
msgid "``JPEG_INCLUDE_DIRS``"
msgstr "``JPEG_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:41
msgid "where to find jpeglib.h, etc."
msgstr "在哪里可以找到 jpeglib.h 等"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:29
msgid "``JPEG_LIBRARIES``"
msgstr "``JPEG_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:30
msgid "the libraries needed to use JPEG."
msgstr "使用 JPEG 所需的库。"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:33
msgid "``JPEG_VERSION``"
msgstr "``JPEG_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:32
msgid "the version of the JPEG library found"
msgstr "找到的 JPEG 库的版本"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:42
msgid "``JPEG_LIBRARY_RELEASE``"
msgstr "``JPEG_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:43
msgid "where to find the JPEG library (optimized)."
msgstr "在哪里可以找到 JPEG 库（已优化）。"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:45
msgid "``JPEG_LIBRARY_DEBUG``"
msgstr "``JPEG_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:45
msgid "where to find the JPEG library (debug)."
msgstr "在哪里可以找到 JPEG 库（调试）。"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:47
msgid "Debug and Release variand are found separately."
msgstr "调试和发布变体是分开找到的。"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:51
#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:70
msgid "Obsolete variables"
msgstr "过时的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:53
msgid "``JPEG_INCLUDE_DIR``"
msgstr "``JPEG_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:54
msgid "where to find jpeglib.h, etc. (same as JPEG_INCLUDE_DIRS)"
msgstr "在哪里可以找到 jpeglib.h 等（与 JPEG_INCLUDE_DIRS 相同）"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:142
msgid "``JPEG_LIBRARY``"
msgstr "``JPEG_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindJPEG.cmake:56
msgid "where to find the JPEG library."
msgstr "在哪里可以找到 JPEG 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:6
msgid "FindJasper"
msgstr "寻找碧玉"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:8
msgid "Find the Jasper JPEG2000 library."
msgstr "查找 Jasper JPEG2000 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:14
msgid "``Jasper::Jasper``"
msgstr "``碧玉 ::碧玉``"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:14
msgid "The jasper library, if found."
msgstr "jasper 库，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:21
msgid "``JASPER_FOUND``"
msgstr "``JASPER_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:22
msgid "system has Jasper"
msgstr "系统有碧玉"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:25
msgid "``JASPER_INCLUDE_DIRS``"
msgstr "``JASPER_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:26
msgid "the Jasper include directory"
msgstr "Jasper 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:27
msgid "``JASPER_LIBRARIES``"
msgstr "``JASPER_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:28
msgid "the libraries needed to use Jasper"
msgstr "使用 Jasper 所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:30
msgid "``JASPER_VERSION_STRING``"
msgstr "``JASPER_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:30
msgid "the version of Jasper found"
msgstr "找到的 Jasper 版本"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:37
msgid "``JASPER_INCLUDE_DIR``"
msgstr "``JASPER_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:38
msgid "where to find jasper/jasper.h, etc."
msgstr "在哪里可以找到 jasper/jasper.h 等"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:39
msgid "``JASPER_LIBRARY_RELEASE``"
msgstr "``JASPER_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:40
msgid "where to find the Jasper library (optimized)."
msgstr "在哪里可以找到 Jasper 库（已优化）。"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:90
msgid "``JASPER_LIBARRY_DEBUG``"
msgstr "``JASPER_LIBARRY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindJasper.cmake:42
msgid "where to find the Jasper library (debug)."
msgstr "在哪里可以找到 Jasper 库（调试）。"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:6
msgid "FindJava"
msgstr "查找Java"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:8
msgid "Find Java"
msgstr "寻找爪哇"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:10
msgid ""
"This module finds if Java is installed and determines where the include "
"files and libraries are.  The caller may set variable ``JAVA_HOME`` to "
"specify a Java installation prefix explicitly."
msgstr "该模块查找是否安装了 Java 并确定包含文件和库的位置。调用者可以设置变量“JAVA_HOME”来明确指定 Java 安装前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:14
msgid ""
"See also the :module:`FindJNI` module to find Java Native Interface (JNI)."
msgstr "另请参阅 :module:`FindJNI` 模块以查找 Java 本机接口 (JNI)。"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:16
msgid "Added support for Java 9+ version parsing."
msgstr "添加了对 Java 9+ 版本解析的支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:19
msgid ""
"Specify one or more of the following components as you call this find "
"module. See example below."
msgstr "在调用此查找模块时指定以下一个或多个组件。请参见下面的示例。"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:47
msgid ""
"Added the ``Java_IDLJ_EXECUTABLE`` and ``Java_JARSIGNER_EXECUTABLE`` "
"variables."
msgstr "添加了 ``Java_IDLJ_EXECUTABLE`` 和 ``Java_JARSIGNER_EXECUTABLE`` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:51
msgid ""
"The minimum required version of Java can be specified using the "
":command:`find_package` syntax, e.g."
msgstr "可以使用 :command:`find_package` 语法指定所需的最低 Java 版本，例如"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:58
msgid ""
"NOTE: ``${Java_VERSION}`` and ``${Java_VERSION_STRING}`` are not "
"guaranteed to be identical.  For example some java version may return: "
"``Java_VERSION_STRING = 1.8.0_17`` and ``Java_VERSION = 1.8.0.17``"
msgstr ""
"注意：``${Java_VERSION}`` 和``${Java_VERSION_STRING}`` 不保证完全相同。例如，某些 Java "
"版本可能会返回：``Java_VERSION_STRING = 1.8.0_17`` 和 ``Java_VERSION = 1.8.0.17``"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:62
msgid ""
"another example is the Java OEM, with: ``Java_VERSION_STRING = 1.8.0-oem``"
" and ``Java_VERSION = 1.8.0``"
msgstr ""
"另一个例子是 Java OEM，其中：``Java_VERSION_STRING = 1.8.0-oem`` 和``Java_VERSION = "
"1.8.0``"

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:65
msgid "For these components the following variables are set:"
msgstr "对于这些组件，设置了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindJava.cmake:74
msgid "Example Usages:"
msgstr "用法示例："

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:6
msgid "FindKDE3"
msgstr "找到KDE3"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:8
msgid ""
"Find the KDE3 include and library dirs, KDE preprocessors and define a "
"some macros"
msgstr "找到 KDE3 包含和库目录、KDE ​​预处理器并定义一些宏"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:14
msgid "``KDE3_DEFINITIONS``"
msgstr "``KDE3_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:15
msgid "compiler definitions required for compiling KDE software"
msgstr "编译 KDE 软件所需的编译器定义"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:16
msgid "``KDE3_INCLUDE_DIR``"
msgstr "``KDE3_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:17
msgid "the KDE include directory"
msgstr "KDE 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:18
msgid "``KDE3_INCLUDE_DIRS``"
msgstr "``KDE3_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:19
msgid ""
"the KDE and the Qt include directory, for use with include_directories()"
msgstr "KDE 和 Qt 包含目录，用于 include_directories()"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:20
msgid "``KDE3_LIB_DIR``"
msgstr "``KDE3_LIB_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:21
msgid ""
"the directory where the KDE libraries are installed, for use with "
"link_directories()"
msgstr "安装 KDE 库的目录，用于 link_directories()"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:22
msgid "``QT_AND_KDECORE_LIBS``"
msgstr "``QT_AND_KDECORE_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:23
msgid "this contains both the Qt and the kdecore library"
msgstr "这包含 Qt 和 kdecore 库"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:24
msgid "``KDE3_DCOPIDL_EXECUTABLE``"
msgstr "``KDE3_DCOPIDL_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:25
msgid "the dcopidl executable"
msgstr "dcopidl 可执行文件"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:26
msgid "``KDE3_DCOPIDL2CPP_EXECUTABLE``"
msgstr "``KDE3_DCOPIDL2CPP_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:27
msgid "the dcopidl2cpp executable"
msgstr "dcopidl2cpp 可执行文件"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:28
msgid "``KDE3_KCFGC_EXECUTABLE``"
msgstr "``KDE3_KCFGC_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:29
msgid "the kconfig_compiler executable"
msgstr "kconfig_compiler 可执行文件"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:31
msgid "``KDE3_FOUND``"
msgstr "``KDE3_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:31
msgid "set to TRUE if all of the above has been found"
msgstr "如果找到以上所有内容，则设置为 TRUE"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:33
msgid "The following user adjustable options are provided:"
msgstr "提供以下用户可调整选项："

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:36
msgid "``KDE3_BUILD_TESTS``"
msgstr "``KDE3_BUILD_TESTS``"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:36
msgid "enable this to build KDE testcases"
msgstr "启用它来构建 KDE 测试用例"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:38
msgid ""
"It also adds the following macros (from ``KDE3Macros.cmake``) ``SRCS_VAR``"
" is always the variable which contains the list of source files for your "
"application or library."
msgstr "它还添加了以下宏（来自``KDE3Macros.cmake``）``SRCS_VAR`` 始终是包含应用程序或库的源文件列表的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:42
msgid "KDE3_AUTOMOC(file1 ...  fileN)"
msgstr "KDE3_AUTOMOC（文件 1 ... 文件 N）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:54
msgid "KDE3_ADD_MOC_FILES(SRCS_VAR file1 ...  fileN )"
msgstr "KDE3_ADD_MOC_FILES（SRCS_VAR 文件 1 ... 文件 N ）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:63
msgid "KDE3_ADD_DCOP_SKELS(SRCS_VAR header1.h ...  headerN.h )"
msgstr "KDE3_ADD_DCOP_SKELS（SRCS_VAR header1.h ... headerN.h）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:71
msgid "KDE3_ADD_DCOP_STUBS(SRCS_VAR header1.h ...  headerN.h )"
msgstr "KDE3_ADD_DCOP_STUBS（SRCS_VAR header1.h ... headerN.h）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:79
msgid "KDE3_ADD_UI_FILES(SRCS_VAR file1.ui ...  fileN.ui )"
msgstr "KDE3_ADD_UI_FILES(SRCS_VAR file1.ui ... fileN.ui )"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:87
msgid "KDE3_ADD_KCFG_FILES(SRCS_VAR file1.kcfgc ...  fileN.kcfgc )"
msgstr "KDE3_ADD_KCFG_FILES（SRCS_VAR 文件 1.kcfgc ... 文件 N.kcfgc ）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:95
msgid "KDE3_INSTALL_LIBTOOL_FILE(target)"
msgstr "KDE3_INSTALL_LIBTOOL_FILE（目标）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:103
msgid "KDE3_ADD_EXECUTABLE(name file1 ...  fileN )"
msgstr "KDE3_ADD_EXECUTABLE（名称文件 1 ... 文件 N ）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:112
msgid "KDE3_ADD_KPART(name [WITH_PREFIX] file1 ...  fileN )"
msgstr "KDE3_ADD_KPART（名称 [WITH_PREFIX] 文件 1 ... 文件 N ）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:123
msgid "KDE3_ADD_KDEINIT_EXECUTABLE(name file1 ...  fileN )"
msgstr "KDE3_ADD_KDEINIT_EXECUTABLE（名称文件 1 ... 文件 N ）"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:133
msgid ""
"The option KDE3_ENABLE_FINAL to enable all-in-one compilation is no longer"
" supported."
msgstr "不再支持启用多合一编译的选项 KDE3_ENABLE_FINAL。"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE3.cmake:138
#: ../../cmake-prefix/src/cmake/Modules/FindKDE4.cmake:26
msgid "Author: Alexander Neundorf <neundorf@kde.org>"
msgstr "作者：Alexander Neundorf <neundorf@kde.org>"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE4.cmake:6
msgid "FindKDE4"
msgstr "找到KDE4"

#: ../../cmake-prefix/src/cmake/Modules/FindKDE4.cmake:10
msgid ""
"Find KDE4 and provide all necessary variables and macros to compile "
"software for it.  It looks for KDE 4 in the following directories in the "
"given order:"
msgstr "找到 KDE4 并提供所有必要的变量和宏来为它编译软件。它按给定顺序在以下目录中查找 KDE 4："

#: ../../cmake-prefix/src/cmake/Modules/FindKDE4.cmake:22
msgid ""
"Please look in ``FindKDE4Internal.cmake`` and ``KDE4Macros.cmake`` for "
"more information.  They are installed with the KDE 4 libraries in "
"$KDEDIRS/share/apps/cmake/modules/."
msgstr ""
"请查看``FindKDE4Internal.cmake`` 和``KDE4Macros.cmake`` 以获得更多信息。它们与 "
"$KDEDIRS/share/apps/cmake/modules/ 中的 KDE 4 库一起安装。"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:6
msgid "FindLAPACK"
msgstr "找到LAPACK"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:8
msgid "Find Linear Algebra PACKage (LAPACK) library"
msgstr "查找线性代数包 (LAPACK) 库"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:10
msgid ""
"This module finds an installed Fortran library that implements the `LAPACK"
" linear-algebra interface`_."
msgstr "该模块找到一个已安装的 Fortran 库，该库实现了“LAPACK 线性代数接口”_。"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:30
msgid "if ``ON`` tries to find the BLAS95/LAPACK95 interfaces"
msgstr "如果 ``ON`` 试图找到 BLAS95/LAPACK95 接口"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:35
msgid ""
"if set ``pkg-config`` will be used to search for a LAPACK library first "
"and if one is found that is preferred"
msgstr "如果设置 ``pkg-config`` 将首先用于搜索 LAPACK 库，如果找到一个是首选"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:43
msgid "``BLA_PKGCONFIG_LAPACK``"
msgstr "``BLA_PKGCONFIG_LAPACK``"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:41
msgid ""
"If set, the ``pkg-config`` method will look for this module name instead "
"of just ``lapack``."
msgstr "如果设置，``pkg-config`` 方法将查找此模块名称，而不仅仅是 ``lapack``。"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:66
msgid "``LAPACK::LAPACK``"
msgstr "``拉帕克 ::拉帕克``"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:66
msgid "The libraries to use for LAPACK, if found."
msgstr "用于 LAPACK 的库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:73
msgid "``LAPACK_FOUND``"
msgstr "``LAPACK_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:74
msgid "library implementing the LAPACK interface is found"
msgstr "找到实现 LAPACK 接口的库"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:75
msgid "``LAPACK_LINKER_FLAGS``"
msgstr "``LAPACK_LINKER_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:78
msgid "``LAPACK_LIBRARIES``"
msgstr "``LAPACK_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:78
msgid ""
"uncached list of libraries (using full path name) to link against to use "
"LAPACK"
msgstr "未缓存的库列表（使用完整路径名）链接以使用 LAPACK"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:81
msgid "``LAPACK95_LIBRARIES``"
msgstr "``LAPACK95_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:81
msgid ""
"uncached list of libraries (using full path name) to link against to use "
"LAPACK95"
msgstr "未缓存的库列表（使用完整路径名）链接以使用 LAPACK95"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:84
msgid "``LAPACK95_FOUND``"
msgstr "``LAPACK95_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:84
msgid "library implementing the LAPACK95 interface is found"
msgstr "找到实现 LAPACK95 接口的库"

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:89
msgid ""
"To use the Intel MKL implementation of LAPACK, a project must enable at "
"least one of the ``C`` or ``CXX`` languages.  Set ``BLA_VENDOR`` to an "
"Intel MKL variant either on the command-line as "
"``-DBLA_VENDOR=Intel10_64lp`` or in project code:"
msgstr ""
"要使用 LAPACK 的英特尔 MKL 实现，项目必须启用至少一种“C”或“CXX”语言。在命令行上将“BLA_VENDOR”设置为英特尔 MKL "
"变体，如“-DBLA_VENDOR=Intel10_64lp”或在项目代码中："

#: ../../cmake-prefix/src/cmake/Modules/FindLAPACK.cmake:99
msgid ""
"In order to build a project using Intel MKL, and end user must first "
"establish an Intel MKL environment.  See the :module:`FindBLAS` module "
"section on :ref:`Intel MKL` for details."
msgstr ""
"为了使用英特尔 MKL 构建项目，最终用户必须首先建立英特尔 MKL 环境。有关详细信息，请参阅英特尔 MKL 上的 FindBLAS 模块部分。"

#: ../../cmake-prefix/src/cmake/Modules/FindLATEX.cmake:6
msgid "FindLATEX"
msgstr "查找LATEX"

#: ../../cmake-prefix/src/cmake/Modules/FindLATEX.cmake:8
msgid "Find LaTeX"
msgstr "查找乳胶"

#: ../../cmake-prefix/src/cmake/Modules/FindLATEX.cmake:10
msgid ""
"This module finds an installed LaTeX and determines the location of the "
"compiler.  Additionally the module looks for Latex-related software like "
"BibTeX."
msgstr "该模块查找已安装的 LaTeX 并确定编译器的位置。此外，该模块还会寻找与 BibTeX 等 Latex 相关的软件。"

#: ../../cmake-prefix/src/cmake/Modules/FindLATEX.cmake:14
msgid ""
"Component processing; support for htlatex, pdftops, Biber, xindy, XeLaTeX,"
" LuaLaTeX."
msgstr "组件加工；支持 htlatex、pdftops、Biber、xindy、XeLaTeX、LuaLaTeX。"

#: ../../cmake-prefix/src/cmake/Modules/FindLATEX.cmake:18
msgid "This module sets the following result variables::"
msgstr "该模块设置以下结果变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindLATEX.cmake:37
msgid "Possible components are::"
msgstr "可能的组件是："

#: ../../cmake-prefix/src/cmake/Modules/FindLATEX.cmake:53
msgid "Example Usages::"
msgstr "示例用法 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:6
msgid "FindLTTngUST"
msgstr "查找LTTngUST"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:10
msgid ""
"Find `Linux Trace Toolkit Next Generation (LTTng-UST) "
"<https://lttng.org/>`__ library."
msgstr ""
"找到 `Linux Trace Toolkit Next Generation (LTTng-UST) "
"<https://lttng.org/>`__ 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:14
msgid "Imported target"
msgstr "导入目标"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:19
msgid "``LTTng::UST``"
msgstr "``LTTng::UST``"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:19
msgid "The LTTng-UST library, if found"
msgstr "LTTng-UST 库（如果找到）"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:24
msgid "This module sets the following"
msgstr "该模块设置以下内容"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:26
msgid "``LTTNGUST_FOUND``"
msgstr "``LTTNGUST_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:27
msgid "``TRUE`` if system has LTTng-UST"
msgstr "``TRUE`` 如果系统有 LTTng-UST"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:28
msgid "``LTTNGUST_INCLUDE_DIRS``"
msgstr "``LTTNGUST_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:29
msgid "The LTTng-UST include directories"
msgstr "LTTng-UST 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:30
msgid "``LTTNGUST_LIBRARIES``"
msgstr "``LTTNGUST_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:31
msgid "The libraries needed to use LTTng-UST"
msgstr "使用 LTTng-UST 所需的库"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:32
msgid "``LTTNGUST_VERSION_STRING``"
msgstr "``LTTNGUST_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:33
msgid "The LTTng-UST version"
msgstr "LTTng-UST 版本"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:34
msgid "``LTTNGUST_HAS_TRACEF``"
msgstr "``LTTNGUST_HAS_TRACEF``"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:35
msgid ""
"``TRUE`` if the ``tracef()`` API is available in the system's LTTng-UST"
msgstr "如果 ``tracef()`` API 在系统的 LTTng-UST 中可用，则为 ``TRUE``"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:102
msgid "``LTTNGUST_HAS_TRACELOG``"
msgstr "``LTTNGUST_HAS_TRACELOG``"

#: ../../cmake-prefix/src/cmake/Modules/FindLTTngUST.cmake:37
msgid ""
"``TRUE`` if the ``tracelog()`` API is available in the system's LTTng-UST"
msgstr "如果 ``tracelog()`` API 在系统的 LTTng-UST 中可用，则为 ``TRUE``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibArchive.cmake:6
msgid "FindLibArchive"
msgstr "查找库存档"

#: ../../cmake-prefix/src/cmake/Modules/FindLibArchive.cmake:8
msgid ""
"Find libarchive library and headers. Libarchive is multi-format archive "
"and compression library."
msgstr "查找 libarchive 库和标头。 Libarchive 是多格式归档和压缩库。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibArchive.cmake:20
msgid "The module defines the following ``IMPORTED`` targets:"
msgstr "该模块定义了以下“IMPORTED”目标："

#: ../../cmake-prefix/src/cmake/Modules/FindLibArchive.cmake:26
msgid "Support for new libarchive 3.2 version string format."
msgstr "支持新的 libarchive 3.2 版本字符串格式。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibArchive.cmake:29
msgid "Provides an imported target."
msgstr "提供导入的目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:6
msgid "FindLibLZMA"
msgstr "查找库LZMA"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:8
msgid "Find LZMA compression algorithm headers and library."
msgstr "查找 LZMA 压缩算法标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:16
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``LibLZMA::LibLZMA``, if "
"liblzma has been found."
msgstr "此模块定义:prop_tgt:`IMPORTED` 目标``LibLZMA::LibLZMA``，如果已找到 liblzma。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:24
msgid "``LIBLZMA_FOUND``"
msgstr "``LIBLZMA_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:25
msgid "True if liblzma headers and library were found."
msgstr "如果找到 liblzma 标头和库，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:26
msgid "``LIBLZMA_INCLUDE_DIRS``"
msgstr "``LIBLZMA_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:27
msgid "Directory where liblzma headers are located."
msgstr "liblzma 标头所在的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:28
msgid "``LIBLZMA_LIBRARIES``"
msgstr "``LIBLZMA_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:29
msgid "Lzma libraries to link against."
msgstr "要链接的 Lzma 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:30
msgid "``LIBLZMA_HAS_AUTO_DECODER``"
msgstr "``LIBLZMA_HAS_AUTO_DECODER``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:31
msgid "True if lzma_auto_decoder() is found (required)."
msgstr "如果找到 lzma_auto_decoder() 则为真（必需）。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:32
msgid "``LIBLZMA_HAS_EASY_ENCODER``"
msgstr "``LIBLZMA_HAS_EASY_ENCODER``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:33
msgid "True if lzma_easy_encoder() is found (required)."
msgstr "如果找到 lzma_easy_encoder() 则为真（必需）。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:34
msgid "``LIBLZMA_HAS_LZMA_PRESET``"
msgstr "``LIBLZMA_HAS_LZMA_PRESET``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:35
msgid "True if lzma_lzma_preset() is found (required)."
msgstr "如果找到 lzma_lzma_preset() 则为真（必需）。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:40
msgid "``LIBLZMA_VERSION``"
msgstr "``LIBLZMA_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:37
msgid "the version of LZMA found."
msgstr "找到的 LZMA 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:40
msgid "See also legacy variable ``LIBLZMA_VERSION_STRING``."
msgstr "另请参阅遗留变量 ``LIBLZMA_VERSION_STRING``。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:47
msgid "``LIBLZMA_VERSION_MAJOR``"
msgstr "``LIBLZMA_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:48
msgid "The major version of lzma"
msgstr "lzma的主要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:49
msgid "``LIBLZMA_VERSION_MINOR``"
msgstr "``LIBLZMA_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:50
msgid "The minor version of lzma"
msgstr "lzma的次要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:51
msgid "``LIBLZMA_VERSION_PATCH``"
msgstr "``LIBLZMA_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:52
msgid "The patch version of lzma"
msgstr "lzma的补丁版本"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:142
msgid "``LIBLZMA_VERSION_STRING``"
msgstr "``LIBLZMA_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:54
msgid "version number as a string (ex: \"5.0.3\")"
msgstr "作为字符串的版本号（例如：“5.0.3”）"

#: ../../cmake-prefix/src/cmake/Modules/FindLibLZMA.cmake:56
msgid "Superseded by ``LIBLZMA_VERSION``."
msgstr "被 ``LIBLZMA_VERSION`` 取代。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:6
msgid "FindLibXml2"
msgstr "查找LibXml2"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:8
msgid "Find the XML processing library (libxml2)."
msgstr "找到 XML 处理库 (libxml2)。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:15
#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:16
msgid "The following :prop_tgt:`IMPORTED` targets may be defined:"
msgstr "可以定义以下 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:17
msgid "``LibXml2::LibXml2``"
msgstr "``LibXml2::LibXml2``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:18
msgid "libxml2 library."
msgstr "libxml2 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:22
msgid "``LibXml2::xmllint``"
msgstr "``LibXml2::xmllint``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:22
msgid "xmllint command-line executable."
msgstr "xmllint 命令行可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:29
msgid "``LibXml2_FOUND``"
msgstr "``LibXml2_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:30
msgid "true if libxml2 headers and libraries were found"
msgstr "如果找到 libxml2 标头和库，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:49
msgid "``LIBXML2_INCLUDE_DIR``"
msgstr "``LIBXML2_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:50
msgid "the directory containing LibXml2 headers"
msgstr "包含 LibXml2 标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:33
msgid "``LIBXML2_INCLUDE_DIRS``"
msgstr "``LIBXML2_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:34
msgid "list of the include directories needed to use LibXml2"
msgstr "使用 LibXml2 所需的包含目录列表"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:35
msgid "``LIBXML2_LIBRARIES``"
msgstr "``LIBXML2_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:36
msgid "LibXml2 libraries to be linked"
msgstr "要链接的 LibXml2 库"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:37
msgid "``LIBXML2_DEFINITIONS``"
msgstr "``LIBXML2_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:38
msgid "the compiler switches required for using LibXml2"
msgstr "使用 LibXml2 所需的编译器开关"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:39
msgid "``LIBXML2_XMLLINT_EXECUTABLE``"
msgstr "``LIBXML2_XMLLINT_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:40
msgid "path to the XML checking tool xmllint coming with LibXml2"
msgstr "LibXml2 附带的 XML 检查工具 xmllint 的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:42
msgid "``LIBXML2_VERSION_STRING``"
msgstr "``LIBXML2_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:42
msgid "the version of LibXml2 found (since CMake 2.8.8)"
msgstr "找到的 LibXml2 版本（自 CMake 2.8.8 起）"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:124
msgid "``LIBXML2_LIBRARY``"
msgstr "``LIBXML2_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXml2.cmake:52
msgid "path to the LibXml2 library"
msgstr "LibXml2 库的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:6
msgid "FindLibXslt"
msgstr "查找LibXslt"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:8
msgid ""
"Find the XSL Transformations, Extensible Stylesheet Language "
"Transformations (XSLT) library (LibXslt)"
msgstr "查找 XSL 转换、可扩展样式表语言转换 (XSLT) 库 (LibXslt)"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:18
msgid "``LibXslt::LibXslt``"
msgstr "``LibXslt::LibXslt``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:19
msgid "If the libxslt library has been found"
msgstr "如果已找到 libxslt 库"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:20
msgid "``LibXslt::LibExslt``"
msgstr "``LibXslt::LibExslt``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:21
msgid "If the libexslt library has been found"
msgstr "如果已找到 libexslt 库"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:23
msgid "``LibXslt::xsltproc``"
msgstr "``LibXslt::xsltproc``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:23
msgid "If the xsltproc command-line executable has been found"
msgstr "如果找到 xsltproc 命令行可执行文件"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:30
msgid ""
"LIBXSLT_FOUND - system has LibXslt LIBXSLT_INCLUDE_DIR - the LibXslt "
"include directory LIBXSLT_LIBRARIES - Link these to LibXslt "
"LIBXSLT_DEFINITIONS - Compiler switches required for using LibXslt "
"LIBXSLT_VERSION_STRING - version of LibXslt found (since CMake 2.8.8)"
msgstr ""
"LIBXSLT_FOUND - 系统有 LibXslt LIBXSLT_INCLUDE_DIR - LibXslt 包含目录 "
"LIBXSLT_LIBRARIES - 将这些链接到 LibXslt LIBXSLT_DEFINITIONS - 使用 LibXslt "
"所需的编译器开关 LIBXSLT_VERSION_STRING - 找到的 LibXslt 版本（自 CMake 2.8.8 起）"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:36
msgid ""
"Additionally, the following two variables are set (but not required for "
"using xslt):"
msgstr "此外，还设置了以下两个变量（但使用 xslt 不需要）："

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:40
msgid "``LIBXSLT_EXSLT_INCLUDE_DIR``"
msgstr "``LIBXSLT_EXSLT_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:40
msgid "The include directory for exslt."
msgstr "exslt 的包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:42
msgid "``LIBXSLT_EXSLT_LIBRARIES``"
msgstr "``LIBXSLT_EXSLT_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:43
msgid "Link to these if you need to link against the exslt library."
msgstr "如果您需要链接到 exslt 库，请链接到这些。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:134
msgid "``LIBXSLT_XSLTPROC_EXECUTABLE``"
msgstr "``LIBXSLT_XSLTPROC_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibXslt.cmake:45
msgid "Contains the full path to the xsltproc executable if found."
msgstr "如果找到，则包含 xsltproc 可执行文件的完整路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:6
msgid "FindLibinput"
msgstr "查找库输入"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:10
msgid "Find libinput headers and library."
msgstr "查找 libinput 标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:16
msgid "``Libinput::Libinput``"
msgstr "``Libinput::Libinput``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:16
msgid "The libinput library, if found."
msgstr "libinput 库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:23
msgid "``Libinput_FOUND``"
msgstr "``Libinput_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:24
msgid "true if (the requested version of) libinput is available."
msgstr "如果（请求的版本）libinput 可用，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:25
msgid "``Libinput_VERSION``"
msgstr "``Libinput_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:26
msgid "the version of libinput."
msgstr "libinput 的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:27
msgid "``Libinput_LIBRARIES``"
msgstr "``Libinput_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:28
msgid "the libraries to link against to use libinput."
msgstr "要链接的库以使用 libinput。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:29
msgid "``Libinput_INCLUDE_DIRS``"
msgstr "``Libinput_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:30
msgid "where to find the libinput headers."
msgstr "在哪里可以找到 libinput 标头。"

#: ../../cmake-prefix/src/cmake/Modules/FindLibinput.cmake:84
msgid "``Libinput_COMPILE_OPTIONS``"
msgstr "``Libinput_COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:6
msgid "FindLua"
msgstr "查找Lua"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:8
msgid "Locate Lua library."
msgstr "找到 Lua 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:10
msgid "Support for Lua 5.4."
msgstr "支持 Lua 5.4。"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindQt3.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_gfx.cmake:12
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_image.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_mixer.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_net.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_ttf.cmake:10
msgid "This module defines:"
msgstr "该模块定义："

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:15
msgid "``LUA_FOUND``"
msgstr "``LUA_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:16
msgid "if false, do not try to link to Lua"
msgstr "如果为 false，则不要尝试链接到 Lua"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:17
msgid "``LUA_LIBRARIES``"
msgstr "``LUA_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:18
msgid "both lua and lualib"
msgstr "lua 和 lualib"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:19
msgid "``LUA_INCLUDE_DIR``"
msgstr "``LUA_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:20
msgid "where to find lua.h"
msgstr "在哪里可以找到 lua.h"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:21
msgid "``LUA_VERSION_STRING``"
msgstr "``LUA_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:22
msgid "the version of Lua found"
msgstr "找到的 Lua 版本"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:23
msgid "``LUA_VERSION_MAJOR``"
msgstr "``LUA_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:24
msgid "the major version of Lua"
msgstr "Lua的主要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:25
msgid "``LUA_VERSION_MINOR``"
msgstr "``LUA_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:26
msgid "the minor version of Lua"
msgstr "Lua 的次要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:28
msgid "``LUA_VERSION_PATCH``"
msgstr "``LUA_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:28
msgid "the patch version of Lua"
msgstr "补丁版本的Lua"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindLua50.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindLua51.cmake:22
msgid "Note that the expected include convention is"
msgstr "请注意，预期的包含约定是"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/FindLua50.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/FindLua51.cmake:28
msgid "and not"
msgstr "并不是"

#: ../../cmake-prefix/src/cmake/Modules/FindLua.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/FindLua50.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindLua51.cmake:34
msgid ""
"This is because, the lua location is not standardized and may exist in "
"locations other than lua/"
msgstr "这是因为，lua 位置不规范，可能存在于 lua/ 以外的位置"

#: ../../cmake-prefix/src/cmake/Modules/FindLua50.cmake:6
msgid "FindLua50"
msgstr "找到Lua50"

#: ../../cmake-prefix/src/cmake/Modules/FindLua50.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindLua51.cmake:10
msgid "Locate Lua library. This module defines::"
msgstr "找到 Lua 库。该模块定义："

#: ../../cmake-prefix/src/cmake/Modules/FindLua50.cmake:15
msgid ""
"LUA50_FOUND, if false, do not try to link to Lua LUA_LIBRARIES, both lua "
"and lualib LUA_INCLUDE_DIR, where to find lua.h and lualib.h (and probably"
" lauxlib.h)"
msgstr ""
"LUA50_FOUND，如果为假，不要尝试链接到 Lua LUA_LIBRARIES，包括 lua 和 lualib "
"LUA_INCLUDE_DIR，在哪里可以找到 lua.h 和 lualib.h（可能还有 lauxlib.h）"

#: ../../cmake-prefix/src/cmake/Modules/FindLua51.cmake:6
msgid "FindLua51"
msgstr "找到Lua51"

#: ../../cmake-prefix/src/cmake/Modules/FindLua51.cmake:15
msgid ""
"LUA51_FOUND, if false, do not try to link to Lua LUA_LIBRARIES "
"LUA_INCLUDE_DIR, where to find lua.h LUA_VERSION_STRING, the version of "
"Lua found (since CMake 2.8.8)"
msgstr ""
"LUA51_FOUND，如果为假，不要尝试链接到 Lua LUA_LIBRARIES LUA_INCLUDE_DIR，在哪里可以找到 lua.h "
"LUA_VERSION_STRING，找到的 Lua 版本（自 CMake 2.8.8 起）"

#: ../../cmake-prefix/src/cmake/Modules/FindMFC.cmake:6
msgid "FindMFC"
msgstr "查找MFC"

#: ../../cmake-prefix/src/cmake/Modules/FindMFC.cmake:8
msgid "Find Microsoft Foundation Class Library (MFC) on Windows"
msgstr "在 Windows 上查找 Microsoft 基础类库 (MFC)"

#: ../../cmake-prefix/src/cmake/Modules/FindMFC.cmake:10
msgid ""
"Find the native MFC - i.e.  decide if an application can link to the MFC "
"libraries."
msgstr "查找本机 MFC - 即确定应用程序是否可以链接到 MFC 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindMFC.cmake:17
msgid "You don't need to include anything or link anything to use it."
msgstr "您无需包含任何内容或链接任何内容即可使用它。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPEG.cmake:6
msgid "FindMPEG"
msgstr "查找MPEG"

#: ../../cmake-prefix/src/cmake/Modules/FindMPEG.cmake:8
msgid "Find the native MPEG includes and library"
msgstr "查找原生 MPEG 包含和库"

#: ../../cmake-prefix/src/cmake/Modules/FindMPEG.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindMPEG2.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:15
msgid "This module defines"
msgstr "这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindMPEG.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/FindMPEG2.cmake:18
msgid "also defined, but not for general use are"
msgstr "也有定义，但不是一般用途"

#: ../../cmake-prefix/src/cmake/Modules/FindMPEG2.cmake:6
msgid "FindMPEG2"
msgstr "查找MPEG2"

#: ../../cmake-prefix/src/cmake/Modules/FindMPEG2.cmake:8
msgid "Find the native MPEG2 includes and library"
msgstr "查找原生 MPEG2 包含和库"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:6
msgid "FindMPI"
msgstr "查找MPI"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:8
msgid "Find a Message Passing Interface (MPI) implementation."
msgstr "查找消息传递接口 (MPI) 实现。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:10
msgid ""
"The Message Passing Interface (MPI) is a library used to write high-"
"performance distributed-memory parallel applications, and is typically "
"deployed on a cluster.  MPI is a standard interface (defined by the MPI "
"forum) for which many implementations are available."
msgstr ""
"消息传递接口 (MPI) 是用于编写高性能分布式内存并行应用程序的库，通常部署在集群上。 MPI 是一个标准接口（由 MPI "
"论坛定义），有许多实现可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:15
msgid ""
"Major overhaul of the module: many new variables, per-language components,"
" support for a wider variety of runtimes."
msgstr "模块的大修：许多新变量，每种语言的组件，支持更广泛的运行时。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:20
msgid "Variables for using MPI"
msgstr "使用 MPI 的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:22
msgid ""
"The module exposes the components ``C``, ``CXX``, ``MPICXX`` and "
"``Fortran``. Each of these controls the various MPI languages to search "
"for. The difference between ``CXX`` and ``MPICXX`` is that ``CXX`` refers "
"to the MPI C API being usable from C++, whereas ``MPICXX`` refers to the "
"MPI-2 C++ API that was removed again in MPI-3."
msgstr ""
"该模块公开了组件“C”、“CXX”、“MPICXX”和“Fortran”。其中每一个都控制要搜索的各种 MPI 语言。 ``CXX`` 和 "
"``MPICXX`` 之间的区别在于 ``CXX`` 指的是可从 C++ 使用的 MPI C API，而 ``MPICXX`` 指的是再次被删除的 "
"MPI-2 C++ API在 MPI-3 中。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:26
msgid ""
"Depending on the enabled components the following variables will be set:"
msgstr "根据启用的组件，将设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:32
msgid "``MPI_FOUND``"
msgstr "``MPI_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:31
msgid ""
"Variable indicating that MPI settings for all requested languages have "
"been found. If no components are specified, this is true if MPI settings "
"for all enabled languages were detected. Note that the ``MPICXX`` "
"component does not affect this variable."
msgstr ""
"指示已找到所有请求语言的 MPI 设置的变量。如果未指定任何组件，则如果检测到所有已启用语言的 MPI 设置，则为真。请注意，``MPICXX`` "
"组件不会影响此变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:36
msgid "``MPI_VERSION``"
msgstr "``MPI_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:35
msgid ""
"Minimal version of MPI detected among the requested languages, or all "
"enabled languages if no components were specified."
msgstr "在请求的语言中检测到最低版本的 MPI，如果未指定组件，则检测到所有启用的语言。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:36
msgid ""
"This module will set the following variables per language in your project,"
" where ``<lang>`` is one of C, CXX, or Fortran:"
msgstr "该模块将为您的项目中的每种语言设置以下变量，其中 <lang> 是 C、CXX 或 Fortran 之一："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:42
msgid "``MPI_<lang>_FOUND``"
msgstr "``MPI_<lang>_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:42
msgid ""
"Variable indicating the MPI settings for ``<lang>`` were found and that "
"simple MPI test programs compile with the provided settings."
msgstr "找到了指示 ``<lang>`` 的 MPI 设置的变量，并且简单的 MPI 测试程序使用提供的设置进行编译。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:126
msgid "``MPI_<lang>_COMPILER``"
msgstr "``MPI_<lang>_COMPILER``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:45
msgid "MPI compiler for ``<lang>`` if such a program exists."
msgstr "``<lang>`` 的 MPI 编译器（如果存在这样的程序）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:46
msgid "``MPI_<lang>_COMPILE_OPTIONS``"
msgstr "``MPI<语言 COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:47
msgid ""
"Compilation options for MPI programs in ``<lang>``, given as a "
":ref:`;-list <CMake Language Lists>`."
msgstr ""
"``<lang>`` 中 MPI 程序的编译选项，作为 :ref:`;-list <CMake Language Lists>` 给出。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:48
msgid "``MPI_<lang>_COMPILE_DEFINITIONS``"
msgstr "``MPI<语言 COMPILE_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:49
msgid ""
"Compilation definitions for MPI programs in ``<lang>``, given as a "
":ref:`;-list <CMake Language Lists>`."
msgstr ""
"``<lang>`` 中 MPI 程序的编译定义，作为 :ref:`;-list <CMake Language Lists>` 给出。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:50
msgid "``MPI_<lang>_INCLUDE_DIRS``"
msgstr "``MPI_<lang>_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:51
msgid "Include path(s) for MPI header."
msgstr "包括 MPI 标头的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:52
msgid "``MPI_<lang>_LINK_FLAGS``"
msgstr "``MPI_<lang>_LINK_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:53
msgid "Linker flags for MPI programs."
msgstr "MPI 程序的链接器标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:55
msgid "``MPI_<lang>_LIBRARIES``"
msgstr "``MPI_<lang>_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:55
msgid "All libraries to link MPI programs against."
msgstr "链接 MPI 程序的所有库。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:57
msgid ""
"Additionally, the following :prop_tgt:`IMPORTED` targets are defined:"
msgstr "此外，还定义了以下 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:61
msgid "``MPI::MPI_<lang>``"
msgstr "``MPI::MPI_<lang>``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:61
msgid "Target for using MPI from ``<lang>``."
msgstr "使用来自 ``<lang>`` 的 MPI 的目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:63
msgid ""
"The following variables indicating which bindings are present will be "
"defined:"
msgstr "将定义以下指示存在哪些绑定的变量："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:65
msgid "``MPI_MPICXX_FOUND``"
msgstr "``MPI_MPICXX_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:66
msgid ""
"Variable indicating whether the MPI-2 C++ bindings are present (introduced"
" in MPI-2, removed with MPI-3)."
msgstr "指示 MPI-2 C++ 绑定是否存在的变量（在 MPI-2 中引入，随 MPI-3 一起删除）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:67
msgid "``MPI_Fortran_HAVE_F77_HEADER``"
msgstr "``MPI_Fortran_HAVE_F77_HEADER``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:68
msgid "True if the Fortran 77 header ``mpif.h`` is available."
msgstr "如果 Fortran 77 标头“mpif.h”可用，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:69
msgid "``MPI_Fortran_HAVE_F90_MODULE``"
msgstr "``MPI_Fortran_HAVE_F90_MODULE``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:70
msgid ""
"True if the Fortran 90 module ``mpi`` can be used for accessing MPI (MPI-2"
" and higher only)."
msgstr "如果 Fortran 90 模块“mpi”可用于访问 MPI（仅限 MPI-2 及更高版本），则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:72
msgid "``MPI_Fortran_HAVE_F08_MODULE``"
msgstr "``MPI_Fortran_HAVE_F08_MODULE``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:72
msgid ""
"True if the Fortran 2008 ``mpi_f08`` is available to MPI programs (MPI-3 "
"and higher only)."
msgstr "如果 Fortran 2008 ``mpi_f08`` 可用于 MPI 程序（仅限 MPI-3 及更高版本），则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:74
msgid ""
"If possible, the MPI version will be determined by this module. The "
"facilities to detect the MPI version were introduced with MPI-1.2, and "
"therefore cannot be found for older MPI versions."
msgstr "如果可能，MPI 版本将由该模块确定。检测 MPI 版本的工具是在 MPI-1.2 中引入的，因此对于旧的 MPI 版本是找不到的。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:77
msgid "``MPI_<lang>_VERSION_MAJOR``"
msgstr "``MPI<lang>_VERSION_ MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:78
msgid ""
"Major version of MPI implemented for ``<lang>`` by the MPI distribution."
msgstr "MPI 发行版为 ``<lang>`` 实现的 MPI 主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:79
msgid "``MPI_<lang>_VERSION_MINOR``"
msgstr "``MPI<lang>_VERSION_ MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:80
msgid ""
"Minor version of MPI implemented for ``<lang>`` by the MPI distribution."
msgstr "MPI 分发版为 ``<lang>`` 实现的 MPI 次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:82
msgid "``MPI_<lang>_VERSION``"
msgstr "``MPI_<lang>_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:82
msgid "MPI version implemented for ``<lang>`` by the MPI distribution."
msgstr "MPI 发行版为 ``<lang>`` 实现的 MPI 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:84
msgid ""
"Note that there's no variable for the C bindings being accessible through "
"``mpi.h``, since the MPI standards always have required this binding to "
"work in both C and C++ code."
msgstr "请注意，对于可通过“mpi.h”访问的 C 绑定，没有变量，因为 MPI 标准始终要求此绑定在 C 和 C++ 代码中工作。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:87
msgid "For running MPI programs, the module sets the following variables"
msgstr "为了运行 MPI 程序，该模块设置了以下变量"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:89
#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:115
msgid "``MPIEXEC_EXECUTABLE``"
msgstr "``MPIEXEC_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:90
msgid "Executable for running MPI programs, if such exists."
msgstr "用于运行 MPI 程序的可执行文件（如果存在）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:91
msgid "``MPIEXEC_NUMPROC_FLAG``"
msgstr "``MPIEXEC_NUMPROC_FLAG``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:92
msgid ""
"Flag to pass to ``mpiexec`` before giving it the number of processors to "
"run on."
msgstr "在给它运行的处理器数量之前传递给 ``mpiexec`` 的标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:94
msgid "``MPIEXEC_MAX_NUMPROCS``"
msgstr "``MPIEXEC_MAX_NUMPROCS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:94
msgid ""
"Number of MPI processors to utilize. Defaults to the number of processors "
"detected on the host system."
msgstr "要使用的 MPI 处理器数。默认为在主机系统上检测到的处理器数。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:96
msgid "``MPIEXEC_PREFLAGS``"
msgstr "``MPIEXEC_PREFLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:97
msgid "Flags to pass to ``mpiexec`` directly before the executable to run."
msgstr "在要运行的可执行文件之前直接传递给“mpiexec”的标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:99
msgid "``MPIEXEC_POSTFLAGS``"
msgstr "``MPIEXEC_POSTFLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:99
msgid "Flags to pass to ``mpiexec`` after other flags."
msgstr "在其他标志之后传递给 ``mpiexec`` 的标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:102
msgid "Variables for locating MPI"
msgstr "用于定位 MPI 的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:104
msgid "This module performs a four step search for an MPI implementation:"
msgstr "该模块对 MPI 实现执行四步搜索："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:106
msgid ""
"Search for ``MPIEXEC_EXECUTABLE`` and, if found, use its base directory."
msgstr "搜索“MPIEXEC_EXECUTABLE”，如果找到，则使用其基本目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:107
msgid ""
"Check if the compiler has MPI support built-in. This is the case if the "
"user passed a compiler wrapper as ``CMAKE_<LANG>_COMPILER`` or if they use"
" Cray system compiler wrappers."
msgstr ""
"检查编译器是否内置了 MPI 支持。如果用户将编译器包装器作为 CMAKE_<LANG>_COMPILER 传递，或者他们使用 Cray "
"系统编译器包装器，就会出现这种情况。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:109
msgid ""
"Attempt to find an MPI compiler wrapper and determine the compiler "
"information from it."
msgstr "尝试找到 MPI 编译器包装器并从中确定编译器信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:110
msgid ""
"Try to find an MPI implementation that does not ship such a wrapper by "
"guessing settings. Currently, only Microsoft MPI and MPICH2 on Windows are"
" supported."
msgstr ""
"尝试通过猜测设置找到不提供此类包装器的 MPI 实现。目前，仅支持 Windows 上的 Microsoft MPI 和 MPICH2。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:113
msgid ""
"For controlling the ``MPIEXEC_EXECUTABLE`` step, the following variables "
"may be set:"
msgstr "为了控制“MPIEXEC_EXECUTABLE”步骤，可以设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:116
msgid "Manually specify the location of ``mpiexec``."
msgstr "手动指定 ``mpiexec`` 的位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:117
msgid "``MPI_HOME``"
msgstr "``MPI_HOME``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:118
msgid "Specify the base directory of the MPI installation."
msgstr "指定 MPI 安装的基本目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:119
msgid "``ENV{MPI_HOME}``"
msgstr "``ENV{MPI_HOME}``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:120
#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:122
msgid ""
"Environment variable to specify the base directory of the MPI "
"installation."
msgstr "用于指定 MPI 安装基目录的环境变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:122
msgid "``ENV{I_MPI_ROOT}``"
msgstr "``ENV{I_MPI_ROOT}``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:124
msgid ""
"For controlling the compiler wrapper step, the following variables may be "
"set:"
msgstr "为了控制编译器包装器步骤，可以设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:127
msgid "Search for the specified compiler wrapper and use it."
msgstr "搜索指定的编译器包装器并使用它。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:130
msgid "``MPI_<lang>_COMPILER_FLAGS``"
msgstr "``MPI_<lang>_COMPILER_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:129
msgid ""
"Flags to pass to the MPI compiler wrapper during interrogation. Some "
"compiler wrappers support linking debug or tracing libraries if a specific"
" flag is passed and this variable may be used to obtain them."
msgstr "在询问期间传递给 MPI 编译器包装器的标志。如果传递了特定标志，一些编译器包装器支持链接调试或跟踪库，并且可以使用此变量来获取它们。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:133
msgid "``MPI_COMPILER_FLAGS``"
msgstr "``MPI_COMPILER_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:133
msgid ""
"Used to initialize ``MPI_<lang>_COMPILER_FLAGS`` if no language specific "
"flag has been given. Empty by default."
msgstr "如果没有给出特定于语言的标志，则用于初始化“MPI_<lang>_COMPILER_FLAGS”。默认为空。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:137
msgid "``MPI_EXECUTABLE_SUFFIX``"
msgstr "``MPI_EXECUTABLE_SUFFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:136
msgid ""
"A suffix which is appended to all names that are being looked for. For "
"instance you may set this to ``.mpich`` or ``.openmpi`` to prefer the one "
"or the other on Debian and its derivatives."
msgstr ""
"附加到正在查找的所有名称的后缀。例如，您可以将其设置为 ``.mpich`` 或 ``.openmpi`` 以在 Debian "
"及其衍生产品上更喜欢其中一个。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:139
msgid ""
"In order to control the guessing step, the following variable may be set:"
msgstr "为了控制猜测步骤，可以设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:144
msgid "``MPI_GUESS_LIBRARY_NAME``"
msgstr "``MPI_GUESS_LIBRARY_NAME``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:142
msgid ""
"Valid values are ``MSMPI`` and ``MPICH2``. If set, only the given library "
"will be searched for. By default, ``MSMPI`` will be preferred over "
"``MPICH2`` if both are available. This also sets "
"``MPI_SKIP_COMPILER_WRAPPER`` to ``true``, which may be overridden."
msgstr ""
"有效值为“MSMPI”和“MPICH2”。如果设置，将只搜索给定的库。默认情况下，``MSMPI`` 将优先于 ``MPICH2`` "
"如果两者都可用。这还将“MPI_SKIP_COMPILER_WRAPPER”设置为“true”，这可能会被覆盖。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:146
msgid ""
"Each of the search steps may be skipped with the following control "
"variables:"
msgstr "可以使用以下控制变量跳过每个搜索步骤："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:149
msgid "``MPI_ASSUME_NO_BUILTIN_MPI``"
msgstr "``MPI_ASSUME_NO_BUILTIN_MPI``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:149
msgid ""
"If true, the module assumes that the compiler itself does not provide an "
"MPI implementation and skips to step 2."
msgstr "如果为真，则模块假定编译器本身不提供 MPI 实现并跳到步骤 2。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:151
msgid "``MPI_SKIP_COMPILER_WRAPPER``"
msgstr "``MPI_SKIP_COMPILER_WRAPPER``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:152
msgid "If true, no compiler wrapper will be searched for."
msgstr "如果为真，则不会搜索编译器包装器。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:154
msgid "``MPI_SKIP_GUESSING``"
msgstr "``MPI_SKIP_GUESSING``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:154
msgid "If true, the guessing step will be skipped."
msgstr "如果为真，则将跳过猜测步骤。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:156
msgid ""
"Additionally, the following control variable is available to change search"
" behavior:"
msgstr "此外，以下控制变量可用于更改搜索行为："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:161
msgid "``MPI_CXX_SKIP_MPICXX``"
msgstr "``MPI_CXX_SKIP_MPICXX``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:159
msgid ""
"Add some definitions that will disable the MPI-2 C++ bindings. Currently "
"supported are MPICH, Open MPI, Platform MPI and derivatives thereof, for "
"example MVAPICH or Intel MPI."
msgstr ""
"添加一些将禁用 MPI-2 C++ 绑定的定义。当前支持的是 MPICH、Open MPI、Platform MPI 及其衍生产品，例如 "
"MVAPICH 或 Intel MPI。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:163
msgid ""
"If the find procedure fails for a variable ``MPI_<lang>_WORKS``, then the "
"settings detected by or passed to the module did not work and even a "
"simple MPI test program failed to compile."
msgstr ""
"如果变量“MPI_<lang>_WORKS”的查找过程失败，则由模块检测到或传递给模块的设置不起作用，甚至一个简单的 MPI 测试程序也无法编译。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:166
msgid ""
"If all of these parameters were not sufficient to find the right MPI "
"implementation, a user may disable the entire autodetection process by "
"specifying both a list of libraries in ``MPI_<lang>_LIBRARIES`` and a list"
" of include directories in ``MPI_<lang>_ADDITIONAL_INCLUDE_DIRS``. Any "
"other variable may be set in addition to these two. The module will then "
"validate the MPI settings and store the settings in the cache."
msgstr ""
"如果所有这些参数都不足以找到正确的 MPI 实现，用户可以通过在 ``MPI_<lang>_LIBRARIES`` 中指定库列表和 ``MPI_ "
"中的包含目录列表来禁用整个自动检测过程<lang>_ADDITIONAL_INCLUDE_DIRS``。除了这两个之外，还可以设置任何其他变量。然后模块将验证"
" MPI 设置并将设置存储在缓存中。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:173
msgid "Cache variables for MPI"
msgstr "MPI 的缓存变量"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:175
msgid ""
"The variable ``MPI_<lang>_INCLUDE_DIRS`` will be assembled from the "
"following variables. For C and CXX:"
msgstr "变量 ``MPI_<lang>_INCLUDE_DIRS`` 将从以下变量中组装。对于 C 和 CXX："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:179
msgid "``MPI_<lang>_HEADER_DIR``"
msgstr "``MPI_<lang>_HEADER_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:179
msgid "Location of the ``mpi.h`` header on disk."
msgstr "``mpi.h`` 头文件在磁盘上的位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:181
msgid "For Fortran:"
msgstr "对于 Fortran："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:183
msgid "``MPI_Fortran_F77_HEADER_DIR``"
msgstr "``MPI_Fortran_F77_HEADER_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:184
msgid "Location of the Fortran 77 header ``mpif.h``, if it exists."
msgstr "Fortran 77 标头 ``mpif.h`` 的位置（如果存在）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:186
msgid "``MPI_Fortran_MODULE_DIR``"
msgstr "``MPI_Fortran_MODULE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:186
msgid "Location of the ``mpi`` or ``mpi_f08`` modules, if available."
msgstr "``mpi`` 或 ``mpi_f08`` 模块的位置（如果可用）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:188
msgid ""
"For all languages the following variables are additionally considered:"
msgstr "对于所有语言，还考虑以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:190
msgid "``MPI_<lang>_ADDITIONAL_INCLUDE_DIRS``"
msgstr "``MPI_<lang>_ADDITIONAL_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:191
msgid ""
"A :ref:`;-list <CMake Language Lists>` of paths needed in addition to the "
"normal include directories."
msgstr "A :ref:`;-list <CMake Language Lists>` 除了正常的包含目录之外还需要的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:192
msgid "``MPI_<include_name>_INCLUDE_DIR``"
msgstr "``MPI<include name>INCLUDE DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:193
msgid ""
"Path variables for include folders referred to by ``<include_name>``."
msgstr "包含由``<include_name>``引用的文件夹的路径变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:195
msgid "``MPI_<lang>_ADDITIONAL_INCLUDE_VARS``"
msgstr "``MPI_<lang>_ADDITIONAL_INCLUDE_VARS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:195
msgid ""
"A :ref:`;-list <CMake Language Lists>` of ``<include_name>`` that will be "
"added to the include locations of ``<lang>``."
msgstr ""
"A :ref:`;-list <CMake Language Lists>` 的 ``<include_name>`` 将被添加到 "
"``<lang>`` 的包含位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:197
msgid ""
"The variable ``MPI_<lang>_LIBRARIES`` will be assembled from the following"
" variables:"
msgstr "变量 ``MPI_<lang>_LIBRARIES`` 将从以下变量中组装："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:199
msgid "``MPI_<lib_name>_LIBRARY``"
msgstr "``MPI_<lib_name>_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:200
msgid "The location of a library called ``<lib_name>`` for use with MPI."
msgstr "用于 MPI 的名为“<lib_name>”的库的位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:202
msgid "``MPI_<lang>_LIB_NAMES``"
msgstr "``MPI_<lang>_LIB_NAMES``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:202
msgid ""
"A :ref:`;-list <CMake Language Lists>` of ``<lib_name>`` that will be "
"added to the include locations of ``<lang>``."
msgstr ""
"A :ref:`;-list <CMake Language Lists>` of ``<lib_name>`` 将添加到 ``<lang>`` "
"的包含位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:205
msgid "Usage of mpiexec"
msgstr "mpiexec的使用"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:207
msgid ""
"When using ``MPIEXEC_EXECUTABLE`` to execute MPI applications, you should "
"typically use all of the ``MPIEXEC_EXECUTABLE`` flags as follows:"
msgstr ""
"当使用 ``MPIEXEC_EXECUTABLE`` 来执行 MPI 应用程序时，您通常应该使用所有的 ``MPIEXEC_EXECUTABLE``"
" 标志，如下所示："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:215
msgid ""
"where ``EXECUTABLE`` is the MPI program, and ``ARGS`` are the arguments to"
" pass to the MPI program."
msgstr "其中 ``EXECUTABLE`` 是 MPI 程序，``ARGS`` 是传递给 MPI 程序的参数。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:219
msgid "Advanced variables for using MPI"
msgstr "使用 MPI 的高级变量"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:221
msgid ""
"The module can perform some advanced feature detections upon explicit "
"request."
msgstr "该模块可以根据明确请求执行一些高级功能检测。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:223
msgid ""
"**Important notice:** The following checks cannot be performed without "
"*executing* an MPI test program. Consider the special considerations for "
"the behavior of :command:`try_run` during cross compilation. Moreover, "
"running an MPI program can cause additional issues, like a firewall "
"notification on some systems. You should only enable these detections if "
"you absolutely need the information."
msgstr ""
"**重要提示：**如果不*执行* MPI 测试程序，则无法执行以下检查。考虑交叉编译期间 :command:`try_run` "
"行为的特殊注意事项。此外，运行 MPI 程序可能会导致其他问题，例如某些系统上的防火墙通知。如果您绝对需要这些信息，您应该只启用这些检测。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:228
msgid ""
"If the following variables are set to true, the respective search will be "
"performed:"
msgstr "如果以下变量设置为真，将执行相应的搜索："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:233
msgid "``MPI_DETERMINE_Fortran_CAPABILITIES``"
msgstr "``MPI_DETERMINE_Fortran_CAPABILITIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:231
msgid ""
"Determine for all available Fortran bindings what the values of "
"``MPI_SUBARRAYS_SUPPORTED`` and ``MPI_ASYNC_PROTECTS_NONBLOCKING`` are and"
" make their values available as ``MPI_Fortran_<binding>_SUBARRAYS`` and "
"``MPI_Fortran_<binding>_ASYNCPROT``, where ``<binding>`` is one of "
"``F77_HEADER``, ``F90_MODULE`` and ``F08_MODULE``."
msgstr ""
"为所有可用的 Fortran 绑定确定 ``MPI_SUBARRAYS_SUPPORTED`` 和 "
"``MPI_ASYNC_PROTECTS_NONBLOCKING`` 的值是什么，并使它们的值可用作 "
"``MPI_Fortran_<binding>_SUBARRAYS`` 和 "
"``MPI_Fortran_<binding>_ASYNCPROT``，其中 ` `<binding>`` 是 "
"``F77_HEADER``、``F90_MODULE`` 和 ``F08_MODULE`` 之一。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:239
msgid "``MPI_DETERMINE_LIBRARY_VERSION``"
msgstr "``MPI_DETERMINE_LIBRARY_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:236
msgid ""
"For each language, find the output of ``MPI_Get_library_version`` and make"
" it available as ``MPI_<lang>_LIBRARY_VERSION_STRING``. This information "
"is usually tied to the runtime component of an MPI implementation and "
"might differ depending on ``<lang>``. Note that the return value is "
"entirely implementation defined. This information might be used to "
"identify the MPI vendor and for example pick the correct one of multiple "
"third party binaries that matches the MPI vendor."
msgstr ""
"对于每种语言，找到“MPI_Get_library_version”的输出并将其作为“MPI_<lang>_LIBRARY_VERSION_STRING”提供。此信息通常与"
" MPI 实现的运行时组件相关联，并且可能因“<lang>”而异。请注意，返回值完全由实现定义。此信息可用于识别 MPI "
"供应商，例如从多个第三方二进制文件中选择与 MPI 供应商匹配的正确一个。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:246
msgid ""
"For backward compatibility with older versions of FindMPI, these variables"
" are set:"
msgstr "为了与旧版本的 FindMPI 向后兼容，设置了这些变量："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:255
msgid ""
"In new projects, please use the ``MPI_<lang>_XXX`` equivalents. "
"Additionally, the following variables are deprecated:"
msgstr "在新项目中，请使用 ``MPI_<lang>_XXX`` 等价物。此外，以下变量已弃用："

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:258
msgid "``MPI_<lang>_COMPILE_FLAGS``"
msgstr "``MPI<语言 COMPILE_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:259
msgid ""
"Use ``MPI_<lang>_COMPILE_OPTIONS`` and ``MPI_<lang>_COMPILE_DEFINITIONS`` "
"instead."
msgstr "请改用``MPI<lang>COMPILE_OPTIONS`` 和``MPI<lang>COMPILE_DEFINITIONS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:260
msgid "``MPI_<lang>_INCLUDE_PATH``"
msgstr "``MPI<lang>c_INCLUDE_PATH``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:261
msgid ""
"For consumption use ``MPI_<lang>_INCLUDE_DIRS`` and for specifying folders"
" use ``MPI_<lang>_ADDITIONAL_INCLUDE_DIRS`` instead."
msgstr ""
"对于消费，使用``MPI_<lang>_INCLUDE_DIRS``，对于指定文件夹，使用``MPI_<lang>_ADDITIONAL_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:1907
msgid "``MPIEXEC``"
msgstr "``MPIEXEC``"

#: ../../cmake-prefix/src/cmake/Modules/FindMPI.cmake:263
msgid "Use ``MPIEXEC_EXECUTABLE`` instead."
msgstr "请改用``MPIEXEC_EXECUTABLE``。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:6
msgid "FindMatlab"
msgstr "查找Matlab"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:8
msgid ""
"Finds Matlab or Matlab Compiler Runtime (MCR) and provides Matlab tools, "
"libraries and compilers to CMake."
msgstr ""
"查找 Matlab 或 Matlab Compiler Runtime (MCR) 并为 CMake 提供 Matlab 工具、库和编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:11
msgid ""
"This package primary purpose is to find the libraries associated with "
"Matlab or the MCR in order to be able to build Matlab extensions (mex "
"files). It can also be used:"
msgstr "这个包的主要目的是找到与 Matlab 或 MCR 相关的库，以便能够构建 Matlab 扩展（mex 文件）。它也可以用于："

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:15
msgid "to run specific commands in Matlab in case Matlab is available"
msgstr "在 Matlab 可用的情况下在 Matlab 中运行特定命令"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:16
msgid "for declaring Matlab unit test"
msgstr "用于声明 Matlab 单元测试"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:17
msgid ""
"to retrieve various information from Matlab (mex extensions, versions and "
"release queries, ...)"
msgstr "从 Matlab 检索各种信息（mex 扩展、版本和发布查询，...）"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:20
msgid "Added Matlab Compiler Runtime (MCR) support."
msgstr "添加了 Matlab 编译器运行时 (MCR) 支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:23
msgid "The module supports the following components:"
msgstr "该模块支持以下组件："

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:25
msgid ""
"``ENG_LIBRARY`` and ``MAT_LIBRARY``: respectively the ``ENG`` and ``MAT`` "
"libraries of Matlab"
msgstr "``ENG_LIBRARY`` 和 ``MAT_LIBRARY``：分别是 Matlab 的 ``ENG`` 和 ``MAT`` 库"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:27
msgid ""
"``MAIN_PROGRAM`` the Matlab binary program. Note that this component is "
"not available on the MCR version, and will yield an error if the MCR is "
"found instead of the regular Matlab installation."
msgstr ""
"``MAIN_PROGRAM`` Matlab 二进制程序。请注意，此组件在 MCR 版本上不可用，如果找到 MCR 而不是常规的 Matlab "
"安装，则会产生错误。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:30
msgid "``MEX_COMPILER`` the MEX compiler."
msgstr "``MEX_COMPILER`` MEX 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:31
msgid ""
"``MCC_COMPILER`` the MCC compiler, included with the Matlab Compiler add-"
"on."
msgstr "``MCC_COMPILER`` MCC 编译器，包含在 Matlab 编译器附加组件中。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:32
msgid "``SIMULINK`` the Simulink environment."
msgstr "``SIMULINK`` Simulink 环境。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:34
msgid "Added the ``MAT_LIBRARY`` component."
msgstr "添加了``MAT_LIBRARY`` 组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:37
msgid ""
"Added the ``ENGINE_LIBRARY``, ``DATAARRAY_LIBRARY`` and ``MCC_COMPILER`` "
"components."
msgstr "添加了``ENGINE_LIBRARY``、``DATAARRAY_LIBRARY`` 和``MCC_COMPILER`` 组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:41
msgid ""
"Removed the ``MX_LIBRARY``, ``ENGINE_LIBRARY`` and ``DATAARRAY_LIBRARY`` "
"components.  These libraries are found unconditionally."
msgstr ""
"删除了 ``MX_LIBRARY``、``ENGINE_LIBRARY`` 和 ``DATAARRAY_LIBRARY`` "
"组件。这些库是无条件找到的。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:47
msgid ""
"The version given to the :command:`find_package` directive is the Matlab "
"**version**, which should not be confused with the Matlab *release* name "
"(eg. `R2014`). The :command:`matlab_get_version_from_release_name` and "
":command:`matlab_get_release_name_from_version` provide a mapping between "
"the release name and the version."
msgstr ""
"提供给 :command:`find_package` 指令的版本是 Matlab **version**，不应与 Matlab *release*"
" 名称（例如 `R2014`）混淆。 :command:`matlab_get_version_from_release_name` 和 "
":command:`matlab_get_release_name_from_version` 提供发布名称和版本之间的映射。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:54
msgid ""
"The variable :variable:`Matlab_ROOT_DIR` may be specified in order to give"
" the path of the desired Matlab version. Otherwise, the behavior is "
"platform specific:"
msgstr "可以指定变量 :variable:`Matlab_ROOT_DIR` 以提供所需 Matlab 版本的路径。否则，行为是特定于平台的："

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:58
msgid ""
"Windows: The installed versions of Matlab/MCR are retrieved from the "
"Windows registry"
msgstr "Windows：从 Windows 注册表中检索已安装的 Matlab/MCR 版本"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:60
msgid ""
"OS X: The installed versions of Matlab/MCR are given by the MATLAB default"
" installation paths in ``/Application``. If no such application is found, "
"it falls back to the one that might be accessible from the ``PATH``."
msgstr ""
"OS X：安装的 Matlab/MCR 版本由 ``/Application`` 中的 MATLAB "
"默认安装路径给出。如果没有找到这样的应用程序，它会回退到可以从 ``PATH`` 访问的应用程序。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:63
msgid ""
"Unix: The desired Matlab should be accessible from the ``PATH``. This does"
" not work for MCR installation and :variable:`Matlab_ROOT_DIR` should be "
"specified on this platform."
msgstr ""
"Unix：所需的 Matlab 应该可以从 ``PATH`` 访问。这不适用于 MCR "
"安装，应在此平台上指定 :variable:`Matlab_ROOT_DIR`。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:67
msgid ""
"Additional information is provided when :variable:`MATLAB_FIND_DEBUG` is "
"set. When a Matlab/MCR installation is found automatically and the "
"``MATLAB_VERSION`` is not given, the version is queried from Matlab "
"directly (on Windows this may pop up a Matlab window) or from the MCR "
"installation."
msgstr ""
"设置 :variable:`MATLAB_FIND_DEBUG` 时会提供其他信息。当自动找到 Matlab/MCR 安装且未给出 "
"``MATLAB_VERSION`` 时，将直接从 Matlab（在 Windows 上这可能会弹出一个 Matlab 窗口）或从 MCR "
"安装查询版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:72
msgid ""
"The mapping of the release names and the version of Matlab is performed by"
" defining pairs (name, version).  The variable "
":variable:`MATLAB_ADDITIONAL_VERSIONS` may be provided before the call to "
"the :command:`find_package` in order to handle additional versions."
msgstr ""
"发布名称和 Matlab 版本的映射是通过定义对 (name, version) 来执行的。可以在调用 "
":command:`find_package` 之前提供变量 MATLAB_ADDITIONAL_VERSIONS 以处理其他版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:77
msgid ""
"A Matlab scripts can be added to the set of tests using the "
":command:`matlab_add_unit_test`. By default, the Matlab unit test "
"framework will be used (>= 2013a) to run this script, but regular ``.m`` "
"files returning an exit code can be used as well (0 indicating a success)."
msgstr ""
"可以使用 :command:`matlab_add_unit_test` 将 Matlab 脚本添加到测试集中。默认情况下，将使用 Matlab "
"单元测试框架 (>= 2013a) 来运行此脚本，但也可以使用返回退出代码的常规 ``.m`` 文件（0 表示成功）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:83
msgid "Module Input Variables"
msgstr "模块输入变量"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:85
msgid ""
"Users or projects may set the following variables to configure the module "
"behavior:"
msgstr "用户或项目可以设置以下变量来配置模块行为："

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:92
msgid ":variable:`Matlab_ROOT <<PackageName>_ROOT>`"
msgstr ":variable:`Matlab_ROOT <<PackageName>_ROOT>`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:91
msgid ""
"Default value for :variable:`Matlab_ROOT_DIR`, the root of the Matlab "
"installation."
msgstr ":variable:`Matlab_ROOT_DIR` 的默认值，Matlab 安装的根目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:95
msgid ":variable:`Matlab_ROOT_DIR`"
msgstr ":variable:`Matlab_ROOT_DIR`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:95
msgid "The root of the Matlab installation."
msgstr "Matlab 安装的根目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:98
msgid ":variable:`MATLAB_FIND_DEBUG`"
msgstr ":variable:`MATLAB_FIND_DEBUG`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:98
msgid "outputs debug information"
msgstr "输出调试信息"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:102
msgid ":variable:`MATLAB_ADDITIONAL_VERSIONS`"
msgstr ":variable:`MATLAB_ADDITIONAL_VERSIONS`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:101
msgid ""
"additional versions of Matlab for the automatic retrieval of the installed"
" versions."
msgstr "其他版本的 Matlab 用于自动检索已安装的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:112
msgid "``Matlab::mex``"
msgstr "``Matlab::mex``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:112
msgid "The ``mex`` library, always available."
msgstr "``mex`` 库，始终可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:115
msgid "``Matlab::mx``"
msgstr "``Matlab::mx``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:115
msgid "The mx library of Matlab (arrays), always available."
msgstr "Matlab 的 mx 库（数组），始终可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:119
msgid "``Matlab::eng``"
msgstr "``Matlab::eng``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:118
msgid ""
"Matlab engine library. Available only if the ``ENG_LIBRARY`` component is "
"requested."
msgstr "Matlab引擎库。仅在请求“ENG_LIBRARY”组件时可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:123
msgid "``Matlab::mat``"
msgstr "``Matlab::mat``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:122
msgid ""
"Matlab matrix library. Available only if the ``MAT_LIBRARY`` component is "
"requested."
msgstr "Matlab矩阵库。仅在请求“MAT_LIBRARY”组件时可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:126
msgid "``Matlab::MatlabEngine``"
msgstr "``Matlab::MatlabEngine``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:126
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:161
msgid "Matlab C++ engine library, always available for R2018a and newer."
msgstr "Matlab C++ 引擎库，始终适用于 R2018a 及更新版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:129
msgid "``Matlab::MatlabDataArray``"
msgstr "``Matlab::Matlab 数据数组``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:129
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:165
msgid ""
"Matlab C++ data array library, always available for R2018a and newer."
msgstr "Matlab C++ 数据数组库，始终适用于 R2018a 及更新版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:132
msgid "Variables defined by the module"
msgstr "模块定义的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:138
msgid "``Matlab_FOUND``"
msgstr "``Matlab_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:138
msgid ""
"``TRUE`` if the Matlab installation is found, ``FALSE`` otherwise. All "
"variable below are defined if Matlab is found."
msgstr "如果找到 Matlab 安装，则为 TRUE，否则为 FALSE。如果找到 Matlab，则定义以下所有变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:141
#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:184
msgid "``Matlab_ROOT_DIR``"
msgstr "``Matlab_ROOT_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:141
msgid ""
"the final root of the Matlab installation determined by the FindMatlab "
"module."
msgstr "由 FindMatlab 模块确定的 Matlab 安装的最终根目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:144
msgid "``Matlab_MAIN_PROGRAM``"
msgstr "``Matlab_MAIN_PROGRAM``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:144
msgid ""
"the Matlab binary program. Available only if the component "
"``MAIN_PROGRAM`` is given in the :command:`find_package` directive."
msgstr ""
"Matlab 二进制程序。只有在 :command:`find_package` 指令中给出了组件 ``MAIN_PROGRAM`` 才可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:146
msgid "``Matlab_INCLUDE_DIRS``"
msgstr "``Matlab_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:147
msgid "the path of the Matlab libraries headers"
msgstr "Matlab 库标题的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:148
msgid "``Matlab_MEX_LIBRARY``"
msgstr "``Matlab_MEX_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:149
msgid "library for mex, always available."
msgstr "mex 库，始终可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:150
msgid "``Matlab_MX_LIBRARY``"
msgstr "``Matlab_MX_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:151
msgid "mx library of Matlab (arrays), always available."
msgstr "Matlab 的 mx 库（数组），始终可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:153
msgid "``Matlab_ENG_LIBRARY``"
msgstr "``Matlab_ENG_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:153
msgid ""
"Matlab engine library. Available only if the component ``ENG_LIBRARY`` is "
"requested."
msgstr "Matlab引擎库。仅在请求组件“ENG_LIBRARY”时可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:156
msgid "``Matlab_MAT_LIBRARY``"
msgstr "``Matlab_MAT_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:156
msgid ""
"Matlab matrix library. Available only if the component ``MAT_LIBRARY`` is "
"requested."
msgstr "Matlab矩阵库。仅在请求组件“MAT_LIBRARY”时可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:160
msgid "``Matlab_ENGINE_LIBRARY``"
msgstr "``Matlab_ENGINE_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:164
msgid "``Matlab_DATAARRAY_LIBRARY``"
msgstr "``Matlab_DATAARRAY_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:166
msgid "``Matlab_LIBRARIES``"
msgstr "``Matlab_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:167
msgid "the whole set of libraries of Matlab"
msgstr "整套Matlab库"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:169
msgid "``Matlab_MEX_COMPILER``"
msgstr "``Matlab_MEX_COMPILER``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:169
msgid ""
"the mex compiler of Matlab. Currently not used. Available only if the "
"component ``MEX_COMPILER`` is requested."
msgstr "Matlab 的 mex 编译器。目前没有使用。仅在请求组件“MEX_COMPILER”时可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:175
msgid "``Matlab_MCC_COMPILER``"
msgstr "``Matlab_MCC_COMPILER``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:174
msgid ""
"the mcc compiler of Matlab. Included with the Matlab Compiler add-on. "
"Available only if the component ``MCC_COMPILER`` is requested."
msgstr "Matlab的mcc编译器。包含在 Matlab 编译器附加组件中。仅在请求组件“MCC_COMPILER”时可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:178
msgid "Cached variables"
msgstr "缓存变量"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:180
msgid "``Matlab_MEX_EXTENSION``"
msgstr "``Matlab_MEX_EXTENSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:181
msgid ""
"the extension of the mex files for the current platform (given by Matlab)."
msgstr "当前平台的 mex 文件扩展名（由 Matlab 提供）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:183
msgid ""
"the location of the root of the Matlab installation found. If this value "
"is changed by the user, the result variables are recomputed."
msgstr "找到 Matlab 安装根目录的位置。如果用户更改了该值，则会重新计算结果变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:187
msgid "Provided macros"
msgstr "提供的宏"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:189
msgid ":command:`matlab_get_version_from_release_name`"
msgstr ":command:`matlab_get_version_from_release_name`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:190
msgid "returns the version from the release name"
msgstr "从发布名称返回版本"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:192
msgid ":command:`matlab_get_release_name_from_version`"
msgstr ":command:`matlab_get_release_name_from_version`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:192
msgid "returns the release name from the Matlab version"
msgstr "返回 Matlab 版本的发布名称"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:195
msgid "Provided functions"
msgstr "提供的功能"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:197
msgid ":command:`matlab_add_mex`"
msgstr ":command:`matlab_add_mex`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:198
msgid "adds a target compiling a MEX file."
msgstr "添加编译 MEX 文件的目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:199
msgid ":command:`matlab_add_unit_test`"
msgstr ":command:`matlab_add_unit_test`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:200
msgid "adds a Matlab unit test file as a test to the project."
msgstr "添加一个 Matlab 单元测试文件作为对项目的测试。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:202
msgid ":command:`matlab_extract_all_installed_versions_from_registry`"
msgstr ":command:`matlab_extract_all_installed_versions_from_registry`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:202
msgid ""
"parses the registry for all Matlab versions. Available on Windows only. "
"The part of the registry parsed is dependent on the host processor"
msgstr "解析所有 Matlab 版本的注册表。仅适用于 Windows。解析的注册表部分取决于主机处理器"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:206
msgid ":command:`matlab_get_all_valid_matlab_roots_from_registry`"
msgstr ":command:`matlab_get_all_valid_matlab_roots_from_registry`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:205
msgid ""
"returns all the possible Matlab or MCR paths, according to a previously "
"given list. Only the existing/accessible paths are kept. This is mainly "
"useful for the searching all possible Matlab installation."
msgstr ""
"根据先前给定的列表，返回所有可能的 Matlab 或 MCR 路径。只保留现有/可访问的路径。这主要用于搜索所有可能的 Matlab 安装。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:209
msgid ":command:`matlab_get_mex_suffix`"
msgstr ":command:`matlab_get_mex_suffix`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:209
msgid ""
"returns the suffix to be used for the mex files (platform/architecture "
"dependent)"
msgstr "返回用于 mex 文件的后缀（取决于平台/体系结构）"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:214
msgid ":command:`matlab_get_version_from_matlab_run`"
msgstr ":command:`matlab_get_version_from_matlab_run`"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:212
msgid ""
"returns the version of Matlab/MCR, given the full directory of the "
"Matlab/MCR installation path."
msgstr "返回 Matlab/MCR 的版本，给定 Matlab/MCR 安装路径的完整目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:217
msgid "Known issues"
msgstr "已知的问题"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:232
msgid "**Symbol clash in a MEX target**"
msgstr "**MEX 目标中的符号冲突**"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:220
msgid ""
"By default, every symbols inside a MEX file defined with the command "
":command:`matlab_add_mex` have hidden visibility, except for the entry "
"point. This is the default behavior of the MEX compiler, which lowers the "
"risk of symbol collision between the libraries shipped with Matlab, and "
"the libraries to which the MEX file is linking to. This is also the "
"default on Windows platforms."
msgstr ""
"默认情况下，MEX 文件中使用命令 matlab_add_mex 定义的每个符号都隐藏可见性，入口点除外。这是 MEX 编译器的默认行为，它降低了 "
"Matlab 附带的库与 MEX 文件链接到的库之间发生符号冲突的风险。这也是 Windows 平台上的默认设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:227
msgid ""
"However, this is not sufficient in certain case, where for instance your "
"MEX file is linking against libraries that are already loaded by Matlab, "
"even if those libraries have different SONAMES. A possible solution is to "
"hide the symbols of the libraries to which the MEX target is linking to. "
"This can be achieved in GNU GCC compilers with the linker option ``-Wl,--"
"exclude-libs,ALL``."
msgstr ""
"但是，这在某些情况下是不够的，例如您的 MEX 文件链接到 Matlab 已经加载的库，即使这些库具有不同的 "
"SONAMES。一种可能的解决方案是隐藏 MEX 目标链接到的库的符号。这可以在 GNU GCC 编译器中使用链接器选项“-Wl,--"
"exclude-libs,ALL”来实现。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:241
msgid "**Tests using GPU resources**"
msgstr "**使用 GPU 资源进行测试**"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:235
msgid ""
"in case your MEX file is using the GPU and in order to be able to run unit"
" tests on this MEX file, the GPU resources should be properly released by "
"Matlab. A possible solution is to make Matlab aware of the use of the GPU "
"resources in the session, which can be performed by a command such as ``D "
"= gpuDevice()`` at the beginning of the test script (or via a fixture)."
msgstr ""
"如果您的 MEX 文件正在使用 GPU，并且为了能够对此 MEX 文件运行单元测试，Matlab 应正确释放 GPU 资源。一个可能的解决方案是让 "
"Matlab 知道会话中 GPU 资源的使用，这可以通过在测试脚本开头（或通过夹具）执行诸如“D = gpuDevice()”之类的命令."

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:244
msgid "Reference"
msgstr "参考"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:248
msgid ""
"The root folder of the Matlab installation. If set before the call to "
":command:`find_package`, the module will look for the components in that "
"path. If not set, then an automatic search of Matlab will be performed. If"
" set, it should point to a valid version of Matlab."
msgstr ""
"Matlab 安装的根文件夹。如果在调用 :command:`find_package` 之前设置，模块将在该路径中查找组件。如果未设置，则将执行 "
"Matlab 的自动搜索。如果设置，它应该指向一个有效的 Matlab 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:255
msgid ""
"If set, the lookup of Matlab and the intermediate configuration steps are "
"outputted to the console."
msgstr "如果设置，Matlab 的查找和中间配置步骤将输出到控制台。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:260
msgid ""
"If set, specifies additional versions of Matlab that may be looked for. "
"The variable should be a list of strings, organized by pairs of release "
"name and versions, such as follows::"
msgstr "如果设置，指定可能查找的其他版本的 Matlab。该变量应该是一个字符串列表，由成对的发布名称和版本组织，例如："

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:277
msgid ""
"The order of entries in this list matters when several versions of Matlab "
"are installed. The priority is set according to the ordering in this list."
msgstr "当安装了多个版本的 Matlab 时，此列表中的条目顺序很重要。优先级是根据此列表中的顺序设置的。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:340
msgid "Returns the version of Matlab (17.58) from a release name (R2017k)"
msgstr "从发布名称 (R2017k) 返回 Matlab (17.58) 的版本"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:363
msgid "Returns the release name (R2017k) from the version of Matlab (17.58)"
msgstr "返回 Matlab (17.58) 版本的发布名称 (R2017k)"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:424
msgid ""
"This function parses the registry and founds the Matlab versions that are "
"installed. The found versions are returned in `matlab_versions`. Set "
"`win64` to `TRUE` if the 64 bit version of Matlab should be looked for The"
" returned list contains all versions under "
"``HKLM\\\\SOFTWARE\\\\Mathworks\\\\MATLAB`` and "
"``HKLM\\\\SOFTWARE\\\\Mathworks\\\\MATLAB Runtime`` or an empty list in "
"case an error occurred (or nothing found)."
msgstr ""
"此函数解析注册表并找到已安装的 Matlab 版本。找到的版本在“matlab_versions”中返回。如果要查找 64 位版本的 "
"Matlab，请将 `win64` 设置为 `TRUE` 返回的列表包含 "
"``HKLM\\\\SOFTWARE\\\\Mathworks\\\\MATLAB`` 和 "
"``HKLM\\\\SOFTWARE\\\\Mathworks 下的所有版本\\\\MATLAB Runtime`` "
"或一个空列表，以防发生错误（或未找到任何内容）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:434
msgid ""
"Only the versions are provided. No check is made over the existence of the"
" installation referenced in the registry,"
msgstr "仅提供版本。不检查注册表中引用的安装是否存在，"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:549
msgid ""
"Populates the Matlab root with valid versions of Matlab or Matlab Runtime "
"(MCR). The returned matlab_roots is organized in triplets "
"``(type,version_number,matlab_root_path)``, where ``type`` indicates "
"either ``MATLAB`` or ``MCR``."
msgstr ""
"使用有效版本的 Matlab 或 Matlab Runtime (MCR) 填充 Matlab 根目录。返回的 matlab_roots "
"被组织成三元组``(type,version_number,matlab_root_path)``，其中``type`` 表示``MATLAB`` "
"或``MCR``。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:561
msgid "``matlab_versions``"
msgstr "``matlab_versions``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:562
msgid "the versions of each of the Matlab or MCR installations"
msgstr "每个 Matlab 或 MCR 安装的版本"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:563
msgid "``matlab_roots``"
msgstr "``matlab_roots``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:564
msgid "the location of each of the Matlab or MCR installations"
msgstr "每个 Matlab 或 MCR 安装的位置"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:623
msgid ""
"Returns the extension of the mex files (the suffixes). This function "
"should not be called before the appropriate Matlab root has been found."
msgstr "返回 mex 文件的扩展名（后缀）。在找到适当的 Matlab 根之前，不应调用此函数。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:633
msgid "``matlab_root``"
msgstr "``matlab_root``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:634
msgid "the root of the Matlab/MCR installation"
msgstr "Matlab/MCR 安装的根目录"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:635
msgid "``mex_suffix``"
msgstr "``mex_suffix``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:636
msgid "the variable name in which the suffix will be returned."
msgstr "返回后缀的变量名。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:719
msgid ""
"This function runs Matlab program specified on arguments and extracts its "
"version. If the path provided for the Matlab installation points to an MCR"
" installation, the version is extracted from the installed files."
msgstr ""
"此函数运行参数指定的 Matlab 程序并提取其版本。如果为 Matlab 安装提供的路径指向 MCR 安装，则会从安装的文件中提取版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:729
msgid "``matlab_binary_path``"
msgstr "``matlab_binary_path``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:730
msgid "the location of the `matlab` binary executable"
msgstr "`matlab` 二进制可执行文件的位置"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:731
msgid "``matlab_list_versions``"
msgstr "``matlab_list_versions``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:732
msgid "the version extracted from Matlab"
msgstr "从 Matlab 中提取的版本"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:887
msgid ""
"Adds a Matlab unit test to the test set of cmake/ctest. This command "
"requires the component ``MAIN_PROGRAM`` and hence is not available for an "
"MCR installation."
msgstr ""
"将 Matlab 单元测试添加到 cmake/ctest 的测试集中。此命令需要组件“MAIN_PROGRAM”，因此不适用于 MCR 安装。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:891
msgid ""
"The unit test uses the Matlab unittest framework (default, available "
"starting Matlab 2013b+) except if the option ``NO_UNITTEST_FRAMEWORK`` is "
"given."
msgstr ""
"单元测试使用 Matlab unittest 框架（默认，从 Matlab 2013b+ 开始可用）除非给出选项 "
"``NO_UNITTEST_FRAMEWORK``。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:895
msgid ""
"The function expects one Matlab test script file to be given. In the case "
"``NO_UNITTEST_FRAMEWORK`` is given, the unittest script file should "
"contain the script to be run, plus an exit command with the exit value. "
"This exit value will be passed to the ctest framework (0 success, non 0 "
"failure). Additional arguments accepted by :command:`add_test` can be "
"passed through ``TEST_ARGS`` (eg. ``CONFIGURATION <config> ...``)."
msgstr ""
"该函数需要一个 Matlab 测试脚本文件。在给出 ``NO_UNITTEST_FRAMEWORK`` 的情况下，unittest "
"脚本文件应包含要运行的脚本，以及带有退出值的退出命令。此退出值将传递给 ctest 框架（0 成功，非 0 失败）。 "
":command:`add_test` 接受的附加参数可以通过 ``TEST_ARGS`` 传递（例如 ``CONFIGURATION "
"<config> ...``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:916
msgid "The function arguments are:"
msgstr "函数参数是："

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:919
msgid "name of the unittest in ctest."
msgstr "ctest中单元测试的名称。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:921
msgid "``UNITTEST_FILE``"
msgstr "``UNITTEST_FILE``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:921
msgid ""
"the matlab unittest file. Its path will be automatically added to the "
"Matlab path."
msgstr "matlab 单元测试文件。它的路径将自动添加到 Matlab 路径中。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:926
msgid "``CUSTOM_TEST_COMMAND``"
msgstr "``CUSTOM_TEST_COMMAND``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:924
msgid ""
"Matlab script command to run as the test. If this is not set, then the "
"following is run: ``runtests('matlab_file_name'), "
"exit(max([ans(1,:).Failed]))`` where ``matlab_file_name`` is the "
"``UNITTEST_FILE`` without the extension."
msgstr ""
"作为测试运行的 Matlab 脚本命令。如果未设置，则运行以下命令：``runtests('matlab_file_name'), "
"exit(max([ans(1,:).Failed]))`` 其中 ``matlab_file_name`` 是 ``UNITTEST_FILE "
"`` 没有扩展名。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:930
msgid "``UNITTEST_PRECOMMAND``"
msgstr "``UNITTEST_PRECOMMAND``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:929
msgid ""
"Matlab script command to be ran before the file containing the test (eg. "
"GPU device initialization based on CMake variables)."
msgstr "在包含测试的文件之前运行的 Matlab 脚本命令（例如，基于 CMake 变量的 GPU 设备初始化）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:933
msgid "``TIMEOUT``"
msgstr "``超时``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:933
msgid ""
"the test timeout in seconds. Defaults to 180 seconds as the Matlab unit "
"test may hang."
msgstr "以秒为单位的测试超时。默认为 180 秒，因为 Matlab 单元测试可能会挂起。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:936
msgid "``ADDITIONAL_PATH``"
msgstr "``ADDITIONAL_PATH``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:936
msgid ""
"a list of paths to add to the Matlab path prior to running the unit test."
msgstr "在运行单元测试之前添加到 Matlab 路径的路径列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:940
msgid "``MATLAB_ADDITIONAL_STARTUP_OPTIONS``"
msgstr "``MATLAB_ADDITIONAL_STARTUP_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:939
msgid ""
"a list of additional option in order to run Matlab from the command line. "
"``-nosplash -nodesktop -nodisplay`` are always added."
msgstr "为了从命令行运行 Matlab 的附加选项列表。 ``-nosplash -nodesktop -nodisplay`` 总是被添加。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:943
msgid "``TEST_ARGS``"
msgstr "``测试参数``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:943
msgid ""
"Additional options provided to the add_test command. These options are "
"added to the default options (eg. \"CONFIGURATIONS Release\")"
msgstr "提供给 add_test 命令的附加选项。这些选项被添加到默认选项（例如“CONFIGURATIONS Release”）"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:946
msgid "``NO_UNITTEST_FRAMEWORK``"
msgstr "``NO_UNITTEST_FRAMEWORK``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:946
msgid ""
"when set, indicates that the test should not use the unittest framework of"
" Matlab (available for versions >= R2013a)."
msgstr "设置后，表示测试不应使用 Matlab 的单元测试框架（适用于 >= R2013a 的版本）。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:951
msgid "``WORKING_DIRECTORY``"
msgstr "``工作目录``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:949
msgid ""
"This will be the working directory for the test. If specified it will also"
" be the output directory used for the log file of the test run. If not "
"specified the temporary directory ``${CMAKE_BINARY_DIR}/Matlab`` will be "
"used as the working directory and the log location."
msgstr ""
"这将是测试的工作目录。如果指定，它也将是用于测试运行日志文件的输出目录。如果未指定临时目录 "
"``${CMAKE_BINARY_DIR}/Matlab`` 将用作工作目录和日志位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1007
msgid ""
"Adds a Matlab MEX target. This commands compiles the given sources with "
"the current tool-chain in order to produce a MEX file. The final name of "
"the produced output may be specified, as well as additional link "
"libraries, and a documentation entry for the MEX file. Remaining arguments"
" of the call are passed to the :command:`add_library` or "
":command:`add_executable` command."
msgstr ""
"添加 Matlab MEX 目标。此命令使用当前工具链编译给定源以生成 MEX 文件。可以指定生成的输出的最终名称，以及其他链接库和 MEX "
"文件的文档条目。调用的其余参数传递给 :command:`add_library` 或 :command:`add_executable` 命令。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1030
msgid "name of the target."
msgstr "目标的名称。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1031
msgid "``SRC``"
msgstr "``SRC``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1032
msgid "list of source files."
msgstr "源文件列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1035
msgid "``LINK_TO``"
msgstr "``LINK_TO``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1034
msgid ""
"a list of additional link dependencies.  The target links to ``libmex`` "
"and ``libmx`` by default, unless the "
"``NO_IMPLICIT_LINK_TO_MATLAB_LIBRARIES`` option is passed."
msgstr ""
"附加链接依赖项的列表。默认情况下，目标链接到 ``libmex`` 和 ``libmx``，除非传递了 "
"``NO_IMPLICIT_LINK_TO_MATLAB_LIBRARIES`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1039
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:122
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:340
msgid "``OUTPUT_NAME``"
msgstr "``OUTPUT_NAME``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1038
msgid ""
"if given, overrides the default name. The default name is the name of the "
"target without any prefix and with ``Matlab_MEX_EXTENSION`` suffix."
msgstr "如果给定，则覆盖默认名称。默认名称是没有任何前缀和带有“Matlab_MEX_EXTENSION”后缀的目标名称。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1045
msgid "``DOCUMENTATION``"
msgstr "``文档``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1042
msgid ""
"if given, the file ``file.txt`` will be considered as being the "
"documentation file for the MEX file. This file is copied into the same "
"folder without any processing, with the same name as the final mex file, "
"and with extension `.m`. In that case, typing ``help <name>`` in Matlab "
"prints the documentation contained in this file."
msgstr ""
"如果给定，文件 ``file.txt`` 将被视为 MEX 文件的文档文件。该文件未经任何处理被复制到同一文件夹中，与最终的 mex "
"文件同名，扩展名为“.m”。在这种情况下，在 Matlab 中键入 ``help <name>`` 将打印此文件中包含的文档。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1055
msgid "``R2017b`` or ``R2018a``"
msgstr "``R2017b`` 或 ``R2018a``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1050
msgid ""
"May be given to specify the version of the C API to use: ``R2017b`` "
"specifies the traditional (separate complex) C API, and corresponds to the"
" ``-R2017b`` flag for the `mex` command. ``R2018a`` specifies the new "
"interleaved complex C API, and corresponds to the ``-R2018a`` flag for the"
" `mex` command. Ignored if MATLAB version prior to R2018a. Defaults to "
"``R2017b``."
msgstr ""
"可以给出指定要使用的 C API 的版本：``R2017b`` 指定传统的（单独的复杂）C API，并且对应于``-R2017b`` "
"标志用于`mex` 命令。 ``R2018a`` 指定新的交错复杂 C API，对应于 `mex` 命令的 ``-R2018a`` 标志。如果 "
"MATLAB 版本早于 R2018a，则忽略。默认为“R2017b”。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1061
msgid "``MODULE`` or ``SHARED``"
msgstr "``MODULE`` 或 ``SHARED``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1060
msgid "May be given to specify the type of library to be created."
msgstr "可以给出指定要创建的库的类型。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1066
msgid "``EXECUTABLE``"
msgstr "``可执行``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1066
msgid ""
"May be given to create an executable instead of a library. If no type is "
"given explicitly, the type is ``SHARED``."
msgstr "可以创建一个可执行文件而不是一个库。如果没有明确给出类型，则类型为“SHARED”。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1070
msgid "``EXCLUDE_FROM_ALL``"
msgstr "``EXCLUDE_FROM_ALL``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1069
msgid ""
"This option has the same meaning as for :prop_tgt:`EXCLUDE_FROM_ALL` and "
"is forwarded to :command:`add_library` or :command:`add_executable` "
"commands."
msgstr ""
"此选项与 :prop_tgt:`EXCLUDE_FROM_ALL` 具有相同的含义，并转发到 :command:`add_library` 或 "
":command:`add_executable` 命令。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1077
msgid "``NO_IMPLICIT_LINK_TO_MATLAB_LIBRARIES``"
msgstr "``NO_IMPLICIT_LINK_TO_MATLAB_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1075
msgid ""
"This option permits to disable the automatic linking of MATLAB libraries, "
"so that only the libraries that are actually required can be linked via "
"the ``LINK_TO`` option."
msgstr "此选项允许禁用 MATLAB 库的自动链接，以便只有实际需要的库可以通过“LINK_TO”选项链接。"

#: ../../cmake-prefix/src/cmake/Modules/FindMatlab.cmake:1079
msgid ""
"The documentation file is not processed and should be in the following "
"format:"
msgstr "文档文件未处理，应采用以下格式："

#: ../../cmake-prefix/src/cmake/Modules/FindMotif.cmake:6
msgid "FindMotif"
msgstr "寻找主题"

#: ../../cmake-prefix/src/cmake/Modules/FindMotif.cmake:8
msgid "Try to find Motif (or lesstif)"
msgstr "尝试找到 Motif（或 lesstif）"

#: ../../cmake-prefix/src/cmake/Modules/FindMotif.cmake:10
msgid "Once done this will define:"
msgstr "一旦完成，这将定义："

#: ../../cmake-prefix/src/cmake/Modules/FindMsys.cmake:6
msgid "FindMsys"
msgstr "查找Msys"

#: ../../cmake-prefix/src/cmake/Modules/FindMsys.cmake:10
msgid ""
"Find MSYS, a POSIX-compatible environment that runs natively on Microsoft "
"Windows"
msgstr "查找 MSYS，一个在 Microsoft Windows 上本地运行的 POSIX 兼容环境"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:6
msgid "FindODBC"
msgstr "查找ODBC"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:10
msgid ""
"Find an Open Database Connectivity (ODBC) include directory and library."
msgstr "查找开放式数据库连接 (ODBC) 包含目录和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:12
msgid ""
"On Windows, when building with Visual Studio, this module assumes the ODBC"
" library is provided by the available Windows SDK."
msgstr "在 Windows 上，当使用 Visual Studio 构建时，此模块假定 ODBC 库由可用的 Windows SDK 提供。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:15
msgid ""
"On Unix, this module allows to search for ODBC library provided by "
"unixODBC or iODBC implementations of ODBC API. This module reads hint "
"about location of the config program:"
msgstr ""
"在 Unix 上，此模块允许搜索由 unixODBC 或 ODBC API 的 iODBC 实现提供的 ODBC "
"库。该模块读取有关配置程序位置的提示："

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:21
msgid "Location of odbc_config or iodbc-config program"
msgstr "odbc_config 或 iodbc-config 程序的位置"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:23
msgid ""
"Otherwise, this module tries to find the config program, first from "
"unixODBC, then from iODBC. If no config program found, this module "
"searches for ODBC header and library in list of known locations."
msgstr ""
"否则，此模块会尝试查找配置程序，首先从 unixODBC，然后从 iODBC。如果未找到配置程序，此模块会在已知位置列表中搜索 ODBC 标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:35
msgid "Imported target for using the ODBC library, if found."
msgstr "使用 ODBC 库的导入目标（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:42
msgid "Set to true if ODBC library found, otherwise false or undefined."
msgstr "如果找到 ODBC 库，则设置为 true，否则为 false 或未定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:46
msgid ""
"Paths to include directories listed in one variable for use by ODBC "
"client. May be empty on Windows, where the include directory corresponding"
" to the expected Windows SDK is already available in the compilation "
"environment."
msgstr ""
"包含在一个变量中列出的目录的路径，供 ODBC 客户端使用。在 Windows 上可能为空，编译环境中已经有预期的 Windows SDK 对应的 "
"include 目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:52
msgid ""
"Paths to libraries to linked against to use ODBC. May just a library name "
"on Windows, where the library directory corresponding to the expected "
"Windows SDK is already available in the compilation environment."
msgstr "要链接以使用 ODBC 的库的路径。在Windows上可能只是一个库名，编译环境中已经有预期的Windows SDK对应的库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:58
msgid "Path to unixODBC or iODBC config program, if found or specified."
msgstr "unixODBC 或 iODBC 配置程序的路径（如果找到或已指定）。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:63
msgid ""
"For users who wish to edit and control the module behavior, this module "
"reads hints about search locations from the following variables:"
msgstr "对于希望编辑和控制模块行为的用户，此模块从以下变量中读取有关搜索位置的提示："

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:68
msgid "Path to ODBC include directory with ``sql.h`` header."
msgstr "ODBC 的路径包括带有 ``sql.h`` 标题的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:72
msgid "Path to ODBC library to be linked."
msgstr "要链接的 ODBC 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:74
msgid "These variables should not be used directly by project code."
msgstr "这些变量不应由项目代码直接使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:77
msgid "Limitations"
msgstr "限制"

#: ../../cmake-prefix/src/cmake/Modules/FindODBC.cmake:79
msgid ""
"On Windows, this module does not search for iODBC. On Unix, there is no "
"way to prefer unixODBC over iODBC, or vice versa, other than providing the"
" config program location using the ``ODBC_CONFIG``. This module does not "
"allow to search for a specific ODBC driver."
msgstr ""
"在 Windows 上，此模块不搜索 iODBC。在 Unix 上，除了使用 ``ODBC_CONFIG`` 提供配置程序位置之外，没有办法优先使用"
" unixODBC 而不是 iODBC，反之亦然。此模块不允许搜索特定的 ODBC 驱动程序。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:6
msgid "FindOpenACC"
msgstr "查找OpenACC"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:10
msgid "Detect OpenACC support by the compiler."
msgstr "检测编译器对 OpenACC 的支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:12
msgid ""
"This module can be used to detect OpenACC support in a compiler. If the "
"compiler supports OpenACC, the flags required to compile with OpenACC "
"support are returned in variables for the different languages. Currently, "
"only NVHPC, PGI, GNU and Cray compilers are supported."
msgstr ""
"该模块可用于检测编译器中的 OpenACC 支持。如果编译器支持 OpenACC，则使用 OpenACC "
"支持进行编译所需的标志将在不同语言的变量中返回。目前，仅支持 NVHPC、PGI、GNU 和 Cray 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:22
msgid "The module provides :prop_tgt:`IMPORTED` targets:"
msgstr "该模块提供 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:25
msgid "``OpenACC::OpenACC_<lang>``"
msgstr "``OpenACC::OpenACC_<lang>``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:25
msgid "Target for using OpenACC from ``<lang>``."
msgstr "使用 ``<lang>`` 中的 OpenACC 的目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:35
msgid "``OpenACC_FOUND``"
msgstr "``OpenACC_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:35
msgid ""
"Variable indicating that OpenACC flags for at least one languages have "
"been found."
msgstr "指示已找到至少一种语言的 OpenACC 标志的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:40
msgid "``OpenACC_<lang>_FOUND``"
msgstr "``OpenACC_<lang>_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:41
msgid "Variable indicating if OpenACC support for ``<lang>`` was detected."
msgstr "指示是否检测到 OpenACC 支持 ``<lang>`` 的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:42
msgid "``OpenACC_<lang>_FLAGS``"
msgstr "``OpenACC_<lang>_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:43
msgid "OpenACC compiler flags for ``<lang>``, separated by spaces."
msgstr "``<lang>`` 的 OpenACC 编译器标志，以空格分隔。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:48
msgid "``OpenACC_<lang>_OPTIONS``"
msgstr "``OpenACC_<lang>_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:47
msgid ""
"OpenACC compiler flags for ``<lang>``, as a list. Suitable for usage with "
"target_compile_options or target_link_options."
msgstr ""
"``<lang>`` 的 OpenACC 编译器标志，作为列表。适合与 target_compile_options 或 "
"target_link_options 一起使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:50
msgid "The module will also try to provide the OpenACC version variables:"
msgstr "该模块还将尝试提供 OpenACC 版本变量："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:52
msgid "``OpenACC_<lang>_SPEC_DATE``"
msgstr "``OpenACC_<lang>_SPEC_DATE``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:53
msgid ""
"Date of the OpenACC specification implemented by the ``<lang>`` compiler."
msgstr "``<lang>`` 编译器实现的 OpenACC 规范的日期。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:54
msgid "``OpenACC_<lang>_VERSION_MAJOR``"
msgstr "``OpenACC_<lang>_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:55
msgid "Major version of OpenACC implemented by the ``<lang>`` compiler."
msgstr "``<lang>`` 编译器实现的 OpenACC 主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:56
msgid "``OpenACC_<lang>_VERSION_MINOR``"
msgstr "``OpenACC_<lang>_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:57
msgid "Minor version of OpenACC implemented by the ``<lang>`` compiler."
msgstr "由 ``<lang>`` 编译器实现的 OpenACC 的次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:59
msgid "``OpenACC_<lang>_VERSION``"
msgstr "``OpenACC_<lang>_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:59
msgid "OpenACC version implemented by the ``<lang>`` compiler."
msgstr "由 ``<lang>`` 编译器实现的 OpenACC 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:61
msgid ""
"The specification date is formatted as given in the OpenACC standard: "
"``yyyymm`` where ``yyyy`` and ``mm`` represents the year and month of the "
"OpenACC specification implemented by the ``<lang>`` compiler."
msgstr ""
"规范日期的格式与 OpenACC 标准中给出的格式相同：``yyyymm`` 其中 ``yyyy`` 和 ``mm`` 代表 ``<lang>`` "
"编译器实现的 OpenACC 规范的年月。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenACC.cmake:68
msgid ""
"``OpenACC_ACCEL_TARGET=<target>`` If set, will the correct target "
"accelerator flag set to the <target> will be returned with "
"OpenACC_<lang>_FLAGS."
msgstr ""
"``OpenACC_ACCEL_TARGET=<target>`` 如果设置，则设置为 <target> 的正确目标加速器标志将与 "
"OpenACC_<lang>_FLAGS 一起返回。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:6
msgid "FindOpenAL"
msgstr "查找OpenAL"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:8
msgid "Finds Open Audio Library (OpenAL)."
msgstr "查找开放音频库 (OpenAL)。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:10
msgid ""
"Projects using this module should use ``#include \"al.h\"`` to include the"
" OpenAL header file, **not** ``#include <AL/al.h>``.  The reason for this "
"is that the latter is not entirely portable.  Windows/Creative Labs does "
"not by default put their headers in ``AL/`` and macOS uses the convention "
"``<OpenAL/al.h>``."
msgstr ""
"使用此模块的项目应使用``#include \"al.h\"`` 来包含 OpenAL 头文件，**而不是**``#include "
"<AL/al.h>``。这样做的原因是后者不是完全可移植的。 Windows/Creative Labs 默认情况下不会将它们的标头放在 "
"``AL/`` 中，而 macOS 使用约定``<OpenAL/al.h>``。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:18
msgid ""
"Environment variable ``$OPENALDIR`` can be used to set the prefix of "
"OpenAL installation to be found."
msgstr "环境变量 ``$OPENALDIR`` 可用于设置要查找的 OpenAL 安装的前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:21
msgid ""
"By default on macOS, system framework is search first.  In other words, "
"OpenAL is searched in the following order:"
msgstr "默认情况下，在 macOS 上，系统框架优先搜索。换句话说，按照以下顺序搜索 OpenAL："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:24
msgid ""
"System framework: ``/System/Library/Frameworks``, whose priority can be "
"changed via setting the :variable:`CMAKE_FIND_FRAMEWORK` variable."
msgstr ""
"系统框架：``/System/Library/Frameworks``，其优先级可以通过设置 "
":variable:`CMAKE_FIND_FRAMEWORK` 变量来改变。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:26
msgid "Environment variable ``$OPENALDIR``."
msgstr "环境变量“$OPENALDIR”。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:27
msgid "System paths."
msgstr "系统路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:28
msgid "User-compiled framework: ``~/Library/Frameworks``."
msgstr "用户编译的框架：``~/Library/Frameworks``。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:29
msgid "Manually compiled framework: ``/Library/Frameworks``."
msgstr "手动编译的框架：``/Library/Frameworks``。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:30
msgid "Add-on package: ``/opt``."
msgstr "附加包：``/opt``。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:37
msgid "This module defines the :prop_tgt:`IMPORTED` target:"
msgstr "该模块定义了 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:40
msgid "``OpenAL::OpenAL``"
msgstr "``OpenAL::OpenAL``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:40
msgid "The OpenAL library, if found."
msgstr "OpenAL 库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:47
msgid "``OPENAL_FOUND``"
msgstr "``OPENAL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:48
msgid "If false, do not try to link to OpenAL"
msgstr "如果为 false，则不要尝试链接到 OpenAL"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:49
msgid "``OPENAL_INCLUDE_DIR``"
msgstr "``OPENAL_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:50
msgid "OpenAL include directory"
msgstr "OpenAL 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:51
msgid "``OPENAL_LIBRARY``"
msgstr "``OPENAL_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:52
msgid "Path to the OpenAL library"
msgstr "OpenAL 库的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:122
msgid "``OPENAL_VERSION_STRING``"
msgstr "``OPENAL_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenAL.cmake:54
msgid "Human-readable string containing the version of OpenAL"
msgstr "包含 OpenAL 版本的人类可读字符串"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenCL.cmake:6
msgid "FindOpenCL"
msgstr "找到OpenCL"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenCL.cmake:10
msgid "Finds Open Computing Language (OpenCL)"
msgstr "寻找开放计算语言 (OpenCL)"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenCL.cmake:12
msgid "Detection of OpenCL 2.1 and 2.2."
msgstr "检测 OpenCL 2.1 和 2.2。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenCL.cmake:20
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``OpenCL::OpenCL``, if "
"OpenCL has been found."
msgstr "这个模块定义:prop_tgt:`IMPORTED` 目标``OpenCL::OpenCL``，如果已经找到 OpenCL。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenCL.cmake:26
msgid "This module defines the following variables::"
msgstr "该模块定义了以下变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenCL.cmake:35
msgid "The module will also define two cache variables::"
msgstr "该模块还将定义两个缓存变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:6
msgid "FindOpenGL"
msgstr "查找OpenGL"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:8
msgid "FindModule for OpenGL and OpenGL Utility Library (GLU)."
msgstr "FindModule for OpenGL 和 OpenGL Utility Library (GLU)。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:10
msgid "X11 is no longer added as a dependency on Unix/Linux systems."
msgstr "X11 不再添加为对 Unix/Linux 系统的依赖。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:13
msgid ""
"GLVND support on Linux.  See the :ref:`Linux Specific` section below."
msgstr "Linux 上的 GLVND 支持。请参阅下面的 :ref:`Linux Specific` 部分。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:17
#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:11
#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:14
msgid "Optional COMPONENTS"
msgstr "可选组件"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:21
msgid ""
"This module respects several optional COMPONENTS: ``EGL``, ``GLX``, and "
"``OpenGL``.  There are corresponding import targets for each of these "
"flags."
msgstr "该模块涉及几个可选组件：``EGL``、``GLX`` 和 ``OpenGL``。这些标志中的每一个都有相应的导入目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:31
msgid "``OpenGL::GL``"
msgstr "``OpenGL::GL``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:32
msgid ""
"Defined to the platform-specific OpenGL libraries if the system has "
"OpenGL."
msgstr "如果系统具有 OpenGL，则定义为特定于平台的 OpenGL 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:34
msgid "``OpenGL::GLU``"
msgstr "``OpenGL::GLU``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:34
msgid "Defined if the system has OpenGL Utility Library (GLU)."
msgstr "定义系统是否具有 OpenGL 实用程序库 (GLU)。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:36
msgid ""
"Additionally, the following GLVND-specific library targets are defined:"
msgstr "此外，还定义了以下特定于 GLVND 的库目标："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:39
msgid "``OpenGL::OpenGL``"
msgstr "``OpenGL::OpenGL``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:40
msgid "Defined to libOpenGL if the system is GLVND-based."
msgstr "如果系统是基于 GLVND 的，则定义为 libOpenGL。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:41
msgid "``OpenGL::GLX``"
msgstr "``OpenGL::GLX``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:42
msgid ""
"Defined if the system has OpenGL Extension to the X Window System (GLX)."
msgstr "定义系统是否具有 X 窗口系统 (GLX) 的 OpenGL 扩展。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:44
msgid "``OpenGL::EGL``"
msgstr "``OpenGL::EGL``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:44
msgid "Defined if the system has EGL."
msgstr "定义系统是否有 EGL。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:51
msgid "``OPENGL_FOUND``"
msgstr "``OPENGL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:52
msgid "True, if the system has OpenGL and all components are found."
msgstr "是的，如果系统有 OpenGL 并且找到所有组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:53
msgid "``OPENGL_XMESA_FOUND``"
msgstr "``OPENGL_XMESA_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:54
msgid "True, if the system has XMESA."
msgstr "是的，如果系统有 XMESA。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:55
msgid "``OPENGL_GLU_FOUND``"
msgstr "``OPENGL_GLU_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:56
msgid "True, if the system has GLU."
msgstr "是的，如果系统有 GLU。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:57
msgid "``OpenGL_OpenGL_FOUND``"
msgstr "``OpenGL_OpenGL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:58
msgid "True, if the system has an OpenGL library."
msgstr "是的，如果系统有 OpenGL 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:59
msgid "``OpenGL_GLX_FOUND``"
msgstr "``OpenGL_GLX_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:60
msgid "True, if the system has GLX."
msgstr "是的，如果系统有 GLX。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:61
msgid "``OpenGL_EGL_FOUND``"
msgstr "``OpenGL_EGL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:62
msgid "True, if the system has EGL."
msgstr "是的，如果系统有 EGL。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:63
msgid "``OPENGL_INCLUDE_DIR``"
msgstr "``OPENGL_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:64
msgid "Path to the OpenGL include directory."
msgstr "OpenGL 包含目录的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:65
msgid "``OPENGL_EGL_INCLUDE_DIRS``"
msgstr "``OPENGL_EGL_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:66
msgid "Path to the EGL include directory."
msgstr "EGL 包含目录的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:70
msgid "``OPENGL_LIBRARIES``"
msgstr "``OPENGL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:68
msgid ""
"Paths to the OpenGL library, windowing system libraries, and GLU "
"libraries. On Linux, this assumes GLX and is never correct for EGL-based "
"targets. Clients are encouraged to use the ``OpenGL::*`` import targets "
"instead."
msgstr ""
"OpenGL 库、窗口系统库和 GLU 库的路径。在 Linux 上，这假定为 GLX，并且对于基于 EGL 的目标永远不正确。鼓励客户改用 "
"``OpenGL::*`` 导入目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:72
#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:92
msgid ""
"Variables for GLVND-specific libraries ``OpenGL``, ``EGL`` and ``GLX``."
msgstr "GLVND 特定库``OpenGL``、``EGL`` 和``GLX`` 的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:80
msgid "``OPENGL_egl_LIBRARY``"
msgstr "``OPENGL_egl_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:81
msgid "Path to the EGL library."
msgstr "EGL 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:82
msgid "``OPENGL_glu_LIBRARY``"
msgstr "``OPENGL_glu_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:83
msgid "Path to the GLU library."
msgstr "GLU 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:84
msgid "``OPENGL_glx_LIBRARY``"
msgstr "``OPENGL_glx_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:85
msgid "Path to the GLVND 'GLX' library."
msgstr "GLVND 'GLX' 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:86
msgid "``OPENGL_opengl_LIBRARY``"
msgstr "``OPENGL_opengl_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:87
msgid "Path to the GLVND 'OpenGL' library"
msgstr "GLVND 'OpenGL' 库的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:90
msgid "``OPENGL_gl_LIBRARY``"
msgstr "``OPENGL_glx_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:89
msgid ""
"Path to the OpenGL library.  New code should prefer the ``OpenGL::*`` "
"import targets."
msgstr "OpenGL 库的路径。新代码应该更喜欢 ``OpenGL::*`` 导入目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:98
msgid "Linux-specific"
msgstr "特定于 Linux"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:100
msgid ""
"Some Linux systems utilize GLVND as a new ABI for OpenGL.  GLVND separates"
" context libraries from OpenGL itself; OpenGL lives in \"libOpenGL\", and "
"contexts are defined in \"libGLX\" or \"libEGL\".  GLVND is currently the "
"only way to get OpenGL 3+ functionality via EGL in a manner portable "
"across vendors. Projects may use GLVND explicitly with target "
"``OpenGL::OpenGL`` and either ``OpenGL::GLX`` or ``OpenGL::EGL``."
msgstr ""
"一些 Linux 系统使用 GLVND 作为 OpenGL 的新 ABI。 GLVND 将上下文库与 OpenGL 本身分开； OpenGL "
"存在于“libOpenGL”中，上下文在“libGLX”或“libEGL”中定义。 GLVND 是目前以跨供应商可移植的方式通过 EGL 获得 "
"OpenGL 3+ 功能的唯一方法。项目可以将 GLVND 明确地用于目标 ``OpenGL::OpenGL`` 和 ``OpenGL::GLX``"
" 或 ``OpenGL::EGL``。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:107
msgid ""
"Projects may use the ``OpenGL::GL`` target (or ``OPENGL_LIBRARIES`` "
"variable) to use legacy GL interfaces.  These will use the legacy GL "
"library located by ``OPENGL_gl_LIBRARY``, if available.  If "
"``OPENGL_gl_LIBRARY`` is empty or not found and GLVND is available, the "
"``OpenGL::GL`` target will use GLVND ``OpenGL::OpenGL`` and "
"``OpenGL::GLX`` (and the ``OPENGL_LIBRARIES`` variable will use the "
"corresponding libraries).  Thus, for non-EGL-based Linux targets, the "
"``OpenGL::GL`` target is most portable."
msgstr ""
"项目可以使用 ``OpenGL::GL`` 目标（或 ``OPENGL_LIBRARIES`` 变量）来使用遗留的 GL 接口。这些将使用位于 "
"``OPENGL_gl_LIBRARY`` 的遗留 GL 库（如果可用）。如果 ``OPENGL_gl_LIBRARY`` 为空或未找到且 "
"GLVND 可用，则 ``OpenGL::GL`` 目标将使用 GLVND ``OpenGL::OpenGL`` 和 "
"``OpenGL::GLX``（以及 ` `OPENGL_LIBRARIES`` 变量将使用相应的库）。因此，对于非基于 EGL 的 Linux "
"目标，``OpenGL::GL`` 目标是最可移植的。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:115
msgid ""
"A ``OpenGL_GL_PREFERENCE`` variable may be set to specify the preferred "
"way to provide legacy GL interfaces in case multiple choices are "
"available. The value may be one of:"
msgstr ""
"可以设置 ``OpenGL_GL_PREFERENCE`` 变量来指定在有多种选择的情况下提供遗留 GL 接口的首选方式。该值可能是以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:126
msgid "``GLVND``"
msgstr "``GLVND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:120
msgid ""
"If the GLVND OpenGL and GLX libraries are available, prefer them. This "
"forces ``OPENGL_gl_LIBRARY`` to be empty."
msgstr "如果 GLVND OpenGL 和 GLX 库可用，请首选它们。这会强制 ``OPENGL_gl_LIBRARY`` 为空。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:123
msgid ""
"This is the default, unless policy :policy:`CMP0072` is set to ``OLD`` and"
" no components are requeted (since components correspond to GLVND "
"libraries)."
msgstr ""
"这是默认设置，除非策略 :policy:`CMP0072` 设置为 ``OLD`` 并且没有请求任何组件（因为组件对应于 GLVND 库）。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:129
msgid "``LEGACY``"
msgstr "``遗留的``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:129
msgid "Prefer to use the legacy libGL library, if available."
msgstr "首选使用旧版 libGL 库（如果可用）。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:131
msgid ""
"For EGL targets the client must rely on GLVND support on the user's "
"system. Linking should use the ``OpenGL::OpenGL OpenGL::EGL`` targets.  "
"Using GLES* libraries is theoretically possible in place of "
"``OpenGL::OpenGL``, but this module does not currently support that; "
"contributions welcome."
msgstr ""
"对于 EGL 目标，客户端必须依赖用户系统上的 GLVND 支持。链接应该使用 ``OpenGL::OpenGL OpenGL::EGL`` "
"目标。理论上可以使用 GLES* 库代替 ``OpenGL::OpenGL``，但该模块目前不支持；欢迎投稿。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:136
msgid ""
"``OPENGL_egl_LIBRARY`` and ``OPENGL_EGL_INCLUDE_DIRS`` are defined in the "
"case of GLVND.  For non-GLVND Linux and other systems these are left "
"undefined."
msgstr ""
"``OPENGL_egl_LIBRARY`` 和 ``OPENGL_EGL_INCLUDE_DIRS`` 是在 GLVND 的情况下定义的。对于非 "
"GLVND Linux 和其他系统，这些未定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:140
msgid "macOS-Specific"
msgstr "macOS 特定"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenGL.cmake:142
msgid ""
"On OSX FindOpenGL defaults to using the framework version of OpenGL. "
"People will have to change the cache values of OPENGL_glu_LIBRARY and "
"OPENGL_gl_LIBRARY to use OpenGL with X11 on OSX."
msgstr ""
"在 OSX 上，FindOpenGL 默认使用 OpenGL 的框架版本。人们必须更改 OPENGL_glu_LIBRARY 和 "
"OPENGL_gl_LIBRARY 的缓存值才能在 OSX 上使用 OpenGL 和 X11。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:6
msgid "FindOpenMP"
msgstr "找到OpenMP"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:8
msgid "Finds Open Multi-Processing (OpenMP) support."
msgstr "查找开放多处理 (OpenMP) 支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:10
msgid ""
"This module can be used to detect OpenMP support in a compiler.  If the "
"compiler supports OpenMP, the flags required to compile with OpenMP "
"support are returned in variables for the different languages. The "
"variables may be empty if the compiler does not need a special flag to "
"support OpenMP."
msgstr ""
"该模块可用于检测编译器中的 OpenMP 支持。如果编译器支持 OpenMP，则在不同语言的变量中返回使用 OpenMP "
"支持进行编译所需的标志。如果编译器不需要特殊标志来支持 OpenMP，则变量可以为空。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:16
msgid "Clang support."
msgstr "铿锵支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:22
msgid ""
"The module exposes the components ``C``, ``CXX``, and ``Fortran``. Each of"
" these controls the various languages to search OpenMP support for."
msgstr "该模块公开组件“C”、“CXX”和“Fortran”。其中每一个都控制着各种语言来搜索 OpenMP 支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:30
msgid "``OpenMP_FOUND``"
msgstr "``OpenMP_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:29
msgid ""
"Variable indicating that OpenMP flags for all requested languages have "
"been found. If no components are specified, this is true if OpenMP "
"settings for all enabled languages were detected."
msgstr "指示已找到所有请求语言的 OpenMP 标志的变量。如果未指定任何组件，则如果检测到所有已启用语言的 OpenMP 设置，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:34
msgid "``OpenMP_VERSION``"
msgstr "``OpenMP_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:33
msgid ""
"Minimal version of the OpenMP standard detected among the requested "
"languages, or all enabled languages if no components were specified."
msgstr "在请求的语言中检测到的 OpenMP 标准的最低版本，或者如果未指定组件，则在所有启用的语言中检测到。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:39
msgid "``OpenMP_<lang>_FOUND``"
msgstr "``OpenMP_<lang>_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:40
msgid "Variable indicating if OpenMP support for ``<lang>`` was detected."
msgstr "指示是否检测到 OpenMP 对 ``<lang>`` 的支持的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:41
msgid "``OpenMP_<lang>_FLAGS``"
msgstr "``OpenMP_<lang>_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:42
msgid "OpenMP compiler flags for ``<lang>``, separated by spaces."
msgstr "``<lang>`` 的 OpenMP 编译器标志，以空格分隔。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:45
msgid "``OpenMP_<lang>_INCLUDE_DIRS``"
msgstr "``OpenMP_<lang>_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:44
msgid ""
"Directories that must be added to the header search path for ``<lang>`` "
"when using OpenMP."
msgstr "使用 OpenMP 时必须添加到 ``<lang>`` 的标头搜索路径中的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:47
msgid ""
"For linking with OpenMP code written in ``<lang>``, the following "
"variables are provided:"
msgstr "为了与用 ``<lang>`` 编写的 OpenMP 代码进行链接，提供了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:50
msgid "``OpenMP_<lang>_LIB_NAMES``"
msgstr "``OpenMP_<lang>_LIB_NAMES``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:51
msgid ""
":ref:`;-list <CMake Language Lists>` of libraries for OpenMP programs for "
"``<lang>``."
msgstr ":ref:`;-list <CMake Language Lists>` 用于 ``<lang>`` 的 OpenMP 程序库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:52
msgid "``OpenMP_<libname>_LIBRARY``"
msgstr "``OpenMP_<libname>_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:53
msgid ""
"Location of the individual libraries needed for OpenMP support in "
"``<lang>``."
msgstr "``<lang>`` 中 OpenMP 支持所需的各个库的位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:55
msgid "``OpenMP_<lang>_LIBRARIES``"
msgstr "``OpenMP_<lang>_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:55
msgid ""
"A list of libraries needed to link with OpenMP code written in ``<lang>``."
msgstr "与用 ``<lang>`` 编写的 OpenMP 代码链接所需的库列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:57
msgid "Additionally, the module provides :prop_tgt:`IMPORTED` targets:"
msgstr "此外，该模块提供 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:60
msgid "``OpenMP::OpenMP_<lang>``"
msgstr "``OpenMP::OpenMP_<lang>``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:60
msgid "Target for using OpenMP from ``<lang>``."
msgstr "使用 ``<lang>`` 中的 OpenMP 的目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:62
msgid "Specifically for Fortran, the module sets the following variables:"
msgstr "专门针对 Fortran，该模块设置了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:64
msgid "``OpenMP_Fortran_HAVE_OMPLIB_HEADER``"
msgstr "``OpenMP_Fortran_HAVE_OMPLIB_HEADER``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:65
msgid "Boolean indicating if OpenMP is accessible through ``omp_lib.h``."
msgstr "指示 OpenMP 是否可通过 ``omp_lib.h`` 访问的布尔值。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:67
msgid "``OpenMP_Fortran_HAVE_OMPLIB_MODULE``"
msgstr "``OpenMP_Fortran_HAVE_OMPLIB_MODULE``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:67
msgid ""
"Boolean indicating if OpenMP is accessible through the ``omp_lib`` Fortran"
" module."
msgstr "指示 OpenMP 是否可通过 ``omp_lib`` Fortran 模块访问的布尔值。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:69
msgid "The module will also try to provide the OpenMP version variables:"
msgstr "该模块还将尝试提供 OpenMP 版本变量："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:73
msgid "``OpenMP_<lang>_SPEC_DATE``"
msgstr "``OpenMP_<lang>_SPEC_DATE``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:74
msgid ""
"Date of the OpenMP specification implemented by the ``<lang>`` compiler."
msgstr "``<lang>`` 编译器实现的 OpenMP 规范的日期。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:75
msgid "``OpenMP_<lang>_VERSION_MAJOR``"
msgstr "``OpenMP_<lang>_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:76
msgid "Major version of OpenMP implemented by the ``<lang>`` compiler."
msgstr "``<lang>`` 编译器实现的 OpenMP 主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:77
msgid "``OpenMP_<lang>_VERSION_MINOR``"
msgstr "``OpenMP_<lang>_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:78
msgid "Minor version of OpenMP implemented by the ``<lang>`` compiler."
msgstr "由 ``<lang>`` 编译器实现的 OpenMP 次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:80
msgid "``OpenMP_<lang>_VERSION``"
msgstr "``OpenMP_<lang>_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:80
msgid "OpenMP version implemented by the ``<lang>`` compiler."
msgstr "由 ``<lang>`` 编译器实现的 OpenMP 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:82
msgid ""
"The specification date is formatted as given in the OpenMP standard: "
"``yyyymm`` where ``yyyy`` and ``mm`` represents the year and month of the "
"OpenMP specification implemented by the ``<lang>`` compiler."
msgstr ""
"规范日期按照 OpenMP 标准中给出的格式进行格式化：``yyyymm`` 其中 ``yyyy`` 和 ``mm`` 代表 ``<lang>`` "
"编译器实现的 OpenMP 规范的年月。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenMP.cmake:86
msgid ""
"For some compilers, it may be necessary to add a header search path to "
"find the relevant OpenMP headers.  This location may be language-specific."
"  Where this is needed, the module may attempt to find the location, but "
"it can be provided directly by setting the ``OpenMP_<lang>_INCLUDE_DIR`` "
"cache variable. Note that this variable is an _input_ control to the "
"module.  Project code should use the ``OpenMP_<lang>_INCLUDE_DIRS`` "
"_output_ variable if it needs to know what include directories are needed."
msgstr ""
"对于某些编译器，可能需要添加标头搜索路径以查找相关的 OpenMP "
"标头。该位置可能是特定于语言的。在需要的地方，模块可能会尝试查找位置，但可以通过设置 ``OpenMP_<lang>_INCLUDE_DIR`` "
"缓存变量直接提供。请注意，此变量是模块的_输入_控件。如果项目代码需要知道需要哪些包含目录，则应使用 "
"``OpenMP_<lang>_INCLUDE_DIRS`` _output_ 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:6
msgid "FindOpenSP"
msgstr "查找OpenSP"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:10
msgid "Try to find the OpenSP library."
msgstr "尝试找到 OpenSP 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:15
msgid "This will define the following variables:"
msgstr "这将定义以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:18
msgid "``OpenSP_FOUND``"
msgstr "``OpenSP_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:18
msgid "True if (the requested version of) ``OpenSP`` is available"
msgstr "如果（请求的版本）``OpenSP`` 可用，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:21
msgid "``OpenSP_VERSION``"
msgstr "``OpenSP_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:21
msgid "The version of ``OpenSP``"
msgstr "``OpenSP`` 的版本"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:24
msgid "``OpenSP_VERSION_MAJOR``"
msgstr "``OpenSP_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:24
msgid "The major version of ``OpenSP``"
msgstr "``OpenSP`` 的主要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:27
msgid "``OpenSP_VERSION_MINOR``"
msgstr "``OpenSP_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:27
msgid "The minor version of ``OpenSP``"
msgstr "``OpenSP`` 的次要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:30
msgid "``OpenSP_VERSION_PATCH``"
msgstr "``OpenSP_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:30
msgid "The patch version of ``OpenSP``"
msgstr "``OpenSP`` 的补丁版本"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:33
msgid "``OpenSP_INCLUDE_DIRS``"
msgstr "``OpenSP_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:33
msgid "The include dirs of ``OpenSP`` with its headers"
msgstr "``OpenSP`` 的包含目录及其标头"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:38
msgid "``OpenSP_LIBRARIES``"
msgstr "``OpenSP_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:36
msgid ""
"The OpenSP library for use with target_link_libraries(). This can be "
"passed to target_link_libraries() instead of the :prop_tgt:`IMPORTED` "
"``OpenSP::OpenSP`` target"
msgstr ""
"用于 target_link_libraries() 的 OpenSP 库。这可以传递给 target_link_libraries() 而不是 "
":prop_tgt:`IMPORTED` ``OpenSP::OpenSP`` 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:45
msgid "``OpenSP_MULTI_BYTE``"
msgstr "``OpenSP_MULTI_BYTE``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:41
msgid ""
"True if ``SP_MULTI_BYTE`` was found to be defined in OpenSP's ``config.h``"
" header file, which indicates that the ``OpenSP`` library was compiled "
"with support for multi-byte characters. The consuming target needs to "
"define the ``SP_MULTI_BYTE`` to match this value in order to avoid issues "
"with character decoding."
msgstr ""
"如果发现 ``SP_MULTI_BYTE`` 在 OpenSP 的``config.h`` 头文件中定义，则为真，这表明 ``OpenSP`` "
"库是在支持多字节字符的情况下编译的。消费目标需要定义 ``SP_MULTI_BYTE`` 来匹配这个值以避免字符解码问题。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:50
msgid ""
"This module defines the :prop_tgt:`IMPORTED` target ``OpenSP::OpenSP``, if"
" OpenSP has been found."
msgstr "如果已找到 OpenSP，此模块定义 :prop_tgt:`IMPORTED` 目标 ``OpenSP::OpenSP``。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:59
msgid "``OpenSP_INCLUDE_DIR``"
msgstr "``OpenSP_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:59
msgid "the OpenSP include directory"
msgstr "OpenSP 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:160
msgid "``OpenSP_LIBRARY``"
msgstr "``OpenSP_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSP.cmake:62
msgid "the absolute path of the osp library"
msgstr "osp库的绝对路径"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:6
msgid "FindOpenSSL"
msgstr "查找OpenSSL"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:8
msgid "Find the OpenSSL encryption library."
msgstr "找到 OpenSSL 加密库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:10
msgid ""
"This module finds an installed OpenSSL library and determines its version."
msgstr "该模块查找已安装的 OpenSSL 库并确定其版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:12
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:13
#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:17
msgid ""
"When a version is requested, it can be specified as a simple value or as a"
" range. For a detailed description of version range usage and "
"capabilities, refer to the :command:`find_package` command."
msgstr "请求版本时，可以将其指定为简单值或范围。有关版本范围用法和功能的详细说明，请参阅:command:`find_package` 命令。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:17
msgid "Support for OpenSSL 3.0."
msgstr "支持 OpenSSL 3.0。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:25
msgid ""
"This module supports two optional COMPONENTS: ``Crypto`` and ``SSL``.  "
"Both components have associated imported targets, as described below."
msgstr "该模块支持两个可选组件：``Crypto`` 和``SSL``。两个组件都有关联的导入目标，如下所述。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:35
msgid "``OpenSSL::SSL``"
msgstr "``OpenSSL::SSL``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:36
msgid "The OpenSSL ``ssl`` library, if found."
msgstr "OpenSSL ``ssl`` 库，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:37
msgid "``OpenSSL::Crypto``"
msgstr "``OpenSSL::加密``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:38
msgid "The OpenSSL ``crypto`` library, if found."
msgstr "OpenSSL ``crypto`` 库，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:47
msgid "``OpenSSL::applink``"
msgstr "``OpenSSL::applink``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:42
msgid ""
"The OpenSSL ``applink`` components that might be need to be compiled into "
"projects under MSVC. This target is available only if found OpenSSL "
"version is not less than 0.9.8. By linking this target the above OpenSSL "
"targets can be linked even if the project has different MSVC runtime "
"configurations with the above OpenSSL targets. This target has no effect "
"on platforms other than MSVC."
msgstr ""
"可能需要编译到 MSVC 下的项目中的 OpenSSL ``applink`` 组件。此目标仅在发现 OpenSSL 版本不低于 0.9.8 "
"时可用。通过链接此目标，即使项目具有与上述 OpenSSL 目标不同的 MSVC 运行时配置，也可以链接上述 OpenSSL 目标。此目标对 "
"MSVC 以外的平台没有影响。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:49
msgid ""
"NOTE: Due to how ``INTERFACE_SOURCES`` are consumed by the consuming "
"target, unless you certainly know what you are doing, it is always "
"preferred to link ``OpenSSL::applink`` target as ``PRIVATE`` and to make "
"sure that this target is linked at most once for the whole dependency "
"graph of any library or executable:"
msgstr ""
"注意：由于 ``INTERFACE_SOURCES`` 是如何被消费目标消费的，除非您确实知道自己在做什么，否则始终首选将 "
"``OpenSSL::applink`` 目标链接为 ``PRIVATE`` 并使确保对于任何库或可执行文件的整个依赖关系图，此目标最多链接一次："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:59
msgid ""
"Otherwise you would probably encounter unexpected random problems when "
"building and linking, as both the ISO C and the ISO C++ standard claims "
"almost nothing about what a link process should be."
msgstr "否则，您可能会在构建和链接时遇到意想不到的随机问题，因为 ISO C 和 ISO C++ 标准几乎没有声明链接过程应该是什么。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:69
msgid "``OPENSSL_FOUND``"
msgstr "``OPENSSL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:69
msgid ""
"System has the OpenSSL library. If no components are requested it only "
"requires the crypto library."
msgstr "系统有 OpenSSL 库。如果没有请求任何组件，它只需要加密库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:71
msgid "``OPENSSL_INCLUDE_DIR``"
msgstr "``OPENSSL_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:72
msgid "The OpenSSL include directory."
msgstr "OpenSSL 包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:73
msgid "``OPENSSL_CRYPTO_LIBRARY``"
msgstr "``OPENSSL_CRYPTO_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:74
msgid "The OpenSSL crypto library."
msgstr "OpenSSL 加密库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:75
msgid "``OPENSSL_CRYPTO_LIBRARIES``"
msgstr "``OPENSSL_CRYPTO_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:76
msgid "The OpenSSL crypto library and its dependencies."
msgstr "OpenSSL 加密库及其依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:77
msgid "``OPENSSL_SSL_LIBRARY``"
msgstr "``OPENSSL_SSL_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:78
msgid "The OpenSSL SSL library."
msgstr "OpenSSL SSL 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:79
msgid "``OPENSSL_SSL_LIBRARIES``"
msgstr "``OPENSSL_SSL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:80
msgid "The OpenSSL SSL library and its dependencies."
msgstr "OpenSSL SSL 库及其依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:81
msgid "``OPENSSL_LIBRARIES``"
msgstr "``OPENSSL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:82
msgid "All OpenSSL libraries and their dependencies."
msgstr "所有 OpenSSL 库及其依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:83
msgid "``OPENSSL_VERSION``"
msgstr "``OPENSSL_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:84
msgid "This is set to ``$major.$minor.$revision$patch`` (e.g. ``0.9.8s``)."
msgstr "这被设置为 ``$major.$minor.$revision$patch``（例如 ``0.9.8s``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:88
msgid "``OPENSSL_APPLINK_SOURCE``"
msgstr "``OPENSSL_APPLINK_SOURCE``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:86
msgid ""
"The sources in the target ``OpenSSL::applink`` that is mentioned above. "
"This variable shall always be undefined if found openssl version is less "
"than 0.9.8 or if platform is not MSVC."
msgstr ""
"上面提到的目标 ``OpenSSL::applink`` 中的源。如果发现 openssl 版本低于 0.9.8 或者平台不是 "
"MSVC，则此变量应始终未定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:93
msgid "The following variables may be set to control search behavior:"
msgstr "可以设置以下变量来控制搜索行为："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:96
msgid "``OPENSSL_ROOT_DIR``"
msgstr "``OPENSSL_ROOT_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:96
msgid "Set to the root directory of an OpenSSL installation."
msgstr "设置为 OpenSSL 安装的根目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:101
msgid "``OPENSSL_USE_STATIC_LIBS``"
msgstr "``OPENSSL_USE_STATIC_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:101
msgid "Set to ``TRUE`` to look for static libraries."
msgstr "设置为 ``TRUE`` 以查找静态库。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:106
msgid "``OPENSSL_MSVC_STATIC_RT``"
msgstr "``OPENSSL_MSVC_STATIC_RT``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:106
msgid "Set to ``TRUE`` to choose the MT version of the lib."
msgstr "设置为 ``TRUE`` 以选择 lib 的 MT 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:782
msgid "``ENV{PKG_CONFIG_PATH}``"
msgstr "``环境{PKG_CONFIG_PATH}``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSSL.cmake:109
msgid ""
"On UNIX-like systems, ``pkg-config`` is used to locate the system OpenSSL."
" Set the ``PKG_CONFIG_PATH`` environment varialbe to look in alternate "
"locations.  Useful on multi-lib systems."
msgstr ""
"在类 UNIX 系统上，``pkg-config`` 用于定位系统 OpenSSL。设置``PKG_CONFIG_PATH`` "
"环境变量以在备用位置查找。在多库系统上很有用。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:6
msgid "FindOpenSceneGraph"
msgstr "查找OpenSceneGraph"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:8
msgid "Find OpenSceneGraph (3D graphics application programming interface)"
msgstr "查找 OpenSceneGraph（3D 图形应用程序编程接口）"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:10
msgid ""
"This module searches for the OpenSceneGraph core \"osg\" library as well "
"as :module:`FindOpenThreads`, and whatever additional ``COMPONENTS`` "
"(nodekits) that you specify."
msgstr ""
"此模块搜索 OpenSceneGraph 核心“osg”库以及 FindOpenThreads，以及您指定的任何其他“组件”（nodekits）。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:20
msgid ""
"NOTE: To use this module effectively you must either require ``CMake >= "
"2.6.3`` with  :command:`cmake_minimum_required(VERSION 2.6.3)` or download"
" and place :module:`FindOpenThreads`, :module:`Findosg` functions, "
":module:`Findosg` and ``Find<etc>.cmake`` files into your "
":variable:`CMAKE_MODULE_PATH`."
msgstr ""
"注意：要有效地使用此模块，您必须要求 ``CMake >= 2.6.3`` 和 "
":command:`cmake_minimum_required(VERSION 2.6.3)` 或下载并放置 "
":module:`FindOpenThreads`, :module:`Findosg ` 函数、 :module:`Findosg` 和 "
"``Find<etc>.cmake`` 文件到您的 :variable:`CMAKE_MODULE_PATH` 中。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:28
msgid "This module accepts the following variables (note mixed case)"
msgstr "该模块接受以下变量（注意大小写混合）"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:43
msgid ""
"The following environment variables are also respected for finding the OSG"
" and it's various components.  :variable:`CMAKE_PREFIX_PATH` can also be "
"used for this (see :command:`find_library` CMake documentation)."
msgstr ""
"以下环境变量也适用于查找 OSG 及其各种组件。 :variable:`CMAKE_PREFIX_PATH` 也可以用于此（参见 "
":command:`find_library` CMake 文档）。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:48
msgid "``<MODULE>_DIR``"
msgstr "``<MODULE>_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:48
msgid ""
"(where ``MODULE`` is of the form \"OSGVOLUME\" and there is a "
":module:`FindosgVolume`.cmake` file)"
msgstr ""
"（其中 ``MODULE`` 的形式为“OSGVOLUME”，并且有一个 :module:`FindosgVolume`.cmake` 文件）"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:50
msgid "``OSG_DIR``"
msgstr "``OSG_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:52
msgid "``OSGDIR``"
msgstr "``OSGDIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:56
msgid "``OSG_ROOT``"
msgstr "``OSG_ROOT``"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:58
msgid ""
"[CMake 2.8.10]: The CMake variable ``OSG_DIR`` can now be used as well to "
"influence detection, instead of needing to specify an environment "
"variable."
msgstr "[CMake 2.8.10]：CMake 变量“OSG_DIR”现在也可以用来影响检测，而不需要指定环境变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:62
msgid "This module defines the following output variables:"
msgstr "该模块定义了以下输出变量："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenSceneGraph.cmake:88
msgid "================================== Example Usage:"
msgstr "==================================示例用法："

#: ../../cmake-prefix/src/cmake/Modules/FindOpenThreads.cmake:6
msgid "FindOpenThreads"
msgstr "查找OpenThreads"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenThreads.cmake:10
msgid ""
"OpenThreads is a C++ based threading library.  Its largest userbase seems "
"to OpenSceneGraph so you might notice I accept OSGDIR as an environment "
"path.  I consider this part of the Findosg* suite used to find "
"OpenSceneGraph components.  Each component is separate and you must opt in"
" to each module."
msgstr ""
"OpenThreads 是一个基于 C++ 的线程库。它最大的用户群似乎是 OpenSceneGraph，因此您可能会注意到我接受 OSGDIR "
"作为环境路径。我认为 Findosg* 套件的这一部分用于查找 OpenSceneGraph 组件。每个组件都是独立的，您必须选择加入每个模块。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenThreads.cmake:16
msgid ""
"Locate OpenThreads This module defines OPENTHREADS_LIBRARY "
"OPENTHREADS_FOUND, if false, do not try to link to OpenThreads "
"OPENTHREADS_INCLUDE_DIR, where to find the headers"
msgstr ""
"Locate OpenThreads 这个模块定义了OPENTHREADS_LIBRARY "
"OPENTHREADS_FOUND，如果为false，不要尝试链接到OpenThreads "
"OPENTHREADS_INCLUDE_DIR，哪里可以找到headers"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenThreads.cmake:20
msgid ""
"$OPENTHREADS_DIR is an environment variable that would correspond to the "
"./configure --prefix=$OPENTHREADS_DIR used in building osg."
msgstr ""
"$OPENTHREADS_DIR 是一个环境变量，对应于构建 osg 时使用的 ./configure "
"--prefix=$OPENTHREADS_DIR。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenThreads.cmake:23
msgid ""
"[CMake 2.8.10]: The CMake variables OPENTHREADS_DIR or OSG_DIR can now be "
"used as well to influence detection, instead of needing to specify an "
"environment variable."
msgstr ""
"[CMake 2.8.10]：CMake 变量 OPENTHREADS_DIR 或 OSG_DIR 现在也可以用于影响检测，而不需要指定环境变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindOpenThreads.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/FindPhysFS.cmake:17
#: ../../cmake-prefix/src/cmake/Modules/FindProducer.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindQuickTime.cmake:17
#: ../../cmake-prefix/src/cmake/Modules/Findosg.cmake:37
#: ../../cmake-prefix/src/cmake/Modules/FindosgAnimation.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgFX.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgGA.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgIntrospection.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/FindosgManipulator.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/FindosgParticle.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgProducer.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgShadow.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgSim.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgTerrain.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgText.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgUtil.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgViewer.cmake:33
#: ../../cmake-prefix/src/cmake/Modules/FindosgVolume.cmake:33
msgid "Created by Eric Wing."
msgstr "由 Eric Wing 创建。"

#: ../../cmake-prefix/src/cmake/Modules/FindPHP4.cmake:6
msgid "FindPHP4"
msgstr "查找PHP4"

#: ../../cmake-prefix/src/cmake/Modules/FindPHP4.cmake:8
msgid "Find PHP4"
msgstr "寻找 PHP4"

#: ../../cmake-prefix/src/cmake/Modules/FindPHP4.cmake:10
msgid ""
"This module finds if PHP4 is installed and determines where the include "
"files and libraries are.  It also determines what the name of the library "
"is.  This code sets the following variables:"
msgstr "该模块查找是否安装了 PHP4 并确定包含文件和库的位置。它还确定库的名称是什么。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:6
msgid "FindPNG"
msgstr "查找PNG"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:8
msgid ""
"Find libpng, the official reference library for the PNG image format."
msgstr "查找 libpng，PNG 图像格式的官方参考库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:18
msgid "``PNG::PNG``"
msgstr "``PNG::PNG``"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:18
msgid "The libpng library, if found."
msgstr "libpng 库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:25
msgid "``PNG_INCLUDE_DIRS``"
msgstr "``PNG_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:26
msgid "where to find png.h, etc."
msgstr "在哪里可以找到 png.h 等"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:27
msgid "``PNG_LIBRARIES``"
msgstr "``PNG_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:28
msgid "the libraries to link against to use PNG."
msgstr "要链接的库以使用 PNG。"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:30
msgid "``PNG_DEFINITIONS``"
msgstr "``PNG_DEFINITIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:30
msgid ""
"You should add_definitions(${PNG_DEFINITIONS}) before compiling code that "
"includes png library files."
msgstr "在编译包含 png 库文件的代码之前，您应该添加定义（${PNG_DEFINITIONS}）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:32
msgid "``PNG_FOUND``"
msgstr "``PNG_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:33
msgid "If false, do not try to use PNG."
msgstr "如果为 false，请不要尝试使用 PNG。"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:35
msgid "``PNG_VERSION_STRING``"
msgstr "``PNG_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:35
msgid "the version of the PNG library found (since CMake 2.8.8)"
msgstr "找到的 PNG 库的版本（自 CMake 2.8.8 起）"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:40
msgid ""
"The following variables may also be set, for backwards compatibility:"
msgstr "为了向后兼容，还可以设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:42
msgid "``PNG_LIBRARY``"
msgstr "``PNG_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:43
msgid "where to find the PNG library."
msgstr "在哪里可以找到 PNG 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:45
msgid "``PNG_INCLUDE_DIR``"
msgstr "``JPEG_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:45
msgid "where to find the PNG headers (same as PNG_INCLUDE_DIRS)"
msgstr "在哪里可以找到 PNG 标头（与 PNG_INCLUDE_DIRS 相同）"

#: ../../cmake-prefix/src/cmake/Modules/FindPNG.cmake:47
msgid ""
"Since PNG depends on the ZLib compression library, none of the above will "
"be defined unless ZLib can be found."
msgstr "由于 PNG 依赖于 ZLib 压缩库，所以除非能找到 ZLib，否则以上都不会被定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:6
msgid "FindPackageHandleStandardArgs"
msgstr "FindPackageHandleStandardArgs"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:8
msgid ""
"This module provides functions intended to be used in :ref:`Find Modules` "
"implementing :command:`find_package(<PackageName>)` calls."
msgstr ""
"此模块提供旨在用于执行 :command:`find_package(<PackageName>)` 调用的 Find Modules 中的函数。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:13
msgid ""
"This command handles the ``REQUIRED``, ``QUIET`` and version-related "
"arguments of :command:`find_package`.  It also sets the "
"``<PackageName>_FOUND`` variable.  The package is considered found if all "
"variables listed contain valid results, e.g. valid filepaths."
msgstr ""
"此命令处理 ``REQUIRED``、``QUIET`` 和 :command:`find_package` "
"的版本相关参数。它还设置了``<PackageName>_FOUND`` "
"变量。如果列出的所有变量都包含有效结果，则认为包已找到，例如有效的文件路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:18
msgid "There are two signatures:"
msgstr "有两个签名："

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:39
msgid ""
"The ``<PackageName>_FOUND`` variable will be set to ``TRUE`` if all the "
"variables ``<required-var>...`` are valid and any optional constraints are"
" satisfied, and ``FALSE`` otherwise.  A success or failure message may be "
"displayed based on the results and on whether the ``REQUIRED`` and/or "
"``QUIET`` option was given to the :command:`find_package` call."
msgstr ""
"``<PackageName>_FOUND`` 变量将设置为 ``TRUE`` 如果所有变量 ``<required-var>...`` "
"都有效并且满足任何可选约束，则 ``FALSE``否则。可能会根据结果以及是否为 find_package 调用提供了 ``REQUIRED`` "
"和/或 ``QUIET`` 选项来显示成功或失败消息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:51
msgid "``(DEFAULT_MSG|<custom-failure-message>)``"
msgstr "``(DEFAULT_MSG|<自定义失败消息>)``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:49
msgid ""
"In the simple signature this specifies the failure message. Use "
"``DEFAULT_MSG`` to ask for a default message to be computed (recommended)."
"  Not valid in the full signature."
msgstr "在简单签名中，这指定了失败消息。使用 ``DEFAULT_MSG`` 请求计算默认消息（推荐）。在完整签名中无效。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:59
msgid "``FOUND_VAR <result-var>``"
msgstr "``FOUND_VAR <result-var>``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:56
msgid ""
"Specifies either ``<PackageName>_FOUND`` or ``<PACKAGENAME>_FOUND`` as the"
" result variable.  This exists only for compatibility with older versions "
"of CMake and is now ignored. Result variables of both names are always set"
" for compatibility."
msgstr ""
"指定 ``<PackageName>_FOUND`` 或 ``<PACKAGENAME>_FOUND`` 作为结果变量。这只是为了与旧版本的 "
"CMake 兼容而存在，现在已被忽略。始终设置两个名称的结果变量以实现兼容性。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:69
msgid "``REQUIRED_VARS <required-var>...``"
msgstr "``REQUIRED_VARS <required-var>...``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:62
msgid ""
"Specify the variables which are required for this package. These may be "
"named in the generated failure message asking the user to set the missing "
"variable values.  Therefore these should typically be cache entries such "
"as ``FOO_LIBRARY`` and not output variables like ``FOO_LIBRARIES``."
msgstr ""
"指定此包所需的变量。这些可能会在生成的失败消息中命名，要求用户设置缺失的变量值。因此，这些通常应该是诸如“FOO_LIBRARY”之类的缓存条目，而不是诸如“FOO_LIBRARIES”之类的输出变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:68
msgid "If ``HANDLE_COMPONENTS`` is specified, this option can be omitted."
msgstr "如果指定了``HANDLE_COMPONENTS``，这个选项可以省略。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:78
msgid "``VERSION_VAR <version-var>``"
msgstr "``VERSION_VAR <version-var>``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:72
msgid ""
"Specify the name of a variable that holds the version of the package that "
"has been found.  This version will be checked against the (potentially) "
"specified required version given to the :command:`find_package` call, "
"including its ``EXACT`` option. The default messages include information "
"about the required version and the version which has been actually found, "
"both if the version is ok or not."
msgstr ""
"指定一个变量的名称，该变量保存已找到的包的版本。此版本将根据提供给 find_package 调用的（可能）指定的所需版本进行检查，包括其 "
"EXACT 选项。默认消息包括有关所需版本和实际找到的版本的信息，无论版本是否正常。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:85
#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:195
msgid "``HANDLE_VERSION_RANGE``"
msgstr "``HANDLE_VERSION_RANGE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:83
#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:193
msgid ""
"Enable handling of a version range, if one is specified. Without this "
"option, a developer warning will be displayed if a version range is "
"specified."
msgstr "如果指定了版本范围，则启用处理版本范围。如果没有此选项，如果指定了版本范围，将显示开发人员警告。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:93
msgid "``HANDLE_COMPONENTS``"
msgstr "``HANDLE_COMPONENTS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:88
msgid ""
"Enable handling of package components.  In this case, the command will "
"report which components have been found and which are missing, and the "
"``<PackageName>_FOUND`` variable will be set to ``FALSE`` if any of the "
"required components (i.e. not the ones listed after the "
"``OPTIONAL_COMPONENTS`` option of :command:`find_package`) are missing."
msgstr ""
"启用包组件的处理。在这种情况下，该命令将报告已找到哪些组件以及缺少哪些组件，并且如果任何所需组件（即未列出的组件），``<PackageName>_FOUND``"
" 变量将设置为``FALSE``在 :command:`find_package` 的 ``OPTIONAL_COMPONENTS`` "
"选项之后）丢失了。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:100
msgid "``CONFIG_MODE``"
msgstr "``CONFIG_MODE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:96
msgid ""
"Specify that the calling find module is a wrapper around a call to "
"``find_package(<PackageName> NO_MODULE)``.  This implies a ``VERSION_VAR``"
" value of ``<PackageName>_VERSION``.  The command will automatically check"
" whether the package configuration file was found."
msgstr ""
"指定调用查找模块是对 find_package(<PackageName> NO_MODULE) 的调用的包装器。这意味着 "
"``<PackageName>_VERSION`` 的 ``VERSION_VAR`` 值。该命令将自动检查是否找到包配置文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:106
msgid "``REASON_FAILURE_MESSAGE <reason-failure-message>``"
msgstr "``REASON_FAILURE_MESSAGE <原因失败消息>``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:105
msgid ""
"Specify a custom message of the reason for the failure which will be "
"appended to the default generated message."
msgstr "指定失败原因的自定义消息，该消息将附加到默认生成的消息中。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:110
msgid "``FAIL_MESSAGE <custom-failure-message>``"
msgstr "``FAIL_MESSAGE <自定义失败消息>``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:109
msgid ""
"Specify a custom failure message instead of using the default generated "
"message.  Not recommended."
msgstr "指定自定义失败消息而不是使用默认生成的消息。不建议。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:117
msgid "``NAME_MISMATCHED``"
msgstr "``NAME_MISMATCHED``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:115
msgid ""
"Indicate that the ``<PackageName>`` does not match "
"``${CMAKE_FIND_PACKAGE_NAME}``. This is usually a mistake and raises a "
"warning, but it may be intentional for usage of the command for components"
" of a larger package."
msgstr ""
"指示``<PackageName>`` "
"不匹配``${CMAKE_FIND_PACKAGE_NAME}``。这通常是一个错误并会发出警告，但对于较大包的组件使用该命令可能是故意的。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:120
msgid "Example for the simple signature:"
msgstr "简单签名示例："

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:127
msgid ""
"The ``LibXml2`` package is considered to be found if both "
"``LIBXML2_LIBRARY`` and ``LIBXML2_INCLUDE_DIR`` are valid. Then also "
"``LibXml2_FOUND`` is set to ``TRUE``.  If it is not found and ``REQUIRED``"
" was used, it fails with a :command:`message(FATAL_ERROR)`, independent "
"whether ``QUIET`` was used or not.  If it is found, success will be "
"reported, including the content of the first ``<required-var>``.  On "
"repeated CMake runs, the same message will not be printed again."
msgstr ""
"如果 ``LIBXML2_LIBRARY`` 和 ``LIBXML2_INCLUDE_DIR`` 都有效，则认为找到了 ``LibXml2`` "
"包。然后还将 ``LibXml2_FOUND`` 设置为 ``TRUE``。如果没有找到并且使用了 "
"``REQUIRED``，它将失败并显示一条消息（FATAL_ERROR）`，与是否使用``QUIET``无关。如果找到，则报告成功，包括第一个``<required-"
"var>``的内容。在重复运行 CMake 时，不会再次打印相同的消息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:138
msgid ""
"If ``<PackageName>`` does not match ``CMAKE_FIND_PACKAGE_NAME`` for the "
"calling module, a warning that there is a mismatch is given. The "
"``FPHSA_NAME_MISMATCHED`` variable may be set to bypass the warning if "
"using the old signature and the ``NAME_MISMATCHED`` argument using the new"
" signature. To avoid forcing the caller to require newer versions of CMake"
" for usage, the variable's value will be used if defined when the "
"``NAME_MISMATCHED`` argument is not passed for the new signature (but "
"using both is an error).."
msgstr ""
"如果``<PackageName>`` 与调用模块的``CMAKE_FIND_PACKAGE_NAME`` "
"不匹配，则会发出不匹配的警告。如果使用旧签名和使用新签名的 ``NAME_MISMATCHED`` "
"参数，``FPHSA_NAME_MISMATCHED`` 变量可以设置为绕过警告。为避免强制调用者要求使用较新版本的 "
"CMake，如果在未为新签名传递 NAME_MISMATCHED 参数时定义变量值，则将使用该变量值（但同时使用两者是错误的）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:147
msgid "Example for the full signature:"
msgstr "完整签名示例："

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:155
msgid ""
"In this case, the ``LibArchive`` package is considered to be found if both"
" ``LibArchive_LIBRARY`` and ``LibArchive_INCLUDE_DIR`` are valid. Also the"
" version of ``LibArchive`` will be checked by using the version contained "
"in ``LibArchive_VERSION``.  Since no ``FAIL_MESSAGE`` is given, the "
"default messages will be printed."
msgstr ""
"在这种情况下，如果 ``LibArchive_LIBRARY`` 和 ``LibArchive_INCLUDE_DIR`` 都有效，则认为找到了 "
"``LibArchive`` 包。此外，将使用“LibArchive_VERSION”中包含的版本检查“LibArchive”的版本。由于没有给出 "
"``FAIL_MESSAGE``，因此将打印默认消息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:161
msgid "Another example for the full signature:"
msgstr "完整签名的另一个例子："

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:168
msgid ""
"In this case, a ``FindAutmoc4.cmake`` module wraps a call to "
"``find_package(Automoc4 NO_MODULE)`` and adds an additional search "
"directory for ``automoc4``.  Then the call to "
"``find_package_handle_standard_args`` produces a proper success/failure "
"message."
msgstr ""
"在这种情况下，``FindAutmoc4.cmake`` 模块包装了对``find_package(Automoc4 NO_MODULE)`` "
"的调用，并为``automoc4`` 添加了一个额外的搜索目录。然后调用``find_package_handle_standard_args`` "
"产生正确的成功/失败消息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:178
msgid ""
"Helper function which can be used to check if a ``<version>`` is valid "
"against version-related arguments of :command:`find_package`."
msgstr "辅助函数，可用于检查 ``<version>`` 是否对 :command:`find_package` 的版本相关参数有效。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:188
msgid ""
"The ``<result-var>`` will hold a boolean value giving the result of the "
"check."
msgstr "``<result-var>`` 将保存一个布尔值，给出检查结果。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:197
msgid "``RESULT_MESSAGE_VARIABLE <message-var>``"
msgstr "``RESULT_MESSAGE_VARIABLE <message-var>``"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:198
msgid ""
"Specify a variable to get back a message describing the result of the "
"check."
msgstr "指定一个变量以取回描述检查结果的消息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageHandleStandardArgs.cmake:200
msgid "Example for the usage:"
msgstr "使用示例："

#: ../../cmake-prefix/src/cmake/Modules/FindPackageMessage.cmake:6
msgid "FindPackageMessage"
msgstr "查找包裹消息"

#: ../../cmake-prefix/src/cmake/Modules/FindPackageMessage.cmake:12
msgid ""
"This function is intended to be used in FindXXX.cmake modules files. It "
"will print a message once for each unique find result.  This is useful for"
" telling the user where a package was found.  The first argument specifies"
" the name (XXX) of the package.  The second argument specifies the message"
" to display.  The third argument lists details about the find result so "
"that if they change the message will be displayed again.  The macro also "
"obeys the QUIET argument to the find_package command."
msgstr ""
"此函数旨在用于 FindXXX.cmake 模块文件。它将为每个唯一的查找结果打印一次消息。这对于告诉用户在哪里找到包很有用。第一个参数指定包的名称"
" (XXX)。第二个参数指定要显示的消息。第三个参数列出了有关查找结果的详细信息，因此如果它们发生更改，将再次显示消息。该宏还遵循 "
"find_package 命令的 QUIET 参数。"

#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:6
msgid "FindPatch"
msgstr "查找补丁"

#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:12
msgid "``Patch_EXECUTABLE``"
msgstr "``Patch_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:13
msgid "Path to patch command-line executable."
msgstr "修补命令行可执行文件的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:15
msgid "``Patch_FOUND``"
msgstr "``Patch_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:15
msgid "True if the patch command-line executable was found."
msgstr "如果找到补丁命令行可执行文件，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:17
#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:56
msgid "The following :prop_tgt:`IMPORTED` targets are also defined:"
msgstr "还定义了以下 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:20
msgid "``Patch::patch``"
msgstr "``补丁 ::补丁``"

#: ../../cmake-prefix/src/cmake/Modules/FindPatch.cmake:20
msgid "The command-line executable."
msgstr "命令行可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPerl.cmake:6
msgid "FindPerl"
msgstr "查找Perl"

#: ../../cmake-prefix/src/cmake/Modules/FindPerl.cmake:8
msgid "Find perl"
msgstr "寻找 perl"

#: ../../cmake-prefix/src/cmake/Modules/FindPerl.cmake:10
msgid "this module looks for Perl"
msgstr "这个模块寻找 Perl"

#: ../../cmake-prefix/src/cmake/Modules/FindPerlLibs.cmake:6
msgid "FindPerlLibs"
msgstr "查找 PerlLibs"

#: ../../cmake-prefix/src/cmake/Modules/FindPerlLibs.cmake:8
msgid "Find Perl libraries"
msgstr "查找 Perl 库"

#: ../../cmake-prefix/src/cmake/Modules/FindPerlLibs.cmake:10
msgid ""
"This module finds if PERL is installed and determines where the include "
"files and libraries are.  It also determines what the name of the library "
"is.  This code sets the following variables:"
msgstr "该模块查找是否安装了 PERL 并确定包含文件和库的位置。它还确定库的名称是什么。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindPerlLibs.cmake:23
msgid ""
"The minimum required version of Perl can be specified using the standard "
"syntax, e.g.  find_package(PerlLibs 6.0)"
msgstr "可以使用标准语法指定所需的最低 Perl 版本，例如查找包（PerlLibs 6.0）"

#: ../../cmake-prefix/src/cmake/Modules/FindPhysFS.cmake:6
msgid "FindPhysFS"
msgstr "查找PhysFS"

#: ../../cmake-prefix/src/cmake/Modules/FindPhysFS.cmake:10
msgid ""
"Locate PhysFS library This module defines PHYSFS_LIBRARY, the name of the "
"library to link against PHYSFS_FOUND, if false, do not try to link to "
"PHYSFS PHYSFS_INCLUDE_DIR, where to find physfs.h"
msgstr ""
"Locate PhysFS library 此模块定义 PHYSFS_LIBRARY，链接到 PHYSFS_FOUND 的库的名称，如果为 "
"false，不要尝试链接到 PHYSFS PHYSFS_INCLUDE_DIR，在哪里可以找到 physfs.h"

#: ../../cmake-prefix/src/cmake/Modules/FindPhysFS.cmake:14
msgid ""
"$PHYSFSDIR is an environment variable that would correspond to the "
"./configure --prefix=$PHYSFSDIR used in building PHYSFS."
msgstr ""
"$PHYSFSDIR 是一个环境变量，对应于构建 PHYSFS 时使用的 ./configure --prefix=$PHYSFSDIR。"

#: ../../cmake-prefix/src/cmake/Modules/FindPike.cmake:6
msgid "FindPike"
msgstr "找派克"

#: ../../cmake-prefix/src/cmake/Modules/FindPike.cmake:8
msgid "Find Pike"
msgstr "找到派克"

#: ../../cmake-prefix/src/cmake/Modules/FindPike.cmake:10
msgid ""
"This module finds if PIKE is installed and determines where the include "
"files and libraries are.  It also determines what the name of the library "
"is.  This code sets the following variables:"
msgstr "该模块查找是否安装了 PIKE 并确定包含文件和库的位置。它还确定库的名称是什么。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:6
msgid "FindPkgConfig"
msgstr "查找PkgConfig"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:8
msgid "A ``pkg-config`` module for CMake."
msgstr "用于 CMake 的 ``pkg-config`` 模块。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:10
msgid ""
"Finds the ``pkg-config`` executable and adds the "
":command:`pkg_get_variable`, :command:`pkg_check_modules` and "
":command:`pkg_search_module` commands. The following variables will also "
"be set:"
msgstr ""
"查找 ``pkg-config`` "
"可执行文件并添加:command:`pkg_get_variable`、:command:`pkg_check_modules` 和 "
":command:`pkg_search_module` 命令。还将设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:15
msgid "``PKG_CONFIG_FOUND``"
msgstr "``PKG_CONFIG_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:15
msgid "True if a pkg-config executable was found."
msgstr "如果找到 pkg-config 可执行文件，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:20
msgid "``PKG_CONFIG_VERSION_STRING``"
msgstr "``PKG_CONFIG_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:20
msgid "The version of pkg-config that was found."
msgstr "找到的 pkg-config 的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:23
msgid "``PKG_CONFIG_EXECUTABLE``"
msgstr "``PKG_CONFIG_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:23
msgid "The pathname of the pkg-config program."
msgstr "pkg-config 程序的路径名。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:28
msgid "``PKG_CONFIG_ARGN``"
msgstr "``PKG_CONFIG_ARGN``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:28
msgid "A list of arguments to pass to pkg-config."
msgstr "传递给 pkg-config 的参数列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:30
msgid ""
"Both ``PKG_CONFIG_EXECUTABLE`` and ``PKG_CONFIG_ARGN`` are initialized by "
"the module, but may be overridden by the user.  See `Variables Affecting "
"Behavior`_ for how these variables are initialized."
msgstr ""
"``PKG_CONFIG_EXECUTABLE`` 和 ``PKG_CONFIG_ARGN`` "
"都由模块初始化，但可以被用户覆盖。有关如何初始化这些变量的信息，请参阅“影响行为的变量”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:672
msgid ""
"Checks for all the given modules, setting a variety of result variables in"
" the calling scope."
msgstr "检查所有给定的模块，在调用范围内设置各种结果变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:684
msgid ""
"When the ``REQUIRED`` argument is given, the command will fail with an "
"error if module(s) could not be found."
msgstr "当给出 ``REQUIRED`` 参数时，如果找不到模块，命令将失败并出现错误。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:687
msgid ""
"When the ``QUIET`` argument is given, no status messages will be printed."
msgstr "当给出 ``QUIET`` 参数时，不会打印任何状态消息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:689
msgid ""
"The :variable:`CMAKE_PREFIX_PATH`, :variable:`CMAKE_FRAMEWORK_PATH`, and "
":variable:`CMAKE_APPBUNDLE_PATH` cache and environment variables will be "
"added to the ``pkg-config`` search path. The ``NO_CMAKE_PATH`` and "
"``NO_CMAKE_ENVIRONMENT_PATH`` arguments disable this behavior for the "
"cache variables and environment variables respectively. The "
":variable:`PKG_CONFIG_USE_CMAKE_PREFIX_PATH` variable set to ``FALSE`` "
"disables this behavior globally."
msgstr ""
"CMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH 和 CMAKE_APPBUNDLE_PATH 缓存和环境变量将添加到 "
"pkg-config 搜索路径。 ``NO_CMAKE_PATH`` 和 ``NO_CMAKE_ENVIRONMENT_PATH`` "
"参数分别对缓存变量和环境变量禁用此行为。 :variable:`PKG_CONFIG_USE_CMAKE_PREFIX_PATH` 变量设置为 "
"``FALSE`` 全局禁用此行为。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:701
msgid ""
"The ``IMPORTED_TARGET`` argument will create an imported target named "
"``PkgConfig::<prefix>`` that can be passed directly as an argument to "
":command:`target_link_libraries`."
msgstr ""
"``IMPORTED_TARGET`` 参数将创建一个名为 ``PkgConfig::<prefix>`` 的导入目标，它可以作为参数直接传递给 "
":command:`target_link_libraries`。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:708
msgid ""
"The ``GLOBAL`` argument will make the imported target available in global "
"scope."
msgstr "``GLOBAL`` 参数将使导入的目标在全局范围内可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:712
msgid ""
"Non-library linker options reported by ``pkg-config`` are stored in the "
":prop_tgt:`INTERFACE_LINK_OPTIONS` target property."
msgstr ""
"``pkg-config`` 报告的非库链接器选项存储在 :prop_tgt:`INTERFACE_LINK_OPTIONS` 目标属性中。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:716
msgid ""
"Include directories specified with ``-isystem`` are stored in the "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` target property.  Previous "
"versions of CMake left them in the :prop_tgt:`INTERFACE_COMPILE_OPTIONS` "
"property."
msgstr ""
"使用“-isystem”指定的包含目录存储在 INTERFACE_INCLUDE_DIRECTORIES 目标属性中。以前版本的 CMake "
"将它们留在 :prop_tgt:`INTERFACE_COMPILE_OPTIONS` 属性中。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:722
msgid ""
"Each ``<moduleSpec>`` can be either a bare module name or it can be a "
"module name with a version constraint (operators ``=``, ``<``, ``>``, "
"``<=`` and ``>=`` are supported).  The following are examples for a module"
" named ``foo`` with various constraints:"
msgstr ""
"每个 ``<moduleSpec>`` 可以是裸模块名称，也可以是具有版本约束的模块名称（运算符 ``=``、``<``、``>``、``<= ``"
" 和 ``>=`` 被支持）。以下是具有各种约束的名为“foo”的模块的示例："

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:727
msgid "``foo`` matches any version."
msgstr "``foo`` 匹配任何版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:728
msgid "``foo<2`` only matches versions before 2."
msgstr "``foo<2`` 只匹配 2 之前的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:729
msgid "``foo>=3.1`` matches any version from 3.1 or later."
msgstr "``foo>=3.1`` 匹配 3.1 或更高版本的任何版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:730
msgid "``foo=1.2.3`` requires that foo must be exactly version 1.2.3."
msgstr "``foo=1.2.3`` 要求 foo 必须是 1.2.3 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:732
msgid ""
"The following variables may be set upon return.  Two sets of values exist:"
" One for the common case (``<XXX> = <prefix>``) and another for the "
"information ``pkg-config`` provides when called with the ``--static`` "
"option (``<XXX> = <prefix>_STATIC``)."
msgstr ""
"返回时可以设置以下变量。存在两组值：一组用于常见情况（``<XXX> = "
"<prefix>``），另一组用于使用``--static``选项调用时``pkg-config``提供的信息（ ``<XXX> = "
"<前缀>_STATIC``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:737
msgid "``<XXX>_FOUND``"
msgstr "``<XXX>_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:738
msgid "set to 1 if module(s) exist"
msgstr "如果模块存在则设置为 1"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:739
msgid "``<XXX>_LIBRARIES``"
msgstr "``<XXX>_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:740
msgid "only the libraries (without the '-l')"
msgstr "只有图书馆（没有'-l'）"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:741
msgid "``<XXX>_LINK_LIBRARIES``"
msgstr "``<XXX>_LINK_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:742
msgid "the libraries and their absolute paths"
msgstr "图书馆和他们的绝对路径"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:743
msgid "``<XXX>_LIBRARY_DIRS``"
msgstr "``<XXX>_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:744
msgid "the paths of the libraries (without the '-L')"
msgstr "库的路径（没有'-L'）"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:745
msgid "``<XXX>_LDFLAGS``"
msgstr "``<XXX>_LDFLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:746
msgid "all required linker flags"
msgstr "所有必需的链接器标志"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:747
msgid "``<XXX>_LDFLAGS_OTHER``"
msgstr "``<XXX>_LDFLAGS_OTHER``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:748
msgid "all other linker flags"
msgstr "所有其他链接器标志"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:749
msgid "``<XXX>_INCLUDE_DIRS``"
msgstr "``<XXX>_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:750
msgid "the '-I' preprocessor flags (without the '-I')"
msgstr "“-I”预处理器标志（没有“-I”）"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:751
msgid "``<XXX>_CFLAGS``"
msgstr "``<XXX>_CFLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:752
msgid "all required cflags"
msgstr "所有必需的标志"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:754
msgid "``<XXX>_CFLAGS_OTHER``"
msgstr "``<XXX>_CFLAGS_OTHER``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:754
msgid "the other compiler flags"
msgstr "其他编译器标志"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:756
msgid ""
"All but ``<XXX>_FOUND`` may be a :ref:`;-list <CMake Language Lists>` if "
"the associated variable returned from ``pkg-config`` has multiple values."
msgstr ""
"如果从 ``pkg-config`` 返回的关联变量有多个值，则除了 ``<XXX>_FOUND`` 之外的所有都可能是 :ref:`;-list "
"<CMake Language Lists>`。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:759
msgid ""
"Include directories specified with ``-isystem`` are stored in the "
"``<XXX>_INCLUDE_DIRS`` variable.  Previous versions of CMake left them in "
"``<XXX>_CFLAGS_OTHER``."
msgstr ""
"使用“-isystem”指定的包含目录存储在“<XXX>_INCLUDE_DIRS”变量中。以前版本的 CMake "
"将它们留在了``<XXX>_CFLAGS_OTHER`` 中。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:764
msgid ""
"There are some special variables whose prefix depends on the number of "
"``<moduleSpec>`` given.  When there is only one ``<moduleSpec>``, "
"``<YYY>`` will simply be ``<prefix>``, but if two or more ``<moduleSpec>``"
" items are given, ``<YYY>`` will be ``<prefix>_<moduleName>``."
msgstr ""
"有一些特殊变量的前缀取决于给定的``<moduleSpec>``的数量。当只有一个 ``<moduleSpec>`` 时，``<YYY>`` 将只是"
" ``<prefix>``，但是如果给出了两个或更多的 ``<moduleSpec>`` 项，``< YYY>`` 将是 "
"``<prefix>_<moduleName>``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:769
msgid "``<YYY>_VERSION``"
msgstr "``<YYY>_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:770
msgid "version of the module"
msgstr "模块的版本"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:771
msgid "``<YYY>_PREFIX``"
msgstr "``<YYY>_PREFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:772
msgid "prefix directory of the module"
msgstr "模块前缀目录"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:773
msgid "``<YYY>_INCLUDEDIR``"
msgstr "``<YYY>_INCLUDEDIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:774
msgid "include directory of the module"
msgstr "include 模块目录"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:776
msgid "``<YYY>_LIBDIR``"
msgstr "``<YYY>_LIBDIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:776
msgid "lib directory of the module"
msgstr "模块的lib目录"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:778
msgid ""
"For any given ``<prefix>``, ``pkg_check_modules()`` can be called multiple"
" times with different parameters.  Previous versions of CMake cached and "
"returned the first successful result."
msgstr ""
"对于任何给定的 ``<prefix>``，``pkg_check_modules()`` 可以使用不同的参数多次调用。以前版本的 CMake "
"会缓存并返回第一个成功的结果。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:783
msgid ""
"If a full path to the found library can't be determined, but it's still "
"visible to the linker, pass it through as ``-l<name>``.  Previous versions"
" of CMake failed in this case."
msgstr "如果无法确定找到的库的完整路径，但它仍然对链接器可见，请将其作为“-l<名称>”传递。在这种情况下，以前版本的 CMake 失败了。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:788
msgid "Examples:"
msgstr "例子："

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:794
msgid ""
"Looks for any version of glib2.  If found, the output variable "
"``GLIB2_VERSION`` will hold the actual version found."
msgstr "寻找任何版本的 glib2。如果找到，输出变量“GLIB2_VERSION”将保存找到的实际版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:801
msgid ""
"Looks for at least version 2.10 of glib2.  If found, the output variable "
"``GLIB2_VERSION`` will hold the actual version found."
msgstr "查找至少 2.10 版的 glib2。如果找到，输出变量“GLIB2_VERSION”将保存找到的实际版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:808
msgid ""
"Looks for both glib2-2.0 (at least version 2.10) and any version of "
"gtk2+-2.0.  Only if both are found will ``FOO`` be considered found. The "
"``FOO_glib-2.0_VERSION`` and ``FOO_gtk+-2.0_VERSION`` variables will be "
"set to their respective found module versions."
msgstr ""
"查找 glib2-2.0（至少版本 2.10）和任何版本的 gtk2+-2.0。只有两者都找到，才会认为“FOO”已找到。 "
"``FOO_glib-2.0_VERSION`` 和 ``FOO_gtk+-2.0_VERSION`` 变量将设置为它们各自找到的模块版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:817
msgid ""
"Requires any version of ``xrender``.  Example output variables set by a "
"successful call::"
msgstr "需要任何版本的``xrender``。成功调用设置的示例输出变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:846
msgid ""
"The behavior of this command is the same as :command:`pkg_check_modules`, "
"except that rather than checking for all the specified modules, it "
"searches for just the first successful match."
msgstr ""
"此命令的行为与 :command:`pkg_check_modules` 相同，不同之处在于它不是检查所有指定的模块，而是仅搜索第一个成功的匹配项。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:859
msgid ""
"If a module is found, the ``<prefix>_MODULE_NAME`` variable will contain "
"the name of the matching module. This variable can be used if you need to "
"run :command:`pkg_get_variable`."
msgstr ""
"如果找到模块，``<prefix>_MODULE_NAME`` 变量将包含匹配模块的名称。如果您需要运行 "
"pkg_get_variable，可以使用此变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:909
msgid ""
"Retrieves the value of a pkg-config variable ``varName`` and stores it in "
"the result variable ``resultVar`` in the calling scope."
msgstr "检索 pkg-config 变量“varName”的值并将其存储在调用范围内的结果变量“resultVar”中。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:916
msgid ""
"If ``pkg-config`` returns multiple values for the specified variable, "
"``resultVar`` will contain a :ref:`;-list <CMake Language Lists>`."
msgstr ""
"如果 ``pkg-config`` 为指定变量返回多个值，``resultVar`` 将包含一个 :ref:`;-list <CMake "
"Language Lists>`。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:937
#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:39
msgid "Variables Affecting Behavior"
msgstr "影响行为的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:941
msgid ""
"This cache variable can be set to the path of the pkg-config executable. "
":command:`find_program` is called internally by the module with this "
"variable."
msgstr ""
"这个缓存变量可以设置为 pkg-config 可执行文件的路径。 :command:`find_program` 由带有此变量的模块在内部调用。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:945
msgid ""
"The ``PKG_CONFIG`` environment variable can be used as a hint if "
"``PKG_CONFIG_EXECUTABLE`` has not yet been set."
msgstr "如果尚未设置“PKG_CONFIG_EXECUTABLE”，则“PKG_CONFIG”环境变量可用作提示。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:949
msgid ""
"If the ``PKG_CONFIG`` environment variable is set, only the first argument"
" is taken from it when using it as a hint."
msgstr "如果设置了 ``PKG_CONFIG`` 环境变量，则在将其用作提示时仅从中获取第一个参数。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:957
msgid ""
"This cache variable can be set to a list of arguments to additionally pass"
" to pkg-config if needed. If not provided, it will be initialized from the"
" ``PKG_CONFIG`` environment variable, if set. The first argument in that "
"environment variable is assumed to be the pkg-config program, while all "
"remaining arguments after that are used to initialize ``PKG_CONFIG_ARGN``."
" If no such environment variable is defined, ``PKG_CONFIG_ARGN`` is "
"initialized to an empty string. The module does not update the variable "
"once it has been set in the cache."
msgstr ""
"如果需要，可以将此缓存变量设置为参数列表，以额外传递给 pkg-config。如果未提供，它将从``PKG_CONFIG`` "
"环境变量（如果已设置）中初始化。该环境变量中的第一个参数被假定为 pkg-config "
"程序，而之后的所有剩余参数都用于初始化“PKG_CONFIG_ARGN”。如果没有定义这样的环境变量，``PKG_CONFIG_ARGN`` "
"被初始化为一个空字符串。一旦在缓存中设置了变量，模块就不会更新它。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:970
msgid ""
"Specifies whether :command:`pkg_check_modules` and "
":command:`pkg_search_module` should add the paths in the "
":variable:`CMAKE_PREFIX_PATH`, :variable:`CMAKE_FRAMEWORK_PATH` and "
":variable:`CMAKE_APPBUNDLE_PATH` cache and environment variables to the "
"``pkg-config`` search path."
msgstr ""
"指定 :command:`pkg_check_modules` 和 :command:`pkg_search_module` 是否应该将 "
":variable:`CMAKE_PREFIX_PATH`、 :variable:`CMAKE_FRAMEWORK_PATH` 和 "
":variable:`CMAKE_APPBUNDLE_PATH` 缓存和环境变量中的路径添加到 ``pkg -config`` 搜索路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindPkgConfig.cmake:976
msgid ""
"If this variable is not set, this behavior is enabled by default if "
":variable:`CMAKE_MINIMUM_REQUIRED_VERSION` is 3.1 or later, disabled "
"otherwise."
msgstr ""
"如果未设置此变量，如果 CMAKE_MINIMUM_REQUIRED_VERSION 为 3.1 或更高版本，则默认情况下启用此行为，否则禁用。"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:6
msgid "FindPostgreSQL"
msgstr "查找PostgreSQL"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:8
msgid "Find the PostgreSQL installation."
msgstr "找到 PostgreSQL 安装。"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:15
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``PostgreSQL::PostgreSQL``"
" if PostgreSQL has been found."
msgstr ""
"如果已找到 PostgreSQL，此模块定义 :prop_tgt:`IMPORTED` 目标 ``PostgreSQL::PostgreSQL``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:23
msgid "``PostgreSQL_FOUND``"
msgstr "``PostgreSQL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:24
msgid "True if PostgreSQL is found."
msgstr "如果找到 PostgreSQL，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:25
msgid "``PostgreSQL_LIBRARIES``"
msgstr "``PostgreSQL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:26
msgid "the PostgreSQL libraries needed for linking"
msgstr "链接所需的 PostgreSQL 库"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:27
msgid "``PostgreSQL_INCLUDE_DIRS``"
msgstr "``PostgreSQL_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:28
msgid "the directories of the PostgreSQL headers"
msgstr "PostgreSQL 标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:29
msgid "``PostgreSQL_LIBRARY_DIRS``"
msgstr "``PostgreSQL_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:30
msgid "the link directories for PostgreSQL libraries"
msgstr "PostgreSQL 库的链接目录"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:31
msgid "``PostgreSQL_VERSION_STRING``"
msgstr "``PostgreSQL_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:32
msgid "the version of PostgreSQL found"
msgstr "找到的 PostgreSQL 版本"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:34
msgid "``PostgreSQL_TYPE_INCLUDE_DIR``"
msgstr "``PostgreSQL_TYPE_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:34
msgid "the directories of the PostgreSQL server headers"
msgstr "PostgreSQL 服务器标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:37
msgid "Components"
msgstr "成分"

#: ../../cmake-prefix/src/cmake/Modules/FindPostgreSQL.cmake:39
msgid ""
"This module contains additional ``Server`` component, that forcibly checks"
" for the presence of server headers. Note that "
"``PostgreSQL_TYPE_INCLUDE_DIR`` is set regardless of the presence of the "
"``Server`` component in find_package call."
msgstr ""
"该模块包含额外的“服务器”组件，它强制检查服务器标头的存在。请注意，无论 find_package "
"调用中是否存在“Server”组件，都会设置“PostgreSQL_TYPE_INCLUDE_DIR”。"

#: ../../cmake-prefix/src/cmake/Modules/FindProducer.cmake:6
msgid "FindProducer"
msgstr "寻找制作人"

#: ../../cmake-prefix/src/cmake/Modules/FindProducer.cmake:10
msgid ""
"Though Producer isn't directly part of OpenSceneGraph, its primary user is"
" OSG so I consider this part of the Findosg* suite used to find "
"OpenSceneGraph components.  You'll notice that I accept OSGDIR as an "
"environment path."
msgstr ""
"尽管 Producer 不是 OpenSceneGraph 的直接组成部分，但它的主要用户是 OSG，因此我认为 Findosg* "
"套件的这一部分用于查找 OpenSceneGraph 组件。您会注意到我接受 OSGDIR 作为环境路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindProducer.cmake:15
msgid ""
"Each component is separate and you must opt in to each module.  You must "
"also opt into OpenGL (and OpenThreads?) as these modules won't do it for "
"you.  This is to allow you control over your own system piece by piece in "
"case you need to opt out of certain components or change the Find behavior"
" for a particular module (perhaps because the default FindOpenGL.cmake "
"module doesn't work with your system as an example). If you want to use a "
"more convenient module that includes everything, use the "
"FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules."
msgstr ""
"每个组件都是独立的，您必须选择加入每个模块。您还必须选择加入 OpenGL（和 "
"OpenThreads？），因为这些模块不会为您做这件事。这是为了允许您逐个控制自己的系统，以防您需要选择退出某些组件或更改特定模块的查找行为（可能是因为默认的"
" FindOpenGL.cmake 模块不能与您的系统一起使用作为例子）。如果您想使用包含所有内容的更方便的模块，请使用 "
"FindOpenSceneGraph.cmake 而不是 Findosg*.cmake 模块。"

#: ../../cmake-prefix/src/cmake/Modules/FindProducer.cmake:25
msgid ""
"Locate Producer This module defines PRODUCER_LIBRARY PRODUCER_FOUND, if "
"false, do not try to link to Producer PRODUCER_INCLUDE_DIR, where to find "
"the headers"
msgstr ""
"Locate Producer 这个模块定义了PRODUCER_LIBRARY "
"PRODUCER_FOUND，如果为false，不要尝试链接到Producer PRODUCER_INCLUDE_DIR，哪里可以找到headers"

#: ../../cmake-prefix/src/cmake/Modules/FindProducer.cmake:29
msgid ""
"$PRODUCER_DIR is an environment variable that would correspond to the "
"./configure --prefix=$PRODUCER_DIR used in building osg."
msgstr ""
"$PRODUCER_DIR 是一个环境变量，对应于构建 osg 时使用的 ./configure --prefix=$PRODUCER_DIR。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:6
msgid "FindProtobuf"
msgstr "查找Protobuf"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:8
msgid "Locate and configure the Google Protocol Buffers library."
msgstr "找到并配置 Google Protocol Buffers 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:10
msgid "Support for :command:`find_package` version checks."
msgstr "支持 :command:`find_package` 版本检查。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:13
msgid ""
"All input and output variables use the ``Protobuf_`` prefix. Variables "
"with ``PROTOBUF_`` prefix are still supported for compatibility."
msgstr "所有输入和输出变量都使用“Protobuf_”前缀。为了兼容性，仍然支持带有 ``PROTOBUF_`` 前缀的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:17
msgid "The following variables can be set and are optional:"
msgstr "可以设置以下变量并且是可选的："

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:23
msgid "``Protobuf_SRC_ROOT_FOLDER``"
msgstr "``Protobuf_SRC_ROOT_FOLDER``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:20
msgid ""
"When compiling with MSVC, if this cache variable is set the protobuf-"
"default VS project build locations (vsprojects/Debug and "
"vsprojects/Release or vsprojects/x64/Debug and vsprojects/x64/Release) "
"will be searched for libraries and binaries."
msgstr ""
"使用 MSVC 编译时，如果设置了此缓存变量，则会在 protobuf-default VS 项目构建位置（vsprojects/Debug 和 "
"vsprojects/Release 或 vsprojects/x64/Debug 和 "
"vsprojects/x64/Release）中搜索库和二进制文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:26
msgid "``Protobuf_IMPORT_DIRS``"
msgstr "``Protobuf_IMPORT_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:26
msgid ""
"List of additional directories to be searched for imported .proto files."
msgstr "要搜索导入的 .proto 文件的其他目录列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:30
msgid "``Protobuf_DEBUG``"
msgstr "``Protobuf_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:31
msgid "Show debug messages."
msgstr "显示调试信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:36
msgid "``Protobuf_USE_STATIC_LIBS``"
msgstr "``Protobuf_USE_STATIC_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:35
msgid "Set to ON to force the use of the static libraries. Default is OFF."
msgstr "设置为 ON 以强制使用静态库。默认为关闭。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:38
msgid "Defines the following variables:"
msgstr "定义以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:41
msgid "``Protobuf_FOUND``"
msgstr "``Protobuf_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:41
msgid ""
"Found the Google Protocol Buffers library (libprotobuf & header files)"
msgstr "找到 Google Protocol Buffers 库（libprotobuf 和头文件）"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:45
msgid "``Protobuf_VERSION``"
msgstr "``Protobuf_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:46
msgid "Version of package found."
msgstr "找到包的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:47
msgid "``Protobuf_INCLUDE_DIRS``"
msgstr "``Protobuf_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:48
msgid "Include directories for Google Protocol Buffers"
msgstr "包含 Google Protocol Buffers 的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:49
msgid "``Protobuf_LIBRARIES``"
msgstr "``Protobuf_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:50
msgid "The protobuf libraries"
msgstr "protobuf 库"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:51
msgid "``Protobuf_PROTOC_LIBRARIES``"
msgstr "``Protobuf_PROTOC_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:52
msgid "The protoc libraries"
msgstr "协议库"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:54
msgid "``Protobuf_LITE_LIBRARIES``"
msgstr "``Protobuf_LITE_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:54
msgid "The protobuf-lite libraries"
msgstr "protobuf-lite 库"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:59
msgid "``protobuf::libprotobuf``"
msgstr "``protobuf::libprotobuf``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:60
msgid "The protobuf library."
msgstr "protobuf 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:61
msgid "``protobuf::libprotobuf-lite``"
msgstr "``protobuf::libprotobuf-lite``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:62
msgid "The protobuf lite library."
msgstr "protobuf 精简版库。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:63
msgid "``protobuf::libprotoc``"
msgstr "``protobuf::libprotoc``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:64
msgid "The protoc library."
msgstr "协议库。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:67
msgid "``protobuf::protoc``"
msgstr "``protobuf::protoc``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:66
msgid "The protoc compiler."
msgstr "协议编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:71
msgid "``Protobuf_LIBRARY``"
msgstr "``Protobuf_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:72
msgid "The protobuf library"
msgstr "protobuf 库"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:73
msgid "``Protobuf_PROTOC_LIBRARY``"
msgstr "``Protobuf_PROTOC_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:74
msgid "The protoc library"
msgstr "协议库"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:75
msgid "``Protobuf_INCLUDE_DIR``"
msgstr "``Protobuf_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:76
msgid "The include directory for protocol buffers"
msgstr "协议缓冲区的包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:77
msgid "``Protobuf_PROTOC_EXECUTABLE``"
msgstr "``Protobuf_PROTOC_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:78
msgid "The protoc compiler"
msgstr "协议编译器"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:79
msgid "``Protobuf_LIBRARY_DEBUG``"
msgstr "``Protobuf_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:80
msgid "The protobuf library (debug)"
msgstr "protobuf 库（调试）"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:81
msgid "``Protobuf_PROTOC_LIBRARY_DEBUG``"
msgstr "``Protobuf_PROTOC_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:82
msgid "The protoc library (debug)"
msgstr "协议库（调试）"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:83
msgid "``Protobuf_LITE_LIBRARY``"
msgstr "``Protobuf_LITE_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:84
msgid "The protobuf lite library"
msgstr "protobuf lite 库"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:86
msgid "``Protobuf_LITE_LIBRARY_DEBUG``"
msgstr "``Protobuf_LITE_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:86
msgid "The protobuf lite library (debug)"
msgstr "protobuf lite 库（调试）"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:103
msgid ""
"The ``protobuf_generate_cpp`` and ``protobuf_generate_python`` functions "
"and :command:`add_executable` or :command:`add_library` calls only work "
"properly within the same directory."
msgstr ""
"``protobuf_generate_cpp`` 和 ``protobuf_generate_python`` 函数和 "
":command:`add_executable` 或 :command:`add_library` 调用只能在同一目录中正常工作。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:109
msgid "Add custom commands to process ``.proto`` files to C++::"
msgstr "添加自定义命令以将 ``.proto`` 文件处理到 C++::"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:114
msgid "``SRCS``"
msgstr "``SRCS``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:115
msgid "Variable to define with autogenerated source files"
msgstr "使用自动生成的源文件定义的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:116
msgid "``HDRS``"
msgstr "``HDRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:117
msgid "Variable to define with autogenerated header files"
msgstr "使用自动生成的头文件定义的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:119
msgid "``DESCRIPTORS``"
msgstr "``描述符``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:119
msgid ""
"Variable to define with autogenerated descriptor files, if requested."
msgstr "如果需要，使用自动生成的描述符文件定义的变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:122
msgid "``EXPORT_MACRO``"
msgstr "``EXPORT_MACRO``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:122
msgid ""
"is a macro which should expand to ``__declspec(dllexport)`` or "
"``__declspec(dllimport)`` depending on what is being compiled."
msgstr ""
"是一个宏，它应该扩展为``__declspec(dllexport)`` "
"或``__declspec(dllimport)``，具体取决于正在编译的内容。"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:124
#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:137
msgid "``ARGN``"
msgstr "``ARGN``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:125
#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:138
msgid "``.proto`` files"
msgstr "``.proto`` 文件"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:131
msgid "Add custom commands to process ``.proto`` files to Python::"
msgstr "添加自定义命令以处理 ``.proto`` 文件到 Python::"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:135
msgid "``PY``"
msgstr "``PY``"

#: ../../cmake-prefix/src/cmake/Modules/FindProtobuf.cmake:136
msgid "Variable to define with autogenerated Python files"
msgstr "使用自动生成的 Python 文件定义的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:6
msgid "FindPython"
msgstr "查找Python"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:10
msgid ""
"Find Python interpreter, compiler and development environment (include "
"directories and libraries)."
msgstr "查找 Python 解释器、编译器和开发环境（包括目录和库）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:18
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:18
msgid "The following components are supported:"
msgstr "支持以下组件："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:20
msgid "``Interpreter``: search for Python interpreter."
msgstr "``Interpreter``：搜索 Python 解释器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:21
msgid ""
"``Compiler``: search for Python compiler. Only offered by IronPython."
msgstr "``Compiler``：搜索 Python 编译器。仅由 IronPython 提供。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:22
msgid ""
"``Development``: search for development artifacts (include directories and"
" libraries)."
msgstr "``Development``：搜索开发工件（包括目录和库）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:25
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:25
msgid ""
"This component includes two sub-components which can be specified "
"independently:"
msgstr "该组件包括两个可以独立指定的子组件："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:29
msgid ""
"``Development.Module``: search for artifacts for Python module "
"developments."
msgstr "``Development.Module``：搜索用于 Python 模块开发的工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:31
msgid ""
"``Development.Embed``: search for artifacts for Python embedding "
"developments."
msgstr "``Development.Embed``：搜索用于 Python 嵌入开发的工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:36
msgid ""
"``Development.SABIModule``: search for artifacts for Python module "
"developments using the `Stable Application Binary Interface "
"<https://docs.python.org/3/c-api/stable.html>`_. This component is "
"available only for version ``3.2`` and upper."
msgstr ""
"``Development.SABIModule``：使用 `Stable Application Binary Interface "
"<https://docs.python.org/3/c-api/stable.html>`_ 搜索用于 Python "
"模块开发的工件。此组件仅适用于版本 ``3.2`` 及更高版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:41
msgid "``NumPy``: search for NumPy include directories."
msgstr "``NumPy``：搜索 NumPy 包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:43
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:36
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:43
msgid "Added the ``NumPy`` component."
msgstr "添加了``NumPy`` 组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:39
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:46
msgid "If no ``COMPONENTS`` are specified, ``Interpreter`` is assumed."
msgstr "如果未指定 ``COMPONENTS``，则假定为 ``Interpreter``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:48
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:48
msgid ""
"If component ``Development`` is specified, it implies sub-components "
"``Development.Module`` and ``Development.Embed``."
msgstr "如果指定组件“Development”，则表示子组件“Development.Module”和“Development.Embed”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:51
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:51
msgid ""
"To ensure consistent versions between components ``Interpreter``, "
"``Compiler``, ``Development`` (or one of its sub-components) and "
"``NumPy``, specify all components at the same time::"
msgstr ""
"为确保组件“Interpreter”、“Compiler”、“Development”（或其子组件之一）和“NumPy”之间的版本一致，请同时指定所有组件："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:57
msgid ""
"This module looks preferably for version 3 of Python. If not found, "
"version 2 is searched. To manage concurrent versions 3 and 2 of Python, "
"use :module:`FindPython3` and :module:`FindPython2` modules rather than "
"this one."
msgstr ""
"该模块更适合 Python 版本 3。如果未找到，则搜索版本 2。要管理 Python 的并发版本 3 和 2，请使用 FindPython3 和 "
"FindPython2 模块，而不是这个模块。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:64
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:58
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:65
msgid ""
"If components ``Interpreter`` and ``Development`` (or one of its sub-"
"components) are both specified, this module search only for interpreter "
"with same platform architecture as the one defined by CMake configuration."
" This constraint does not apply if only ``Interpreter`` component is "
"specified."
msgstr ""
"如果同时指定组件“Interpreter”和“Development”（或其子组件之一），则此模块仅搜索与 CMake "
"配置定义的平台架构相同的解释器。如果仅指定了 Interpreter 组件，则此约束不适用。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:75
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:69
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:76
msgid ""
":ref:`Imported Targets <Imported Targets>` are only created when "
":prop_gbl:`CMAKE_ROLE` is ``PROJECT``."
msgstr ""
":ref:`Imported Targets <Imported Targets>` 仅在 :prop_gbl:`CMAKE_ROLE` 为 "
"``PROJECT`` 时创建。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:79
msgid "``Python::Interpreter``"
msgstr "``Python::解释器``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:80
msgid ""
"Python interpreter. Target defined if component ``Interpreter`` is found."
msgstr "Python 解释器。如果找到组件“解释器”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:82
msgid "``Python::Compiler``"
msgstr "``Python::编译器``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:82
msgid "Python compiler. Target defined if component ``Compiler`` is found."
msgstr "Python编译器。如果找到组件“Compiler”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:88
msgid "``Python::Module``"
msgstr "``Python::模块``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:87
msgid ""
"Python library for Python module. Target defined if component "
"``Development.Module`` is found."
msgstr "Python 模块的 Python 库。如果找到组件“Development.Module”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:94
msgid "``Python::SABIModule``"
msgstr "``Python::SABIModule``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:93
msgid ""
"Python library for Python module using the Stable Application Binary "
"Interface. Target defined if component ``Development.SABIModule`` is "
"found."
msgstr ""
"使用稳定应用程序二进制接口的 Python 模块的 Python 库。如果找到组件“Development.SABIModule”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:98
msgid "``Python::Python``"
msgstr "``蟒蛇 ::蟒蛇``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:97
msgid ""
"Python library for Python embedding. Target defined if component "
"``Development.Embed`` is found."
msgstr "用于 Python 嵌入的 Python 库。如果找到组件“Development.Embed”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:103
msgid "``Python::NumPy``"
msgstr "``Python::NumPy``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:103
msgid ""
"NumPy Python library. Target defined if component ``NumPy`` is found."
msgstr "NumPy Python 库。如果找到组件“NumPy”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:108
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:95
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:109
msgid ""
"This module will set the following variables in your project (see "
":ref:`Standard Variable Names <CMake Developer Standard Variable Names>`):"
msgstr "该模块将在您的项目中设置以下变量（请参阅 :ref:`标准变量名称 <CMake 开发人员标准变量名称>`）："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:111
msgid "``Python_FOUND``"
msgstr "``Python_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:112
msgid "System has the Python requested components."
msgstr "系统具有 Python 请求的组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:113
msgid "``Python_Interpreter_FOUND``"
msgstr "``Python_Interpreter_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:114
msgid "System has the Python interpreter."
msgstr "系统有 Python 解释器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:115
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:454
msgid "``Python_EXECUTABLE``"
msgstr "``Python_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:116
msgid "Path to the Python interpreter."
msgstr "Python 解释器的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:123
msgid "``Python_INTERPRETER_ID``"
msgstr "``Python_INTERPRETER_ID``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:123
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:110
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:124
msgid "A short string unique to the interpreter. Possible values include:"
msgstr "解释器独有的短字符串。可能的值包括："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:119
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:106
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:120
msgid "Python"
msgstr "Python"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:120
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:107
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:121
msgid "ActivePython"
msgstr "ActivePython"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:121
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:108
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:122
msgid "Anaconda"
msgstr "蟒蛇"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:122
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:109
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:123
msgid "Canopy"
msgstr "雨棚"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:123
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:177
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:110
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:142
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:124
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:178
msgid "IronPython"
msgstr "铁蟒"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:124
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:111
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:125
msgid "PyPy"
msgstr "PyPy"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:129
msgid "``Python_STDLIB``"
msgstr "``Python_STDLIB``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:126
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:113
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:127
msgid "Standard platform independent installation directory."
msgstr "标准平台独立安装目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:128
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:115
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:129
msgid ""
"Information returned by "
"``distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=True)``"
" or else ``sysconfig.get_path('stdlib')``."
msgstr ""
"``distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=True)``"
" 或 ``sysconfig.get_path('stdlib')`` 返回的信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:135
msgid "``Python_STDARCH``"
msgstr "``Python_STDARCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:132
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:119
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:133
msgid "Standard platform dependent installation directory."
msgstr "标准平台相关安装目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:134
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:121
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:135
msgid ""
"Information returned by "
"``distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=True)``"
" or else ``sysconfig.get_path('platstdlib')``."
msgstr ""
"``distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=True)``"
" 或 ``sysconfig.get_path('platstdlib')`` 返回的信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:141
msgid "``Python_SITELIB``"
msgstr "``Python_SITELIB``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:138
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:125
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:139
msgid "Third-party platform independent installation directory."
msgstr "第三方平台独立安装目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:140
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:127
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:141
msgid ""
"Information returned by "
"``distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=False)``"
" or else ``sysconfig.get_path('purelib')``."
msgstr ""
"``distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=False)``"
" 或 ``sysconfig.get_path('purelib')`` 返回的信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:148
msgid "``Python_SITEARCH``"
msgstr "``Python_SITEARCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:144
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:131
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:145
msgid "Third-party platform dependent installation directory."
msgstr "第三方平台依赖安装目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:146
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:133
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:147
msgid ""
"Information returned by "
"``distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=False)``"
" or else ``sysconfig.get_path('platlib')``."
msgstr ""
"``distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=False)``"
" 或 ``sysconfig.get_path('platlib')`` 返回的信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:159
msgid "``Python_SOABI``"
msgstr "``Python_SOABI``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:153
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:154
msgid "Extension suffix for modules."
msgstr "模块的扩展后缀。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:155
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:156
msgid ""
"Information computed from "
"``distutils.sysconfig.get_config_var('EXT_SUFFIX')`` or "
"``distutils.sysconfig.get_config_var('SOABI')`` or ``python3-config "
"--extension-suffix``. If package ``distutils.sysconfig`` is not available,"
" ``sysconfig.get_config_var('EXT_SUFFIX')`` or "
"``sysconfig.get_config_var('SOABI')`` are used."
msgstr ""
"从``distutils.sysconfig.get_config_var('EXT_SUFFIX')`` "
"或``distutils.sysconfig.get_config_var('SOABI')`` 或``python3-config "
"--extension-suffix`` 计算的信息。如果包 ``distutils.sysconfig`` 不可用，则使用 "
"``sysconfig.get_config_var('EXT_SUFFIX')`` 或 "
"``sysconfig.get_config_var('SOABI')``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:169
msgid "``Python_SOSABI``"
msgstr "``Python_SOSABI``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:164
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:165
msgid ""
"Extension suffix for modules using the Stable Application Binary "
"Interface."
msgstr "使用稳定应用程序二进制接口的模块的扩展后缀。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:166
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:167
msgid ""
"Information computed from ``importlib.machinery.EXTENSION_SUFFIXES`` if "
"the COMPONENT ``Interpreter`` was specified. Otherwise, the extension is "
"``abi3`` except for ``Windows``, ``MSYS`` and ``CYGWIN`` for which this is"
" an empty string."
msgstr ""
"如果指定了 COMPONENT ``Interpreter``，则根据 "
"``importlib.machinery.EXTENSION_SUFFIXES`` 计算的信息。否则，扩展名是 ``abi3`` 除了 "
"``Windows``、``MSYS`` 和 ``CYGWIN`` 之外，这是一个空字符串。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:171
msgid "``Python_Compiler_FOUND``"
msgstr "``Python_Compiler_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:172
msgid "System has the Python compiler."
msgstr "系统有 Python 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:173
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:457
msgid "``Python_COMPILER``"
msgstr "``Python_COMPILER``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:174
msgid "Path to the Python compiler. Only offered by IronPython."
msgstr "Python 编译器的路径。仅由 IronPython 提供。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:177
msgid "``Python_COMPILER_ID``"
msgstr "``Python_COMPILER_ID``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:177
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:142
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:178
msgid "A short string unique to the compiler. Possible values include:"
msgstr "编译器独有的短字符串。可能的值包括："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:182
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:462
msgid "``Python_DOTNET_LAUNCHER``"
msgstr "``Python_DOTNET_LAUNCHER``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:182
#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:462
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:147
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:361
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:183
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:460
msgid ""
"The ``.Net`` interpreter. Only used by ``IronPython`` implementation."
msgstr "``.Net`` 解释器。仅供“IronPython”实现使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:185
msgid "``Python_Development_FOUND``"
msgstr "``Python_Development_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:185
msgid "System has the Python development artifacts."
msgstr "系统有Python开发神器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:190
msgid "``Python_Development.Module_FOUND``"
msgstr "``Python_Development.Module_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:190
msgid "System has the Python development artifacts for Python module."
msgstr "系统具有 Python 模块的 Python 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:196
msgid "``Python_Development.SABIModule_FOUND``"
msgstr "``Python_Development.SABIModule_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:195
msgid ""
"System has the Python development artifacts for Python module using the "
"Stable Application Binary Interface."
msgstr "系统具有使用稳定应用程序二进制接口的 Python 模块的 Python 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:201
msgid "``Python_Development.Embed_FOUND``"
msgstr "``Python_Development.Embed_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:201
msgid "System has the Python development artifacts for Python embedding."
msgstr "系统具有用于 Python 嵌入的 Python 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:203
msgid "``Python_INCLUDE_DIRS``"
msgstr "``Python_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:205
msgid "The Python include directories."
msgstr "Python 包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:211
msgid "``Python_LINK_OPTIONS``"
msgstr "``Python_LINK_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:210
msgid ""
"The Python link options. Some configurations require specific link options"
" for a correct build and execution."
msgstr "Python 链接选项。某些配置需要特定的链接选项才能正确构建和执行。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:213
msgid "``Python_LIBRARIES``"
msgstr "``Python_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:214
msgid "The Python libraries."
msgstr "Python 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:215
msgid "``Python_LIBRARY_DIRS``"
msgstr "``Python_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:216
msgid "The Python library directories."
msgstr "Python 库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:217
msgid "``Python_RUNTIME_LIBRARY_DIRS``"
msgstr "``Python_RUNTIME_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:218
msgid "The Python runtime library directories."
msgstr "Python 运行时库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:221
msgid "``Python_SABI_LIBRARIES``"
msgstr "``Python_SABI_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:222
msgid "The Python libraries for the Stable Application Binary Interface."
msgstr "用于稳定应用程序二进制接口的 Python 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:225
msgid "``Python_SABI_LIBRARY_DIRS``"
msgstr "``Python_SABI_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:226
msgid "The Python ``SABI`` library directories."
msgstr "Python ``SABI`` 库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:229
msgid "``Python_RUNTIME_SABI_LIBRARY_DIRS``"
msgstr "``Python_RUNTIME_SABI_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:230
msgid "The Python runtime ``SABI`` library directories."
msgstr "Python 运行时 ``SABI`` 库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:231
msgid "``Python_VERSION``"
msgstr "``Python_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:232
msgid "Python version."
msgstr "蟒蛇版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:233
msgid "``Python_VERSION_MAJOR``"
msgstr "``Python_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:234
msgid "Python major version."
msgstr "Python 主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:235
msgid "``Python_VERSION_MINOR``"
msgstr "``Python_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:236
msgid "Python minor version."
msgstr "Python 次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:238
msgid "``Python_VERSION_PATCH``"
msgstr "``Python_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:238
msgid "Python patch version."
msgstr "Python补丁版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:243
msgid "``Python_PyPy_VERSION``"
msgstr "``Python_PyPy_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:243
msgid "Python PyPy version."
msgstr "Python PyPy 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:248
msgid "``Python_NumPy_FOUND``"
msgstr "``Python_NumPy_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:248
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:194
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:250
msgid "System has the NumPy."
msgstr "系统有 NumPy。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:253
msgid "``Python_NumPy_INCLUDE_DIRS``"
msgstr "``Python_NumPy_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:253
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:199
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:255
msgid "The NumPy include directories."
msgstr "NumPy 包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:258
msgid "``Python_NumPy_VERSION``"
msgstr "``Python_NumPy_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:258
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:204
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:260
msgid "The NumPy version."
msgstr "NumPy 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:264
msgid "``Python_ROOT_DIR``"
msgstr "``Python_ROOT_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:264
msgid "Define the root directory of a Python installation."
msgstr "定义 Python 安装的根目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:275
msgid "``Python_USE_STATIC_LIBS``"
msgstr "``Python_USE_STATIC_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:267
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:213
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:269
msgid ""
"If not defined, search for shared libraries and static libraries in that "
"order."
msgstr "如果未定义，则按该顺序搜索共享库和静态库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:269
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:215
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:271
msgid "If set to TRUE, search **only** for static libraries."
msgstr "如果设置为 TRUE，则**仅**搜索静态库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:270
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:216
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:272
msgid "If set to FALSE, search **only** for shared libraries."
msgstr "如果设置为 FALSE，则**仅**搜索共享库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:274
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:220
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:276
msgid ""
"This hint will be ignored on ``Windows`` because static libraries are not "
"available on this platform."
msgstr "此提示将在 ``Windows`` 上被忽略，因为静态库在此平台上不可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:322
msgid "``Python_FIND_ABI``"
msgstr "``Python_FIND_ABI``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:280
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:282
msgid ""
"This variable defines which ABIs, as defined in :pep:`3149`, should be "
"searched."
msgstr "此变量定义应搜索哪些 ABI，如 :pep:`3149` 中所定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:285
msgid ""
"This hint will be honored only when searched for ``Python`` version 3."
msgstr "只有在搜索 ``Python`` 版本 3 时才会接受此提示。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:289
msgid "If ``Python_FIND_ABI`` is not defined, any ABI will be searched."
msgstr "如果未定义 ``Python_FIND_ABI``，将搜索任何 ABI。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:291
msgid ""
"The ``Python_FIND_ABI`` variable is a 3-tuple specifying, in that order, "
"``pydebug`` (``d``), ``pymalloc`` (``m``) and ``unicode`` (``u``) flags. "
"Each element can be set to one of the following:"
msgstr ""
"``Python_FIND_ABI`` 变量是一个 3 元组，按顺序指定 ``pydebug`` (``d``)、``pymalloc`` "
"(``m``) 和 ``unicode`` ( ``u``) 标志。每个元素都可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:295
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:293
msgid "``ON``: Corresponding flag is selected."
msgstr "``ON``：选择相应的标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:296
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:294
msgid "``OFF``: Corresponding flag is not selected."
msgstr "``OFF``：未选择相应标志。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:297
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:295
msgid ""
"``ANY``: The two possibilities (``ON`` and ``OFF``) will be searched."
msgstr "``ANY``：将搜索两种可能性（``ON`` 和``OFF``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:299
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:297
msgid ""
"From this 3-tuple, various ABIs will be searched starting from the most "
"specialized to the most general. Moreover, ``debug`` versions will be "
"searched **after** ``non-debug`` ones."
msgstr "从这个 3 元组开始，将搜索各种 ABI，从最专业到最通用。此外，“调试”版本将在**“非调试”版本之后搜索。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:303
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:301
msgid "For example, if we have::"
msgstr "例如，如果我们有："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:307
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:305
msgid ""
"The following flags combinations will be appended, in that order, to the "
"artifact names: ``dmu``, ``dm``, ``du``, and ``d``."
msgstr "以下标志组合将按顺序附加到工件名称：``dmu``、``dm``、``du`` 和 ``d``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:310
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:308
msgid "And to search any possible ABIs::"
msgstr "并搜索任何可能的 ABI::"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:314
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:312
msgid ""
"The following combinations, in that order, will be used: ``mu``, ``m``, "
"``u``, ``<empty>``, ``dmu``, ``dm``, ``du`` and ``d``."
msgstr ""
"以下组合将按顺序使用：``mu``、``m``、``u``、``<empty>``、``dmu``、``dm``、 ``du`` 和 ``d``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:319
msgid ""
"This hint is useful only on ``POSIX`` systems. So, on ``Windows`` systems,"
" when ``Python_FIND_ABI`` is defined, ``Python`` distributions from "
"`python.org <https://www.python.org/>`_ will be found only if value for "
"each flag is ``OFF`` or ``ANY``."
msgstr ""
"此提示仅在 ``POSIX`` 系统上有用。因此，在 ``Windows`` 系统上，当定义 ``Python_FIND_ABI`` "
"时，只有当值每个标志都是 ``OFF`` 或 ``ANY``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:336
msgid "``Python_FIND_STRATEGY``"
msgstr "``Python_FIND_STRATEGY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:327
msgid ""
"This variable defines how lookup will be done. The "
"``Python_FIND_STRATEGY`` variable can be set to one of the following:"
msgstr "此变量定义如何完成查找。 ``Python_FIND_STRATEGY`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:330
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:229
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:328
msgid ""
"``VERSION``: Try to find the most recent version in all specified "
"locations. This is the default if policy :policy:`CMP0094` is undefined or"
" set to ``OLD``."
msgstr "``VERSION``：尝试在所有指定位置找到最新版本。如果策略 CMP0094 未定义或设置为“旧”，则这是默认设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:334
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:233
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:332
msgid ""
"``LOCATION``: Stops lookup as soon as a version satisfying version "
"constraints is founded. This is the default if policy :policy:`CMP0094` is"
" set to ``NEW``."
msgstr "``LOCATION``：一旦找到满足版本约束的版本就停止查找。如果策略 CMP0094 设置为 NEW，则这是默认设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:348
msgid "``Python_FIND_REGISTRY``"
msgstr "``Python_FIND_REGISTRY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:341
msgid ""
"On Windows the ``Python_FIND_REGISTRY`` variable determine the order of "
"preference between registry and environment variables. the "
"``Python_FIND_REGISTRY`` variable can be set to one of the following:"
msgstr ""
"在 Windows 上，``Python_FIND_REGISTRY`` 变量确定注册表和环境变量之间的优先顺序。 "
"``Python_FIND_REGISTRY`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:345
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:244
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:343
msgid ""
"``FIRST``: Try to use registry before environment variables. This is the "
"default."
msgstr "``FIRST``：尝试在环境变量之前使用注册表。这是默认设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:347
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:246
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:345
msgid "``LAST``: Try to use registry after environment variables."
msgstr "``LAST``：尝试在环境变量之后使用注册表。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:348
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:247
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:346
msgid "``NEVER``: Never try to use registry."
msgstr "``从不``：永远不要尝试使用注册表。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:363
msgid "``Python_FIND_FRAMEWORK``"
msgstr "``Python_FIND_FRAMEWORK``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:353
msgid ""
"On macOS the ``Python_FIND_FRAMEWORK`` variable determine the order of "
"preference between Apple-style and unix-style package components. This "
"variable can take same values as :variable:`CMAKE_FIND_FRAMEWORK` "
"variable."
msgstr ""
"在 macOS 上，``Python_FIND_FRAMEWORK`` 变量确定 Apple 风格和 unix "
"风格的包组件之间的优先顺序。此变量可以采用与 CMAKE_FIND_FRAMEWORK 变量相同的值。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:360
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:259
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:358
msgid "Value ``ONLY`` is not supported so ``FIRST`` will be used instead."
msgstr "不支持值“ONLY”，因此将使用“FIRST”代替。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:362
msgid ""
"If ``Python_FIND_FRAMEWORK`` is not defined, "
":variable:`CMAKE_FIND_FRAMEWORK` variable will be used, if any."
msgstr ""
"如果未定义 ``Python_FIND_FRAMEWORK``，则将使用 :variable:`CMAKE_FIND_FRAMEWORK` 变量（如果有）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:393
msgid "``Python_FIND_VIRTUALENV``"
msgstr "``Python_FIND_VIRTUALENV``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:368
msgid ""
"This variable defines the handling of virtual environments managed by "
"``virtualenv`` or ``conda``. It is meaningful only when a virtual "
"environment is active (i.e. the ``activate`` script has been evaluated). "
"In this case, it takes precedence over ``Python_FIND_REGISTRY`` and "
"``CMAKE_FIND_FRAMEWORK`` variables.  The ``Python_FIND_VIRTUALENV`` "
"variable can be set to one of the following:"
msgstr ""
"这个变量定义了由 ``virtualenv`` 或 ``conda`` "
"管理的虚拟环境的处理。它只有在虚拟环境处于活动状态时才有意义（即“activate”脚本已被评估）。在这种情况下，它优先于 "
"``Python_FIND_REGISTRY`` 和 ``CMAKE_FIND_FRAMEWORK`` 变量。 "
"``Python_FIND_VIRTUALENV`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:375
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:274
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:373
#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:82
msgid ""
"``FIRST``: The virtual environment is used before any other standard paths"
" to look-up for the interpreter. This is the default."
msgstr "``FIRST``：在任何其他标准路径之前使用虚拟环境来查找解释器。这是默认设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:377
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:276
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:375
#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:84
msgid ""
"``ONLY``: Only the virtual environment is used to look-up for the "
"interpreter."
msgstr "``ONLY``：只有虚拟环境用于查找解释器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:379
msgid ""
"``STANDARD``: The virtual environment is not used to look-up for the "
"interpreter but environment variable ``PATH`` is always considered. In "
"this case, variable ``Python_FIND_REGISTRY`` (Windows) or "
"``CMAKE_FIND_FRAMEWORK`` (macOS) can be set with value ``LAST`` or "
"``NEVER`` to select preferably the interpreter from the virtual "
"environment."
msgstr ""
"``STANDARD``：虚拟环境不用于查找解释器，但始终考虑环境变量``PATH``。在这种情况下，变量``Python_FIND_REGISTRY``（Windows）或``CMAKE_FIND_FRAMEWORK``（macOS）可以设置为``LAST``或``NEVER``的值，以从虚拟环境中优先选择解释器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:386
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:285
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:384
msgid "Added support for ``conda`` environments."
msgstr "添加了对“conda”环境的支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:391
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:290
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:389
msgid ""
"If the component ``Development`` is requested, it is **strongly** "
"recommended to also include the component ``Interpreter`` to get expected "
"result."
msgstr "如果请求组件``Development``，**强烈**建议还包含组件``Interpreter``以获得预期结果。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:428
msgid "``Python_FIND_IMPLEMENTATIONS``"
msgstr "``Python_FIND_IMPLEMENTATIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:398
msgid ""
"This variable defines, in an ordered list, the different implementations "
"which will be searched. The ``Python_FIND_IMPLEMENTATIONS`` variable can "
"hold the following values:"
msgstr "此变量在有序列表中定义将要搜索的不同实现。 ``Python_FIND_IMPLEMENTATIONS`` 变量可以包含以下值："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:402
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:301
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:400
msgid ""
"``CPython``: this is the standard implementation. Various products, like "
"``Anaconda`` or ``ActivePython``, rely on this implementation."
msgstr "``CPython``：这是标准实现。各种产品，如“Anaconda”或“ActivePython”，都依赖于此实现。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:404
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:303
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:402
msgid ""
"``IronPython``: This implementation use the ``CSharp`` language for ``.NET"
" Framework`` on top of the `Dynamic Language Runtime` (``DLR``). See "
"`IronPython <https://ironpython.net>`_."
msgstr ""
"``IronPython``：此实现在`动态语言运行时`（``DLR``）之上使用``CSharp``语言用于``.NET "
"Framework``。请参阅`IronPython <https://ironpython.net>`_。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:407
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:306
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:405
msgid ""
"``PyPy``: This implementation use ``RPython`` language and ``RPython "
"translation toolchain`` to produce the python interpreter. See `PyPy "
"<https://www.pypy.org>`_."
msgstr ""
"``PyPy``：此实现使用``RPython`` 语言和``RPython 翻译工具链`` 来生成 python 解释器。请参阅`PyPy "
"<https://www.pypy.org>`_。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:411
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:310
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:409
msgid "The default value is:"
msgstr "默认值为："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:413
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:312
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:411
msgid "Windows platform: ``CPython``, ``IronPython``"
msgstr "Windows 平台：``CPython``、``IronPython``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:414
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:313
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:412
msgid "Other platforms: ``CPython``"
msgstr "其他平台：``CPython``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:418
msgid ""
"This hint has the lowest priority of all hints, so even if, for example, "
"you specify ``IronPython`` first and ``CPython`` in second, a python "
"product based on ``CPython`` can be selected because, for example with "
"``Python_FIND_STRATEGY=LOCATION``, each location will be search first for "
"``IronPython`` and second for ``CPython``."
msgstr ""
"此提示在所有提示中具有最低的优先级，因此，例如，即使您首先指定“IronPython”，然后再指定“CPython”，也可以选择基于“CPython”的"
" Python "
"产品，因为，对于以``Python_FIND_STRATEGY=LOCATION``为例，每个位置将首先搜索``IronPython``，然后搜索``CPython``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:426
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:325
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:424
msgid ""
"When ``IronPython`` is specified, on platforms other than ``Windows``, the"
" ``.Net`` interpreter (i.e. ``mono`` command) is expected to be available "
"through the ``PATH`` variable."
msgstr ""
"当指定 ``IronPython`` 时，在 ``Windows`` 以外的平台上，``.Net`` 解释器（即 ``mono`` 命令）应该通过 "
"``PATH`` 变量可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:443
msgid "``Python_FIND_UNVERSIONED_NAMES``"
msgstr "``Python_FIND_UNVERSIONED_NAMES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:433
msgid ""
"This variable defines how the generic names will be searched. Currently, "
"it only applies to the generic names of the interpreter, namely, "
"``python3`` or ``python2`` and ``python``. The "
"``Python_FIND_UNVERSIONED_NAMES`` variable can be set to one of the "
"following values:"
msgstr ""
"此变量定义如何搜索通用名称。目前，它仅适用于解释器的通用名称，即 ``python3`` 或 ``python2`` 和 ``python``。 "
"``Python_FIND_UNVERSIONED_NAMES`` 变量可以设置为以下值之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:439
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:338
msgid ""
"``FIRST``: The generic names are searched before the more specialized ones"
" (such as ``python2.5`` for example)."
msgstr "``FIRST``：在更专业的名称之前搜索通用名称（例如``python2.5``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:441
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:340
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:439
msgid ""
"``LAST``: The generic names are searched after the more specialized ones. "
"This is the default."
msgstr "``LAST``：在更专业的名称之后搜索通用名称。这是默认设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:443
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:342
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:441
msgid "``NEVER``: The generic name are not searched at all."
msgstr "``NEVER``：根本不搜索通用名称。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:446
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:345
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:444
msgid "Artifacts Specification"
msgstr "工件规格"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:450
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:349
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:448
msgid ""
"To solve special cases, it is possible to specify directly the artifacts "
"by setting the following variables:"
msgstr "为了解决特殊情况，可以通过设置以下变量直接指定工件："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:454
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:353
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:452
msgid "The path to the interpreter."
msgstr "解释器的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:457
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:356
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:455
msgid "The path to the compiler."
msgstr "编译器的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:467
msgid "``Python_LIBRARY``"
msgstr "``Python_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:465
msgid ""
"The path to the library. It will be used to compute the variables "
"``Python_LIBRARIES``, ``Python_LIBRARY_DIRS`` and "
"``Python_RUNTIME_LIBRARY_DIRS``."
msgstr ""
"图书馆的路径。它将用于计算变量“Python_LIBRARIES”、“Python_LIBRARY_DIRS”和“Python_RUNTIME_LIBRARY_DIRS”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:474
msgid "``Python_SABI_LIBRARY``"
msgstr "``Python_SABI_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:472
msgid ""
"The path to the library for Stable Application Binary Interface. It will "
"be used to compute the variables ``Python_SABI_LIBRARIES``, "
"``Python_SABI_LIBRARY_DIRS`` and ``Python_RUNTIME_SABI_LIBRARY_DIRS``."
msgstr ""
"稳定应用程序二进制接口库的路径。它将用于计算变量“Python_SABI_LIBRARIES”、“Python_SABI_LIBRARY_DIRS”和“Python_RUNTIME_SABI_LIBRARY_DIRS”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:478
msgid "``Python_INCLUDE_DIR``"
msgstr "``Python_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:477
msgid ""
"The path to the directory of the ``Python`` headers. It will be used to "
"compute the variable ``Python_INCLUDE_DIRS``."
msgstr "``Python`` 标头目录的路径。它将用于计算变量 ``Python_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:482
msgid "``Python_NumPy_INCLUDE_DIR``"
msgstr "``Python_NumPy_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:481
msgid ""
"The path to the directory of the ``NumPy`` headers. It will be used to "
"compute the variable ``Python_NumPy_INCLUDE_DIRS``."
msgstr "``NumPy`` 标头目录的路径。它将用于计算变量 ``Python_NumPy_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:486
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:378
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:484
msgid ""
"All paths must be absolute. Any artifact specified with a relative path "
"will be ignored."
msgstr "所有路径都必须是绝对路径。将忽略使用相对路径指定的任何工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:491
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:383
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:489
msgid ""
"When an artifact is specified, all ``HINTS`` will be ignored and no search"
" will be performed for this artifact."
msgstr "指定工件时，将忽略所有“提示”，并且不会对该工件执行任何搜索。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:494
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:386
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:492
msgid ""
"If more than one artifact is specified, it is the user's responsibility to"
" ensure the consistency of the various artifacts."
msgstr "如果指定了多个工件，则用户有责任确保各种工件的一致性。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:497
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:389
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:495
msgid ""
"By default, this module supports multiple calls in different directories "
"of a project with different version/component requirements while providing"
" correct and consistent results for each call. To support this behavior, "
"CMake cache is not used in the traditional way which can be problematic "
"for interactive specification. So, to enable also interactive "
"specification, module behavior can be controlled with the following "
"variable:"
msgstr ""
"默认情况下，此模块支持在具有不同版本/组件要求的项目的不同目录中进行多次调用，同时为每次调用提供正确且一致的结果。为了支持这种行为，CMake "
"缓存没有以传统方式使用，这对于交互式规范来说可能是有问题的。因此，为了启用交互式规范，可以使用以下变量控制模块行为："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:513
msgid "``Python_ARTIFACTS_INTERACTIVE``"
msgstr "``Python_ARTIFACTS_INTERACTIVE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:507
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:399
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:505
msgid "Selects the behavior of the module. This is a boolean variable:"
msgstr "选择模块的行为。这是一个布尔变量："

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:509
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:401
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:507
msgid ""
"If set to ``TRUE``: Create CMake cache entries for the above artifact "
"specification variables so that users can edit them interactively. This "
"disables support for multiple version/component requirements."
msgstr "如果设置为“TRUE”：为上述工件规范变量创建 CMake 缓存条目，以便用户可以交互式编辑它们。这将禁用对多个版本/组件要求的支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:512
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:404
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:510
msgid ""
"If set to ``FALSE`` or undefined: Enable multiple version/component "
"requirements."
msgstr "如果设置为“FALSE”或未定义：启用多个版本/组件要求。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:518
msgid ""
"This module defines the command ``Python_add_library`` (when "
":prop_gbl:`CMAKE_ROLE` is ``PROJECT``), which has the same semantics as "
":command:`add_library` and adds a dependency to target ``Python::Python`` "
"or, when library type is ``MODULE``, to target ``Python::Module`` or "
"``Python::SABIModule`` (when ``USE_SABI`` option is specified) and takes "
"care of Python module naming rules::"
msgstr ""
"此模块定义命令 ``Python_add_library``（当 :prop_gbl:`CMAKE_ROLE` 为 ``PROJECT`` "
"时），它与 :command:`add_library` 具有相同的语义，并添加对目标 ``Python::Python 的依赖`` "
"或者，当库类型为 ``MODULE`` 时，以 ``Python::Module`` 或 ``Python::SABIModule`` "
"为目标（当指定了 ``USE_SABI`` 选项时）并处理 Python 模块命名规则 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:528
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:526
msgid "If the library type is not specified, ``MODULE`` is assumed."
msgstr "如果未指定库类型，则假定为“MODULE”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:530
msgid ""
"For ``MODULE`` library type, if option ``WITH_SOABI`` is specified, the "
"module suffix will include the ``Python_SOABI`` value, if any."
msgstr ""
"对于 ``MODULE`` 库类型，如果指定选项 ``WITH_SOABI``，则模块后缀将包含 ``Python_SOABI`` 值（如果有）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:534
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:532
msgid ""
"For ``MODULE`` type, if the option ``USE_SABI`` is specified, the "
"preprocessor definition ``Py_LIMITED_API`` will be specified, as "
"``PRIVATE``, for the target ``<name>`` with the value computed from "
"``<version>`` argument. The expected format for ``<version>`` is "
"``major[.minor]``, where each component is a numeric value. If ``minor`` "
"component is specified, the version should be, at least, ``3.2`` which is "
"the version where the `Stable Application Binary Interface "
"<https://docs.python.org/3/c-api/stable.html>`_ was introduced. Specifying"
" only major version ``3`` is equivalent to ``3.2``."
msgstr ""
"对于 ``MODULE`` 类型，如果指定选项 ``USE_SABI``，预处理器定义 ``Py_LIMITED_API`` 将被指定为 "
"``PRIVATE``，用于目标 ``<name>``从 ``<version>`` 参数计算的值。 ``<version>`` 的预期格式是 "
"``major[.minor]``，其中每个组件都是一个数值。如果指定了 ``minor`` 组件，则版本至少应为 ``3.2``，这是 "
"`Stable Application Binary Interface <https://docs.python.org/3/c-api "
"/stable.html>`_ 被引入。仅指定主要版本 ``3`` 等同于 ``3.2``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython.cmake:544
msgid ""
"When option ``WITH_SOABI`` is also specified,  the module suffix will "
"include the ``Python_SOSABI`` value, if any."
msgstr "当还指定选项 WITH_SOABI 时，模块后缀将包括 Python_SOSABI 值（如果有）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:6
msgid "FindPython2"
msgstr "查找Python2"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:10
msgid ""
"Find Python 2 interpreter, compiler and development environment (include "
"directories and libraries)."
msgstr "查找 Python 2 解释器、编译器和开发环境（包括目录和库）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:20
msgid "``Interpreter``: search for Python 2 interpreter"
msgstr "``Interpreter``：搜索 Python 2 解释器"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:21
msgid ""
"``Compiler``: search for Python 2 compiler. Only offered by IronPython."
msgstr "``Compiler``：搜索 Python 2 编译器。仅由 IronPython 提供。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:29
msgid ""
"``Development.Module``: search for artifacts for Python 2 module "
"developments."
msgstr "``Development.Module``：搜索用于 Python 2 模块开发的工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:31
msgid ""
"``Development.Embed``: search for artifacts for Python 2 embedding "
"developments."
msgstr "``Development.Embed``：搜索用于 Python 2 嵌入开发的工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:50
msgid ""
"This module looks only for version 2 of Python. This module can be used "
"concurrently with :module:`FindPython3` module to use both Python "
"versions."
msgstr "此模块仅查找 Python 版本 2。该模块可以与 FindPython3 模块同时使用，以使用两个 Python 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:60
msgid ""
"The :module:`FindPython` module can be used if Python version does not "
"matter for you."
msgstr "如果 Python 版本对你来说无关紧要，可以使用 FindPython 模块。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:73
msgid "``Python2::Interpreter``"
msgstr "``Python2::解释器``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:74
msgid ""
"Python 2 interpreter. Target defined if component ``Interpreter`` is "
"found."
msgstr "Python 2 解释器。如果找到组件“解释器”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:75
msgid "``Python2::Compiler``"
msgstr "``Python2::编译器``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:76
msgid ""
"Python 2 compiler. Target defined if component ``Compiler`` is found."
msgstr "Python 2 编译器。如果找到组件“Compiler”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:81
msgid "``Python2::Module``"
msgstr "``Python2::模块``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:80
msgid ""
"Python 2 library for Python module. Target defined if component "
"``Development.Module`` is found."
msgstr "Python 模块的 Python 2 库。如果找到组件“Development.Module”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:85
msgid "``Python2::Python``"
msgstr "``Python2::Python``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:84
msgid ""
"Python 2 library for Python embedding. Target defined if component "
"``Development.Embed`` is found."
msgstr "用于 Python 嵌入的 Python 2 库。如果找到组件“Development.Embed”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:90
msgid "``Python2::NumPy``"
msgstr "``Python2::NumPy``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:90
msgid ""
"NumPy library for Python 2. Target defined if component ``NumPy`` is "
"found."
msgstr "Python 2 的 NumPy 库。如果找到组件“NumPy”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:98
msgid "``Python2_FOUND``"
msgstr "``Python2_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:99
msgid "System has the Python 2 requested components."
msgstr "系统具有 Python 2 请求的组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:100
msgid "``Python2_Interpreter_FOUND``"
msgstr "``Python2_Interpreter_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:101
msgid "System has the Python 2 interpreter."
msgstr "系统有 Python 2 解释器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:102
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:353
msgid "``Python2_EXECUTABLE``"
msgstr "``Python2_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:103
msgid "Path to the Python 2 interpreter."
msgstr "Python 2 解释器的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:110
msgid "``Python2_INTERPRETER_ID``"
msgstr "``Python2_INTERPRETER_ID``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:116
msgid "``Python2_STDLIB``"
msgstr "``Python2_STDLIB``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:122
msgid "``Python2_STDARCH``"
msgstr "``Python2_STDARCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:128
msgid "``Python2_SITELIB``"
msgstr "``Python2_SITELIB``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:134
msgid "``Python2_SITEARCH``"
msgstr "``Python2_SITEARCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:136
msgid "``Python2_Compiler_FOUND``"
msgstr "``Python2_Compiler_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:137
msgid "System has the Python 2 compiler."
msgstr "系统有 Python 2 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:138
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:356
msgid "``Python2_COMPILER``"
msgstr "``Python2_COMPILER``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:139
msgid "Path to the Python 2 compiler. Only offered by IronPython."
msgstr "Python 2 编译器的路径。仅由 IronPython 提供。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:142
msgid "``Python2_COMPILER_ID``"
msgstr "``Python2_COMPILER_ID``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:147
#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:361
msgid "``Python2_DOTNET_LAUNCHER``"
msgstr "``Python2_DOTNET_LAUNCHER``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:150
msgid "``Python2_Development_FOUND``"
msgstr "``Python2_Development_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:150
msgid "System has the Python 2 development artifacts."
msgstr "系统具有 Python 2 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:155
msgid "``Python2_Development.Module_FOUND``"
msgstr "``Python2_Development.Module_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:155
msgid "System has the Python 2 development artifacts for Python module."
msgstr "系统具有 Python 模块的 Python 2 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:160
msgid "``Python2_Development.Embed_FOUND``"
msgstr "``Python2_Development.Embed_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:160
msgid "System has the Python 2 development artifacts for Python embedding."
msgstr "系统具有用于 Python 嵌入的 Python 2 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:163
msgid "``Python2_INCLUDE_DIRS``"
msgstr "``Python2_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:163
msgid "The Python 2 include directories."
msgstr "Python 2 包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:169
msgid "``Python2_LINK_OPTIONS``"
msgstr "``Python2_LINK_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:168
msgid ""
"The Python 2 link options. Some configurations require specific link "
"options for a correct build and execution."
msgstr "Python 2 链接选项。某些配置需要特定的链接选项才能正确构建和执行。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:171
msgid "``Python2_LIBRARIES``"
msgstr "``Python2_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:172
msgid "The Python 2 libraries."
msgstr "Python 2 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:173
msgid "``Python2_LIBRARY_DIRS``"
msgstr "``Python2_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:174
msgid "The Python 2 library directories."
msgstr "Python 2 库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:175
msgid "``Python2_RUNTIME_LIBRARY_DIRS``"
msgstr "``Python2_RUNTIME_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:176
msgid "The Python 2 runtime library directories."
msgstr "Python 2 运行时库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:177
msgid "``Python2_VERSION``"
msgstr "``Python2_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:178
msgid "Python 2 version."
msgstr "Python 2 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:179
msgid "``Python2_VERSION_MAJOR``"
msgstr "``Python2_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:180
msgid "Python 2 major version."
msgstr "Python 2 主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:181
msgid "``Python2_VERSION_MINOR``"
msgstr "``Python2_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:182
msgid "Python 2 minor version."
msgstr "Python 2 次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:184
msgid "``Python2_VERSION_PATCH``"
msgstr "``Python2_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:184
msgid "Python 2 patch version."
msgstr "Python 2 补丁版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:189
msgid "``Python2_PyPy_VERSION``"
msgstr "``Python2_PyPy_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:189
msgid "Python 2 PyPy version."
msgstr "Python 2 PyPy 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:194
msgid "``Python2_NumPy_FOUND``"
msgstr "``Python2_NumPy_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:199
msgid "``Python2_NumPy_INCLUDE_DIRS``"
msgstr "``Python2_NumPy_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:204
msgid "``Python2_NumPy_VERSION``"
msgstr "``Python2_NumPy_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:210
msgid "``Python2_ROOT_DIR``"
msgstr "``Python2_ROOT_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:210
msgid "Define the root directory of a Python 2 installation."
msgstr "定义 Python 2 安装的根目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:221
msgid "``Python2_USE_STATIC_LIBS``"
msgstr "``Python2_USE_STATIC_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:235
msgid "``Python2_FIND_STRATEGY``"
msgstr "``Python2_FIND_STRATEGY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:226
msgid ""
"This variable defines how lookup will be done. The "
"``Python2_FIND_STRATEGY`` variable can be set to one of the following:"
msgstr "此变量定义如何完成查找。 ``Python2_FIND_STRATEGY`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:247
msgid "``Python2_FIND_REGISTRY``"
msgstr "``Python2_FIND_REGISTRY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:240
msgid ""
"On Windows the ``Python2_FIND_REGISTRY`` variable determine the order of "
"preference between registry and environment variables. the "
"``Python2_FIND_REGISTRY`` variable can be set to one of the following:"
msgstr ""
"在 Windows 上，``Python2_FIND_REGISTRY`` 变量确定注册表和环境变量之间的优先顺序。 "
"``Python2_FIND_REGISTRY`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:262
msgid "``Python2_FIND_FRAMEWORK``"
msgstr "``Python2_FIND_FRAMEWORK``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:252
msgid ""
"On macOS the ``Python2_FIND_FRAMEWORK`` variable determine the order of "
"preference between Apple-style and unix-style package components. This "
"variable can take same values as :variable:`CMAKE_FIND_FRAMEWORK` "
"variable."
msgstr ""
"在 macOS 上，``Python2_FIND_FRAMEWORK`` 变量确定 Apple 风格和 unix "
"风格的包组件之间的优先顺序。此变量可以采用与 CMAKE_FIND_FRAMEWORK 变量相同的值。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:261
msgid ""
"If ``Python2_FIND_FRAMEWORK`` is not defined, "
":variable:`CMAKE_FIND_FRAMEWORK` variable will be used, if any."
msgstr ""
"如果未定义 ``Python2_FIND_FRAMEWORK``，则将使用 :variable:`CMAKE_FIND_FRAMEWORK` 变量（如果有）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:292
msgid "``Python2_FIND_VIRTUALENV``"
msgstr "``Python2_FIND_VIRTUALENV``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:267
msgid ""
"This variable defines the handling of virtual environments managed by "
"``virtualenv`` or ``conda``. It is meaningful only when a virtual "
"environment is active (i.e. the ``activate`` script has been evaluated). "
"In this case, it takes precedence over ``Python2_FIND_REGISTRY`` and "
"``CMAKE_FIND_FRAMEWORK`` variables.  The ``Python2_FIND_VIRTUALENV`` "
"variable can be set to one of the following:"
msgstr ""
"这个变量定义了由 ``virtualenv`` 或 ``conda`` "
"管理的虚拟环境的处理。它只有在虚拟环境处于活动状态时才有意义（即“activate”脚本已被评估）。在这种情况下，它优先于 "
"``Python2_FIND_REGISTRY`` 和 ``CMAKE_FIND_FRAMEWORK`` 变量。 "
"``Python2_FIND_VIRTUALENV`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:278
msgid ""
"``STANDARD``: The virtual environment is not used to look-up for the "
"interpreter but environment variable ``PATH`` is always considered. In "
"this case, variable ``Python2_FIND_REGISTRY`` (Windows) or "
"``CMAKE_FIND_FRAMEWORK`` (macOS) can be set with value ``LAST`` or "
"``NEVER`` to select preferably the interpreter from the virtual "
"environment."
msgstr ""
"``STANDARD``：虚拟环境不用于查找解释器，但始终考虑环境变量``PATH``。在这种情况下，变量``Python2_FIND_REGISTRY``（Windows）或``CMAKE_FIND_FRAMEWORK``（macOS）可以设置为``LAST``或``NEVER``的值，以从虚拟环境中优先选择解释器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:327
msgid "``Python2_FIND_IMPLEMENTATIONS``"
msgstr "``Python2_FIND_IMPLEMENTATIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:297
msgid ""
"This variable defines, in an ordered list, the different implementations "
"which will be searched. The ``Python2_FIND_IMPLEMENTATIONS`` variable can "
"hold the following values:"
msgstr "此变量在有序列表中定义将要搜索的不同实现。 ``Python2_FIND_IMPLEMENTATIONS`` 变量可以包含以下值："

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:317
msgid ""
"This hint has the lowest priority of all hints, so even if, for example, "
"you specify ``IronPython`` first and ``CPython`` in second, a python "
"product based on ``CPython`` can be selected because, for example with "
"``Python2_FIND_STRATEGY=LOCATION``, each location will be search first for"
" ``IronPython`` and second for ``CPython``."
msgstr ""
"此提示在所有提示中具有最低的优先级，因此，例如，即使您首先指定“IronPython”，然后再指定“CPython”，也可以选择基于“CPython”的"
" Python "
"产品，因为，对于以``Python2_FIND_STRATEGY=LOCATION``为例，每个位置将首先搜索``IronPython``，然后搜索``CPython``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:342
msgid "``Python2_FIND_UNVERSIONED_NAMES``"
msgstr "``Python2_FIND_UNVERSIONED_NAMES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:332
msgid ""
"This variable defines how the generic names will be searched. Currently, "
"it only applies to the generic names of the interpreter, namely, "
"``python2`` and ``python``. The ``Python2_FIND_UNVERSIONED_NAMES`` "
"variable can be set to one of the following values:"
msgstr ""
"此变量定义如何搜索通用名称。目前，它仅适用于解释器的通用名称，即 ``python2`` 和 ``python``。 "
"``Python2_FIND_UNVERSIONED_NAMES`` 变量可以设置为以下值之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:366
msgid "``Python2_LIBRARY``"
msgstr "``Python2_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:364
msgid ""
"The path to the library. It will be used to compute the variables "
"``Python2_LIBRARIES``, ``Python2_LIBRARY_DIRS`` and "
"``Python2_RUNTIME_LIBRARY_DIRS``."
msgstr ""
"图书馆的路径。它将用于计算变量“Python2_LIBRARIES”、“Python2_LIBRARY_DIRS”和“Python2_RUNTIME_LIBRARY_DIRS”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:370
msgid "``Python2_INCLUDE_DIR``"
msgstr "``Python2_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:369
msgid ""
"The path to the directory of the ``Python`` headers. It will be used to "
"compute the variable ``Python2_INCLUDE_DIRS``."
msgstr "``Python`` 标头目录的路径。它将用于计算变量 ``Python2_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:374
msgid "``Python2_NumPy_INCLUDE_DIR``"
msgstr "``Python2_NumPy_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:373
msgid ""
"The path to the directory of the ``NumPy`` headers. It will be used to "
"compute the variable ``Python2_NumPy_INCLUDE_DIRS``."
msgstr "``NumPy`` 标头目录的路径。它将用于计算变量 ``Python2_NumPy_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:405
msgid "``Python2_ARTIFACTS_INTERACTIVE``"
msgstr "``Python2_ARTIFACTS_INTERACTIVE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:410
msgid ""
"This module defines the command ``Python2_add_library`` (when "
":prop_gbl:`CMAKE_ROLE` is ``PROJECT``), which has the same semantics as "
":command:`add_library` and adds a dependency to target ``Python2::Python``"
" or, when library type is ``MODULE``, to target ``Python2::Module`` and "
"takes care of Python module naming rules::"
msgstr ""
"此模块定义命令 ``Python2_add_library``（当 :prop_gbl:`CMAKE_ROLE` 为 ``PROJECT`` "
"时），它具有与 :command:`add_library` 相同的语义，并添加对目标 ``Python2::Python 的依赖`` "
"或者，当库类型为 ``MODULE`` 时，以 ``Python2::Module`` 为目标并处理 Python 模块命名规则 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindPython2.cmake:419
msgid "If library type is not specified, ``MODULE`` is assumed."
msgstr "如果未指定库类型，则假定为“MODULE”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:6
msgid "FindPython3"
msgstr "查找Python3"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:10
msgid ""
"Find Python 3 interpreter, compiler and development environment (include "
"directories and libraries)."
msgstr "查找 Python 3 解释器、编译器和开发环境（包括目录和库）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:20
msgid "``Interpreter``: search for Python 3 interpreter"
msgstr "``Interpreter``：搜索 Python 3 解释器"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:21
msgid ""
"``Compiler``: search for Python 3 compiler. Only offered by IronPython."
msgstr "``Compiler``：搜索 Python 3 编译器。仅由 IronPython 提供。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:29
msgid ""
"``Development.Module``: search for artifacts for Python 3 module "
"developments."
msgstr "``Development.Module``：搜索用于 Python 3 模块开发的工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:31
msgid ""
"``Development.Embed``: search for artifacts for Python 3 embedding "
"developments."
msgstr "``Development.Embed``：搜索用于 Python 3 嵌入开发的工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:36
msgid ""
"``Development.SABIModule``: search for artifacts for Python 3 module "
"developments using the `Stable Application Binary Interface "
"<https://docs.python.org/3/c-api/stable.html>`_. This component is "
"available only for version ``3.2`` and upper."
msgstr ""
"``Development.SABIModule``：使用 `Stable Application Binary Interface "
"<https://docs.python.org/3/c-api/stable.html>`_ 搜索用于 Python 3 "
"模块开发的工件。此组件仅适用于版本 ``3.2`` 及更高版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:57
msgid ""
"This module looks only for version 3 of Python. This module can be used "
"concurrently with :module:`FindPython2` module to use both Python "
"versions."
msgstr "此模块仅查找 Python 版本 3。该模块可以与 FindPython2 模块同时使用，以使用两个 Python 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:80
msgid "``Python3::Interpreter``"
msgstr "``Python3::解释器``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:81
msgid ""
"Python 3 interpreter. Target defined if component ``Interpreter`` is "
"found."
msgstr "Python 3 解释器。如果找到组件“解释器”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:83
msgid "``Python3::Compiler``"
msgstr "``Python3::编译器``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:83
msgid ""
"Python 3 compiler. Target defined if component ``Compiler`` is found."
msgstr "Python 3 编译器。如果找到组件“Compiler”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:89
msgid "``Python3::Module``"
msgstr "``Python3::模块``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:88
msgid ""
"Python 3 library for Python module. Target defined if component "
"``Development.Module`` is found."
msgstr "Python 模块的 Python 3 库。如果找到组件“Development.Module”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:95
msgid "``Python3::SABIModule``"
msgstr "``Python3::SABIModule``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:94
msgid ""
"Python 3 library for Python module using the Stable Application Binary "
"Interface. Target defined if component ``Development.SABIModule`` is "
"found."
msgstr ""
"使用稳定应用程序二进制接口的 Python 模块的 Python 3 库。如果找到组件“Development.SABIModule”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:99
msgid "``Python3::Python``"
msgstr "``Python3::Python``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:98
msgid ""
"Python 3 library for Python embedding. Target defined if component "
"``Development.Embed`` is found."
msgstr "用于 Python 嵌入的 Python 3 库。如果找到组件“Development.Embed”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:104
msgid "``Python3::NumPy``"
msgstr "``Python3::NumPy``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:104
msgid ""
"NumPy library for Python 3. Target defined if component ``NumPy`` is "
"found."
msgstr "Python 3 的 NumPy 库。如果找到组件“NumPy”，则定义目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:112
msgid "``Python3_FOUND``"
msgstr "``Python3_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:113
msgid "System has the Python 3 requested components."
msgstr "系统具有 Python 3 请求的组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:114
msgid "``Python3_Interpreter_FOUND``"
msgstr "``Python3_Interpreter_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:115
msgid "System has the Python 3 interpreter."
msgstr "系统有 Python 3 解释器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:116
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:452
msgid "``Python3_EXECUTABLE``"
msgstr "``Python3_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:117
msgid "Path to the Python 3 interpreter."
msgstr "Python 3 解释器的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:124
msgid "``Python3_INTERPRETER_ID``"
msgstr "``Python3_INTERPRETER_ID``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:130
msgid "``Python3_STDLIB``"
msgstr "``Python3_STDLIB``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:136
msgid "``Python3_STDARCH``"
msgstr "``Python3_STDARCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:142
msgid "``Python3_SITELIB``"
msgstr "``Python3_SITELIB``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:149
msgid "``Python3_SITEARCH``"
msgstr "``Python3_SITEARCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:160
msgid "``Python3_SOABI``"
msgstr "``Python3_SOABI``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:170
msgid "``Python3_SOSABI``"
msgstr "``Python3_SOSABI``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:172
msgid "``Python3_Compiler_FOUND``"
msgstr "``Python3_Compiler_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:173
msgid "System has the Python 3 compiler."
msgstr "系统有 Python 3 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:174
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:455
msgid "``Python3_COMPILER``"
msgstr "``Python3_COMPILER``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:175
msgid "Path to the Python 3 compiler. Only offered by IronPython."
msgstr "Python 3 编译器的路径。仅由 IronPython 提供。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:178
msgid "``Python3_COMPILER_ID``"
msgstr "``Python3_COMPILER_ID``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:183
#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:460
msgid "``Python3_DOTNET_LAUNCHER``"
msgstr "``Python3_DOTNET_LAUNCHER``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:185
msgid "``Python3_Development_FOUND``"
msgstr "``Python3_Development_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:187
msgid "System has the Python 3 development artifacts."
msgstr "系统具有 Python 3 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:192
msgid "``Python3_Development.Module_FOUND``"
msgstr "``Python3_Development.Module_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:192
msgid "System has the Python 3 development artifacts for Python module."
msgstr "系统具有 Python 模块的 Python 3 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:198
msgid "``Python3_Development.SABIModule_FOUND``"
msgstr "``Python3_Development.SABIModule_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:197
msgid ""
"System has the Python 3 development artifacts for Python module using the "
"Stable Application Binary Interface."
msgstr "系统具有使用稳定应用程序二进制接口的 Python 模块的 Python 3 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:203
msgid "``Python3_Development.Embed_FOUND``"
msgstr "``Python3_Development.Embed_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:203
msgid "System has the Python 3 development artifacts for Python embedding."
msgstr "系统具有用于 Python 嵌入的 Python 3 开发工件。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:205
msgid "``Python3_INCLUDE_DIRS``"
msgstr "``Python3_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:207
msgid "The Python 3 include directories."
msgstr "Python 3 包含目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:213
msgid "``Python3_LINK_OPTIONS``"
msgstr "``Python3_LINK_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:212
msgid ""
"The Python 3 link options. Some configurations require specific link "
"options for a correct build and execution."
msgstr "Python 3 链接选项。某些配置需要特定的链接选项才能正确构建和执行。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:215
msgid "``Python3_LIBRARIES``"
msgstr "``Python3_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:216
msgid "The Python 3 libraries."
msgstr "Python 3 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:217
msgid "``Python3_LIBRARY_DIRS``"
msgstr "``Python3_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:218
msgid "The Python 3 library directories."
msgstr "Python 3 库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:219
msgid "``Python3_RUNTIME_LIBRARY_DIRS``"
msgstr "``Python3_RUNTIME_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:220
msgid "The Python 3 runtime library directories."
msgstr "Python 3 运行时库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:223
msgid "``Python3_SABI_LIBRARIES``"
msgstr "``Python3_SABI_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:224
msgid "The Python 3 libraries for the Stable Application Binary Interface."
msgstr "用于稳定应用程序二进制接口的 Python 3 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:227
msgid "``Python3_SABI_LIBRARY_DIRS``"
msgstr "``Python3_SABI_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:228
msgid "The Python 3 ``SABI`` library directories."
msgstr "Python 3 ``SABI`` 库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:231
msgid "``Python3_RUNTIME_SABI_LIBRARY_DIRS``"
msgstr "``Python3_RUNTIME_SABI_LIBRARY_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:232
msgid "The Python 3 runtime ``SABI`` library directories."
msgstr "Python 3 运行时 ``SABI`` 库目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:233
msgid "``Python3_VERSION``"
msgstr "``Python3_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:234
msgid "Python 3 version."
msgstr "Python 3 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:235
msgid "``Python3_VERSION_MAJOR``"
msgstr "``Python3_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:236
msgid "Python 3 major version."
msgstr "Python 3 主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:237
msgid "``Python3_VERSION_MINOR``"
msgstr "``Python3_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:238
msgid "Python 3 minor version."
msgstr "Python 3 次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:240
msgid "``Python3_VERSION_PATCH``"
msgstr "``Python3_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:240
msgid "Python 3 patch version."
msgstr "Python 3 补丁版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:245
msgid "``Python3_PyPy_VERSION``"
msgstr "``Python3_PyPy_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:245
msgid "Python 3 PyPy version."
msgstr "Python 3 PyPy 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:250
msgid "``Python3_NumPy_FOUND``"
msgstr "``Python3_NumPy_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:255
msgid "``Python3_NumPy_INCLUDE_DIRS``"
msgstr "``Python3_NumPy_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:260
msgid "``Python3_NumPy_VERSION``"
msgstr "``Python3_NumPy_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:266
msgid "``Python3_ROOT_DIR``"
msgstr "``Python3_ROOT_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:266
msgid "Define the root directory of a Python 3 installation."
msgstr "定义 Python 3 安装的根目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:277
msgid "``Python3_USE_STATIC_LIBS``"
msgstr "``Python3_USE_STATIC_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:320
msgid "``Python3_FIND_ABI``"
msgstr "``Python3_FIND_ABI``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:287
msgid "If ``Python3_FIND_ABI`` is not defined, any ABI will be searched."
msgstr "如果未定义 ``Python3_FIND_ABI``，将搜索任何 ABI。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:289
msgid ""
"The ``Python3_FIND_ABI`` variable is a 3-tuple specifying, in that order, "
"``pydebug`` (``d``), ``pymalloc`` (``m``) and ``unicode`` (``u``) flags. "
"Each element can be set to one of the following:"
msgstr ""
"``Python3_FIND_ABI`` 变量是一个三元组，按顺序指定 ``pydebug`` (``d``)、``pymalloc`` "
"(``m``) 和 ``unicode`` ( ``u``) 标志。每个元素都可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:317
msgid ""
"This hint is useful only on ``POSIX`` systems. So, on ``Windows`` systems,"
" when ``Python3_FIND_ABI`` is defined, ``Python`` distributions from "
"`python.org <https://www.python.org/>`_ will be found only if value for "
"each flag is ``OFF`` or ``ANY``."
msgstr ""
"此提示仅在 ``POSIX`` 系统上有用。因此，在 ``Windows`` 系统上，当定义 ``Python3_FIND_ABI`` "
"时，只有当值每个标志都是 ``OFF`` 或 ``ANY``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:334
msgid "``Python3_FIND_STRATEGY``"
msgstr "``Python3_FIND_STRATEGY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:325
msgid ""
"This variable defines how lookup will be done. The "
"``Python3_FIND_STRATEGY`` variable can be set to one of the following:"
msgstr "此变量定义如何完成查找。 ``Python3_FIND_STRATEGY`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:346
msgid "``Python3_FIND_REGISTRY``"
msgstr "``Python3_FIND_REGISTRY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:339
msgid ""
"On Windows the ``Python3_FIND_REGISTRY`` variable determine the order of "
"preference between registry and environment variables. The "
"``Python3_FIND_REGISTRY`` variable can be set to one of the following:"
msgstr ""
"在 Windows 上，``Python3_FIND_REGISTRY`` 变量确定注册表和环境变量之间的优先顺序。 "
"``Python3_FIND_REGISTRY`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:361
msgid "``Python3_FIND_FRAMEWORK``"
msgstr "``Python3_FIND_FRAMEWORK``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:351
msgid ""
"On macOS the ``Python3_FIND_FRAMEWORK`` variable determine the order of "
"preference between Apple-style and unix-style package components. This "
"variable can take same values as :variable:`CMAKE_FIND_FRAMEWORK` "
"variable."
msgstr ""
"在 macOS 上，``Python3_FIND_FRAMEWORK`` 变量确定 Apple 风格和 unix "
"风格的包组件之间的优先顺序。此变量可以采用与 CMAKE_FIND_FRAMEWORK 变量相同的值。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:360
msgid ""
"If ``Python3_FIND_FRAMEWORK`` is not defined, "
":variable:`CMAKE_FIND_FRAMEWORK` variable will be used, if any."
msgstr ""
"如果未定义 ``Python3_FIND_FRAMEWORK``，则将使用 :variable:`CMAKE_FIND_FRAMEWORK` 变量（如果有）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:391
msgid "``Python3_FIND_VIRTUALENV``"
msgstr "``Python3_FIND_VIRTUALENV``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:366
msgid ""
"This variable defines the handling of virtual environments managed by "
"``virtualenv`` or ``conda``. It is meaningful only when a virtual "
"environment is active (i.e. the ``activate`` script has been evaluated). "
"In this case, it takes precedence over ``Python3_FIND_REGISTRY`` and "
"``CMAKE_FIND_FRAMEWORK`` variables.  The ``Python3_FIND_VIRTUALENV`` "
"variable can be set to one of the following:"
msgstr ""
"这个变量定义了由 ``virtualenv`` 或 ``conda`` "
"管理的虚拟环境的处理。它只有在虚拟环境处于活动状态时才有意义（即“activate”脚本已被评估）。在这种情况下，它优先于 "
"``Python3_FIND_REGISTRY`` 和 ``CMAKE_FIND_FRAMEWORK`` 变量。 "
"``Python3_FIND_VIRTUALENV`` 变量可以设置为以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:377
msgid ""
"``STANDARD``: The virtual environment is not used to look-up for the "
"interpreter but environment variable ``PATH`` is always considered. In "
"this case, variable ``Python3_FIND_REGISTRY`` (Windows) or "
"``CMAKE_FIND_FRAMEWORK`` (macOS) can be set with value ``LAST`` or "
"``NEVER`` to select preferably the interpreter from the virtual "
"environment."
msgstr ""
"``STANDARD``：虚拟环境不用于查找解释器，但始终考虑环境变量``PATH``。在这种情况下，变量``Python3_FIND_REGISTRY``（Windows）或``CMAKE_FIND_FRAMEWORK``（macOS）可以设置为``LAST``或``NEVER``值，以从虚拟环境中优先选择解释器。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:426
msgid "``Python3_FIND_IMPLEMENTATIONS``"
msgstr "``Python3_FIND_IMPLEMENTATIONS``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:396
msgid ""
"This variable defines, in an ordered list, the different implementations "
"which will be searched. The ``Python3_FIND_IMPLEMENTATIONS`` variable can "
"hold the following values:"
msgstr "此变量在有序列表中定义将要搜索的不同实现。 ``Python3_FIND_IMPLEMENTATIONS`` 变量可以包含以下值："

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:416
msgid ""
"This hint has the lowest priority of all hints, so even if, for example, "
"you specify ``IronPython`` first and ``CPython`` in second, a python "
"product based on ``CPython`` can be selected because, for example with "
"``Python3_FIND_STRATEGY=LOCATION``, each location will be search first for"
" ``IronPython`` and second for ``CPython``."
msgstr ""
"此提示在所有提示中具有最低的优先级，因此，例如，即使您首先指定“IronPython”，然后再指定“CPython”，也可以选择基于“CPython”的"
" Python "
"产品，因为，对于以``Python3_FIND_STRATEGY=LOCATION``为例，每个位置将首先搜索``IronPython``，然后搜索``CPython``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:441
msgid "``Python3_FIND_UNVERSIONED_NAMES``"
msgstr "``Python3_FIND_UNVERSIONED_NAMES``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:431
msgid ""
"This variable defines how the generic names will be searched. Currently, "
"it only applies to the generic names of the interpreter, namely, "
"``python3`` and ``python``. The ``Python3_FIND_UNVERSIONED_NAMES`` "
"variable can be set to one of the following values:"
msgstr ""
"此变量定义如何搜索通用名称。目前，它仅适用于解释器的通用名称，即 ``python3`` 和 ``python``。 "
"``Python3_FIND_UNVERSIONED_NAMES`` 变量可以设置为以下值之一："

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:437
msgid ""
"``FIRST``: The generic names are searched before the more specialized ones"
" (such as ``python3.5`` for example)."
msgstr "``FIRST``：在更专业的名称之前搜索通用名称（例如``python3.5``）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:465
msgid "``Python3_LIBRARY``"
msgstr "``Python3_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:463
msgid ""
"The path to the library. It will be used to compute the variables "
"``Python3_LIBRARIES``, ``Python3_LIBRARY_DIRS`` and "
"``Python3_RUNTIME_LIBRARY_DIRS``."
msgstr ""
"图书馆的路径。它将用于计算变量“Python3_LIBRARIES”、“Python3_LIBRARY_DIRS”和“Python3_RUNTIME_LIBRARY_DIRS”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:472
msgid "``Python3_SABI_LIBRARY``"
msgstr "``Python3_SABI_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:470
msgid ""
"The path to the library for Stable Application Binary Interface. It will "
"be used to compute the variables ``Python3_SABI_LIBRARIES``, "
"``Python3_SABI_LIBRARY_DIRS`` and ``Python3_RUNTIME_SABI_LIBRARY_DIRS``."
msgstr ""
"稳定应用程序二进制接口库的路径。它将用于计算变量“Python3_SABI_LIBRARIES”、“Python3_SABI_LIBRARY_DIRS”和“Python3_RUNTIME_SABI_LIBRARY_DIRS”。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:476
msgid "``Python3_INCLUDE_DIR``"
msgstr "``Python3_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:475
msgid ""
"The path to the directory of the ``Python`` headers. It will be used to "
"compute the variable ``Python3_INCLUDE_DIRS``."
msgstr "``Python`` 标头目录的路径。它将用于计算变量 ``Python3_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:480
msgid "``Python3_NumPy_INCLUDE_DIR``"
msgstr "``Python3_NumPy_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:479
msgid ""
"The path to the directory of the ``NumPy`` headers. It will be used to "
"compute the variable ``Python3_NumPy_INCLUDE_DIRS``."
msgstr "``NumPy`` 标头目录的路径。它将用于计算变量 ``Python3_NumPy_INCLUDE_DIRS``。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:511
msgid "``Python3_ARTIFACTS_INTERACTIVE``"
msgstr "``Python3_ARTIFACTS_INTERACTIVE``"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:516
msgid ""
"This module defines the command ``Python3_add_library`` (when "
":prop_gbl:`CMAKE_ROLE` is ``PROJECT``), which has the same semantics as "
":command:`add_library` and adds a dependency to target ``Python3::Python``"
" or, when library type is ``MODULE``, to target ``Python3::Module`` or "
"``Python3::SABIModule`` (when ``USE_SABI`` option is specified) and takes "
"care of Python module naming rules::"
msgstr ""
"此模块定义命令 ``Python3_add_library``（当 :prop_gbl:`CMAKE_ROLE` 为 ``PROJECT`` "
"时），它与 :command:`add_library` 具有相同的语义，并添加对目标 ``Python3::Python 的依赖`` "
"或者，当库类型为 ``MODULE`` 时，目标为 ``Python3::Module`` 或 "
"``Python3::SABIModule``（当指定了 ``USE_SABI`` 选项时）并处理 Python 模块命名规则 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:528
msgid ""
"For ``MODULE`` library type, if option ``WITH_SOABI`` is specified, the "
"module suffix will include the ``Python3_SOABI`` value, if any."
msgstr ""
"对于 ``MODULE`` 库类型，如果指定选项 ``WITH_SOABI``，模块后缀将包括 ``Python3_SOABI`` 值（如果有）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPython3.cmake:542
msgid ""
"When option ``WITH_SOABI`` is also specified,  the module suffix will "
"include the ``Python3_SOSABI`` value, if any."
msgstr "当还指定选项 WITH_SOABI 时，模块后缀将包含 Python3_SOSABI 值（如果有）。"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonInterp.cmake:6
msgid "FindPythonInterp"
msgstr "查找PythonInterp"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonInterp.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindPythonLibs.cmake:10
msgid ""
"Use :module:`FindPython3`, :module:`FindPython2` or :module:`FindPython` "
"instead."
msgstr "请改用 FindPython3、FindPython2 或 FindPython。"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonInterp.cmake:12
msgid "Find python interpreter"
msgstr "查找 python 解释器"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonInterp.cmake:14
msgid ""
"This module finds if Python interpreter is installed and determines where "
"the executables are.  This code sets the following variables:"
msgstr "该模块查找是否安装了 Python 解释器并确定可执行文件的位置。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindPythonInterp.cmake:33
msgid ""
"The Python_ADDITIONAL_VERSIONS variable can be used to specify a list of "
"version numbers that should be taken into account when searching for "
"Python.  You need to set this variable before calling "
"find_package(PythonInterp)."
msgstr ""
"Python_ADDITIONAL_VERSIONS 变量可用于指定搜索 Python 时应考虑的版本号列表。您需要在调用 "
"find_package(PythonInterp) 之前设置此变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonInterp.cmake:38
#: ../../cmake-prefix/src/cmake/Modules/FindPythonLibs.cmake:42
msgid ""
"If calling both ``find_package(PythonInterp)`` and "
"``find_package(PythonLibs)``, call ``find_package(PythonInterp)`` first to"
" get the currently active Python version by default with a consistent "
"version of PYTHON_LIBRARIES."
msgstr ""
"如果同时调用 ``find_package(PythonInterp)`` 和 ``find_package(PythonLibs)``，请先调用 "
"``find_package(PythonInterp)`` 以获取当前活动的 Python 版本，默认情况下与 PYTHON_LIBRARIES "
"的版本一致。"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonInterp.cmake:45
msgid ""
"A call to ``find_package(PythonInterp ${V})`` for python version ``V`` may"
" find a ``python`` executable with no version suffix.  In this case no "
"attempt is made to avoid python executables from other versions. Use "
":module:`FindPython3`, :module:`FindPython2` or :module:`FindPython` "
"instead."
msgstr ""
"为 python 版本“V”调用“find_package(PythonInterp "
"${V})”可能会找到一个没有版本后缀的“python”可执行文件。在这种情况下，不会尝试避免来自其他版本的 python 可执行文件。请改用 "
"FindPython3、FindPython2 或 FindPython。"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonLibs.cmake:6
msgid "FindPythonLibs"
msgstr "查找Python库"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonLibs.cmake:12
msgid "Find python libraries"
msgstr "查找 python 库"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonLibs.cmake:14
msgid ""
"This module finds if Python is installed and determines where the include "
"files and libraries are.  It also determines what the name of the library "
"is.  This code sets the following variables:"
msgstr "该模块查找是否安装了 Python 并确定包含文件和库的位置。它还确定库的名称是什么。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindPythonLibs.cmake:29
msgid ""
"The Python_ADDITIONAL_VERSIONS variable can be used to specify a list of "
"version numbers that should be taken into account when searching for "
"Python.  You need to set this variable before calling "
"find_package(PythonLibs)."
msgstr ""
"Python_ADDITIONAL_VERSIONS 变量可用于指定搜索 Python 时应考虑的版本号列表。您需要在调用 "
"find_package(PythonLibs) 之前设置此变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindPythonLibs.cmake:34
msgid ""
"If you'd like to specify the installation of Python to use, you should "
"modify the following cache variables:"
msgstr "如果你想指定使用 Python 的安装，你应该修改以下缓存变量："

#: ../../cmake-prefix/src/cmake/Modules/FindQt.cmake:6
msgid "FindQt"
msgstr "查找Qt"

#: ../../cmake-prefix/src/cmake/Modules/FindQt.cmake:8
msgid ""
"This module is available only if policy :policy:`CMP0084` is not set to "
"``NEW``."
msgstr "此模块仅在政策:policy:`CMP0084` 未设置为``NEW`` 时可用。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt.cmake:11
msgid "Searches for all installed versions of Qt3 or Qt4."
msgstr "搜索所有已安装的 Qt3 或 Qt4 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt.cmake:13
msgid ""
"This module cannot handle Qt5 or any later versions. For those, see "
":manual:`cmake-qt(7)`."
msgstr "此模块无法处理 Qt5 或任何更高版本。对于那些，请参阅 :manual:`cmake-qt(7)`。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt.cmake:16
msgid ""
"This module should only be used if your project can work with multiple "
"versions of Qt.  If not, you should just directly use FindQt4 or FindQt3."
"  If multiple versions of Qt are found on the machine, then The user must "
"set the option DESIRED_QT_VERSION to the version they want to use.  If "
"only one version of qt is found on the machine, then the "
"DESIRED_QT_VERSION is set to that version and the matching FindQt3 or "
"FindQt4 module is included.  Once the user sets DESIRED_QT_VERSION, then "
"the FindQt3 or FindQt4 module is included."
msgstr ""
"仅当您的项目可以使用多个版本的 Qt 时才应使用此模块。如果没有，您应该直接使用 FindQt4 或 FindQt3。如果在机器上发现多个版本的 "
"Qt，那么用户必须将选项 DESIRED_QT_VERSION 设置为他们想要使用的版本。如果在机器上只找到一个版本的 qt，则将 "
"DESIRED_QT_VERSION 设置为该版本，并包含匹配的 FindQt3 或 FindQt4 模块。一旦用户设置了 "
"DESIRED_QT_VERSION，就会包含 FindQt3 或 FindQt4 模块。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt3.cmake:6
msgid "FindQt3"
msgstr "FindQt3"

#: ../../cmake-prefix/src/cmake/Modules/FindQt3.cmake:8
msgid "Locate Qt include paths and libraries"
msgstr "找到 Qt 包含路径和库"

#: ../../cmake-prefix/src/cmake/Modules/FindQt3.cmake:23
msgid ""
"If you need the multithreaded version of Qt, set QT_MT_REQUIRED to TRUE"
msgstr "如果需要 Qt 的多线程版本，请将 QT_MT_REQUIRED 设置为 TRUE"

#: ../../cmake-prefix/src/cmake/Modules/FindQt3.cmake:26
msgid "Also defined, but not for general use are:"
msgstr "还定义但不用于一般用途的是："

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:6
msgid "FindQt4"
msgstr "FindQt4"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:9
msgid "Finding and Using Qt4"
msgstr "查找和使用 Qt4"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:11
msgid ""
"This module can be used to find Qt4.  The most important issue is that the"
" Qt4 qmake is available via the system path.  This qmake is then used to "
"detect basically everything else.  This module defines a number of "
":prop_tgt:`IMPORTED` targets, macros and variables."
msgstr ""
"这个模块可以用来查找Qt4。最重要的问题是 Qt4 qmake 可以通过系统路径获得。这个 qmake "
"然后基本上用于检测其他所有内容。该模块定义了许多 :prop_tgt:`IMPORTED` 目标、宏和变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:16
msgid "Typical usage could be something like:"
msgstr "典型的用法可能是这样的："

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:28
msgid ""
"When using :prop_tgt:`IMPORTED` targets, the qtmain.lib static library is "
"automatically linked on Windows for :prop_tgt:`WIN32 <WIN32_EXECUTABLE>` "
"executables. To disable that globally, set the ``QT4_NO_LINK_QTMAIN`` "
"variable before finding Qt4. To disable that for a particular executable, "
"set the ``QT4_NO_LINK_QTMAIN`` target property to ``TRUE`` on the "
"executable."
msgstr ""
"当使用 :prop_tgt:`IMPORTED` 目标时，qtmain.lib 静态库会在 Windows 上自动链接到 "
":prop_tgt:`WIN32 <WIN32_EXECUTABLE>` 可执行文件。要全局禁用它，请在查找 Qt4 之前设置 "
"``QT4_NO_LINK_QTMAIN`` "
"变量。要为特定的可执行文件禁用它，请在可执行文件上将“QT4_NO_LINK_QTMAIN”目标属性设置为“TRUE”。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:36
msgid "Qt Build Tools"
msgstr "Qt 构建工具"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:38
msgid ""
"Qt relies on some bundled tools for code generation, such as ``moc`` for "
"meta-object code generation,``uic`` for widget layout and population, and "
"``rcc`` for virtual filesystem content generation.  These tools may be "
"automatically invoked by :manual:`cmake(1)` if the appropriate conditions "
"are met.  See :manual:`cmake-qt(7)` for more."
msgstr ""
"Qt "
"依赖于一些捆绑的代码生成工具，例如用于元对象代码生成的``moc``，用于小部件布局和填充的``uic``，以及用于虚拟文件系统内容生成的``rcc``。如果满足适当的条件，这些工具可能会被"
" cmake(1) 自动调用。有关更多信息，请参见 :manual:`cmake-qt(7)`。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:45
msgid "Qt Macros"
msgstr "Qt 宏"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:47
msgid ""
"In some cases it can be necessary or useful to invoke the Qt build tools "
"in a more-manual way. Several macros are available to add targets for such"
" uses."
msgstr "在某些情况下，以更手动的方式调用 Qt 构建工具可能是必要的或有用的。有几个宏可用于为此类用途添加目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:209
msgid ""
"A particular Qt library may be used by using the corresponding "
":prop_tgt:`IMPORTED` target with the :command:`target_link_libraries` "
"command:"
msgstr ""
"特定的 Qt 库可以通过使用相应的 :prop_tgt:`IMPORTED` 目标和 "
":command:`target_link_libraries` 命令来使用："

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:217
msgid ""
"Using a target in this way causes :cmake(1)` to use the appropriate "
"include directories and compile definitions for the target when compiling "
"``myexe``."
msgstr "以这种方式使用目标会导致 :cmake(1)` 在编译 ``myexe`` 时为目标使用适当的包含目录和编译定义。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:220
msgid ""
"Targets are aware of their dependencies, so for example it is not "
"necessary to list ``Qt4::QtCore`` if another Qt library is listed, and it "
"is not necessary to list ``Qt4::QtGui`` if ``Qt4::QtDeclarative`` is "
"listed. Targets may be tested for existence in the usual way with the "
":command:`if(TARGET)` command."
msgstr ""
"目标知道它们的依赖关系，例如，如果列出了另一个 Qt 库，则不必列出“Qt4::QtCore”，如果“Qt4”，则不必列出“Qt4::QtGui” "
"::QtDeclarative`` 已列出。可以使用 :command:`if(TARGET)` 命令以通常的方式测试目标是否存在。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:226
msgid ""
"The Qt toolkit may contain both debug and release libraries. "
":manual:`cmake(1)` will choose the appropriate version based on the build "
"configuration."
msgstr "Qt 工具包可能同时包含调试和发布库。 :manual:`cmake(1)` 将根据构建配置选择合适的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:230
msgid "``Qt4::QtCore``"
msgstr "``Qt4::QtCore``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:231
msgid "The QtCore target"
msgstr "QtCore 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:232
msgid "``Qt4::QtGui``"
msgstr "``Qt4::QtGui``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:233
msgid "The QtGui target"
msgstr "QtGui 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:234
msgid "``Qt4::Qt3Support``"
msgstr "``Qt4::Qt3Support``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:235
msgid "The Qt3Support target"
msgstr "Qt3Support 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:236
msgid "``Qt4::QtAssistant``"
msgstr "``Qt4::QtAssistant``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:237
msgid "The QtAssistant target"
msgstr "QtAssistant 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:238
msgid "``Qt4::QtAssistantClient``"
msgstr "``Qt4::QtAssistantClient``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:239
msgid "The QtAssistantClient target"
msgstr "QtAssistantClient 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:240
msgid "``Qt4::QAxContainer``"
msgstr "``Qt4::QAxContainer``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:241
msgid "The QAxContainer target (Windows only)"
msgstr "QAxContainer 目标（仅限 Windows）"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:242
msgid "``Qt4::QAxServer``"
msgstr "``Qt4::QAxServer``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:243
msgid "The QAxServer target (Windows only)"
msgstr "QAxServer 目标（仅限 Windows）"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:244
msgid "``Qt4::QtDBus``"
msgstr "``Qt4::QtDBus``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:245
msgid "The QtDBus target"
msgstr "QtDBus 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:246
msgid "``Qt4::QtDeclarative``"
msgstr "``Qt4::QtDeclarative``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:247
msgid "The QtDeclarative target"
msgstr "QtDeclarative 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:248
msgid "``Qt4::QtDesigner``"
msgstr "``Qt4::QtDesigner``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:249
msgid "The QtDesigner target"
msgstr "QtDesigner 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:250
msgid "``Qt4::QtDesignerComponents``"
msgstr "``Qt4::QtDesignerComponents``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:251
msgid "The QtDesignerComponents target"
msgstr "QtDesignerComponents 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:252
msgid "``Qt4::QtHelp``"
msgstr "``Qt4::QtHelp``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:253
msgid "The QtHelp target"
msgstr "QtHelp 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:254
msgid "``Qt4::QtMotif``"
msgstr "``Qt4::QtMotif``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:255
msgid "The QtMotif target"
msgstr "QtMotif 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:256
msgid "``Qt4::QtMultimedia``"
msgstr "``Qt4::Qt多媒体``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:257
msgid "The QtMultimedia target"
msgstr "Qt多媒体目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:258
msgid "``Qt4::QtNetwork``"
msgstr "``Qt4::QtNetwork``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:259
msgid "The QtNetwork target"
msgstr "QtNetwork 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:260
msgid "``Qt4::QtNsPLugin``"
msgstr "``Qt4::QtNsPLugin``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:261
msgid "The QtNsPLugin target"
msgstr "QtNsPlugin 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:262
msgid "``Qt4::QtOpenGL``"
msgstr "``Qt4::QtOpenGL``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:263
msgid "The QtOpenGL target"
msgstr "QtOpenGL 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:264
msgid "``Qt4::QtScript``"
msgstr "``Qt4::QtScript``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:265
msgid "The QtScript target"
msgstr "QtScript 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:266
msgid "``Qt4::QtScriptTools``"
msgstr "``Qt4::QtScriptTools``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:267
msgid "The QtScriptTools target"
msgstr "QtScriptTools 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:268
msgid "``Qt4::QtSql``"
msgstr "``Qt4::QtSql``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:269
msgid "The QtSql target"
msgstr "QtSql 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:270
msgid "``Qt4::QtSvg``"
msgstr "``Qt4::QtSvg``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:271
msgid "The QtSvg target"
msgstr "QtSvg 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:272
msgid "``Qt4::QtTest``"
msgstr "``Qt4::QtTest``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:273
msgid "The QtTest target"
msgstr "QtTest 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:274
msgid "``Qt4::QtUiTools``"
msgstr "``Qt4::QtUiTools``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:275
msgid "The QtUiTools target"
msgstr "QtUiTools 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:276
msgid "``Qt4::QtWebKit``"
msgstr "``Qt4::QtWebKit``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:277
msgid "The QtWebKit target"
msgstr "QtWebKit 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:278
msgid "``Qt4::QtXml``"
msgstr "``Qt4::QtXml``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:279
msgid "The QtXml target"
msgstr "QtXml 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:280
msgid "``Qt4::QtXmlPatterns``"
msgstr "``Qt4::QtXmlPatterns``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:281
msgid "The QtXmlPatterns target"
msgstr "QtXmlPatterns 目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:283
msgid "``Qt4::phonon``"
msgstr "``Qt4::phonon``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:283
msgid "The phonon target"
msgstr "声子目标"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:288
msgid "Below is a detailed list of variables that FindQt4.cmake sets."
msgstr "下面是 FindQt4.cmake 设置的变量的详细列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:290
msgid "``Qt4_FOUND``"
msgstr "``Qt4_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:291
msgid "If false, don't try to use Qt 4."
msgstr "如果为 false，请不要尝试使用 Qt 4。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:292
msgid "``QT_FOUND``"
msgstr "``QT_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:293
msgid ""
"If false, don't try to use Qt. This variable is for compatibility only."
msgstr "如果为 false，请不要尝试使用 Qt。此变量仅用于兼容性。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:294
msgid "``QT4_FOUND``"
msgstr "``QT4_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:295
msgid ""
"If false, don't try to use Qt 4. This variable is for compatibility only."
msgstr "如果为 false，请不要尝试使用 Qt 4。此变量仅用于兼容性。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:296
msgid "``QT_VERSION_MAJOR``"
msgstr "``QT_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:297
msgid "The major version of Qt found."
msgstr "找到 Qt 的主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:298
msgid "``QT_VERSION_MINOR``"
msgstr "``QT_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:299
msgid "The minor version of Qt found."
msgstr "找到 Qt 的次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:1346
msgid "``QT_VERSION_PATCH``"
msgstr "``QT_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindQt4.cmake:301
msgid "The patch version of Qt found."
msgstr "找到Qt的补丁版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindQuickTime.cmake:6
msgid "FindQuickTime"
msgstr "查找QuickTime"

#: ../../cmake-prefix/src/cmake/Modules/FindQuickTime.cmake:10
msgid ""
"Locate QuickTime This module defines QUICKTIME_LIBRARY QUICKTIME_FOUND, if"
" false, do not try to link to gdal QUICKTIME_INCLUDE_DIR, where to find "
"the headers"
msgstr ""
"定位 QuickTime 此模块定义 QUICKTIME_LIBRARY QUICKTIME_FOUND，如果为假，不要尝试链接到 gdal "
"QUICKTIME_INCLUDE_DIR，在哪里可以找到标题"

#: ../../cmake-prefix/src/cmake/Modules/FindQuickTime.cmake:14
msgid ""
"$QUICKTIME_DIR is an environment variable that would correspond to the "
"./configure --prefix=$QUICKTIME_DIR"
msgstr "$QUICKTIME_DIR 是一个环境变量，对应于 ./configure --prefix=$QUICKTIME_DIR"

#: ../../cmake-prefix/src/cmake/Modules/FindRTI.cmake:6
msgid "FindRTI"
msgstr "查找RTI"

#: ../../cmake-prefix/src/cmake/Modules/FindRTI.cmake:8
msgid "Try to find M&S HLA RTI libraries"
msgstr "尝试查找 M&S HLA RTI 文库"

#: ../../cmake-prefix/src/cmake/Modules/FindRTI.cmake:10
msgid ""
"This module finds if any HLA RTI is installed and locates the standard RTI"
" include files and libraries."
msgstr "该模块查找是否安装了任何 HLA RTI 并定位标准 RTI 包含文件和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindRTI.cmake:13
msgid ""
"RTI is a simulation infrastructure standardized by IEEE and SISO.  It has "
"a well defined C++ API that assures that simulation applications are "
"independent on a particular RTI implementation."
msgstr ""
"RTI 是由 IEEE 和 SISO 标准化的模拟基础设施。它具有定义良好的 C++ API，可确保仿真应用程序独立于特定的 RTI 实现。"

#: ../../cmake-prefix/src/cmake/Modules/FindRTI.cmake:23
#: ../../cmake-prefix/src/cmake/Modules/FindTclStub.cmake:24
msgid "This code sets the following variables:"
msgstr "此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindRTI.cmake:34
msgid "Report problems to <certi-devel@nongnu.org>"
msgstr "向 <certi-devel@nongnu.org> 报告问题"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:6
msgid "FindRuby"
msgstr "寻找红宝石"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:8
msgid "Find Ruby"
msgstr "寻找红宝石"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:10
msgid ""
"This module finds if Ruby is installed and determines where the include "
"files and libraries are.  Ruby 1.8 through 3.1 are supported."
msgstr "该模块查找是否安装了 Ruby 并确定包含文件和库的位置。支持 Ruby 1.8 到 3.1。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:14
msgid ""
"The minimum required version of Ruby can be specified using the standard "
"syntax, e.g."
msgstr "可以使用标准语法指定所需的最低 Ruby 版本，例如"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:23
msgid "It also determines what the name of the library is."
msgstr "它还确定库的名称是什么。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:25
msgid ""
"Virtual environments such as RVM are handled as well, by passing the "
"argument ``Ruby_FIND_VIRTUALENV``"
msgstr "通过传递参数``Ruby_FIND_VIRTUALENV``，也可以处理 RVM 等虚拟环境"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:33
msgid "``Ruby_FOUND``"
msgstr "``Ruby_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:34
msgid "set to true if ruby was found successfully"
msgstr "如果成功找到 ruby​​，则设置为 true"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:35
msgid "``Ruby_EXECUTABLE``"
msgstr "``Ruby_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:36
msgid "full path to the ruby binary"
msgstr "ruby 二进制文件的完整路径"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:37
msgid "``Ruby_INCLUDE_DIRS``"
msgstr "``Ruby_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:38
msgid "include dirs to be used when using the ruby library"
msgstr "包含使用 ruby​​ 库时要使用的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:40
msgid "``Ruby_LIBRARIES``"
msgstr "``Ruby_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:40
msgid "libraries needed to use ruby from C."
msgstr "使用 C 中的 ruby​​ 所需的库。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:42
msgid "``Ruby_VERSION``"
msgstr "``Ruby_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:43
msgid "the version of ruby which was found, e.g. \"1.8.7\""
msgstr "找到的 ruby​​ 版本，例如“1.8.7”"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:44
msgid "``Ruby_VERSION_MAJOR``"
msgstr "``Ruby_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:45
msgid "Ruby major version."
msgstr "红宝石主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:46
msgid "``Ruby_VERSION_MINOR``"
msgstr "``Ruby_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:47
msgid "Ruby minor version."
msgstr "红宝石次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:49
msgid "``Ruby_VERSION_PATCH``"
msgstr "``Ruby_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:49
msgid "Ruby patch version."
msgstr "红宝石补丁版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:51
msgid ""
"Previous versions of CMake used the ``RUBY_`` prefix for all variables. "
"The following variables are provided for compatibility reasons, don't use "
"them in new code:"
msgstr "以前版本的 CMake 对所有变量都使用 ``RUBY_`` 前缀。出于兼容性原因提供以下变量，请勿在新代码中使用它们："

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:56
msgid "``RUBY_EXECUTABLE``"
msgstr "``RUBY_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:57
msgid "same as Ruby_EXECUTABLE."
msgstr "与 Ruby_EXECUTABLE 相同。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:58
msgid "``RUBY_INCLUDE_DIRS``"
msgstr "``RUBY_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:59
#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:61
msgid "same as Ruby_INCLUDE_DIRS."
msgstr "与 Ruby_INCLUDE_DIRS 相同。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:60
msgid "``RUBY_INCLUDE_PATH``"
msgstr "``RUBY_INCLUDE_PATH``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:62
msgid "``RUBY_LIBRARY``"
msgstr "``RUBY_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:63
msgid "same as Ruby_LIBRARY."
msgstr "与 Ruby_LIBRARY 相同。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:64
msgid "``RUBY_VERSION``"
msgstr "``RUBY_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:65
msgid "same as Ruby_VERSION."
msgstr "与 Ruby_VERSION 相同。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:67
msgid "``RUBY_FOUND``"
msgstr "``RUBY_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:67
msgid "same as Ruby_FOUND."
msgstr "与 Ruby_FOUND 相同。"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:512
msgid "``Ruby_FIND_VIRTUALENV``"
msgstr "``Ruby_FIND_VIRTUALENV``"

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:75
msgid ""
"This variable defines the handling of virtual environments managed by "
"``rvm``. It is meaningful only when a virtual environment is active (i.e. "
"the ``rvm`` script has been evaluated or at least the ``MY_RUBY_HOME`` "
"environment variable is set). The ``Ruby_FIND_VIRTUALENV`` variable can be"
" set to empty or one of the following:"
msgstr ""
"这个变量定义了由 ``rvm`` 管理的虚拟环境的处理。它仅在虚拟环境处于活动状态时才有意义（即已评估 ``rvm`` 脚本或至少设置了 "
"``MY_RUBY_HOME`` 环境变量）。 ``Ruby_FIND_VIRTUALENV`` 变量可以设置为空或以下之一："

#: ../../cmake-prefix/src/cmake/Modules/FindRuby.cmake:86
msgid ""
"``STANDARD``: The virtual environment is not used to look-up for the "
"interpreter (assuming it isn't still in the PATH...)"
msgstr "``STANDARD``：虚拟环境不用于查找解释器（假设它不在路径中......）"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:6
msgid "FindSDL"
msgstr "查找SDL"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:8
msgid "Locate the SDL library"
msgstr "找到 SDL 库"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:19
msgid "``SDL::SDL``"
msgstr "``SDL::SDL``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:19
msgid "The SDL library, if found"
msgstr "SDL 库（如果找到）"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:26
msgid "``SDL_INCLUDE_DIRS``"
msgstr "``SDL_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:27
#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:51
msgid "where to find SDL.h"
msgstr "在哪里可以找到 SDL.h"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:28
msgid "``SDL_LIBRARIES``"
msgstr "``SDL_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:53
msgid "the name of the library to link against"
msgstr "要链接的库的名称"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:30
msgid "``SDL_FOUND``"
msgstr "``SDL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:31
msgid "if false, do not try to link to SDL"
msgstr "如果为 false，则不要尝试链接到 SDL"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:32
msgid "``SDL_VERSION``"
msgstr "``SDL_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:33
msgid "the human-readable string containing the version of SDL if found"
msgstr "如果找到，包含 SDL 版本的人类可读字符串"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:34
msgid "``SDL_VERSION_MAJOR``"
msgstr "``SDL_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:35
msgid "SDL major version"
msgstr "SDL 主要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:36
msgid "``SDL_VERSION_MINOR``"
msgstr "``SDL_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:37
msgid "SDL minor version"
msgstr "SDL 次要版本"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:39
msgid "``SDL_VERSION_PATCH``"
msgstr "``SDL_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:39
msgid "SDL patch version"
msgstr "SDL补丁版本"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:41
msgid ""
"Added the ``SDL_INCLUDE_DIRS``, ``SDL_LIBRARIES`` and "
"``SDL_VERSION[_<PART>]`` variables."
msgstr ""
"添加了``SDL_INCLUDE_DIRS``、``SDL_LIBRARIES`` 和``SDL_VERSION[_<PART>]`` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:48
msgid ""
"These variables may optionally be set to help this module find the correct"
" files:"
msgstr "可以选择设置这些变量以帮助该模块找到正确的文件："

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:50
msgid "``SDL_INCLUDE_DIR``"
msgstr "``SDL_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:54
msgid "``SDL_LIBRARY``"
msgstr "``SDL_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:57
msgid "Variables for locating SDL"
msgstr "用于定位 SDL 的变量"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:59
msgid "This module responds to the flag:"
msgstr "该模块响应标志："

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:67
msgid "``SDL_BUILDING_LIBRARY``"
msgstr "``SDL_BUILDING_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:62
msgid ""
"If this is defined, then no SDL_main will be linked in because only "
"applications need main(). Otherwise, it is assumed you are building an "
"application and this module will attempt to locate and set the proper link"
" flags as part of the returned SDL_LIBRARY variable."
msgstr ""
"如果已定义，则不会链接任何 SDL_main，因为只有应用程序需要 "
"main()。否则，假设您正在构建一个应用程序，并且此模块将尝试定位并设置正确的链接标志作为返回的 SDL_LIBRARY 变量的一部分。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:74
msgid ""
"These variables are obsolete and provided for backwards compatibility:"
msgstr "这些变量已过时并提供用于向后兼容："

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:79
msgid "``SDL_VERSION_STRING``"
msgstr "``SDL_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:77
msgid ""
"the human-readable string containing the version of SDL if found. "
"Identical to SDL_VERSION"
msgstr "如果找到，包含 SDL 版本的人类可读字符串。与 SDL_VERSION 相同"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:81
msgid ""
"Don't forget to include SDLmain.h and SDLmain.m your project for the OS X "
"framework based version.  (Other versions link to -lSDLmain which this "
"module will try to find on your behalf.) Also for OS X, this module will "
"automatically add the -framework Cocoa on your behalf."
msgstr ""
"不要忘记为基于 OS X 框架的版本包含 SDLmain.h 和 SDLmain.m 项目。 （其他版本链接到 "
"-lSDLmain，此模块将尝试代表您查找。）同样对于 OS X，此模块将代表您自动添加 -framework Cocoa。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:88
msgid ""
"Additional Note: If you see an empty SDL_LIBRARY_TEMP in your "
"configuration and no SDL_LIBRARY, it means CMake did not find your SDL "
"library (SDL.dll, libsdl.so, SDL.framework, etc).  Set SDL_LIBRARY_TEMP to"
" point to your SDL library, and configure again. Similarly, if you see an "
"empty SDLMAIN_LIBRARY, you should set this value as appropriate.  These "
"values are used to generate the final SDL_LIBRARY variable, but when these"
" values are unset, SDL_LIBRARY does not get created."
msgstr ""
"附加说明：如果您在配置中看到一个空的 SDL_LIBRARY_TEMP 而没有 SDL_LIBRARY，这意味着 CMake 没有找到您的 SDL "
"库（SDL.dll、libsdl.so、SDL.framework 等）。将 SDL_LIBRARY_TEMP 设置为指向您的 SDL "
"库，然后重新配置。同样，如果您看到一个空的 SDLMAIN_LIBRARY，您应该适当地设置该值。这些值用于生成最终的 SDL_LIBRARY "
"变量，但是当这些值未设置时，不会创建 SDL_LIBRARY。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:99
msgid ""
"$SDLDIR is an environment variable that would correspond to the "
"./configure --prefix=$SDLDIR used in building SDL.  l.e.galup 9-20-02"
msgstr ""
"$SDLDIR 是一个环境变量，对应于构建 SDL 时使用的 ./configure --prefix=$SDLDIR。 l.e.galup "
"9-20-02"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:102
msgid ""
"On OSX, this will prefer the Framework version (if found) over others. "
"People will have to manually change the cache values of SDL_LIBRARY to "
"override this selection or set the CMake environment CMAKE_INCLUDE_PATH to"
" modify the search paths."
msgstr ""
"在 OSX 上，这将比其他版本更喜欢框架版本（如果找到）。人们将不得不手动更改 SDL_LIBRARY 的缓存值以覆盖此选择或设置 CMake 环境"
" CMAKE_INCLUDE_PATH 以修改搜索路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL.cmake:107
msgid ""
"Note that the header path has changed from SDL/SDL.h to just SDL.h This "
"needed to change because \"proper\" SDL convention is #include \"SDL.h\", "
"not <SDL/SDL.h>.  This is done for portability reasons because not all "
"systems place things in SDL/ (see FreeBSD)."
msgstr ""
"请注意，标头路径已从 SDL/SDL.h 更改为仅 SDL.h 这需要更改，因为“正确的”SDL 约定是#include \"SDL.h\"，而不是"
" <SDL/SDL.h>。这样做是出于可移植性的原因，因为并非所有系统都将内容放在 SDL/（请参阅 FreeBSD）中。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_gfx.cmake:6
msgid "FindSDL_gfx"
msgstr "找到SDL_gfx"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_gfx.cmake:10
msgid "Locate SDL_gfx library"
msgstr "找到 SDL_gfx 库"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_gfx.cmake:23
msgid ""
"``$SDLDIR`` is an environment variable that would correspond to the "
"``./configure --prefix=$SDLDIR`` used in building SDL."
msgstr ""
"``$SDLDIR`` 是一个环境变量，对应于构建 SDL 时使用的 ``./configure --prefix=$SDLDIR``。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_image.cmake:6
msgid "FindSDL_image"
msgstr "查找SDL_image"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_image.cmake:8
msgid "Locate SDL_image library"
msgstr "找到 SDL_image 库"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_image.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_mixer.cmake:22
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_net.cmake:21
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_ttf.cmake:21
msgid "For backward compatibility the following variables are also set:"
msgstr "为了向后兼容，还设置了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_image.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_mixer.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_net.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/FindSDL_ttf.cmake:31
msgid ""
"$SDLDIR is an environment variable that would correspond to the "
"./configure --prefix=$SDLDIR used in building SDL."
msgstr "$SDLDIR 是一个环境变量，对应于构建 SDL 时使用的 ./configure --prefix=$SDLDIR。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_mixer.cmake:6
msgid "FindSDL_mixer"
msgstr "找到SDL_mixer"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_mixer.cmake:8
msgid "Locate SDL_mixer library"
msgstr "找到 SDL_mixer 库"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_net.cmake:6
msgid "FindSDL_net"
msgstr "查找SDL_net"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_net.cmake:8
msgid "Locate SDL_net library"
msgstr "找到 SDL_net 库"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:6
msgid "FindSDL_sound"
msgstr "查找SDL_sound"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:8
msgid "Locates the SDL_sound library"
msgstr "找到 SDL_sound 库"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:12
msgid ""
"This module depends on SDL being found and must be called AFTER "
"FindSDL.cmake is called."
msgstr "此模块取决于找到的 SDL，并且必须在调用 FindSDL.cmake 之后调用。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:32
msgid "This module also defines (but you shouldn't need to use directly)"
msgstr "这个模块也定义了（但你不应该直接使用）"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:39
msgid "And might define the following as needed"
msgstr "并可能根据需要定义以下内容"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:53
msgid ""
"Typically, you should not use these variables directly, and you should use"
" SDL_SOUND_LIBRARIES which contains SDL_SOUND_LIBRARY and the other audio "
"libraries (if needed) to successfully compile on your system."
msgstr ""
"通常，您不应直接使用这些变量，而应使用包含 SDL_SOUND_LIBRARY 和其他音频库（如果需要）的 SDL_SOUND_LIBRARIES "
"以在您的系统上成功编译。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:57
msgid ""
"Responds to the $SDLDIR and $SDLSOUNDDIR environmental variable that would"
" correspond to the ./configure --prefix=$SDLDIR used in building SDL."
msgstr ""
"响应与构建 SDL 时使用的 ./configure --prefix=$SDLDIR 相对应的 $SDLDIR 和 $SDLSOUNDDIR "
"环境变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_sound.cmake:61
msgid ""
"On OSX, this will prefer the Framework version (if found) over others. "
"People will have to manually change the cache values of SDL_LIBRARY to "
"override this selectionor set the CMake environment CMAKE_INCLUDE_PATH to "
"modify the search paths."
msgstr ""
"在 OSX 上，这将比其他版本更喜欢框架版本（如果找到）。人们将不得不手动更改 SDL_LIBRARY 的缓存值以覆盖此选择或设置 CMake 环境"
" CMAKE_INCLUDE_PATH 以修改搜索路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_ttf.cmake:6
msgid "FindSDL_ttf"
msgstr "找到SDL_ttf"

#: ../../cmake-prefix/src/cmake/Modules/FindSDL_ttf.cmake:8
msgid "Locate SDL_ttf library"
msgstr "找到 SDL_ttf 库"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:6
msgid "FindSQLite3"
msgstr "找到SQLite3"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:10
msgid "Find the SQLite libraries, v3"
msgstr "查找 SQLite 库，v3"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:13
msgid "IMPORTED targets"
msgstr "进口目标"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:17
msgid "``SQLite::SQLite3``"
msgstr "``SQLite::SQLite3``"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:22
msgid "This module will set the following variables if found:"
msgstr "如果找到，该模块将设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:24
msgid "``SQLite3_INCLUDE_DIRS``"
msgstr "``SQLite3_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:25
msgid "where to find sqlite3.h, etc."
msgstr "在哪里可以找到 sqlite3.h 等"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:26
msgid "``SQLite3_LIBRARIES``"
msgstr "``SQLite3_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:27
msgid "the libraries to link against to use SQLite3."
msgstr "要链接的库以使用 SQLite3。"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:28
msgid "``SQLite3_VERSION``"
msgstr "``SQLite3_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:29
msgid "version of the SQLite3 library found"
msgstr "找到的 SQLite3 库的版本"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:68
msgid "``SQLite3_FOUND``"
msgstr "``SQLite3_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindSQLite3.cmake:31
msgid "TRUE if found"
msgstr "如果找到则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:6
msgid "FindSWIG"
msgstr "找到SWIG"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:8
msgid ""
"Find the Simplified Wrapper and Interface Generator (SWIG_) executable."
msgstr "找到 Simplified Wrapper and Interface Generator (SWIG_) 可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:10
msgid "This module finds an installed SWIG and determines its version."
msgstr "此模块查找已安装的 SWIG 并确定其版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:12
msgid ""
"If a ``COMPONENTS`` or ``OPTIONAL_COMPONENTS`` argument is given to the "
":command:`find_package` command, it will also determine supported target "
"languages."
msgstr ""
"如果将 ``COMPONENTS`` 或 ``OPTIONAL_COMPONENTS`` 参数提供给 :command:`find_package`"
" 命令，它还将确定支持的目标语言。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:24
msgid "``SWIG_FOUND``"
msgstr "``SWIG_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:25
msgid "Whether SWIG and any required components were found on the system."
msgstr "是否在系统上找到 SWIG 和任何必需的组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:26
msgid "``SWIG_EXECUTABLE``"
msgstr "``SWIG_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:27
msgid "Path to the SWIG executable."
msgstr "SWIG 可执行文件的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:28
msgid "``SWIG_DIR``"
msgstr "``SWIG_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:29
msgid ""
"Path to the installed SWIG ``Lib`` directory (result of ``swig "
"-swiglib``)."
msgstr "安装的 SWIG ``Lib`` 目录的路径（``swig -swiglib`` 的结果）。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:30
msgid "``SWIG_VERSION``"
msgstr "``SWIG_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:31
msgid "SWIG executable version (result of ``swig -version``)."
msgstr "SWIG 可执行版本（``swig -version`` 的结果）。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:34
msgid "``SWIG_<lang>_FOUND``"
msgstr "``SWIG_<lang>_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:33
msgid ""
"If ``COMPONENTS`` or ``OPTIONAL_COMPONENTS`` are requested, each available"
" target language ``<lang>`` (lowercase) will be set to TRUE."
msgstr ""
"如果请求 ``COMPONENTS`` 或 ``OPTIONAL_COMPONENTS``，每个可用的目标语言 "
"``<lang>``（小写）将被设置为 TRUE。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:36
msgid ""
"Any ``COMPONENTS`` given to ``find_package`` should be the names of "
"supported target languages as provided to the LANGUAGE argument of "
"``swig_add_library``, such as ``python`` or ``perl5``. Language names "
"*must* be lowercase."
msgstr ""
"提供给 ``find_package`` 的任何 ``COMPONENTS`` 应该是提供给 ``swig_add_library`` 的 "
"LANGUAGE 参数的受支持目标语言的名称，例如 ``python`` 或 ``perl5``。语言名称*必须*是小写的。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:40
msgid ""
"All information is collected from the ``SWIG_EXECUTABLE``, so the version "
"to be found can be changed from the command line by means of setting "
"``SWIG_EXECUTABLE``."
msgstr ""
"所有信息都是从 ``SWIG_EXECUTABLE`` 收集的，因此可以通过设置 ``SWIG_EXECUTABLE`` 从命令行更改要查找的版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindSWIG.cmake:44
msgid ""
"Example usage requiring SWIG 4.0 or higher and Python language support, "
"with optional Fortran support:"
msgstr "需要 SWIG 4.0 或更高版本和 Python 语言支持以及可选的 Fortran 支持的示例用法："

#: ../../cmake-prefix/src/cmake/Modules/FindSelfPackers.cmake:6
msgid "FindSelfPackers"
msgstr "寻找SelfPackers"

#: ../../cmake-prefix/src/cmake/Modules/FindSelfPackers.cmake:8
msgid "Find upx"
msgstr "查找upx"

#: ../../cmake-prefix/src/cmake/Modules/FindSelfPackers.cmake:10
msgid ""
"This module looks for some executable packers (i.e.  software that "
"compress executables or shared libs into on-the-fly self-extracting "
"executables or shared libs.  Examples:"
msgstr "该模块寻找一些可执行打包程序（即，将可执行文件或共享库压缩为即时自解压可执行文件或共享库的软件。示例："

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:6
msgid "FindSquish"
msgstr "寻找挤压"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:8
msgid "-- Typical Use"
msgstr "-- 典型用途"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:12
msgid "This module can be used to find Squish."
msgstr "该模块可用于查找 Squish。"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:41
msgid ""
"It provides the function squish_add_test() for adding a squish test to "
"cmake using Squish >= 4.x:"
msgstr "它提供函数 squish_add_test() 用于使用 Squish >= 4.x 向 cmake 添加挤压测试："

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:50
msgid ""
"In previous CMake versions, this function was named "
"``squish_v4_add_test``."
msgstr "在以前的 CMake 版本中，此函数被命名为“squish_v4_add_test”。"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:53
msgid "The arguments have the following meaning:"
msgstr "参数具有以下含义："

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:55
msgid "``cmakeTestName``"
msgstr "``cmakeTestName``"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:56
msgid "this will be used as the first argument for add_test()"
msgstr "这将用作 add_test() 的第一个参数"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:58
msgid "``AUT targetName``"
msgstr "``AUT 目标名称``"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:58
msgid ""
"the name of the cmake target which will be used as AUT, i.e. the "
"executable which will be tested."
msgstr "将用作 AUT 的 cmake 目标的名称，即要测试的可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:63
msgid "``SUITE suiteName``"
msgstr "``SUITE 套房名称``"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:61
msgid ""
"this is either the full path to the squish suite, or just the last "
"directory of the suite, i.e. the suite name. In this case the "
"CMakeLists.txt which calls squish_add_test() must be located in the parent"
" directory of the suite directory."
msgstr ""
"这是 squish 套件的完整路径，或者只是套件的最后一个目录，即套件名称。在这种情况下，调用 squish_add_test() 的 "
"CMakeLists.txt 必须位于套件目录的父目录中。"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:66
msgid "``TEST squishTestName``"
msgstr "``测试 squishTestName``"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:66
msgid ""
"the name of the squish test, i.e. the name of the subdirectory of the test"
" inside the suite directory."
msgstr "squish 测试的名称，即套件目录中测试子目录的名称。"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:68
msgid "``SETTINGSGROUP group``"
msgstr "``SETTINGSGROUP 组``"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:69
msgid "deprecated, this argument will be ignored."
msgstr "已弃用，此参数将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:70
msgid "``PRE_COMMAND command``"
msgstr "``PRE_COMMAND 命令``"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:71
msgid ""
"if specified, the given command will be executed before starting the "
"squish test."
msgstr "如果指定，给定的命令将在开始压缩测试之前执行。"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:75
msgid "``POST_COMMAND command``"
msgstr "``POST_COMMAND 命令``"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:73
msgid "same as PRE_COMMAND, but after the squish test has been executed."
msgstr "与 PRE_COMMAND 相同，但在执行挤压测试之后。"

#: ../../cmake-prefix/src/cmake/Modules/FindSquish.cmake:93
msgid ""
"For users of Squish version 3.x the macro squish_v3_add_test() is "
"provided:"
msgstr "对于 Squish 版本 3.x 的用户，提供了宏 squish_v3_add_test()："

#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:6
msgid "FindSubversion"
msgstr "查找Subversion"

#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:8
msgid "Extract information from a subversion working copy"
msgstr "从颠覆工作副本中提取信息"

#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:21
msgid ""
"The minimum required version of Subversion can be specified using the "
"standard syntax, e.g. ``find_package(Subversion 1.4)``."
msgstr "可以使用标准语法指定最低要求的 Subversion 版本，例如``find_package(Subversion 1.4)``。"

#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:24
msgid ""
"If the command line client executable is found two macros are defined:"
msgstr "如果找到命令行客户端可执行文件，则定义两个宏："

#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:31
msgid ""
"``Subversion_WC_INFO`` extracts information of a subversion working copy "
"at a given location.  This macro defines the following variables if "
"running Subversion's ``info`` command on ``<dir>`` succeeds; otherwise a "
"``SEND_ERROR`` message is generated."
msgstr ""
"``Subversion_WC_INFO`` 在给定位置提取颠覆工作副本的信息。如果在 ``<dir>`` 上运行 Subversion 的 "
"``info`` 命令成功，这个宏定义了以下变量；否则会生成一条“SEND_ERROR”消息。"

#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:36
msgid ""
"The error can be ignored by providing the ``IGNORE_SVN_FAILURE`` option, "
"which causes these variables to remain undefined."
msgstr "可以通过提供 ``IGNORE_SVN_FAILURE`` 选项来忽略错误，这会导致这些变量保持未定义状态。"

#: ../../cmake-prefix/src/cmake/Modules/FindSubversion.cmake:51
msgid ""
"``Subversion_WC_LOG`` retrieves the log message of the base revision of a "
"subversion working copy at a given location.  This macro defines the "
"variable:"
msgstr "``Subversion_WC_LOG`` 检索给定位置的颠覆工作副本的基本修订的日志消息。这个宏定义变量："

#: ../../cmake-prefix/src/cmake/Modules/FindTCL.cmake:6
msgid "FindTCL"
msgstr "找TCL"

#: ../../cmake-prefix/src/cmake/Modules/FindTCL.cmake:8
msgid "TK_INTERNAL_PATH was removed."
msgstr "TK_INTERNAL_PATH 已删除。"

#: ../../cmake-prefix/src/cmake/Modules/FindTCL.cmake:10
msgid ""
"This module finds if Tcl is installed and determines where the include "
"files and libraries are.  It also determines what the name of the library "
"is.  This code sets the following variables:"
msgstr "该模块查找是否安装了 Tcl 并确定包含文件和库的位置。它还确定库的名称是什么。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindTCL.cmake:28
#: ../../cmake-prefix/src/cmake/Modules/FindTclStub.cmake:34
msgid ""
"In an effort to remove some clutter and clear up some issues for people "
"who are not necessarily Tcl/Tk gurus/developers, some variables were moved"
" or removed.  Changes compared to CMake 2.4 are:"
msgstr ""
"为了为不一定是 Tcl/Tk 大师/开发人员的人们消除一些混乱并解决一些问题，一些变量被移动或删除。与 CMake 2.4 相比的变化是："

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:6
msgid "FindTIFF"
msgstr "查找TIFF"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:8
msgid ""
"Find the TIFF library (``libtiff``, https://libtiff.gitlab.io/libtiff/)."
msgstr "找到 TIFF 库（``libtiff``，https://libtiff.gitlab.io/libtiff/）。"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:13
msgid ""
"This module supports the optional component `CXX`, for use with the "
"COMPONENTS argument of the :command:`find_package` command. This component"
" has an associated imported target, as described below."
msgstr ""
"该模块支持可选组件 `CXX`，与 :command:`find_package` 命令的 COMPONENTS "
"参数一起使用。该组件有一个关联的导入目标，如下所述。"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:25
msgid "``TIFF::TIFF``"
msgstr "``TIFF::TIFF``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:25
msgid "The TIFF library, if found."
msgstr "TIFF 库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:32
msgid "``TIFF::CXX``"
msgstr "``TIFF::CXX``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:30
msgid ""
"The C++ wrapper libtiffxx, if requested by the `COMPONENTS CXX` option, if"
" the compiler is not MSVC (which includes the C++ wrapper in libtiff), and"
" if found."
msgstr ""
"C++ 包装器 libtiffxx，如果“COMPONENTS CXX”选项请求，如果编译器不是 MSVC（它包括 libtiff 中的 C++ "
"包装器），并且如果找到。"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:39
msgid "``TIFF_FOUND``"
msgstr "``TIFF_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:40
msgid "true if the TIFF headers and libraries were found"
msgstr "如果找到 TIFF 标头和库，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:41
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:53
msgid "``TIFF_INCLUDE_DIR``"
msgstr "``TIFF_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:42
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:44
#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:54
msgid "the directory containing the TIFF headers"
msgstr "包含 TIFF 标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:43
msgid "``TIFF_INCLUDE_DIRS``"
msgstr "``TIFF_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:46
msgid "``TIFF_LIBRARIES``"
msgstr "``TIFF_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:46
msgid "TIFF libraries to be linked"
msgstr "要链接的 TIFF 库"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:55
msgid "``TIFF_LIBRARY_RELEASE``"
msgstr "``TIFF_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:56
msgid "the path to the TIFF library for release configurations"
msgstr "用于发布配置的 TIFF 库的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:57
msgid "``TIFF_LIBRARY_DEBUG``"
msgstr "``TIFF_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:58
msgid "the path to the TIFF library for debug configurations"
msgstr "用于调试配置的 TIFF 库的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:59
msgid "``TIFFXX_LIBRARY_RELEASE``"
msgstr "``TIFFXX_LIBRARY_RELEASE``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:60
msgid "the path to the TIFFXX library for release configurations"
msgstr "用于发布配置的 TIFFXX 库的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:62
msgid "``TIFFXX_LIBRARY_DEBUG``"
msgstr "``TIFFXX_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindTIFF.cmake:62
msgid "the path to the TIFFXX library for debug configurations"
msgstr "用于调试配置的 TIFFXX 库的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindTclStub.cmake:6
msgid "FindTclStub"
msgstr "查找 TclStub"

#: ../../cmake-prefix/src/cmake/Modules/FindTclStub.cmake:8
msgid "TCL_STUB_LIBRARY_DEBUG and TK_STUB_LIBRARY_DEBUG were removed."
msgstr "TCL_STUB_LIBRARY_DEBUG 和 TK_STUB_LIBRARY_DEBUG 已删除。"

#: ../../cmake-prefix/src/cmake/Modules/FindTclStub.cmake:10
msgid ""
"This module finds Tcl stub libraries.  It first finds Tcl include files "
"and libraries by calling FindTCL.cmake.  How to Use the Tcl Stubs Library:"
msgstr "该模块查找 Tcl 存根库。它首先通过调用 FindTCL.cmake 查找 Tcl 包含文件和库。如何使用 Tcl 存根库："

#: ../../cmake-prefix/src/cmake/Modules/FindTclStub.cmake:18
msgid "Using Stub Libraries:"
msgstr "使用存根库："

#: ../../cmake-prefix/src/cmake/Modules/FindTclsh.cmake:6
msgid "FindTclsh"
msgstr "查找Tclsh"

#: ../../cmake-prefix/src/cmake/Modules/FindTclsh.cmake:8
msgid "Find tclsh"
msgstr "寻找tclsh"

#: ../../cmake-prefix/src/cmake/Modules/FindTclsh.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindWish.cmake:10
msgid ""
"This module finds if TCL is installed and determines where the include "
"files and libraries are.  It also determines what the name of the library "
"is.  This code sets the following variables:"
msgstr "该模块查找是否安装了 TCL 并确定包含文件和库的位置。它还确定库的名称是什么。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:6
msgid "FindThreads"
msgstr "查找线程"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:8
msgid "This module determines the thread library of the system."
msgstr "该模块决定了系统的线程库。"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:18
msgid "``Threads::Threads``"
msgstr "``线程 ::线程``"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:18
msgid "The thread library, if found."
msgstr "线程库（如果找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:23
msgid "The following variables are set:"
msgstr "设置了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:25
msgid "``Threads_FOUND``"
msgstr "``Threads_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:26
msgid "If a supported thread library was found."
msgstr "如果找到支持的线程库。"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:29
msgid "``CMAKE_THREAD_LIBS_INIT``"
msgstr "``CMAKE_THREAD_LIBS_INIT``"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:28
msgid ""
"The thread library to use. This may be empty if the thread functions are "
"provided by the system libraries and no special flags are needed to use "
"them."
msgstr "要使用的线程库。如果线程函数由系统库提供并且不需要特殊标志来使用它们，则这可能为空。"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:31
msgid "``CMAKE_USE_WIN32_THREADS_INIT``"
msgstr "``CMAKE_USE_WIN32_THREADS_INIT``"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:32
msgid "If the found thread library is the win32 one."
msgstr "如果查到的线程库是win32的。"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:33
msgid "``CMAKE_USE_PTHREADS_INIT``"
msgstr "``CMAKE_USE_PTHREADS_INIT``"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:34
msgid "If the found thread library is pthread compatible."
msgstr "如果找到的线程库是 pthread 兼容的。"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:36
msgid "``CMAKE_HP_PTHREADS_INIT``"
msgstr "``CMAKE_HP_PTHREADS_INIT``"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:36
msgid "If the found thread library is the HP thread library."
msgstr "如果找到的线程库是HP线程库。"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:45
msgid ""
"If the use of the -pthread compiler and linker flag is preferred then the "
"caller can set this variable to TRUE. The compiler flag can only be used "
"with the imported target. Use of both the imported target as well as this "
"switch is highly recommended for new code."
msgstr ""
"如果首选使用 -pthread 编译器和链接器标志，则调用者可以将此变量设置为 "
"TRUE。编译器标志只能与导入的目标一起使用。对于新代码，强烈建议同时使用导入的目标和此开关。"

#: ../../cmake-prefix/src/cmake/Modules/FindThreads.cmake:50
msgid ""
"This variable has no effect if the system libraries provide the thread "
"functions, i.e. when ``CMAKE_THREAD_LIBS_INIT`` will be empty."
msgstr "如果系统库提供线程函数，即当 CMAKE_THREAD_LIBS_INIT 为空时，此变量无效。"

#: ../../cmake-prefix/src/cmake/Modules/FindUnixCommands.cmake:6
msgid "FindUnixCommands"
msgstr "查找 Unix 命令"

#: ../../cmake-prefix/src/cmake/Modules/FindUnixCommands.cmake:10
msgid "Use :option:`${CMAKE_COMMAND} -E <cmake -E>` subcommands instead."
msgstr "使用 :option:`${CMAKE_COMMAND} -E <cmake -E>` 子命令代替。"

#: ../../cmake-prefix/src/cmake/Modules/FindUnixCommands.cmake:12
msgid "Find Unix commands, including the ones from Cygwin"
msgstr "查找 Unix 命令，包括来自 Cygwin 的命令"

#: ../../cmake-prefix/src/cmake/Modules/FindUnixCommands.cmake:14
msgid ""
"This module looks for the Unix commands ``bash``, ``cp``, ``gzip``, "
"``mv``, ``rm``, and ``tar`` and stores the result in the variables "
"``BASH``, ``CP``, ``GZIP``, ``MV``, ``RM``, and ``TAR``."
msgstr ""
"该模块查找 Unix "
"命令“bash”、“cp”、“gzip”、“mv”、“rm”和“tar”，并将结果存储在变量中``BASH``、``CP``、``GZIP``、``MV``、``RM``"
" 和 ``TAR``。"

#: ../../cmake-prefix/src/cmake/Help/module/FindVTK.rst:2
msgid "FindVTK"
msgstr "查找VTK"

#: ../../cmake-prefix/src/cmake/Help/module/FindVTK.rst:6
msgid ""
"This module existed in versions of CMake prior to 3.1, but became only a "
"thin wrapper around ``find_package(VTK NO_MODULE)`` to provide "
"compatibility for projects using long-outdated conventions. Now "
"``find_package(VTK)`` will search for ``VTKConfig.cmake`` directly."
msgstr ""
"此模块存在于 3.1 之前的 CMake 版本中，但仅成为“find_package(VTK "
"NO_MODULE)”的薄包装，为使用早已过时的约定的项目提供兼容性。现在``find_package(VTK)`` "
"将直接搜索``VTKConfig.cmake``。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:6
msgid "FindVulkan"
msgstr "查找Vulkan"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:10
msgid ""
"Find Vulkan, which is a low-overhead, cross-platform 3D graphics and "
"computing API."
msgstr "查找 Vulkan，这是一种低开销、跨平台的 3D 图形和计算 API。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:18
msgid ""
"This module respects several optional COMPONENTS. There are corresponding "
"imported targets for each of these."
msgstr "该模块涉及几个可选组件。其中每一个都有相应的导入目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:22
msgid "``glslc``"
msgstr "``glslc``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:22
msgid "The SPIR-V compiler."
msgstr "SPIR-V 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:25
msgid "``glslangValidator``"
msgstr "``glslangValidator``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:25
msgid "The ``glslangValidator`` tool."
msgstr "``glslangValidator`` 工具。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:28
msgid "``glslang``"
msgstr "``glslang``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:28
msgid "The SPIR-V generator library."
msgstr "SPIR-V 生成器库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:31
msgid "``shaderc_combined``"
msgstr "``shaderc_combined``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:31
msgid "The static library for Vulkan shader compilation."
msgstr "Vulkan 着色器编译的静态库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:34
msgid "``SPIRV-Tools``"
msgstr "``SPIRV-工具``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:34
msgid "Tools to process SPIR-V modules."
msgstr "处理 SPIR-V 模块的工具。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:37
msgid "``MoltenVK``"
msgstr "``熔岩VK``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:37
msgid "On macOS, an additional component ``MoltenVK`` is available."
msgstr "在 macOS 上，可以使用附加组件“MoltenVK”。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:42
msgid "``dxc``"
msgstr "``dxc``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:42
msgid "The DirectX Shader Compiler."
msgstr "DirectX 着色器编译器。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:44
msgid ""
"The ``glslc`` and ``glslangValidator`` components are provided even if not"
" explicitly requested (for backward compatibility)."
msgstr "即使没有明确要求（为了向后兼容），也会提供 ``glslc`` 和 ``glslangValidator`` 组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:50
msgid ""
"This module defines :prop_tgt:`IMPORTED` targets if Vulkan has been found:"
msgstr "如果找到 Vulkan，此模块定义 :prop_tgt:`IMPORTED` 目标："

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:53
msgid "``Vulkan::Vulkan``"
msgstr "``Vulkan::Vulkan``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:53
msgid "The main Vulkan library."
msgstr "主要的 Vulkan 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:58
msgid "``Vulkan::glslc``"
msgstr "``Vulkan::glslc``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:58
msgid "The GLSLC SPIR-V compiler, if it has been found."
msgstr "GLSLC SPIR-V 编译器（如果已找到）。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:65
msgid "``Vulkan::Headers``"
msgstr "``Vulkan::标题``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:63
msgid ""
"Provides just Vulkan headers include paths, if found.  No library is "
"included in this target.  This can be useful for applications that load "
"Vulkan library dynamically."
msgstr "仅提供 Vulkan 标头包含路径（如果找到）。此目标中不包含库。这对于动态加载 Vulkan 库的应用程序很有用。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:71
msgid "``Vulkan::glslangValidator``"
msgstr "``Vulkan::glslangValidator``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:70
msgid ""
"The glslangValidator tool, if found.  It is used to compile GLSL and HLSL "
"shaders into SPIR-V."
msgstr "glslangValidator 工具（如果找到）。它用于将 GLSL 和 HLSL 着色器编译成 SPIR-V。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:77
msgid "``Vulkan::glslang``"
msgstr "``Vulkan::glslang``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:76
msgid ""
"Defined if SDK has the Khronos-reference front-end shader parser and "
"SPIR-V generator library (glslang)."
msgstr "定义 SDK 是否具有 Khronos-reference 前端着色器解析器和 SPIR-V 生成器库 (glslang)。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:83
msgid "``Vulkan::shaderc_combined``"
msgstr "``Vulkan::shaderc_combined``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:82
msgid ""
"Defined if SDK has the Google static library for Vulkan shader compilation"
" (shaderc_combined)."
msgstr "定义 SDK 是否具有用于 Vulkan 着色器编译的 Google 静态库 (shaderc_combined)。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:89
msgid "``Vulkan::SPIRV-Tools``"
msgstr "``Vulkan::SPIRV-工具``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:88
msgid ""
"Defined if SDK has the Khronos library to process SPIR-V modules (SPIRV-"
"Tools)."
msgstr "定义 SDK 是否具有 Khronos 库来处理 SPIR-V 模块（SPIRV-Tools）。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:95
msgid "``Vulkan::MoltenVK``"
msgstr "``Vulkan::MoltenVK``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:94
msgid ""
"Defined if SDK has the Khronos library which implement a subset of Vulkan "
"API over Apple Metal graphics framework. (MoltenVK)."
msgstr ""
"定义 SDK 是否具有 Khronos 库，该库通过 Apple Metal 图形框架实现 Vulkan API 的子集。 （熔岩VK）。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:100
msgid "``Vulkan::volk``"
msgstr "``Vulkan::volk``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:100
msgid "Defined if SDK has the Vulkan meta-loader (volk)."
msgstr "定义 SDK 是否具有 Vulkan 元加载器 (volk)。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:105
msgid "``Vulkan::dxc_lib``"
msgstr "``Vulkan::dxc_lib``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:105
msgid "Defined if SDK has the DirectX shader compiler library."
msgstr "定义 SDK 是否具有 DirectX 着色器编译器库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:110
msgid "``Vulkan::dxc_exe``"
msgstr "``Vulkan::dxc_exe``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:110
msgid "Defined if SDK has the DirectX shader compiler CLI tool."
msgstr "定义 SDK 是否具有 DirectX 着色器编译器 CLI 工具。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:117
msgid "``Vulkan_FOUND``"
msgstr "``Vulkan_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:118
msgid "set to true if Vulkan was found"
msgstr "如果找到 Vulkan，则设置为 true"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:119
msgid "``Vulkan_INCLUDE_DIRS``"
msgstr "``Vulkan_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:120
msgid "include directories for Vulkan"
msgstr "包含 Vulkan 的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:121
msgid "``Vulkan_LIBRARIES``"
msgstr "``Vulkan_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:122
msgid "link against this library to use Vulkan"
msgstr "链接到这个库以使用 Vulkan"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:125
msgid "``Vulkan_VERSION``"
msgstr "``Vulkan_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:126
msgid "value from ``vulkan/vulkan_core.h``"
msgstr "来自 ``vulkan/vulkan_core.h`` 的值"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:129
msgid "``Vulkan_glslc_FOUND``"
msgstr "``Vulkan_glslc_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:130
msgid "True, if the SDK has the glslc executable."
msgstr "是的，如果 SDK 具有 glslc 可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:133
msgid "``Vulkan_glslangValidator_FOUND``"
msgstr "``Vulkan_glslangValidator_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:134
msgid "True, if the SDK has the glslangValidator executable."
msgstr "是的，如果 SDK 具有 glslangValidator 可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:137
msgid "``Vulkan_glslang_FOUND``"
msgstr "``Vulkan_glslang_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:138
msgid "True, if the SDK has the glslang library."
msgstr "是的，如果 SDK 有 glslang 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:141
msgid "``Vulkan_shaderc_combined_FOUND``"
msgstr "``Vulkan_shaderc_combined_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:142
msgid "True, if the SDK has the shaderc_combined library."
msgstr "是的，如果 SDK 具有 shaderc_combined 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:145
msgid "``Vulkan_SPIRV-Tools_FOUND``"
msgstr "``Vulkan_SPIRV-Tools_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:146
msgid "True, if the SDK has the SPIRV-Tools library."
msgstr "是的，如果 SDK 具有 SPIRV-Tools 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:149
msgid "``Vulkan_MoltenVK_FOUND``"
msgstr "``Vulkan_MoltenVK_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:150
msgid "True, if the SDK has the MoltenVK library."
msgstr "是的，如果 SDK 有 MoltenVK 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:154
msgid "``Vulkan_volk_FOUND``"
msgstr "``Vulkan_volk_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:154
msgid "True, if the SDK has the volk library."
msgstr "是的，如果 SDK 有 volk 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:159
msgid "``Vulkan_dxc_lib_FOUND``"
msgstr "``Vulkan_dxc_lib_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:159
msgid "True, if the SDK has the DirectX shader compiler library."
msgstr "是的，如果 SDK 具有 DirectX 着色器编译器库。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:165
msgid "``Vulkan_dxc_exe_FOUND``"
msgstr "``Vulkan_dxc_exe_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:164
msgid "True, if the SDK has the DirectX shader compiler CLI tool."
msgstr "是的，如果 SDK 具有 DirectX 着色器编译器 CLI 工具。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:167
msgid "The module will also defines these cache variables:"
msgstr "该模块还将定义这些缓存变量："

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:169
msgid "``Vulkan_INCLUDE_DIR``"
msgstr "``Vulkan_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:170
msgid "the Vulkan include directory"
msgstr "Vulkan 包含目录"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:171
msgid "``Vulkan_LIBRARY``"
msgstr "``Vulkan_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:172
msgid "the path to the Vulkan library"
msgstr "Vulkan 库的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:173
msgid "``Vulkan_GLSLC_EXECUTABLE``"
msgstr "``Vulkan_GLSLC_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:174
msgid "the path to the GLSL SPIR-V compiler"
msgstr "GLSL SPIR-V 编译器的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:175
msgid "``Vulkan_GLSLANG_VALIDATOR_EXECUTABLE``"
msgstr "``Vulkan_GSLLANG_VALIDATOR_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:176
msgid "the path to the glslangValidator tool"
msgstr "glslangValidator 工具的路径"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:179
msgid "``Vulkan_glslang_LIBRARY``"
msgstr "``Vulkan_glslang_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:180
msgid "Path to the glslang library."
msgstr "glslang 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:183
msgid "``Vulkan_shaderc_combined_LIBRARY``"
msgstr "``Vulkan_shaderc_combined_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:184
msgid "Path to the shaderc_combined library."
msgstr "shaderc_combined 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:187
msgid "``Vulkan_SPIRV-Tools_LIBRARY``"
msgstr "``Vulkan_SPIRV-Tools_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:188
msgid "Path to the SPIRV-Tools library."
msgstr "SPIRV-Tools 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:192
msgid "``Vulkan_MoltenVK_LIBRARY``"
msgstr "``Vulkan_MoltenVK_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:192
msgid "Path to the MoltenVK library."
msgstr "MoltenVK 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:197
msgid "``Vulkan_volk_LIBRARY``"
msgstr "``Vulkan_volk_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:197
msgid "Path to the volk library."
msgstr "volk 库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:202
msgid "``Vulkan_dxc_LIBRARY``"
msgstr "``Vulkan_dxc_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:202
msgid "Path to the DirectX shader compiler library."
msgstr "DirectX 着色器编译器库的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:207
msgid "``Vulkan_dxc_EXECUTABLE``"
msgstr "``Vulkan_dxc_EXECUTABLE``"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:207
msgid "Path to the DirectX shader compiler CLI tool."
msgstr "DirectX 着色器编译器 CLI 工具的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindVulkan.cmake:214
msgid ""
"The ``VULKAN_SDK`` environment variable optionally specifies the location "
"of the Vulkan SDK root directory for the given architecture. It is "
"typically set by sourcing the toplevel ``setup-env.sh`` script of the "
"Vulkan SDK directory into the shell environment."
msgstr ""
"``VULKAN_SDK`` 环境变量可选择指定给定架构的 Vulkan SDK 根目录的位置。它通常通过将 Vulkan SDK "
"目录的顶级“setup-env.sh”脚本引入 shell 环境来设置。"

#: ../../cmake-prefix/src/cmake/Modules/FindWget.cmake:6
msgid "FindWget"
msgstr "查找Wget"

#: ../../cmake-prefix/src/cmake/Modules/FindWget.cmake:8
msgid "Find wget"
msgstr "查找wget"

#: ../../cmake-prefix/src/cmake/Modules/FindWget.cmake:10
msgid ""
"This module looks for wget.  This module defines the following values:"
msgstr "这个模块寻找 wget。该模块定义了以下值："

#: ../../cmake-prefix/src/cmake/Modules/FindWish.cmake:6
msgid "FindWish"
msgstr "寻心愿"

#: ../../cmake-prefix/src/cmake/Modules/FindWish.cmake:8
msgid "Find wish installation"
msgstr "找wish安装"

#: ../../cmake-prefix/src/cmake/Modules/FindWish.cmake:20
msgid "if UNIX is defined, then it will look for the cygwin version first"
msgstr "如果定义了 UNIX，那么它将首先查找 cygwin 版本"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:6
msgid "FindX11"
msgstr "找X11"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:8
msgid "Find X11 installation"
msgstr "查找X11安装"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:10
msgid "Try to find X11 on UNIX systems. The following values are defined"
msgstr "尝试在 UNIX 系统上查找 X11。定义了以下值"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:18
msgid "and also the following more fine grained variables and targets:"
msgstr "以及以下更细粒度的变量和目标："

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:20
msgid "Imported targets."
msgstr "导入的目标。"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:72
msgid ""
"Renamed ``Xxf86misc``, ``X11_Xxf86misc``, ``X11_Xxf86vm``, "
"``X11_xkbfile``, ``X11_Xtst``, and ``X11_Xss`` libraries to match their "
"file names. Deprecated the ``X11_Xinput`` library.  Old names are still "
"available for compatibility."
msgstr ""
"重命名了``Xxf86misc``、``X11_Xxf86misc``、``X11_Xxf86vm``、``X11_xkbfile``、``X11_Xtst``"
" 和``X11_Xss`` 库以匹配它们的文件名。弃用了``X11_Xinput`` 库。旧名称仍然可用于兼容性。"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:78
msgid "Added the ``X11_Xext_INCLUDE_PATH`` variable."
msgstr "添加了 ``X11_Xext_INCLUDE_PATH`` 变量。"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:81
msgid ""
"Added the ``xcb``, ``X11-xcb``, ``xcb-icccm``, ``xcb-xkb``, ``xkbcommon``,"
" and ``xkbcommon-X11`` libraries."
msgstr ""
"添加了``xcb``、``X11-xcb``、``xcb-icccm``、``xcb-xkb``、``xkbcommon`` "
"和``xkbcommon-X11`` 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:85
msgid "Added the ``Xaw``, ``xcb_util``, and ``xcb_xfixes`` libraries."
msgstr "添加了``Xaw``、``xcb_util`` 和``xcb_xfixes`` 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindX11.cmake:88
msgid ""
"Added the ``xcb_randr``, ``xcb_xtext``, and ``xcb_keysyms`` libraries."
msgstr "添加了``xcb_randr``、``xcb_xtext`` 和``xcb_keysyms`` 库。"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:6
msgid "FindXCTest"
msgstr "查找XC测试"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:10
msgid "Functions to help creating and executing XCTest bundles."
msgstr "帮助创建和执行 XCTest 包的功能。"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:12
msgid ""
"An XCTest bundle is a CFBundle with a special product-type and bundle "
"extension. The Mac Developer Library provides more information in the "
"`Testing with Xcode`_ document."
msgstr ""
"XCTest 包是一个具有特殊产品类型和包扩展的 CFBundle。 Mac 开发人员库在“使用 Xcode 进行测试”文档中提供了更多信息。"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:23
msgid ""
"The ``xctest_add_bundle`` function creates a XCTest bundle named <target> "
"which will test the target <testee>. Supported target types for testee are"
" Frameworks and App Bundles::"
msgstr ""
"``xctest_add_bundle`` 函数创建一个名为 <target> 的 XCTest 包，它将测试目标 "
"<testee>。受测者支持的目标类型是框架和应用程序包 ::"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:34
msgid ""
"The ``xctest_add_test`` function adds an XCTest bundle to the project to "
"be run by :manual:`ctest(1)`. The test will be named <name> and tests "
"<bundle>::"
msgstr ""
"``xctest_add_test`` 函数将 XCTest 包添加到要由 ctest(1) 运行的项目中。测试将被命名为 <name> 并测试 "
"<bundle>::"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:46
msgid "The following variables are set by including this module:"
msgstr "通过包含此模块设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:50
msgid "True if the XCTest Framework and executable were found."
msgstr "如果找到 XCTest 框架和可执行文件，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:54
msgid ""
"The path to the xctest command line tool used to execute XCTest bundles."
msgstr "用于执行 XCTest 包的 xctest 命令行工具的路径。"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:58
msgid "The directory containing the XCTest Framework headers."
msgstr "包含 XCTest 框架标头的目录。"

#: ../../cmake-prefix/src/cmake/Modules/FindXCTest.cmake:62
msgid "The location of the XCTest Framework."
msgstr "XCTest 框架的位置。"

#: ../../cmake-prefix/src/cmake/Modules/FindXMLRPC.cmake:6
msgid "FindXMLRPC"
msgstr "查找XMLRPC"

#: ../../cmake-prefix/src/cmake/Modules/FindXMLRPC.cmake:8
msgid "Find xmlrpc"
msgstr "查找xmlrpc"

#: ../../cmake-prefix/src/cmake/Modules/FindXMLRPC.cmake:10
msgid "Find the native XMLRPC headers and libraries."
msgstr "查找本机 XMLRPC 标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindXMLRPC.cmake:18
msgid ""
"XMLRPC modules may be specified as components for this find module. "
"Modules may be listed by running \"xmlrpc-c-config\".  Modules include:"
msgstr "XMLRPC 模块可以指定为此查找模块的组件。可以通过运行“xmlrpc-c-config”来列出模块。模块包括："

#: ../../cmake-prefix/src/cmake/Modules/FindXMLRPC.cmake:28
msgid "Typical usage:"
msgstr "典型用法："

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:6
msgid "FindXalanC"
msgstr "查找XalanC"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:10
msgid ""
"Find the Apache Xalan-C++ XSL transform processor headers and libraries."
msgstr "查找 Apache Xalan-C++ XSL 转换处理器标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:18
msgid "``XalanC::XalanC``"
msgstr "``XalanC::XalanC``"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:18
msgid "The Xalan-C++ ``xalan-c`` library, if found."
msgstr "Xalan-C++ ``xalan-c`` 库，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:25
msgid "``XalanC_FOUND``"
msgstr "``XalanC_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:26
msgid "true if the Xalan headers and libraries were found"
msgstr "如果找到 Xalan 标头和库，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:27
msgid "``XalanC_VERSION``"
msgstr "``XalanC_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:28
msgid "Xalan release version"
msgstr "Xalan 发布版本"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:30
msgid "``XalanC_INCLUDE_DIRS``"
msgstr "``XalanC_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:30
msgid ""
"the directory containing the Xalan headers; note ``XercesC_INCLUDE_DIRS`` "
"is also required"
msgstr "包含 Xalan 标头的目录；注意``XercesC_INCLUDE_DIRS``也是必需的"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:34
msgid "``XalanC_LIBRARIES``"
msgstr "``XalanC_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:33
msgid ""
"Xalan libraries to be linked; note ``XercesC_LIBRARIES`` is also required"
msgstr "要链接的 Xalan 库；注意 ``XercesC_LIBRARIES`` 也是必需的"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:41
msgid "``XalanC_INCLUDE_DIR``"
msgstr "``XalanC_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:42
msgid "the directory containing the Xalan headers"
msgstr "包含 Xalan 标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:155
msgid "``XalanC_LIBRARY``"
msgstr "``XalanC_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindXalanC.cmake:44
msgid "the Xalan library"
msgstr "Xalan图书馆"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:6
msgid "FindXercesC"
msgstr "查找XercesC"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:10
msgid ""
"Find the Apache Xerces-C++ validating XML parser headers and libraries."
msgstr "查找 Apache Xerces-C++ 验证 XML 解析器标头和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:20
msgid "``XercesC::XercesC``"
msgstr "``XercesC::XercesC``"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:20
msgid "The Xerces-C++ ``xerces-c`` library, if found."
msgstr "Xerces-C++ ``xerces-c`` 库，如果找到的话。"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:27
msgid "``XercesC_FOUND``"
msgstr "``XercesC_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:28
msgid "true if the Xerces headers and libraries were found"
msgstr "如果找到 Xerces 头文件和库，则为真"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:29
msgid "``XercesC_VERSION``"
msgstr "``XercesC_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:30
msgid "Xerces release version"
msgstr "Xerces 发布版本"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:31
msgid "``XercesC_INCLUDE_DIRS``"
msgstr "``XercesC_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:32
#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:42
msgid "the directory containing the Xerces headers"
msgstr "包含 Xerces 标头的目录"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:34
msgid "``XercesC_LIBRARIES``"
msgstr "``XercesC_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:34
msgid "Xerces libraries to be linked"
msgstr "要链接的 Xerces 库"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:41
msgid "``XercesC_INCLUDE_DIR``"
msgstr "``XercesC_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:44
msgid "``XercesC_LIBRARY``"
msgstr "``XercesC_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindXercesC.cmake:44
msgid "the Xerces library"
msgstr "Xerces 图书馆"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:6
msgid "FindZLIB"
msgstr "查找ZLIB"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:8
msgid "Find the native ZLIB includes and library."
msgstr "查找本机 ZLIB 包含和库。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:15
msgid ""
"This module defines :prop_tgt:`IMPORTED` target ``ZLIB::ZLIB``, if ZLIB "
"has been found."
msgstr "如果找到 ZLIB，此模块定义:prop_tgt:`IMPORTED` 目标 ``ZLIB::ZLIB``。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:23
msgid "``ZLIB_INCLUDE_DIRS``"
msgstr "``ZLIB_INCLUDE_DIRS``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:24
msgid "where to find zlib.h, etc."
msgstr "在哪里可以找到 zlib.h 等"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:25
msgid "``ZLIB_LIBRARIES``"
msgstr "``ZLIB_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:26
msgid "List of libraries when using zlib."
msgstr "使用 zlib 时的库列表。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:27
msgid "``ZLIB_FOUND``"
msgstr "``ZLIB_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:28
msgid "True if zlib found."
msgstr "如果找到 zlib，则为真。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:33
msgid "``ZLIB_VERSION``"
msgstr "``ZLIB_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:30
msgid "the version of Zlib found."
msgstr "找到的 Zlib 版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:33
msgid "See also legacy variable ``ZLIB_VERSION_STRING``."
msgstr "另见遗留变量“ZLIB_VERSION_STRING”。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:46
msgid "``ZLIB_VERSION_MAJOR``"
msgstr "``ZLIB_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:44
msgid "The major version of zlib."
msgstr "zlib 的主要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:46
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:51
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:56
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:61
#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:66
msgid "Superseded by ``ZLIB_VERSION``."
msgstr "被“ZLIB_VERSION”取代。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:51
msgid "``ZLIB_VERSION_MINOR``"
msgstr "``ZLIB_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:49
msgid "The minor version of zlib."
msgstr "zlib 的次要版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:56
msgid "``ZLIB_VERSION_PATCH``"
msgstr "``ZLIB_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:54
msgid "The patch version of zlib."
msgstr "zlib 的补丁版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:61
msgid "``ZLIB_VERSION_TWEAK``"
msgstr "``ZLIB_VERSION_TWEAK``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:59
msgid "The tweak version of zlib."
msgstr "zlib 的调整版本。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:66
msgid "``ZLIB_VERSION_STRING``"
msgstr "``ZLIB_VERSION_STRING``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:64
msgid "The version of zlib found (x.y.z)"
msgstr "找到的 zlib 版本 (x.y.z)"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:68
msgid "``ZLIB_MAJOR_VERSION``"
msgstr "``ZLIB_MAJOR_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:69
msgid "The major version of zlib.  Superseded by ``ZLIB_VERSION_MAJOR``."
msgstr "zlib 的主要版本。被“ZLIB_VERSION_MAJOR”取代。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:70
msgid "``ZLIB_MINOR_VERSION``"
msgstr "``ZLIB_MINOR_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:71
msgid "The minor version of zlib.  Superseded by ``ZLIB_VERSION_MINOR``."
msgstr "zlib 的次要版本。被“ZLIB_VERSION_MINOR”取代。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:73
msgid "``ZLIB_PATCH_VERSION``"
msgstr "``ZLIB_PATCH_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:73
msgid "The patch version of zlib.  Superseded by ``ZLIB_VERSION_PATCH``."
msgstr "zlib 的补丁版本。被“ZLIB_VERSION_PATCH”取代。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:78
msgid ""
"A user may set ``ZLIB_ROOT`` to a zlib installation root to tell this "
"module where to look."
msgstr "用户可以将 ``ZLIB_ROOT`` 设置为 zlib 安装根目录，以告诉该模块在哪里查找。"

#: ../../cmake-prefix/src/cmake/Modules/FindZLIB.cmake:81
msgid ""
"Set ``ZLIB_USE_STATIC_LIBS`` to ``ON`` to look for static libraries. "
"Default is ``OFF``."
msgstr "将“ZLIB_USE_STATIC_LIBS”设置为“ON”以查找静态库。默认为“关闭”。"

#: ../../cmake-prefix/src/cmake/Modules/Findosg.cmake:6
msgid "Findosg"
msgstr "Findosg"

#: ../../cmake-prefix/src/cmake/Modules/Findosg.cmake:10
msgid ""
"NOTE: It is highly recommended that you use the new "
"FindOpenSceneGraph.cmake introduced in CMake 2.6.3 and not use this Find "
"module directly."
msgstr ""
"注意：强烈建议您使用 CMake 2.6.3 中引入的新 FindOpenSceneGraph.cmake，不要直接使用此 Find 模块。"

#: ../../cmake-prefix/src/cmake/Modules/Findosg.cmake:14
#: ../../cmake-prefix/src/cmake/Modules/FindosgAnimation.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgFX.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgGA.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgIntrospection.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgManipulator.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgParticle.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgPresentation.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgProducer.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgQt.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgShadow.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgSim.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgTerrain.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgText.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgUtil.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgViewer.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgVolume.cmake:10
#: ../../cmake-prefix/src/cmake/Modules/FindosgWidget.cmake:10
msgid ""
"This is part of the Findosg* suite used to find OpenSceneGraph components."
"  Each component is separate and you must opt in to each module.  You must"
" also opt into OpenGL and OpenThreads (and Producer if needed) as these "
"modules won't do it for you.  This is to allow you control over your own "
"system piece by piece in case you need to opt out of certain components or"
" change the Find behavior for a particular module (perhaps because the "
"default FindOpenGL.cmake module doesn't work with your system as an "
"example).  If you want to use a more convenient module that includes "
"everything, use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake"
" modules."
msgstr ""
"这是用于查找 OpenSceneGraph 组件的 Findosg* 套件的一部分。每个组件都是独立的，您必须选择加入每个模块。您还必须选择加入 "
"OpenGL 和 OpenThreads（如果需要，还可以加入 "
"Producer），因为这些模块不会为您做这些。这是为了允许您逐个控制自己的系统，以防您需要选择退出某些组件或更改特定模块的查找行为（可能是因为默认的"
" FindOpenGL.cmake 模块不能与您的系统一起使用作为例子）。如果您想使用包含所有内容的更方便的模块，请使用 "
"FindOpenSceneGraph.cmake 而不是 Findosg*.cmake 模块。"

#: ../../cmake-prefix/src/cmake/Modules/Findosg.cmake:25
msgid "Locate osg This module defines"
msgstr "定位osg这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/Findosg.cmake:27
msgid ""
"OSG_FOUND - Was the Osg found? OSG_INCLUDE_DIR - Where to find the headers"
" OSG_LIBRARIES - The libraries to link against for the OSG (use this)"
msgstr ""
"OSG_FOUND - Osg 找到了吗？ OSG_INCLUDE_DIR - 在哪里可以找到头文件 OSG_LIBRARIES - OSG "
"链接的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/Findosg.cmake:31
msgid ""
"OSG_LIBRARY - The OSG library OSG_LIBRARY_DEBUG - The OSG debug library"
msgstr "OSG_LIBRARY - OSG 库 OSG_LIBRARY_DEBUG - OSG 调试库"

#: ../../cmake-prefix/src/cmake/Modules/Findosg.cmake:34
#: ../../cmake-prefix/src/cmake/Modules/FindosgAnimation.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgFX.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgGA.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgIntrospection.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/FindosgManipulator.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/FindosgParticle.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgPresentation.cmake:31
#: ../../cmake-prefix/src/cmake/Modules/FindosgProducer.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgQt.cmake:29
#: ../../cmake-prefix/src/cmake/Modules/FindosgShadow.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgSim.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgTerrain.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgText.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgUtil.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgViewer.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgVolume.cmake:30
#: ../../cmake-prefix/src/cmake/Modules/FindosgWidget.cmake:30
msgid ""
"$OSGDIR is an environment variable that would correspond to the "
"./configure --prefix=$OSGDIR used in building osg."
msgstr "$OSGDIR 是一个环境变量，对应于构建 osg 时使用的 ./configure --prefix=$OSGDIR。"

#: ../../cmake-prefix/src/cmake/Modules/FindosgAnimation.cmake:6
msgid "FindosgAnimation"
msgstr "Findosg动画"

#: ../../cmake-prefix/src/cmake/Modules/FindosgAnimation.cmake:21
msgid "Locate osgAnimation This module defines"
msgstr "定位osgAnimation这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgAnimation.cmake:23
msgid ""
"OSGANIMATION_FOUND - Was osgAnimation found? OSGANIMATION_INCLUDE_DIR - "
"Where to find the headers OSGANIMATION_LIBRARIES - The libraries to link "
"against for the OSG (use this)"
msgstr ""
"OSGANIMATION_FOUND - 是否找到了 osgAnimation？ OSGANIMATION_INCLUDE_DIR - "
"在哪里可以找到头文件 OSGANIMATION_LIBRARIES - 为 OSG 链接的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgAnimation.cmake:27
msgid ""
"OSGANIMATION_LIBRARY - The OSG library OSGANIMATION_LIBRARY_DEBUG - The "
"OSG debug library"
msgstr "OSGANIMATION_LIBRARY - OSG 库 OSGANIMATION_LIBRARY_DEBUG - OSG 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:6
msgid "FindosgDB"
msgstr "数据库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:10
msgid ""
"This is part of the ``Findosg*`` suite used to find OpenSceneGraph "
"components.  Each component is separate and you must opt in to each "
"module.  You must also opt into OpenGL and OpenThreads (and Producer if "
"needed) as these modules won't do it for you.  This is to allow you "
"control over your own system piece by piece in case you need to opt out of"
" certain components or change the Find behavior for a particular module "
"(perhaps because the default :module:`FindOpenGL` module doesn't work with"
" your system as an example).  If you want to use a more convenient module "
"that includes everything, use the :module:`FindOpenSceneGraph` instead of "
"the ``Findosg*.cmake`` modules."
msgstr ""
"这是用于查找 OpenSceneGraph 组件的“Findosg*”套件的一部分。每个组件都是独立的，您必须选择加入每个模块。您还必须选择加入 "
"OpenGL 和 OpenThreads（如果需要，还可以加入 "
"Producer），因为这些模块不会为您做这些。这是为了允许您逐个控制自己的系统，以防您需要选择退出某些组件或更改特定模块的查找行为（可能是因为默认的"
" FindOpenGL 模块不适用于您的系统为例）。如果您想使用包含所有内容的更方便的模块，请使用 FindOpenSceneGraph 而不是 "
"Findosg*.cmake 模块。"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:21
msgid "Locate osgDB This module defines:"
msgstr "定位osgDB这个模块定义："

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:24
msgid "``OSGDB_FOUND``"
msgstr "``OSGDB_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:24
msgid "Was osgDB found?"
msgstr "找到osgDB了吗？"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:27
msgid "``OSGDB_INCLUDE_DIR``"
msgstr "``OSGDB_INCLUDE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:27
msgid "Where to find the headers"
msgstr "在哪里可以找到标题"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:30
msgid "``OSGDB_LIBRARIES``"
msgstr "``OSGDB_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:30
msgid "The libraries to link against for the osgDB"
msgstr "osgDB 链接的库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:33
msgid "``OSGDB_LIBRARY``"
msgstr "``OSGDB_LIBRARY``"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:33
msgid "The osgDB library"
msgstr "osgDB 库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:36
msgid "``OSGDB_LIBRARY_DEBUG``"
msgstr "``OSGDB_LIBRARY_DEBUG``"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:36
msgid "The osgDB debug library"
msgstr "osgDB调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgDB.cmake:38
msgid "``$OSGDIR`` is an environment variable that would correspond to::"
msgstr "``$OSGDIR`` 是一个环境变量，对应于："

#: ../../cmake-prefix/src/cmake/Modules/FindosgFX.cmake:6
msgid "FindosgFX"
msgstr "FindosgFX"

#: ../../cmake-prefix/src/cmake/Modules/FindosgFX.cmake:21
msgid "Locate osgFX This module defines"
msgstr "定位osgFX这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgFX.cmake:23
msgid ""
"OSGFX_FOUND - Was osgFX found? OSGFX_INCLUDE_DIR - Where to find the "
"headers OSGFX_LIBRARIES - The libraries to link against for the osgFX (use"
" this)"
msgstr ""
"OSGFX_FOUND - 是否找到了 osgFX？ OSGFX_INCLUDE_DIR - 在哪里可以找到标题 OSGFX_LIBRARIES -"
" osgFX 链接的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgFX.cmake:27
msgid ""
"OSGFX_LIBRARY - The osgFX library OSGFX_LIBRARY_DEBUG - The osgFX debug "
"library"
msgstr "OSGFX_LIBRARY - osgFX 库 OSGFX_LIBRARY_DEBUG - osgFX 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgGA.cmake:6
msgid "FindosgGA"
msgstr "FindosgGA"

#: ../../cmake-prefix/src/cmake/Modules/FindosgGA.cmake:21
msgid "Locate osgGA This module defines"
msgstr "定位osgGA这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgGA.cmake:23
msgid ""
"OSGGA_FOUND - Was osgGA found? OSGGA_INCLUDE_DIR - Where to find the "
"headers OSGGA_LIBRARIES - The libraries to link against for the osgGA (use"
" this)"
msgstr ""
"OSGGA_FOUND - 是否找到了 osgGA？ OSGGA_INCLUDE_DIR - 在哪里可以找到标题 OSGGA_LIBRARIES -"
" osgGA 链接的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgGA.cmake:27
msgid ""
"OSGGA_LIBRARY - The osgGA library OSGGA_LIBRARY_DEBUG - The osgGA debug "
"library"
msgstr "OSGGA_LIBRARY - osgGA 库 OSGGA_LIBRARY_DEBUG - osgGA 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgIntrospection.cmake:6
msgid "FindosgIntrospection"
msgstr "Findosg自省"

#: ../../cmake-prefix/src/cmake/Modules/FindosgIntrospection.cmake:21
msgid "Locate osgINTROSPECTION This module defines"
msgstr "定位osgINTROSPECTION这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgIntrospection.cmake:23
msgid ""
"OSGINTROSPECTION_FOUND - Was osgIntrospection found? "
"OSGINTROSPECTION_INCLUDE_DIR - Where to find the headers "
"OSGINTROSPECTION_LIBRARIES - The libraries to link for osgIntrospection "
"(use this)"
msgstr ""
"OSGINTROSPECTION_FOUND - 是否找到了 osgIntrospection？ "
"OSGINTROSPECTION_INCLUDE_DIR - 在哪里可以找到标题 OSGINTROSPECTION_LIBRARIES - 链接到 "
"osgIntrospection 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgIntrospection.cmake:28
msgid ""
"OSGINTROSPECTION_LIBRARY - The osgIntrospection library "
"OSGINTROSPECTION_LIBRARY_DEBUG - The osgIntrospection debug library"
msgstr ""
"OSGINTROSPECTION_LIBRARY - osgIntrospection 库 "
"OSGINTROSPECTION_LIBRARY_DEBUG - osgIntrospection 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgManipulator.cmake:6
msgid "FindosgManipulator"
msgstr "FindosgManipulator"

#: ../../cmake-prefix/src/cmake/Modules/FindosgManipulator.cmake:21
msgid "Locate osgManipulator This module defines"
msgstr "定位osgManipulator这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgManipulator.cmake:23
msgid ""
"OSGMANIPULATOR_FOUND - Was osgManipulator found? "
"OSGMANIPULATOR_INCLUDE_DIR - Where to find the headers "
"OSGMANIPULATOR_LIBRARIES - The libraries to link for osgManipulator (use "
"this)"
msgstr ""
"OSGMANIPULATOR_FOUND - 是否找到了 osgManipulator？ OSGMANIPULATOR_INCLUDE_DIR - "
"在哪里可以找到标题 OSGMANIPULATOR_LIBRARIES - 链接到 osgManipulator 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgManipulator.cmake:28
msgid ""
"OSGMANIPULATOR_LIBRARY - The osgManipulator library "
"OSGMANIPULATOR_LIBRARY_DEBUG - The osgManipulator debug library"
msgstr ""
"OSGMANIPULATOR_LIBRARY - osgManipulator 库 OSGMANIPULATOR_LIBRARY_DEBUG - "
"osgManipulator 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgParticle.cmake:6
msgid "FindosgParticle"
msgstr "查找粒子"

#: ../../cmake-prefix/src/cmake/Modules/FindosgParticle.cmake:21
msgid "Locate osgParticle This module defines"
msgstr "定位osgParticle这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgParticle.cmake:23
msgid ""
"OSGPARTICLE_FOUND - Was osgParticle found? OSGPARTICLE_INCLUDE_DIR - Where"
" to find the headers OSGPARTICLE_LIBRARIES - The libraries to link for "
"osgParticle (use this)"
msgstr ""
"OSGPARTICLE_FOUND - 是否找到了 osgParticle？ OSGPARTICLE_INCLUDE_DIR - 在哪里可以找到标题"
" OSGPARTICLE_LIBRARIES - 链接到 osgParticle 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgParticle.cmake:27
msgid ""
"OSGPARTICLE_LIBRARY - The osgParticle library OSGPARTICLE_LIBRARY_DEBUG - "
"The osgParticle debug library"
msgstr ""
"OSGPARTICLE_LIBRARY - osgParticle 库 OSGPARTICLE_LIBRARY_DEBUG - "
"osgParticle 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgPresentation.cmake:6
msgid "FindosgPresentation"
msgstr "Findosg演示文稿"

#: ../../cmake-prefix/src/cmake/Modules/FindosgPresentation.cmake:21
msgid "Locate osgPresentation This module defines"
msgstr "定位osgPresentation这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgPresentation.cmake:23
msgid ""
"OSGPRESENTATION_FOUND - Was osgPresentation found? "
"OSGPRESENTATION_INCLUDE_DIR - Where to find the headers "
"OSGPRESENTATION_LIBRARIES - The libraries to link for osgPresentation (use"
" this)"
msgstr ""
"OSGPRESENTATION_FOUND - 是否找到了 osgPresentation？ OSGPRESENTATION_INCLUDE_DIR"
" - 在哪里可以找到标题 OSGPRESENTATION_LIBRARIES - 链接到 osgPresentation 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgPresentation.cmake:28
msgid ""
"OSGPRESENTATION_LIBRARY - The osgPresentation library "
"OSGPRESENTATION_LIBRARY_DEBUG - The osgPresentation debug library"
msgstr ""
"OSGPRESENTATION_LIBRARY - osgPresentation 库 OSGPRESENTATION_LIBRARY_DEBUG "
"- osgPresentation 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgPresentation.cmake:34
msgid ""
"Created by Eric Wing.  Modified to work with osgPresentation by Robert "
"Osfield, January 2012."
msgstr ""
"由 Eric Wing 创建。由 Robert Osfield 于 2012 年 1 月修改为与 osgPresentation 一起使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindosgProducer.cmake:6
msgid "FindosgProducer"
msgstr "FindosgProducer"

#: ../../cmake-prefix/src/cmake/Modules/FindosgProducer.cmake:21
msgid "Locate osgProducer This module defines"
msgstr "定位osgProducer这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgProducer.cmake:23
msgid ""
"OSGPRODUCER_FOUND - Was osgProducer found? OSGPRODUCER_INCLUDE_DIR - Where"
" to find the headers OSGPRODUCER_LIBRARIES - The libraries to link for "
"osgProducer (use this)"
msgstr ""
"OSGPRODUCER_FOUND - 是否找到了 osgProducer？ OSGPRODUCER_INCLUDE_DIR - "
"在哪里可以找到头文件 OSGPRODUCER_LIBRARIES - 链接到 osgProducer 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgProducer.cmake:27
msgid ""
"OSGPRODUCER_LIBRARY - The osgProducer library OSGPRODUCER_LIBRARY_DEBUG - "
"The osgProducer debug library"
msgstr ""
"OSGPRODUCER_LIBRARY - osgProducer 库 OSGPRODUCER_LIBRARY_DEBUG - "
"osgProducer 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgQt.cmake:6
msgid "FindosgQt"
msgstr "FindosgQt"

#: ../../cmake-prefix/src/cmake/Modules/FindosgQt.cmake:21
msgid "Locate osgQt This module defines"
msgstr "定位osgQt这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgQt.cmake:23
msgid ""
"OSGQT_FOUND - Was osgQt found? OSGQT_INCLUDE_DIR - Where to find the "
"headers OSGQT_LIBRARIES - The libraries to link for osgQt (use this)"
msgstr ""
"OSGQT_FOUND - 是否找到了 osgQt？ OSGQT_INCLUDE_DIR - 在哪里可以找到头文件 OSGQT_LIBRARIES "
"- 链接到 osgQt 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgQt.cmake:26
msgid ""
"OSGQT_LIBRARY - The osgQt library OSGQT_LIBRARY_DEBUG - The osgQt debug "
"library"
msgstr "OSGQT_LIBRARY - osgQt 库 OSGQT_LIBRARY_DEBUG - osgQt 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgQt.cmake:32
msgid ""
"Created by Eric Wing.  Modified to work with osgQt by Robert Osfield, "
"January 2012."
msgstr "由 Eric Wing 创建。由 Robert Osfield 于 2012 年 1 月修改为与 osgQt 一起使用。"

#: ../../cmake-prefix/src/cmake/Modules/FindosgShadow.cmake:6
msgid "FindosgShadow"
msgstr "FindosgShadow"

#: ../../cmake-prefix/src/cmake/Modules/FindosgShadow.cmake:21
msgid "Locate osgShadow This module defines"
msgstr "定位osgShadow这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgShadow.cmake:23
msgid ""
"OSGSHADOW_FOUND - Was osgShadow found? OSGSHADOW_INCLUDE_DIR - Where to "
"find the headers OSGSHADOW_LIBRARIES - The libraries to link for osgShadow"
" (use this)"
msgstr ""
"OSGSHADOW_FOUND - 是否找到了 osgShadow？ OSGSHADOW_INCLUDE_DIR - 在哪里可以找到标题 "
"OSGSHADOW_LIBRARIES - 链接到 osgShadow 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgShadow.cmake:27
msgid ""
"OSGSHADOW_LIBRARY - The osgShadow library OSGSHADOW_LIBRARY_DEBUG - The "
"osgShadow debug library"
msgstr ""
"OSGSHADOW_LIBRARY - osgShadow 库 OSGSHADOW_LIBRARY_DEBUG - osgShadow 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgSim.cmake:6
msgid "FindosgSim"
msgstr "FindosgSim"

#: ../../cmake-prefix/src/cmake/Modules/FindosgSim.cmake:21
msgid "Locate osgSim This module defines"
msgstr "找到osgSim这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgSim.cmake:23
msgid ""
"OSGSIM_FOUND - Was osgSim found? OSGSIM_INCLUDE_DIR - Where to find the "
"headers OSGSIM_LIBRARIES - The libraries to link for osgSim (use this)"
msgstr ""
"OSGSIM_FOUND - 是否找到了 osgSim？ OSGSIM_INCLUDE_DIR - 在哪里可以找到标题 "
"OSGSIM_LIBRARIES - 链接到 osgSim 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgSim.cmake:27
msgid ""
"OSGSIM_LIBRARY - The osgSim library OSGSIM_LIBRARY_DEBUG - The osgSim "
"debug library"
msgstr "OSGSIM_LIBRARY - osgSim 库 OSGSIM_LIBRARY_DEBUG - osgSim 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgTerrain.cmake:6
msgid "FindosgTerrain"
msgstr "Findosg地形"

#: ../../cmake-prefix/src/cmake/Modules/FindosgTerrain.cmake:21
msgid "Locate osgTerrain This module defines"
msgstr "定位osgTerrain这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgTerrain.cmake:23
msgid ""
"OSGTERRAIN_FOUND - Was osgTerrain found? OSGTERRAIN_INCLUDE_DIR - Where to"
" find the headers OSGTERRAIN_LIBRARIES - The libraries to link for "
"osgTerrain (use this)"
msgstr ""
"OSGTERRAIN_FOUND - 是否找到了 osgTerrain？ OSGTERRAIN_INCLUDE_DIR - 在哪里可以找到标题 "
"OSGTERRAIN_LIBRARIES - 链接到 osgTerrain 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgTerrain.cmake:27
msgid ""
"OSGTERRAIN_LIBRARY - The osgTerrain library OSGTERRAIN_LIBRARY_DEBUG - The"
" osgTerrain debug library"
msgstr ""
"OSGTERRAIN_LIBRARY - osgTerrain 库 OSGTERRAIN_LIBRARY_DEBUG - osgTerrain "
"调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgText.cmake:6
msgid "FindosgText"
msgstr "查找文本"

#: ../../cmake-prefix/src/cmake/Modules/FindosgText.cmake:21
msgid "Locate osgText This module defines"
msgstr "定位osgText这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgText.cmake:23
msgid ""
"OSGTEXT_FOUND - Was osgText found? OSGTEXT_INCLUDE_DIR - Where to find the"
" headers OSGTEXT_LIBRARIES - The libraries to link for osgText (use this)"
msgstr ""
"OSGTEXT_FOUND - 是否找到了 osgText？ OSGTEXT_INCLUDE_DIR - 在哪里可以找到标题 "
"OSGTEXT_LIBRARIES - 链接到 osgText 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgText.cmake:27
msgid ""
"OSGTEXT_LIBRARY - The osgText library OSGTEXT_LIBRARY_DEBUG - The osgText "
"debug library"
msgstr "OSGTEXT_LIBRARY - osgText 库 OSGTEXT_LIBRARY_DEBUG - osgText 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgUtil.cmake:6
msgid "FindosgUtil"
msgstr "FindosgUtil"

#: ../../cmake-prefix/src/cmake/Modules/FindosgUtil.cmake:21
msgid "Locate osgUtil This module defines"
msgstr "定位osgUtil这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgUtil.cmake:23
msgid ""
"OSGUTIL_FOUND - Was osgUtil found? OSGUTIL_INCLUDE_DIR - Where to find the"
" headers OSGUTIL_LIBRARIES - The libraries to link for osgUtil (use this)"
msgstr ""
"OSGUTIL_FOUND - 是否找到了 osgUtil？ OSGUTIL_INCLUDE_DIR - 在哪里可以找到标题 "
"OSGUTIL_LIBRARIES - 链接 osgUtil 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgUtil.cmake:27
msgid ""
"OSGUTIL_LIBRARY - The osgUtil library OSGUTIL_LIBRARY_DEBUG - The osgUtil "
"debug library"
msgstr "OSGUTIL_LIBRARY - osgUtil 库 OSGUTIL_LIBRARY_DEBUG - osgUtil 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgViewer.cmake:6
msgid "FindosgViewer"
msgstr "FindosgViewer"

#: ../../cmake-prefix/src/cmake/Modules/FindosgViewer.cmake:21
msgid "Locate osgViewer This module defines"
msgstr "定位osgViewer这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgViewer.cmake:23
msgid ""
"OSGVIEWER_FOUND - Was osgViewer found? OSGVIEWER_INCLUDE_DIR - Where to "
"find the headers OSGVIEWER_LIBRARIES - The libraries to link for osgViewer"
" (use this)"
msgstr ""
"OSGVIEWER_FOUND - 是否找到了 osgViewer？ OSGVIEWER_INCLUDE_DIR - 在哪里可以找到标题 "
"OSGVIEWER_LIBRARIES - 链接到 osgViewer 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgViewer.cmake:27
msgid ""
"OSGVIEWER_LIBRARY - The osgViewer library OSGVIEWER_LIBRARY_DEBUG - The "
"osgViewer debug library"
msgstr ""
"OSGVIEWER_LIBRARY - osgViewer 库 OSGVIEWER_LIBRARY_DEBUG - osgViewer 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgVolume.cmake:6
msgid "FindosgVolume"
msgstr "查找卷"

#: ../../cmake-prefix/src/cmake/Modules/FindosgVolume.cmake:21
msgid "Locate osgVolume This module defines"
msgstr "定位osgVolume这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgVolume.cmake:23
msgid ""
"OSGVOLUME_FOUND - Was osgVolume found? OSGVOLUME_INCLUDE_DIR - Where to "
"find the headers OSGVOLUME_LIBRARIES - The libraries to link for osgVolume"
" (use this)"
msgstr ""
"OSGVOLUME_FOUND - 是否找到了 osgVolume？ OSGVOLUME_INCLUDE_DIR - 在哪里可以找到标题 "
"OSGVOLUME_LIBRARIES - 链接到 osgVolume 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgVolume.cmake:27
msgid ""
"OSGVOLUME_LIBRARY - The osgVolume library OSGVOLUME_LIBRARY_DEBUG - The "
"osgVolume debug library"
msgstr ""
"OSGVOLUME_LIBRARY - osgVolume 库 OSGVOLUME_LIBRARY_DEBUG - osgVolume 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgWidget.cmake:6
msgid "FindosgWidget"
msgstr "查找工具"

#: ../../cmake-prefix/src/cmake/Modules/FindosgWidget.cmake:21
msgid "Locate osgWidget This module defines"
msgstr "定位osgWidget这个模块定义"

#: ../../cmake-prefix/src/cmake/Modules/FindosgWidget.cmake:23
msgid ""
"OSGWIDGET_FOUND - Was osgWidget found? OSGWIDGET_INCLUDE_DIR - Where to "
"find the headers OSGWIDGET_LIBRARIES - The libraries to link for osgWidget"
" (use this)"
msgstr ""
"OSGWIDGET_FOUND - 是否找到了 osgWidget？ OSGWIDGET_INCLUDE_DIR - 在哪里可以找到标题 "
"OSGWIDGET_LIBRARIES - 链接到 osgWidget 的库（使用这个）"

#: ../../cmake-prefix/src/cmake/Modules/FindosgWidget.cmake:27
msgid ""
"OSGWIDGET_LIBRARY - The osgWidget library OSGWIDGET_LIBRARY_DEBUG - The "
"osgWidget debug library"
msgstr ""
"OSGWIDGET_LIBRARY - osgWidget 库 OSGWIDGET_LIBRARY_DEBUG - osgWidget 调试库"

#: ../../cmake-prefix/src/cmake/Modules/FindosgWidget.cmake:33
msgid ""
"FindosgWidget.cmake tweaked from Findosg* suite as created by Eric Wing."
msgstr "FindosgWidget.cmake 根据 Eric Wing 创建的 Findosg* 套件进行了调整。"

#: ../../cmake-prefix/src/cmake/Modules/Findosg_functions.cmake:6
msgid "Findosg_functions"
msgstr "查找函数"

#: ../../cmake-prefix/src/cmake/Modules/Findosg_functions.cmake:12
msgid ""
"This CMake file contains two macros to assist with searching for OSG "
"libraries and nodekits.  Please see FindOpenSceneGraph.cmake for full "
"documentation."
msgstr ""
"这个 CMake 文件包含两个宏来帮助搜索 OSG 库和 nodekit。请参阅 FindOpenSceneGraph.cmake 以获取完整文档。"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:6
msgid "FindwxWidgets"
msgstr "FindwxWidgets"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:8
msgid "Find a wxWidgets (a.k.a., wxWindows) installation."
msgstr "查找 wxWidgets（又名 wxWindows）安装。"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:10
msgid ""
"This module finds if wxWidgets is installed and selects a default "
"configuration to use.  wxWidgets is a modular library.  To specify the "
"modules that you will use, you need to name them as components to the "
"package:"
msgstr ""
"该模块查找是否安装了 wxWidgets 并选择要使用的默认配置。 wxWidgets "
"是一个模块化的库。要指定您将使用的模块，您需要将它们命名为包的组件："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:15
msgid ""
"find_package(wxWidgets COMPONENTS core base ... OPTIONAL_COMPONENTS net "
"...)"
msgstr ""
"find_package(wxWidgets COMPONENTS core base ... OPTIONAL_COMPONENTS net "
"...)"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:17
msgid ""
"Support for :command:`find_package` version argument; ``webview`` "
"component."
msgstr "支持 :command:`find_package` 版本参数； ``webview`` 组件。"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:20
msgid "``OPTIONAL_COMPONENTS`` support."
msgstr "``OPTIONAL_COMPONENTS`` 支持。"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:23
msgid ""
"There are two search branches: a windows style and a unix style.  For "
"windows, the following variables are searched for and set to defaults in "
"case of multiple choices.  Change them if the defaults are not desired "
"(i.e., these are the only variables you should change to select a "
"configuration):"
msgstr ""
"有两个搜索分支：windows 风格和 unix 风格。对于 "
"windows，在多选的情况下，搜索以下变量并设置为默认值。如果不需要默认值，请更改它们（即，这些是您应该更改以选择配置的唯一变量）："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:44
msgid ""
"For unix style it uses the wx-config utility.  You can select between "
"debug/release, unicode/ansi, universal/non-universal, and static/shared in"
" the QtDialog or ccmake interfaces by turning ON/OFF the following "
"variables:"
msgstr ""
"对于 unix 风格，它使用 wx-config 实用程序。您可以通过打开/关闭以下变量在 QtDialog 或 ccmake "
"界面中的调试/发布、unicode/ansi、通用/非通用和静态/共享之间进行选择："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:56
msgid ""
"There is also a wxWidgets_CONFIG_OPTIONS variable for all other options "
"that need to be passed to the wx-config utility.  For example, to use the "
"base toolkit found in the /usr/local path, set the variable (before "
"calling the FIND_PACKAGE command) as such:"
msgstr ""
"对于需要传递给 wx-config 实用程序的所有其他选项，还有一个 wxWidgets_CONFIG_OPTIONS 变量。例如，要使用在 "
"/usr/local 路径中找到的基本工具包，请将变量（在调用 FIND_PACKAGE 命令之前）设置为："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:67
msgid ""
"The following are set after the configuration is done for both windows and"
" unix style:"
msgstr "windows和unix风格配置完成后设置如下："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:89
msgid ""
"The following environment variables can be used as hints: ``WX_CONFIG``, "
"``WXRC_CMD``."
msgstr "以下环境变量可用作提示：``WX_CONFIG``、``WXRC_CMD``。"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:94
msgid "Sample usage:"
msgstr "示例用法："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWidgets.cmake:108
msgid "If wxWidgets is required (i.e., not an optional part):"
msgstr "如果需要 wxWidgets（即，不是可选部分）："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:6
msgid "FindwxWindows"
msgstr "FindwxWindows"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:10
msgid "Replaced by :module:`FindwxWidgets`."
msgstr "替换为:module:`FindwxWidgets`。"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:12
msgid "Find wxWindows (wxWidgets) installation"
msgstr "找到wxWindows(wxWidgets) 安装"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:14
msgid ""
"This module finds if wxWindows/wxWidgets is installed and determines where"
" the include files and libraries are.  It also determines what the name of"
" the library is.  This code sets the following variables:"
msgstr "该模块查找是否安装了 wxWindows/wxWidgets 并确定包含文件和库的位置。它还确定库的名称是什么。此代码设置以下变量："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:35
msgid "OPTIONS If you need OpenGL support please"
msgstr "选项 如果您需要 OpenGL 支持，请"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:41
msgid "in your CMakeLists.txt *before* you include this file."
msgstr "在您的 CMakeLists.txt *之前*您包含此文件。"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:49
msgid ""
"For convenience include Use_wxWindows.cmake in your project's "
"CMakeLists.txt using "
"include(${CMAKE_CURRENT_LIST_DIR}/Use_wxWindows.cmake)."
msgstr ""
"为方便起见，使用 include(${CMAKE_CURRENT_LIST_DIR}/Use_wxWindows.cmake) 在项目的 "
"CMakeLists.txt 中包含 Use_wxWindows.cmake。"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:53
#: ../../cmake-prefix/src/cmake/Modules/UsewxWidgets.cmake:14
msgid "USAGE"
msgstr "用法"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:62
msgid ""
"NOTES wxWidgets 2.6.x is supported for monolithic builds e.g. compiled in "
"wx/build/msw dir as:"
msgstr "注释 wxWidgets 2.6.x 支持整体构建，例如在 wx/build/msw 目录中编译为："

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:71
#: ../../cmake-prefix/src/cmake/Modules/UsewxWidgets.cmake:26
msgid "DEPRECATED"
msgstr "弃用"

#: ../../cmake-prefix/src/cmake/Modules/FindwxWindows.cmake:82
msgid "AUTHOR Jan Woetzel (07/2003-01/2006)"
msgstr "作者 Jan Woetzel (07/2003-01/2006)"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:6
msgid "FortranCInterface"
msgstr "FortranC接口"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:8
msgid "Fortran/C Interface Detection"
msgstr "Fortran/C 接口检测"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:10
msgid ""
"This module automatically detects the API by which C and Fortran languages"
" interact."
msgstr "该模块自动检测 C 和 Fortran 语言交互的 API。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:16
msgid "Variables that indicate if the mangling is found:"
msgstr "指示是否找到重整的变量："

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:19
msgid "``FortranCInterface_GLOBAL_FOUND``"
msgstr "``FortranCInterface_GLOBAL_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:19
msgid "Global subroutines and functions."
msgstr "全局子程序和函数。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:22
msgid "``FortranCInterface_MODULE_FOUND``"
msgstr "``FortranCInterface_MODULE_FOUND``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:22
msgid "Module subroutines and functions (declared by \"MODULE PROCEDURE\")."
msgstr "模块子例程和函数（由“MODULE PROCEDURE”声明）。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:24
msgid ""
"This module also provides the following variables to specify the detected "
"mangling, though a typical use case does not need to reference them and "
"can use the `Module Functions`_ below."
msgstr "该模块还提供了以下变量来指定检测到的重整，尽管典型的用例不需要引用它们并且可以使用下面的“模块功能”。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:29
msgid "``FortranCInterface_GLOBAL_PREFIX``"
msgstr "``FortranCInterface_GLOBAL_PREFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:29
msgid "Prefix for a global symbol without an underscore."
msgstr "没有下划线的全局符号的前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:32
msgid "``FortranCInterface_GLOBAL_SUFFIX``"
msgstr "``FortranCInterface_GLOBAL_SUFFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:32
msgid "Suffix for a global symbol without an underscore."
msgstr "不带下划线的全局符号的后缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:36
msgid "``FortranCInterface_GLOBAL_CASE``"
msgstr "``FortranCInterface_GLOBAL_CASE``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:35
msgid ""
"The case for a global symbol without an underscore, either ``UPPER`` or "
"``LOWER``."
msgstr "没有下划线的全局符号的情况，``UPPER`` 或 ``LOWER``。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:39
msgid "``FortranCInterface_GLOBAL__PREFIX``"
msgstr "``FortranCInterface_GLOBAL__PREFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:39
msgid "Prefix for a global symbol with an underscore."
msgstr "带下划线的全局符号的前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:42
msgid "``FortranCInterface_GLOBAL__SUFFIX``"
msgstr "``FortranCInterface_GLOBAL__SUFFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:42
msgid "Suffix for a global symbol with an underscore."
msgstr "带下划线的全局符号的后缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:46
msgid "``FortranCInterface_GLOBAL__CASE``"
msgstr "``FortranCInterface_GLOBAL__CASE``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:45
msgid ""
"The case for a global symbol with an underscore, either ``UPPER`` or "
"``LOWER``."
msgstr "带有下划线的全局符号的大小写，``UPPER`` 或 ``LOWER``。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:49
msgid "``FortranCInterface_MODULE_PREFIX``"
msgstr "``FortranCInterface_MODULE_PREFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:49
msgid "Prefix for a module symbol without an underscore."
msgstr "没有下划线的模块符号的前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:53
msgid "``FortranCInterface_MODULE_MIDDLE``"
msgstr "``FortranCInterface_MODULE_MIDDLE``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:52
msgid ""
"Middle of a module symbol without an underscore that appears between the "
"name of the module and the name of the symbol."
msgstr "模块名称和符号名称之间不带下划线的模块符号中间。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:56
msgid "``FortranCInterface_MODULE_SUFFIX``"
msgstr "``FortranCInterface_MODULE_SUFFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:56
msgid "Suffix for a module symbol without an underscore."
msgstr "没有下划线的模块符号的后缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:60
msgid "``FortranCInterface_MODULE_CASE``"
msgstr "``FortranCInterface_MODULE_CASE``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:59
msgid ""
"The case for a module symbol without an underscore, either ``UPPER`` or "
"``LOWER``."
msgstr "没有下划线的模块符号的大小写，``UPPER`` 或 ``LOWER``。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:63
msgid "``FortranCInterface_MODULE__PREFIX``"
msgstr "``FortranCInterface_MODULE__PREFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:63
msgid "Prefix for a module symbol with an underscore."
msgstr "带有下划线的模块符号的前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:67
msgid "``FortranCInterface_MODULE__MIDDLE``"
msgstr "``FortranCInterface_MODULE__MIDDLE``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:66
msgid ""
"Middle of a module symbol with an underscore that appears between the name"
" of the module and the name of the symbol."
msgstr "模块名称和符号名称之间出现下划线的模块符号中间。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:70
msgid "``FortranCInterface_MODULE__SUFFIX``"
msgstr "``FortranCInterface_MODULE__SUFFIX``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:70
msgid "Suffix for a module symbol with an underscore."
msgstr "带下划线的模块符号的后缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:74
msgid "``FortranCInterface_MODULE__CASE``"
msgstr "``FortranCInterface_MODULE__CASE``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:73
msgid ""
"The case for a module symbol with an underscore, either ``UPPER`` or "
"``LOWER``."
msgstr "带有下划线的模块符号的大小写，``UPPER`` 或 ``LOWER``。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:81
msgid ""
"The ``FortranCInterface_HEADER`` function is provided to generate a C "
"header file containing macros to mangle symbol names::"
msgstr "``FortranCInterface_HEADER`` 函数被提供来生成一个包含宏的 C 头文件来破坏符号名称："

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:89
msgid "It generates in ``<file>`` definitions of the following macros::"
msgstr "它在以下宏的 ``<file>`` 定义中生成："

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:96
msgid ""
"These macros mangle four categories of Fortran symbols, respectively:"
msgstr "这些宏分别破坏了四类 Fortran 符号："

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:98
msgid "Global symbols without '_': ``call mysub()``"
msgstr "没有“_”的全局符号：``调用 mysub()``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:99
msgid "Global symbols with '_'   : ``call my_sub()``"
msgstr "带有“_”的全局符号：``call my_sub()``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:100
msgid "Module symbols without '_': ``use mymod; call mysub()``"
msgstr "不带“_”的模块符号：``使用 mymod；调用 mysub()``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:101
msgid "Module symbols with '_'   : ``use mymod; call my_sub()``"
msgstr "带有“_”的模块符号：``use mymod;调用 my_sub()``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:103
msgid ""
"If mangling for a category is not known, its macro is left undefined. All "
"macros require raw names in both lower case and upper case."
msgstr "如果未知类别的重整，则其宏未定义。所有宏都需要小写和大写的原始名称。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:110
msgid "``MACRO_NAMESPACE``"
msgstr "``MACRO_NAMESPACE``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:109
msgid ""
"Replace the default ``FortranCInterface_`` prefix with a given namespace "
"``<macro-ns>``."
msgstr "将默认的“FortranCInterface_”前缀替换为给定的命名空间“<macro-ns>”。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:119
msgid "``SYMBOLS``"
msgstr "``符号``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:113
msgid ""
"List symbols to mangle automatically with C preprocessor definitions::"
msgstr "列出要使用 C 预处理器定义自动处理的符号："

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:118
msgid ""
"If the mangling for some symbol is not known then no preprocessor "
"definition is created, and a warning is displayed."
msgstr "如果不知道某个符号的重整，则不会创建预处理器定义，并显示警告。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:122
msgid "``SYMBOL_NAMESPACE``"
msgstr "``SYMBOL_NAMESPACE``"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:122
msgid ""
"Prefix all preprocessor definitions generated by the ``SYMBOLS`` option "
"with a given namespace ``<ns>``."
msgstr "使用给定的命名空间“<ns>”为“SYMBOLS”选项生成的所有预处理器定义添加前缀。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:127
msgid ""
"The ``FortranCInterface_VERIFY`` function is provided to verify that the "
"Fortran and C/C++ compilers work together::"
msgstr "``FortranCInterface_VERIFY`` 函数用于验证 Fortran 和 C/C++ 编译器是否协同工作："

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:132
msgid ""
"It tests whether a simple test executable using Fortran and C (and C++ "
"when the CXX option is given) compiles and links successfully.  The result"
" is stored in the cache entry ``FortranCInterface_VERIFIED_C`` (or "
"``FortranCInterface_VERIFIED_CXX`` if ``CXX`` is given) as a boolean. If "
"the check fails and ``QUIET`` is not given the function terminates with a "
"fatal error message describing the problem.  The purpose of this check is "
"to stop a build early for incompatible compiler combinations.  The test is"
" built in the ``Release`` configuration."
msgstr ""
"它测试使用 Fortran 和 C（以及 CXX 选项时使用 "
"C++）的简单测试可执行文件是否成功编译和链接。结果作为布尔值存储在缓存条目“FortranCInterface_VERIFIED_C”（或“FortranCInterface_VERIFIED_CXX”，如果给定“CXX”）中。如果检查失败并且未给出“QUIET”，则该函数将终止并显示一条描述问题的致命错误消息。此检查的目的是针对不兼容的编译器组合提前停止构建。测试建立在“发布”配置中。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:149
msgid ""
"This creates a \"FC.h\" header that defines mangling macros "
"``FC_GLOBAL()``, ``FC_GLOBAL_()``, ``FC_MODULE()``, and ``FC_MODULE_()``."
msgstr ""
"这将创建一个“FC.h”标头，它定义了处理宏 ``FC_GLOBAL()``、``FC_GLOBAL_()``、``FC_MODULE()`` 和 "
"``FC_MODULE_()``。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:160
msgid ""
"This creates a \"FCMangle.h\" header that defines the same ``FC_*()`` "
"mangling macros as the previous example plus preprocessor symbols "
"``FC_mysub`` and ``FC_mymod_my_sub``."
msgstr ""
"这将创建一个“FCMangle.h”标头，它定义了与前一个示例相同的 ``FC_*()`` 修饰宏以及预处理器符号 ``FC_mysub`` 和 "
"``FC_mymod_my_sub``。"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:165
msgid "Additional Manglings"
msgstr "额外的加工"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:167
msgid ""
"FortranCInterface is aware of possible ``GLOBAL`` and ``MODULE`` manglings"
" for many Fortran compilers, but it also provides an interface to specify "
"new possible manglings.  Set the variables::"
msgstr ""
"FortranCInterface 知道许多 Fortran 编译器可能的 ``GLOBAL`` 和 ``MODULE`` "
"manglings，但它也提供了一个接口来指定新的可能的 manglings。设置变量 ::"

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:174
msgid ""
"before including FortranCInterface to specify manglings of the symbols "
"``MySub``, ``My_Sub``, ``MyModule:MySub``, and ``My_Module:My_Sub``. For "
"example, the code:"
msgstr ""
"在包含 FortranCInterface 以指定符号 ``MySub``、``My_Sub``、``MyModule:MySub`` 和 "
"``My_Module:My_Sub`` 之前。例如，代码："

#: ../../cmake-prefix/src/cmake/Modules/FortranCInterface.cmake:187
msgid ""
"tells FortranCInterface to try given ``GLOBAL`` and ``MODULE`` manglings. "
"(The carets point at raw symbol names for clarity in this example but are "
"not needed.)"
msgstr ""
"告诉 FortranCInterface 尝试给定的 ``GLOBAL`` 和 ``MODULE`` manglings。 "
"（为了清晰起见，插入符号指向原始符号名称，但不是必需的。）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:6
msgid "GNUInstallDirs"
msgstr "GNU 安装目录"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:8
msgid "Define GNU standard installation directories"
msgstr "定义 GNU 标准安装目录"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:10
msgid ""
"Provides install directory variables as defined by the `GNU Coding "
"Standards`_."
msgstr "提供由“GNU 编码标准”定义的安装目录变量。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:18
msgid "Inclusion of this module defines the following variables:"
msgstr "包含此模块定义了以下变量："

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:20
msgid "``CMAKE_INSTALL_<dir>``"
msgstr "``CMAKE_INSTALL_<目录>``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:22
msgid ""
"Destination for files of a given type.  This value may be passed to the "
"``DESTINATION`` options of :command:`install` commands for the "
"corresponding file type.  It should typically be a path relative to the "
"installation prefix so that it can be converted to an absolute path in a "
"relocatable way (see ``CMAKE_INSTALL_FULL_<dir>``). However, an absolute "
"path is also allowed."
msgstr ""
"给定类型文件的目的地。该值可以传递给相应文件类型的 :command:`install` 命令的 ``DESTINATION`` "
"选项。它通常应该是相对于安装前缀的路径，以便可以以可重定位的方式将其转换为绝对路径（请参阅 "
"``CMAKE_INSTALL_FULL_<dir>``）。但是，也允许使用绝对路径。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:29
msgid "``CMAKE_INSTALL_FULL_<dir>``"
msgstr "``CMAKE_INSTALL_FULL_<目录>``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:31
msgid ""
"The absolute path generated from the corresponding ``CMAKE_INSTALL_<dir>``"
" value.  If the value is not already an absolute path, an absolute path is"
" constructed typically by prepending the value of the "
":variable:`CMAKE_INSTALL_PREFIX` variable.  However, there are some "
"`special cases`_ as documented below."
msgstr ""
"从相应的 ``CMAKE_INSTALL_<dir>`` 值生成的绝对路径。如果该值还不是绝对路径，则通常通过在 "
":variable:`CMAKE_INSTALL_PREFIX` 变量的值前添加绝对路径来构造绝对路径。但是，有一些“特殊情况”_，如下所述。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:37
msgid "where ``<dir>`` is one of:"
msgstr "其中 ``<dir>`` 是以下之一："

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:39
msgid "``BINDIR``"
msgstr "``BINDIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:40
msgid "user executables (``bin``)"
msgstr "用户可执行文件（``bin``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:41
msgid "``SBINDIR``"
msgstr "``SBINDIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:42
msgid "system admin executables (``sbin``)"
msgstr "系统管理员可执行文件（``sbin``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:43
msgid "``LIBEXECDIR``"
msgstr "``LIBEXECDIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:44
msgid "program executables (``libexec``)"
msgstr "程序可执行文件（``libexec``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:45
msgid "``SYSCONFDIR``"
msgstr "``SYSCONFDIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:46
msgid "read-only single-machine data (``etc``)"
msgstr "只读单机数据（``etc``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:47
msgid "``SHAREDSTATEDIR``"
msgstr "``共享状态目录``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:48
msgid "modifiable architecture-independent data (``com``)"
msgstr "可修改的独立于架构的数据（``com``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:49
msgid "``LOCALSTATEDIR``"
msgstr "``本地状态目录``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:50
msgid "modifiable single-machine data (``var``)"
msgstr "可修改的单机数据（``var``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:52
msgid "``RUNSTATEDIR``"
msgstr "``RUNSTATEDIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:52
msgid "run-time variable data (``LOCALSTATEDIR/run``)"
msgstr "运行时变量数据（``LOCALSTATEDIR/run``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:57
msgid "``LIBDIR``"
msgstr "``LIBDIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:55
msgid "object code libraries (``lib`` or ``lib64``)"
msgstr "目标代码库（``lib`` 或 ``lib64``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:57
msgid ""
"On Debian, this may be ``lib/<multiarch-tuple>`` when "
":variable:`CMAKE_INSTALL_PREFIX` is ``/usr``."
msgstr ""
"在 Debian 上，这可能是 ``lib/<multiarch-tuple>`` 当 "
":variable:`CMAKE_INSTALL_PREFIX` 是 ``/usr`` 时。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:59
msgid "``INCLUDEDIR``"
msgstr "``包括目录``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:60
msgid "C header files (``include``)"
msgstr "C 头文件（``include``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:61
msgid "``OLDINCLUDEDIR``"
msgstr "``OLDINCLUDEDIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:62
msgid "C header files for non-gcc (``/usr/include``)"
msgstr "非 gcc 的 C 头文件（``/usr/include``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:63
msgid "``DATAROOTDIR``"
msgstr "``数据根目录``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:64
msgid "read-only architecture-independent data root (``share``)"
msgstr "只读架构独立数据根（``share``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:65
msgid "``DATADIR``"
msgstr "``数据目录``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:66
msgid "read-only architecture-independent data (``DATAROOTDIR``)"
msgstr "只读架构独立数据（``DATAROOTDIR``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:67
msgid "``INFODIR``"
msgstr "``INFODIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:68
msgid "info documentation (``DATAROOTDIR/info``)"
msgstr "信息文档（``DATAROOTDIR/info``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:69
msgid "``LOCALEDIR``"
msgstr "``本地目录``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:70
msgid "locale-dependent data (``DATAROOTDIR/locale``)"
msgstr "区域设置相关数据（``DATAROOTDIR/locale``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:71
msgid "``MANDIR``"
msgstr "``曼迪尔``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:72
msgid "man documentation (``DATAROOTDIR/man``)"
msgstr "man 文档（``DATAROOTDIR/man``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:74
msgid "``DOCDIR``"
msgstr "``DOCDIR``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:74
msgid "documentation root (``DATAROOTDIR/doc/PROJECT_NAME``)"
msgstr "文档根目录（``DATAROOTDIR/doc/PROJECT_NAME``）"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:76
msgid ""
"If the includer does not define a value the above-shown default will be "
"used and the value will appear in the cache for editing by the user."
msgstr "如果包含器未定义值，将使用上面显示的默认值，并且该值将出现在缓存中以供用户编辑。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:80
msgid "Special Cases"
msgstr "特别案例"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:84
msgid ""
"The following values of :variable:`CMAKE_INSTALL_PREFIX` are special:"
msgstr ":variable:`CMAKE_INSTALL_PREFIX` 的以下值是特殊的："

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:86
msgid "``/``"
msgstr "``/``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:88
msgid ""
"For ``<dir>`` other than the ``SYSCONFDIR``, ``LOCALSTATEDIR`` and "
"``RUNSTATEDIR``, the value of ``CMAKE_INSTALL_<dir>`` is prefixed with "
"``usr/`` if it is not user-specified as an absolute path. For example, the"
" ``INCLUDEDIR`` value ``include`` becomes ``usr/include``. This is "
"required by the `GNU Coding Standards`_, which state:"
msgstr ""
"对于除了``SYSCONFDIR``、``LOCALSTATEDIR`` 和``RUNSTATEDIR`` "
"之外的``<dir>``，``CMAKE_INSTALL_<dir>`` 的值以``usr/`` "
"为前缀，如果它不是用户指定的绝对路径。例如，``INCLUDEDIR`` 值``include`` 变为``usr/include``。这是`GNU"
" 编码标准`_ 所要求的，其中规定："

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:94
msgid ""
"When building the complete GNU system, the prefix will be empty and "
"``/usr`` will be a symbolic link to ``/``."
msgstr "在构建完整的 GNU 系统时，前缀将为空，而 ``/usr`` 将是指向 ``/`` 的符号链接。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:97
msgid "``/usr``"
msgstr "``/usr``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:99
msgid ""
"For ``<dir>`` equal to ``SYSCONFDIR``, ``LOCALSTATEDIR`` or "
"``RUNSTATEDIR``, the ``CMAKE_INSTALL_FULL_<dir>`` is computed by "
"prepending just ``/`` to the value of ``CMAKE_INSTALL_<dir>`` if it is not"
" user-specified as an absolute path. For example, the ``SYSCONFDIR`` value"
" ``etc`` becomes ``/etc``. This is required by the `GNU Coding "
"Standards`_."
msgstr ""
"对于等于“SYSCONFDIR”、“LOCALSTATEDIR”或“RUNSTATEDIR”的“<dir>”，“CMAKE_INSTALL_FULL_<dir>”是通过在值前加上“/”来计算的``CMAKE_INSTALL_<dir>``"
" 如果它不是用户指定的绝对路径。例如，``SYSCONFDIR`` 值``etc`` 变成``/etc``。这是`GNU 编码标准`_ 所要求的。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:106
msgid "``/opt/...``"
msgstr "``/选择/...``"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:108
msgid ""
"For ``<dir>`` equal to ``SYSCONFDIR``, ``LOCALSTATEDIR`` or "
"``RUNSTATEDIR``, the ``CMAKE_INSTALL_FULL_<dir>`` is computed by "
"*appending* the prefix to the value of ``CMAKE_INSTALL_<dir>`` if it is "
"not user-specified as an absolute path. For example, the ``SYSCONFDIR`` "
"value ``etc`` becomes ``/etc/opt/...``. This is defined by the `Filesystem"
" Hierarchy Standard`_."
msgstr ""
"对于 ``<dir>`` 等于 ``SYSCONFDIR``、``LOCALSTATEDIR`` 或 "
"``RUNSTATEDIR``，``CMAKE_INSTALL_FULL_<dir>`` 是通过*附加*前缀到 ` "
"`CMAKE_INSTALL_<dir>`` 如果它不是用户指定的绝对路径。例如，``SYSCONFDIR`` 值``etc`` "
"变成``/etc/opt/...``。这是由“文件系统层次结构标准”定义的。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:115
msgid "This behavior does not apply to paths under ``/opt/homebrew/...``."
msgstr "此行为不适用于“/opt/homebrew/...”下的路径。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:120
msgid "Macros"
msgstr "宏指令"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:130
msgid ""
"Set the given variable ``absvar`` to the absolute path contained within "
"the variable ``var``.  This is to allow the computation of an absolute "
"path, accounting for all the special cases documented above.  While this "
"macro is used to compute the various ``CMAKE_INSTALL_FULL_<dir>`` "
"variables, it is exposed publicly to allow users who create additional "
"path variables to also compute absolute paths where necessary, using the "
"same logic.  ``dirname`` is the directory name to get, e.g. ``BINDIR``."
msgstr ""
"将给定变量“absvar”设置为变量“var”中包含的绝对路径。这是为了允许计算绝对路径，考虑到上面记录的所有特殊情况。虽然此宏用于计算各种“CMAKE_INSTALL_FULL_<dir>”变量，但它是公开公开的，以允许创建其他路径变量的用户也可以在必要时使用相同的逻辑计算绝对路径。"
" ``dirname`` 是要获取的目录名称，例如``BINDIR``。"

#: ../../cmake-prefix/src/cmake/Modules/GNUInstallDirs.cmake:139
msgid ""
"Added the ``<dirname>`` parameter.  Previous versions of CMake passed this"
" value through the variable ``${dir}``."
msgstr "添加了``<dirname>`` 参数。以前版本的 CMake 通过变量“${dir}”传递这个值。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:6
msgid "GenerateExportHeader"
msgstr "生成导出头"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:8
msgid "Function for generation of export macros for libraries"
msgstr "为库生成导出宏的函数"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:10
msgid "This module provides the function ``GENERATE_EXPORT_HEADER()``."
msgstr "该模块提供函数``GENERATE_EXPORT_HEADER()``。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:12
msgid ""
"Added support for C projects.  Previous versions supported C++ project "
"only."
msgstr "添加了对 C 项目的支持。以前的版本仅支持 C++ 项目。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:15
msgid ""
"The ``GENERATE_EXPORT_HEADER`` function can be used to generate a file "
"suitable for preprocessor inclusion which contains EXPORT macros to be "
"used in library classes::"
msgstr ""
"``GENERATE_EXPORT_HEADER`` 函数可用于生成适合预处理器包含的文件，其中包含要在库类中使用的 EXPORT 宏："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:33
msgid ""
"The target properties :prop_tgt:`CXX_VISIBILITY_PRESET "
"<<LANG>_VISIBILITY_PRESET>` and :prop_tgt:`VISIBILITY_INLINES_HIDDEN` can "
"be used to add the appropriate compile flags for targets.  See the "
"documentation of those target properties, and the convenience variables "
":variable:`CMAKE_CXX_VISIBILITY_PRESET <CMAKE_<LANG>_VISIBILITY_PRESET>` "
"and :variable:`CMAKE_VISIBILITY_INLINES_HIDDEN`."
msgstr ""
"目标属性 :prop_tgt:`CXX_VISIBILITY_PRESET <<LANG>_VISIBILITY_PRESET>` 和 "
":prop_tgt:`VISIBILITY_INLINES_HIDDEN` "
"可用于为目标添加适当的编译标志。请参阅这些目标属性的文档，以及方便的变量 :variable:`CMAKE_CXX_VISIBILITY_PRESET "
"<CMAKE_<LANG>_VISIBILITY_PRESET>` 和 :variable:`CMAKE_VISIBILITY_INLINES_HIDDEN`。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:40
msgid ""
"By default ``GENERATE_EXPORT_HEADER()`` generates macro names in a file "
"name determined by the name of the library.  This means that in the "
"simplest case, users of ``GenerateExportHeader`` will be equivalent to:"
msgstr ""
"默认情况下，``GENERATE_EXPORT_HEADER()`` "
"在由库名称确定的文件名中生成宏名称。这意味着在最简单的情况下，``GenerateExportHeader`` 的用户将等同于："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:57
msgid "And in the ABI header files:"
msgstr "在 ABI 头文件中："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:67
msgid ""
"The CMake fragment will generate a file in the "
"``${CMAKE_CURRENT_BINARY_DIR}`` called ``somelib_export.h`` containing the"
" macros ``SOMELIB_EXPORT``, ``SOMELIB_NO_EXPORT``, ``SOMELIB_DEPRECATED``,"
" ``SOMELIB_DEPRECATED_EXPORT`` and ``SOMELIB_DEPRECATED_NO_EXPORT``. They "
"will be followed by content taken from the variable specified by the "
"``CUSTOM_CONTENT_FROM_VARIABLE`` option, if any. The resulting file should"
" be installed with other headers in the library."
msgstr ""
"CMake "
"片段将在“${CMAKE_CURRENT_BINARY_DIR}”中生成一个名为“somelib_export.h”的文件，其中包含宏“SOMELIB_EXPORT”、“SOMELIB_NO_EXPORT”、“SOMELIB_DEPRECATED”、“SOMELIB_DEPRECATED_EXPORT”"
" ` 和 "
"``SOMELIB_DEPRECATED_NO_EXPORT``。它们后面将是从“CUSTOM_CONTENT_FROM_VARIABLE”选项指定的变量中获取的内容，如果有的话。生成的文件应与库中的其他标头一起安装。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:75
msgid ""
"The ``BASE_NAME`` argument can be used to override the file name and the "
"names used for the macros:"
msgstr "``BASE_NAME`` 参数可用于覆盖文件名和用于宏的名称："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:86
msgid ""
"Generates a file called ``other_name_export.h`` containing the macros "
"``OTHER_NAME_EXPORT``, ``OTHER_NAME_NO_EXPORT`` and "
"``OTHER_NAME_DEPRECATED`` etc."
msgstr ""
"生成一个名为“other_name_export.h”的文件，其中包含宏“OTHER_NAME_EXPORT”、“OTHER_NAME_NO_EXPORT”和“OTHER_NAME_DEPRECATED”等。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:90
msgid ""
"The ``BASE_NAME`` may be overridden by specifying other options in the "
"function.  For example:"
msgstr "可以通过在函数中指定其他选项来覆盖 ``BASE_NAME``。例如："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:101
msgid ""
"creates the macro ``OTHER_NAME_EXPORT`` instead of ``SOMELIB_EXPORT``, but"
" other macros and the generated file name is as default:"
msgstr "创建宏 ``OTHER_NAME_EXPORT`` 而不是 ``SOMELIB_EXPORT``，但其他宏和生成的文件名是默认的："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:112
msgid ""
"creates the macro ``KDE_DEPRECATED`` instead of ``SOMELIB_DEPRECATED``."
msgstr "创建宏 ``KDE_DEPRECATED`` 而不是 ``SOMELIB_DEPRECATED``。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:114
msgid ""
"If ``LIBRARY_TARGET`` is a static library, macros are defined without "
"values."
msgstr "如果 ``LIBRARY_TARGET`` 是一个静态库，宏定义时没有值。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:117
msgid ""
"If the same sources are used to create both a shared and a static library,"
" the uppercased symbol ``${BASE_NAME}_STATIC_DEFINE`` should be used when "
"building the static library:"
msgstr "如果使用相同的源来创建共享库和静态库，则在构建静态库时应使用大写符号“${BASE_NAME}_STATIC_DEFINE”："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:129
msgid ""
"This will cause the export macros to expand to nothing when building the "
"static library."
msgstr "这将导致导出宏在构建静态库时展开为空。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:132
msgid ""
"If ``DEFINE_NO_DEPRECATED`` is specified, then a macro "
"``${BASE_NAME}_NO_DEPRECATED`` will be defined This macro can be used to "
"remove deprecated code from preprocessor output:"
msgstr ""
"如果指定了 ``DEFINE_NO_DEPRECATED``，那么将定义一个宏 ``${BASE_NAME}_NO_DEPRECATED`` "
"这个宏可用于从预处理器输出中删除不推荐使用的代码："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:145
msgid "And then in somelib:"
msgstr "然后在 somelib 中："

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:164
msgid ""
"If ``PREFIX_NAME`` is specified, the argument will be used as a prefix to "
"all generated macros."
msgstr "如果指定了 ``PREFIX_NAME``，该参数将用作所有生成的宏的前缀。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:173
msgid "Generates the macros ``VTK_SOMELIB_EXPORT`` etc."
msgstr "生成宏“VTK_SOMELIB_EXPORT”等。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:175
msgid "Library target can be an ``OBJECT`` library."
msgstr "库目标可以是 ``OBJECT`` 库。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:178
msgid "Added the ``CUSTOM_CONTENT_FROM_VARIABLE`` option."
msgstr "添加了 ``CUSTOM_CONTENT_FROM_VARIABLE`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:181
msgid "Added the ``INCLUDE_GUARD_NAME`` option."
msgstr "添加了 ``INCLUDE_GUARD_NAME`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:188
msgid ""
"Set the target properties :prop_tgt:`CXX_VISIBILITY_PRESET "
"<<LANG>_VISIBILITY_PRESET>` and :prop_tgt:`VISIBILITY_INLINES_HIDDEN` "
"instead."
msgstr ""
"改为设置目标属性 :prop_tgt:`CXX_VISIBILITY_PRESET <<LANG>_VISIBILITY_PRESET>` 和 "
":prop_tgt:`VISIBILITY_INLINES_HIDDEN`。"

#: ../../cmake-prefix/src/cmake/Modules/GenerateExportHeader.cmake:193
msgid ""
"The ``ADD_COMPILER_EXPORT_FLAGS`` function adds ``-fvisibility=hidden`` to"
" :variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>` if supported, and is a "
"no-op on Windows which does not need extra compiler flags for exporting "
"support. You may optionally pass a single argument to "
"``ADD_COMPILER_EXPORT_FLAGS`` that will be populated with the "
"``CXX_FLAGS`` required to enable visibility support for the "
"compiler/architecture in use."
msgstr ""
"``ADD_COMPILER_EXPORT_FLAGS`` 函数将 ``-fvisibility=hidden`` 添加到 "
":variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>` 如果支持，并且在 Windows "
"上是一个空操作，不需要额外的编译器标志来导出支持。您可以选择将单个参数传递给“ADD_COMPILER_EXPORT_FLAGS”，该参数将填充启用对正在使用的编译器/体系结构的可见性支持所需的“CXX_FLAGS”。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:6
msgid "GetPrerequisites"
msgstr "获取先决条件"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:10
msgid "Use :command:`file(GET_RUNTIME_DEPENDENCIES)` instead."
msgstr "使用 :command:`file(GET_RUNTIME_DEPENDENCIES)` 代替。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:12
msgid "Functions to analyze and list executable file prerequisites."
msgstr "分析和列出可执行文件先决条件的功能。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:14
msgid ""
"This module provides functions to list the .dll, .dylib or .so files that "
"an executable or shared library file depends on.  (Its prerequisites.)"
msgstr "此模块提供列出可执行文件或共享库文件所依赖的 .dll、.dylib 或 .so 文件的功能。 （它的先决条件。）"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:18
msgid ""
"It uses various tools to obtain the list of required shared library files:"
msgstr "它使用各种工具来获取所需共享库文件的列表："

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:28
msgid "The tool specified by ``CMAKE_OBJDUMP`` will be used, if set."
msgstr "如果已设置，将使用 CMAKE_OBJDUMP 指定的工具。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:53
msgid ""
"Get the list of shared library files required by <target>.  The list in "
"the variable named <prerequisites_var> should be empty on first entry to "
"this function.  On exit, <prerequisites_var> will contain the list of "
"required shared library files."
msgstr ""
"获取 <target> 所需的共享库文件列表。名为 <prerequisites_var> "
"的变量中的列表在首次进入此函数时应为空。退出时，<prerequisites_var> 将包含所需共享库文件的列表。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:58
msgid ""
"<target> is the full path to an executable file.  <prerequisites_var> is "
"the name of a CMake variable to contain the results. <exclude_system> must"
" be 0 or 1 indicating whether to include or exclude \"system\" "
"prerequisites.  If <recurse> is set to 1 all prerequisites will be found "
"recursively, if set to 0 only direct prerequisites are listed.  <exepath> "
"is the path to the top level executable used for @executable_path "
"replacement on the Mac.  <dirs> is a list of paths where libraries might "
"be found: these paths are searched first when a target without any path "
"info is given.  Then standard system locations are also searched: PATH, "
"Framework locations, /usr/lib..."
msgstr ""
"<target> 是可执行文件的完整路径。 <prerequisites_var> 是包含结果的 CMake 变量的名称。 "
"<exclude_system> 必须为 0 或 1，指示是包含还是排除“系统”先决条件。如果 <recurse> 设置为 "
"1，将递归查找所有先决条件，如果设置为 0，则仅列出直接先决条件。 <exepath> 是用于在 Mac 上替换 @executable_path "
"的顶级可执行文件的路径。 <dirs> "
"是可能找到库的路径列表：当给出没有任何路径信息的目标时，首先搜索这些路径。然后还会搜索标准系统位置：PATH、Framework "
"位置、/usr/lib..."

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:70
msgid ""
"The variable GET_PREREQUISITES_VERBOSE can be set to true to enable "
"verbose output."
msgstr "可以将变量 GET_PREREQUISITES_VERBOSE 设置为 true 以启用详细输出。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:78
msgid "Print a message listing the prerequisites of <target>."
msgstr "打印一条消息，列出 <target> 的先决条件。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:80
msgid ""
"<target> is the name of a shared library or executable target or the full "
"path to a shared library or executable file.  If <recurse> is set to 1 all"
" prerequisites will be found recursively, if set to 0 only direct "
"prerequisites are listed.  <exclude_system> must be 0 or 1 indicating "
"whether to include or exclude \"system\" prerequisites.  With <verbose> "
"set to 0 only the full path names of the prerequisites are printed, set to"
" 1 extra information will be displayed."
msgstr ""
"<target> 是共享库或可执行目标的名称或共享库或可执行文件的完整路径。如果 <recurse> 设置为 1，将递归查找所有先决条件，如果设置为"
" 0，则仅列出直接先决条件。 <exclude_system> 必须为 0 或 1，指示是包含还是排除“系统”先决条件。当 <verbose> "
"设置为 0 时，仅打印先决条件的完整路径名，设置为 1 时将显示额外信息。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:92
msgid ""
"Print the prerequisites of shared library and executable files matching a "
"globbing pattern.  <glob_arg> is GLOB or GLOB_RECURSE and <glob_exp> is a "
"globbing expression used with \"file(GLOB\" or \"file(GLOB_RECURSE\" to "
"retrieve a list of matching files.  If a matching file is executable, its "
"prerequisites are listed."
msgstr ""
"打印与 globbing 模式匹配的共享库和可执行文件的先决条件。 <glob_arg> 是 GLOB 或 "
"GLOB_RECURSE，<glob_exp> 是与“file(GLOB”或“file(GLOB_RECURSE”) "
"一起使用的通配表达式，用于检索匹配文件列表。如果匹配文件是可执行的，则列出其先决条件。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:98
msgid ""
"Any additional (optional) arguments provided are passed along as the "
"optional arguments to the list_prerequisites calls."
msgstr "提供的任何附加（可选）参数都作为可选参数传递给 list_prerequisites 调用。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:105
msgid ""
"Append <value> to the list variable <list_var> only if the value is not "
"already in the list."
msgstr "仅当值不在列表中时，才将 <value> 附加到列表变量 <list_var>。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:112
msgid ""
"Return 1 in <result_var> if <file> is a binary executable, 0 otherwise."
msgstr "如果 <file> 是二进制可执行文件，则在 <result_var> 中返回 1，否则返回 0。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:119
msgid ""
"Return the path that others should refer to the item by when the item is "
"embedded inside a bundle."
msgstr "当项目嵌入包中时，返回其他人应该引用该项目的路径。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:122
msgid ""
"Override on a per-project basis by providing a project-specific "
"gp_item_default_embedded_path_override function."
msgstr "通过提供特定于项目的 gp_item_default_embedded_pa​​th_override 函数在每个项目的基础上覆盖。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:130
msgid "Resolve an item into an existing full path file."
msgstr "将项目解析为现有的完整路径文件。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:132
msgid ""
"Override on a per-project basis by providing a project-specific "
"gp_resolve_item_override function."
msgstr "通过提供特定于项目的 gp_resolve_item_override 函数在每个项目的基础上进行覆盖。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:140
#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:163
msgid ""
"Return the type of <file> with respect to <original_file>.  String "
"describing type of prerequisite is returned in variable named <type_var>."
msgstr ""
"返回关于 <original_file> 的 <file> 的类型。描述先决条件类型的字符串在名为 <type_var> 的变量中返回。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:144
msgid ""
"Use <exepath> and <dirs> if necessary to resolve non-absolute <file> "
"values -- but only for non-embedded items."
msgstr "如有必要，使用 <exepath> 和 <dirs> 来解析非绝对 <file> 值——但仅适用于非嵌入项。"

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:147
#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:167
msgid "Possible types are:"
msgstr "可能的类型是："

#: ../../cmake-prefix/src/cmake/Modules/GetPrerequisites.cmake:156
msgid ""
"Override on a per-project basis by providing a project-specific "
"gp_resolved_file_type_override function."
msgstr "通过提供特定于项目的 gp_resolved_file_type_override 函数在每个项目的基础上进行覆盖。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:6
msgid "GoogleTest"
msgstr "谷歌测试"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:10
msgid ""
"This module defines functions to help use the Google Test infrastructure."
"  Two mechanisms for adding tests are provided. :command:`gtest_add_tests`"
" has been around for some time, originally via ``find_package(GTest)``. "
":command:`gtest_discover_tests` was introduced in CMake 3.10."
msgstr ""
"该模块定义了帮助使用 Google Test 基础设施的功能。提供了两种添加测试的机制。 :command:`gtest_add_tests` "
"已经存在了一段时间，最初是通过 ``find_package(GTest)``。 :command:`gtest_discover_tests` "
"是在 CMake 3.10 中引入的。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:15
msgid ""
"The (older) :command:`gtest_add_tests` scans source files to identify "
"tests. This is usually effective, with some caveats, including in cross-"
"compiling environments, and makes setting additional properties on tests "
"more convenient. However, its handling of parameterized tests is less "
"comprehensive, and it requires re-running CMake to detect changes to the "
"list of tests."
msgstr ""
"（较旧的） :command:`gtest_add_tests` "
"扫描源文件以识别测试。这通常是有效的，但有一些注意事项，包括在交叉编译环境中，并且使在测试中设置其他属性更加方便。但是，它对参数化测试的处理不够全面，需要重新运行"
" CMake 来检测测试列表的变化。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:21
msgid ""
"The (newer) :command:`gtest_discover_tests` discovers tests by asking the "
"compiled test executable to enumerate its tests.  This is more robust and "
"provides better handling of parameterized tests, and does not require "
"CMake to be re-run when tests change.  However, it may not work in a "
"cross-compiling environment, and setting test properties is less "
"convenient."
msgstr ""
"（较新的） :command:`gtest_discover_tests` "
"通过要求已编译的测试可执行文件枚举其测试来发现测试。这更健壮，可以更好地处理参数化测试，并且不需要在测试更改时重新运行 "
"CMake。但是在交叉编译环境下可能无法正常工作，而且设置测试属性不太方便。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:27
msgid ""
"More details can be found in the documentation of the respective "
"functions."
msgstr "可以在相应功能的文档中找到更多详细信息。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:29
msgid ""
"Both commands are intended to replace use of :command:`add_test` to "
"register tests, and will create a separate CTest test for each Google Test"
" test case. Note that this is in some cases less efficient, as common set-"
"up and tear-down logic cannot be shared by multiple test cases executing "
"in the same instance. However, it provides more fine-grained pass/fail "
"information to CTest, which is usually considered as more beneficial.  By "
"default, the CTest test name is the same as the Google Test name (i.e. "
"``suite.testcase``); see also ``TEST_PREFIX`` and ``TEST_SUFFIX``."
msgstr ""
"这两个命令旨在取代使用 :command:`add_test` 来注册测试，并将为每个 Google Test 测试用例创建一个单独的 CTest "
"测试。请注意，这在某些情况下效率较低，因为在同一实例中执行的多个测试用例无法共享通用设置和拆卸逻辑。然而，它为 CTest "
"提供了更细粒度的通过/失败信息，这通常被认为是更有益的。默认情况下，CTest 测试名称与 Google 测试名称相同（即 "
"``suite.testcase``）；另见 ``TEST_PREFIX`` 和 ``TEST_SUFFIX``。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:40
msgid ""
"Automatically add tests with CTest by scanning source code for Google Test"
" macros::"
msgstr "通过扫描 Google 测试宏的源代码，使用 CTest 自动添加测试："

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:53
msgid ""
"``gtest_add_tests`` attempts to identify tests by scanning source files. "
"Although this is generally effective, it uses only a basic regular "
"expression match, which can be defeated by atypical test declarations, and"
" is unable to fully \"split\" parameterized tests.  Additionally, it "
"requires that CMake be re-run to discover any newly added, removed or "
"renamed tests (by default, this means that CMake is re-run when any test "
"source file is changed, but see ``SKIP_DEPENDENCY``).  However, it has the"
" advantage of declaring tests at CMake time, which somewhat simplifies "
"setting additional properties on tests, and always works in a cross-"
"compiling environment."
msgstr ""
"``gtest_add_tests`` "
"尝试通过扫描源文件来识别测试。虽然这通常是有效的，但它仅使用基本的正则表达式匹配，它可以被非典型测试声明击败，并且无法完全“拆分”参数化测试。此外，它要求重新运行"
" CMake 以发现任何新添加、删除或重命名的测试（默认情况下，这意味着在更改任何测试源文件时重新运行 CMake，但请参阅 "
"``SKIP_DEPENDENCY``）。但是，它具有在 CMake "
"时声明测试的优势，这在某种程度上简化了对测试设置附加属性，并且始终在交叉编译环境中工作。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:68
msgid "``TARGET target``"
msgstr "``目标目标``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:66
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:186
msgid ""
"Specifies the Google Test executable, which must be a known CMake "
"executable target.  CMake will substitute the location of the built "
"executable when running the test."
msgstr ""
"指定 Google Test 可执行文件，它必须是已知的 CMake 可执行文件目标。运行测试时，CMake 将替换构建的可执行文件的位置。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:73
msgid "``SOURCES src1...``"
msgstr "``来源src1 ...``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:71
msgid ""
"When provided, only the listed files will be scanned for test cases.  If "
"this option is not given, the :prop_tgt:`SOURCES` property of the "
"specified ``target`` will be used to obtain the list of sources."
msgstr ""
"提供后，将仅扫描列出的文件以查找测试用例。如果未给出此选项，则指定的 ``target`` 的 :prop_tgt:`SOURCES` "
"属性将用于获取源列表。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:76
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:191
msgid "``EXTRA_ARGS arg1...``"
msgstr "``EXTRA_ARGS arg1 ...``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:76
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:191
msgid "Any extra arguments to pass on the command line to each test case."
msgstr "在命令行上传递给每个测试用例的任何额外参数。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:80
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:195
msgid "``WORKING_DIRECTORY dir``"
msgstr "``WORKING_DIRECTORY 目录``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:79
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:194
msgid ""
"Specifies the directory in which to run the discovered test cases.  If "
"this option is not provided, the current binary directory is used."
msgstr "指定运行发现的测试用例的目录。如果未提供此选项，则使用当前二进制目录。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:85
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:201
msgid "``TEST_PREFIX prefix``"
msgstr "``TEST_PREFIX 前缀``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:83
msgid ""
"Specifies a ``prefix`` to be prepended to the name of each discovered test"
" case.  This can be useful when the same source files are being used in "
"multiple calls to ``gtest_add_test()`` but with different ``EXTRA_ARGS``."
msgstr ""
"指定要添加到每个发现的测试用例的名称前的“前缀”。当在多次调用 ``gtest_add_test()`` 但使用不同的 ``EXTRA_ARGS``"
" 时，这会很有用。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:90
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:206
msgid "``TEST_SUFFIX suffix``"
msgstr "``TEST_SUFFIX 后缀``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:88
#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:204
msgid ""
"Similar to ``TEST_PREFIX`` except the ``suffix`` is appended to the name "
"of every discovered test case.  Both ``TEST_PREFIX`` and ``TEST_SUFFIX`` "
"may be specified."
msgstr ""
"类似于 ``TEST_PREFIX`` 除了``后缀``被附加到每个发现的测试用例的名称。可以指定 ``TEST_PREFIX`` 和 "
"``TEST_SUFFIX``。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:97
msgid "``SKIP_DEPENDENCY``"
msgstr "``跳过依赖``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:93
msgid ""
"Normally, the function creates a dependency which will cause CMake to be "
"re-run if any of the sources being scanned are changed.  This is to ensure"
" that the list of discovered tests is updated.  If this behavior is not "
"desired (as may be the case while actually writing the test cases), this "
"option can be used to prevent the dependency from being added."
msgstr ""
"通常，该函数会创建一个依赖项，如果任何正在扫描的源发生更改，该依赖项将导致 CMake "
"重新运行。这是为了确保更新发现的测试列表。如果不需要此行为（实际编写测试用例时可能会出现这种情况），则可以使用此选项来防止添加依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:102
msgid "``TEST_LIST outVar``"
msgstr "``TEST_LIST 输出变量``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:100
msgid ""
"The variable named by ``outVar`` will be populated in the calling scope "
"with the list of discovered test cases.  This allows the caller to do "
"things like manipulate test properties of the discovered tests."
msgstr "由 ``outVar`` 命名的变量将在调用范围内填充已发现的测试用例列表。这允许调用者执行诸如操纵已发现测试的测试属性之类的事情。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:104
msgid "Usage example:"
msgstr "使用示例："

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:122
msgid "For backward compatibility, the following form is also supported::"
msgstr "为了向后兼容，还支持以下形式："

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:126
msgid "``exe``"
msgstr "``exe``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:127
msgid "The path to the test executable or the name of a CMake target."
msgstr "测试可执行文件的路径或 CMake 目标的名称。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:130
msgid "``args``"
msgstr "``参数``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:129
msgid ""
"A ;-list of extra arguments to be passed to executable.  The entire list "
"must be passed as a single argument.  Enclose it in quotes, or pass "
"``\"\"`` for no arguments."
msgstr "一个 ;- 要传递给可执行文件的额外参数列表。整个列表必须作为单个参数传递。将其括在引号中，或传递 ``\"\"`` 不带参数。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:135
msgid "``files...``"
msgstr "``文件...``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:133
msgid ""
"A list of source files to search for tests and test fixtures. "
"Alternatively, use ``AUTO`` to specify that ``exe`` is the name of a CMake"
" executable target whose sources should be scanned."
msgstr "用于搜索测试和测试装置的源文件列表。或者，使用 ``AUTO`` 指定 ``exe`` 是应扫描其源的 CMake 可执行目标的名称。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:146
msgid ""
"Automatically add tests with CTest by querying the compiled test "
"executable for available tests::"
msgstr "通过查询已编译的测试可执行文件以获取可用测试，使用 CTest 自动添加测试："

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:165
msgid ""
"``gtest_discover_tests()`` sets up a post-build command on the test "
"executable that generates the list of tests by parsing the output from "
"running the test with the ``--gtest_list_tests`` argument.  Compared to "
"the source parsing approach of :command:`gtest_add_tests`, this ensures "
"that the full list of tests, including instantiations of parameterized "
"tests, is obtained.  Since test discovery occurs at build time, it is not "
"necessary to re-run CMake when the list of tests changes. However, it "
"requires that :prop_tgt:`CROSSCOMPILING_EMULATOR` is properly set in order"
" to function in a cross-compiling environment."
msgstr ""
"``gtest_discover_tests()`` 在测试可执行文件上设置一个构建后命令，该命令通过使用 "
"``--gtest_list_tests`` 参数解析运行测试的输出来生成测试列表。与 :command:`gtest_add_tests` "
"的源解析方法相比，这确保了获得完整的测试列表，包括参数化测试的实例。由于测试发现发生在构建时，因此当测试列表更改时无需重新运行 "
"CMake。但是，它需要正确设置 :prop_tgt:`CROSSCOMPILING_EMULATOR` 才能在交叉编译环境中运行。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:175
msgid ""
"Additionally, setting properties on tests is somewhat less convenient, "
"since the tests are not available at CMake time.  Additional test "
"properties may be assigned to the set of tests as a whole using the "
"``PROPERTIES`` option.  If more fine-grained test control is needed, "
"custom content may be provided through an external CTest script using the "
":prop_dir:`TEST_INCLUDE_FILES` directory property.  The set of discovered "
"tests is made accessible to such a script via the ``<target>_TESTS`` "
"variable."
msgstr ""
"此外，设置测试属性不太方便，因为测试在 CMake "
"时不可用。使用“PROPERTIES”选项，可以将其他测试属性作为一个整体分配给测试集。如果需要更细粒度的测试控制，可以使用 "
"TEST_INCLUDE_FILES 目录属性通过外部 CTest "
"脚本提供自定义内容。这样的脚本可以通过“<target>_TESTS”变量访问已发现的测试集。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:188
msgid "``target``"
msgstr "``目标``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:198
msgid ""
"Specifies a ``prefix`` to be prepended to the name of each discovered test"
" case.  This can be useful when the same test executable is being used in "
"multiple calls to ``gtest_discover_tests()`` but with different "
"``EXTRA_ARGS``."
msgstr ""
"指定要添加到每个发现的测试用例的名称前的“前缀”。当在对``gtest_discover_tests()`` "
"的多次调用中使用相同的测试可执行文件但使用不同的``EXTRA_ARGS`` 时，这可能很有用。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:215
msgid "``TEST_FILTER expr``"
msgstr "``TEST_FILTER expr``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:211
msgid ""
"Filter expression to pass as a ``--gtest_filter`` argument during test "
"discovery.  Note that the expression is a wildcard-based format that "
"matches against the original test names as used by gtest.  For type or "
"value-parameterized tests, these names may be different to the potentially"
" pretty-printed test names that :program:`ctest` uses."
msgstr ""
"过滤器表达式在测试发现期间作为 ``--gtest_filter`` 参数传递。请注意，该表达式是一种基于通配符的格式，与 gtest "
"使用的原始测试名称相匹配。对于类型或值参数化测试，这些名称可能与 ctest 使用的可能漂亮的测试名称不同。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:221
msgid "``NO_PRETTY_TYPES``"
msgstr "``NO_PRETTY_TYPES``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:218
msgid ""
"By default, the type index of type-parameterized tests is replaced by the "
"actual type name in the CTest test name.  If this behavior is undesirable "
"(e.g. because the type names are unwieldy), this option will suppress this"
" behavior."
msgstr ""
"默认情况下，类型参数化测试的类型索引替换为 CTest "
"测试名称中的实际类型名称。如果这种行为是不可取的（例如，因为类型名称很笨重），这个选项将抑制这种行为。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:227
msgid "``NO_PRETTY_VALUES``"
msgstr "``NO_PRETTY_VALUES``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:224
msgid ""
"By default, the value index of value-parameterized tests is replaced by "
"the actual value in the CTest test name.  If this behavior is undesirable "
"(e.g. because the value strings are unwieldy), this option will suppress "
"this behavior."
msgstr ""
"默认情况下，值参数化测试的值索引被替换为 CTest "
"测试名称中的实际值。如果这种行为是不可取的（例如，因为值字符串很笨重），这个选项将抑制这种行为。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:231
msgid "``PROPERTIES name1 value1...``"
msgstr "``属性 name1 value1 ...``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:230
msgid ""
"Specifies additional properties to be set on all tests discovered by this "
"invocation of ``gtest_discover_tests()``."
msgstr "指定要在调用 gtest_discover_tests() 发现的所有测试上设置的附加属性。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:237
msgid "``TEST_LIST var``"
msgstr "``TEST_LIST 变量``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:234
msgid ""
"Make the list of tests available in the variable ``var``, rather than the "
"default ``<target>_TESTS``.  This can be useful when the same test "
"executable is being used in multiple calls to ``gtest_discover_tests()``. "
"Note that this variable is only available in CTest."
msgstr ""
"使测试列表在变量 ``var`` 中可用，而不是默认的 "
"``<target>_TESTS``。当在对``gtest_discover_tests()`` "
"的多次调用中使用相同的测试可执行文件时，这可能很有用。请注意，此变量仅在 CTest 中可用。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:257
msgid "``DISCOVERY_TIMEOUT num``"
msgstr "``DISCOVERY_TIMEOUT num``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:242
msgid ""
"Specifies how long (in seconds) CMake will wait for the test to enumerate "
"available tests.  If the test takes longer than this, discovery (and your "
"build) will fail.  Most test executables will enumerate their tests very "
"quickly, but under some exceptional circumstances, a test may require a "
"longer timeout.  The default is 5.  See also the ``TIMEOUT`` option of "
":command:`execute_process`."
msgstr ""
"指定 CMake "
"等待测试枚举可用测试的时间（以秒为单位）。如果测试花费的时间超过此时间，发现（和您的构建）将失败。大多数测试可执行文件会很快枚举它们的测试，但在某些特殊情况下，测试可能需要更长的超时时间。默认值为"
" 5。另请参阅 :command:`execute_process` 的 ``TIMEOUT`` 选项。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:251
msgid ""
"In CMake versions 3.10.1 and 3.10.2, this option was called ``TIMEOUT``. "
"This clashed with the ``TIMEOUT`` test property, which is one of the "
"common properties that would be set with the ``PROPERTIES`` keyword, "
"usually leading to legal but unintended behavior.  The keyword was changed"
" to ``DISCOVERY_TIMEOUT`` in CMake 3.10.3 to address this problem.  The "
"ambiguous behavior of the ``TIMEOUT`` keyword in 3.10.1 and 3.10.2 has not"
" been preserved."
msgstr ""
"在 CMake 版本 3.10.1 和 3.10.2 中，此选项称为“TIMEOUT”。这与 ``TIMEOUT`` 测试属性冲突，后者是使用 "
"``PROPERTIES`` 关键字设置的常见属性之一，通常会导致合法但意外的行为。在 CMake 3.10.3 "
"中将关键字更改为“DISCOVERY_TIMEOUT”以解决此问题。 3.10.1 和 3.10.2 中 ``TIMEOUT`` "
"关键字的不明确行为尚未保留。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:266
msgid "``XML_OUTPUT_DIR dir``"
msgstr "``XML_OUTPUT_DIR 目录``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:262
msgid ""
"If specified, the parameter is passed along with ``--gtest_output=xml:`` "
"to test executable. The actual file name is the same as the test target, "
"including prefix and suffix. This should be used instead of ``EXTRA_ARGS "
"--gtest_output=xml`` to avoid race conditions writing the XML result "
"output when using parallel test execution."
msgstr ""
"如果指定，参数将与``--gtest_output=xml:`` 一起传递以测试可执行文件。实际文件名与测试目标相同，包括前缀和后缀。这应该用来代替"
" ``EXTRA_ARGS --gtest_output=xml`` 以避免在使用并行测试执行时写入 XML 结果输出的竞争条件。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:283
msgid "``DISCOVERY_MODE``"
msgstr "``DISCOVERY_MODE``"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:271
msgid ""
"Provides greater control over when ``gtest_discover_tests()`` performs "
"test discovery. By default, ``POST_BUILD`` sets up a post-build command to"
" perform test discovery at build time. In certain scenarios, like cross-"
"compiling, this ``POST_BUILD`` behavior is not desirable. By contrast, "
"``PRE_TEST`` delays test discovery until just prior to test execution. "
"This way test discovery occurs in the target environment where the test "
"has a better chance at finding appropriate runtime dependencies."
msgstr ""
"更好地控制 gtest_discover_tests() 何时执行测试发现。默认情况下，``POST_BUILD`` "
"设置构建后命令以在构建时执行测试发现。在某些情况下，比如交叉编译，这种 POST_BUILD 行为是不可取的。相比之下，``PRE_TEST`` "
"将测试发现延迟到测试执行之前。通过这种方式，测试发现发生在目标环境中，在该环境中测试更有可能找到合适的运行时依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/GoogleTest.cmake:280
msgid ""
"``DISCOVERY_MODE`` defaults to the value of the "
"``CMAKE_GTEST_DISCOVER_TESTS_DISCOVERY_MODE`` variable if it is not passed"
" when calling ``gtest_discover_tests()``. This provides a mechanism for "
"globally selecting a preferred test discovery behavior without having to "
"modify each call site."
msgstr ""
"``DISCOVERY_MODE`` 默认为 ``CMAKE_GTEST_DISCOVER_TESTS_DISCOVERY_MODE`` "
"变量的值，如果它在调用 ``gtest_discover_tests()`` "
"时未被传递。这提供了一种机制，用于全局选择首选测试发现行为，而无需修改每个调用站点。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:6
msgid "InstallRequiredSystemLibraries"
msgstr "安装必需的系统库"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:8
msgid ""
"Include this module to search for compiler-provided system runtime "
"libraries and add install rules for them.  Some optional variables may be "
"set prior to including the module to adjust behavior:"
msgstr "包括此模块以搜索编译器提供的系统运行时库并为它们添加安装规则。可以在包含模块以调整行为之前设置一些可选变量："

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:14
msgid "``CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS``"
msgstr "``CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:13
msgid ""
"Specify additional runtime libraries that may not be detected. After "
"inclusion any detected libraries will be appended to this."
msgstr "指定可能无法检测到的其他运行时库。包含后，任何检测到的库都将附加到此。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:19
msgid "``CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP``"
msgstr "``CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:17
msgid ""
"Set to TRUE to skip calling the :command:`install(PROGRAMS)` command to "
"allow the includer to specify its own install rule, using the value of "
"``CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS`` to get the list of libraries."
msgstr ""
"设置为 TRUE 以跳过调用 :command:`install(PROGRAMS)` 命令以允许包含程序指定其自己的安装规则，使用 "
"``CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS`` 的值来获取库列表。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:23
msgid "``CMAKE_INSTALL_DEBUG_LIBRARIES``"
msgstr "``CMAKE_INSTALL_DEBUG_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:22
msgid ""
"Set to TRUE to install the debug runtime libraries when available with "
"MSVC tools."
msgstr "设置为 TRUE 以在 MSVC 工具可用时安装调试运行时库。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:27
msgid "``CMAKE_INSTALL_DEBUG_LIBRARIES_ONLY``"
msgstr "``CMAKE_INSTALL_DEBUG_LIBRARIES_ONLY``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:26
msgid ""
"Set to TRUE to install only the debug runtime libraries with MSVC tools "
"even if the release runtime libraries are also available."
msgstr "设置为 TRUE 以仅使用 MSVC 工具安装调试运行时库，即使发布运行时库也可用。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:40
msgid "``CMAKE_INSTALL_UCRT_LIBRARIES``"
msgstr "``CMAKE_INSTALL_UCRT_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:32
msgid ""
"Set to TRUE to install the Windows Universal CRT libraries for app-local "
"deployment (e.g. to Windows XP).  This is meaningful only with MSVC from "
"Visual Studio 2015 or higher."
msgstr ""
"设置为 TRUE 以安装 Windows 通用 CRT 库以进行应用程序本地部署（例如到 Windows XP）。这仅对来自 Visual "
"Studio 2015 或更高版本的 MSVC 有意义。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:36
msgid ""
"One may set a ``CMAKE_WINDOWS_KITS_10_DIR`` *environment variable* to an "
"absolute path to tell CMake to look for Windows 10 SDKs in a custom "
"location.  The specified directory is expected to contain "
"``Redist/ucrt/DLLs/*`` directories."
msgstr ""
"可以将 ``CMAKE_WINDOWS_KITS_10_DIR`` *环境变量* 设置为绝对路径，以告诉 CMake 在自定义位置查找 "
"Windows 10 SDK。指定目录应包含“Redist/ucrt/DLLs/*”目录。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:43
msgid "``CMAKE_INSTALL_MFC_LIBRARIES``"
msgstr "``CMAKE_INSTALL_MFC_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:43
msgid "Set to TRUE to install the MSVC MFC runtime libraries."
msgstr "设置为 TRUE 以安装 MSVC MFC 运行时库。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:46
msgid "``CMAKE_INSTALL_OPENMP_LIBRARIES``"
msgstr "``CMAKE_INSTALL_OPENMP_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:46
msgid "Set to TRUE to install the MSVC OpenMP runtime libraries"
msgstr "设置为 TRUE 以安装 MSVC OpenMP 运行时库"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:51
msgid "``CMAKE_INSTALL_SYSTEM_RUNTIME_DESTINATION``"
msgstr "``CMAKE_INSTALL_SYSTEM_RUNTIME_DESTINATION``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:49
msgid ""
"Specify the :command:`install(PROGRAMS)` command ``DESTINATION`` option.  "
"If not specified, the default is ``bin`` on Windows and ``lib`` elsewhere."
msgstr ""
"指定 :command:`install(PROGRAMS)` 命令``DESTINATION`` 选项。如果未指定，则默认为 Windows 上的 "
"``bin`` 和其他地方的 ``lib``。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:56
msgid "``CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS``"
msgstr "``CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:54
msgid ""
"Set to TRUE to disable warnings about required library files that do not "
"exist.  (For example, Visual Studio Express editions may not provide the "
"redistributable files.)"
msgstr ""
"设置为 TRUE 以禁用有关不存在的所需库文件的警告。 （例如，Visual Studio Express 版本可能不提供可重新分发的文件。）"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:62
msgid "``CMAKE_INSTALL_SYSTEM_RUNTIME_COMPONENT``"
msgstr "``CMAKE_INSTALL_SYSTEM_RUNTIME_COMPONENT``"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:61
msgid ""
"Specify the :command:`install(PROGRAMS)` command ``COMPONENT`` option.  If"
" not specified, no such option will be used."
msgstr "指定 :command:`install(PROGRAMS)` 命令``COMPONENT`` 选项。如果未指定，则不会使用此类选项。"

#: ../../cmake-prefix/src/cmake/Modules/InstallRequiredSystemLibraries.cmake:64
msgid "Support for installing Intel compiler runtimes."
msgstr "支持安装英特尔编译器运行时。"

#: ../../cmake-prefix/src/cmake/Modules/MacroAddFileDependencies.cmake:6
msgid "MacroAddFileDependencies"
msgstr "宏添加文件依赖"

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:6
msgid "ProcessorCount"
msgstr "处理器数量"

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:8
msgid "ProcessorCount(var)"
msgstr "处理器计数（var）"

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:10
msgid "Determine the number of processors/cores and save value in ${var}"
msgstr "确定处理器/内核的数量并将值保存在 ${var} 中"

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:12
msgid ""
"Sets the variable named ${var} to the number of physical cores available "
"on the machine if the information can be determined. Otherwise it is set "
"to 0.  Currently this functionality is implemented for AIX, cygwin, "
"FreeBSD, HPUX, Linux, macOS, QNX, Sun and Windows."
msgstr ""
"如果可以确定信息，则将名为 ${var} 的变量设置为机器上可用的物理内核数。否则设置为 0。目前此功能已针对 "
"AIX、cygwin、FreeBSD、HPUX、Linux、macOS、QNX、Sun 和 Windows 实现。"

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:18
msgid ""
"On Linux, returns the container CPU count instead of the host CPU count."
msgstr "在 Linux 上，返回容器 CPU 计数而不是主机 CPU 计数。"

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:21
msgid ""
"This function is guaranteed to return a positive integer (>=1) if it "
"succeeds.  It returns 0 if there's a problem determining the processor "
"count."
msgstr "如果成功，此函数保证返回正整数 (>=1)。如果在确定处理器数量时出现问题，它会返回 0。"

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:25
msgid ""
"More generally accurate physical CPU count can be obtained via "
":command:`cmake_host_system_information`:"
msgstr "可以通过 cmake_host_system_information 获得更普遍准确的物理 CPU 计数："

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:33
msgid "Example use, in a ctest -S dashboard script:"
msgstr "在 ctest -S 仪表板脚本中使用示例："

#: ../../cmake-prefix/src/cmake/Modules/ProcessorCount.cmake:44
msgid ""
"This function is intended to offer an approximation of the value of the "
"number of compute cores available on the current machine, such that you "
"may use that value for parallel building and parallel testing.  It is "
"meant to help utilize as much of the machine as seems reasonable.  Of "
"course, knowledge of what else might be running on the machine "
"simultaneously should be used when deciding whether to request a machine's"
" full capacity all for yourself."
msgstr ""
"此函数旨在提供当前计算机上可用计算核心数的近似值，以便您可以使用该值进行并行构建和并行测试。它旨在帮助尽可能多地利用机器。当然，在决定是否为自己请求一台机器的全部容量时，应该使用关于机器上可能同时运行的其他东西的知识。"

#: ../../cmake-prefix/src/cmake/Modules/SelectLibraryConfigurations.cmake:6
msgid "SelectLibraryConfigurations"
msgstr "选择库配置"

#: ../../cmake-prefix/src/cmake/Modules/SelectLibraryConfigurations.cmake:12
msgid ""
"This macro takes a library base name as an argument, and will choose good "
"values for the variables"
msgstr "该宏将库基名作为参数，并会为变量选择合适的值"

#: ../../cmake-prefix/src/cmake/Modules/SelectLibraryConfigurations.cmake:22
msgid "depending on what has been found and set."
msgstr "取决于已发现和设置的内容。"

#: ../../cmake-prefix/src/cmake/Modules/SelectLibraryConfigurations.cmake:24
msgid ""
"If only ``basename_LIBRARY_RELEASE`` is defined, ``basename_LIBRARY`` will"
" be set to the release value, and ``basename_LIBRARY_DEBUG`` will be set "
"to ``basename_LIBRARY_DEBUG-NOTFOUND``.  If only "
"``basename_LIBRARY_DEBUG`` is defined, then ``basename_LIBRARY`` will take"
" the debug value, and ``basename_LIBRARY_RELEASE`` will be set to "
"``basename_LIBRARY_RELEASE-NOTFOUND``."
msgstr ""
"如果只定义了 ``basename_LIBRARY_RELEASE``，``basename_LIBRARY`` "
"将被设置为发布值，``basename_LIBRARY_DEBUG`` 将被设置为 ``basename_LIBRARY_DEBUG-"
"NOTFOUND``。如果只定义了“basename_LIBRARY_DEBUG”，那么“basename_LIBRARY”将采用调试值，“basename_LIBRARY_RELEASE”将设置为“basename_LIBRARY_RELEASE-"
"NOTFOUND”。"

#: ../../cmake-prefix/src/cmake/Modules/SelectLibraryConfigurations.cmake:30
msgid ""
"If the generator supports configuration types, then ``basename_LIBRARY`` "
"and ``basename_LIBRARIES`` will be set with debug and optimized flags "
"specifying the library to be used for the given configuration.  If no "
"build type has been set or the generator in use does not support "
"configuration types, then ``basename_LIBRARY`` and ``basename_LIBRARIES`` "
"will take only the release value, or the debug value if the release one is"
" not set."
msgstr ""
"如果生成器支持配置类型，那么 ``basename_LIBRARY`` 和 ``basename_LIBRARIES`` "
"将设置调试和优化标志，指定用于给定配置的库。如果未设置构建类型或使用的生成器不支持配置类型，则 ``basename_LIBRARY`` 和 "
"``basename_LIBRARIES`` 将仅采用发布值，如果未设置发布值，则采用调试值。"

#: ../../cmake-prefix/src/cmake/Modules/SquishTestScript.cmake:6
msgid "SquishTestScript"
msgstr "Squish测试脚本"

#: ../../cmake-prefix/src/cmake/Modules/SquishTestScript.cmake:12
msgid ""
"This script launches a GUI test using Squish.  You should not call the "
"script directly; instead, you should access it via the SQUISH_ADD_TEST "
"macro that is defined in FindSquish.cmake."
msgstr ""
"此脚本使用 Squish 启动 GUI 测试。你不应该直接调用脚本；相反，您应该通过在 FindSquish.cmake 中定义的 "
"SQUISH_ADD_TEST 宏来访问它。"

#: ../../cmake-prefix/src/cmake/Modules/SquishTestScript.cmake:16
msgid ""
"This script starts the Squish server, launches the test on the client, and"
" finally stops the squish server.  If any of these steps fail (including "
"if the tests do not pass) then a fatal error is raised."
msgstr ""
"该脚本启动 Squish 服务器，在客户端启动测试，最后停止 Squish "
"服务器。如果这些步骤中的任何一个失败（包括测试未通过），则会引发致命错误。"

#: ../../cmake-prefix/src/cmake/Modules/TestBigEndian.cmake:6
msgid "TestBigEndian"
msgstr "测试大端"

#: ../../cmake-prefix/src/cmake/Modules/TestBigEndian.cmake:10
msgid "Supserseded by the :variable:`CMAKE_<LANG>_BYTE_ORDER` variable."
msgstr "被 :variable:`CMAKE_<LANG>_BYTE_ORDER` 变量取代。"

#: ../../cmake-prefix/src/cmake/Modules/TestBigEndian.cmake:12
msgid "Check if the target architecture is big endian or little endian."
msgstr "检查目标架构是大端还是小端。"

#: ../../cmake-prefix/src/cmake/Modules/TestBigEndian.cmake:20
msgid ""
"Stores in variable ``<var>`` either 1 or 0 indicating whether the target "
"architecture is big or little endian."
msgstr "在变量“<var>”中存储 1 或 0，指示目标架构是大端还是小端。"

#: ../../cmake-prefix/src/cmake/Modules/TestCXXAcceptsFlag.cmake:6
msgid "TestCXXAcceptsFlag"
msgstr "测试CXX接受标志"

#: ../../cmake-prefix/src/cmake/Modules/TestCXXAcceptsFlag.cmake:10
msgid "See :module:`CheckCXXCompilerFlag`."
msgstr "请参阅 :module:`CheckCXXCompilerFlag`。"

#: ../../cmake-prefix/src/cmake/Modules/TestCXXAcceptsFlag.cmake:12
msgid "Check if the CXX compiler accepts a flag."
msgstr "检查 CXX 编译器是否接受标志。"

#: ../../cmake-prefix/src/cmake/Modules/TestCXXAcceptsFlag.cmake:18
msgid "``<flags>``"
msgstr "``<标志>``"

#: ../../cmake-prefix/src/cmake/Modules/TestCXXAcceptsFlag.cmake:19
msgid "the flags to try"
msgstr "尝试的标志"

#: ../../cmake-prefix/src/cmake/Modules/TestCXXAcceptsFlag.cmake:21
msgid "variable to store the result"
msgstr "存储结果的变量"

#: ../../cmake-prefix/src/cmake/Modules/TestForANSIForScope.cmake:6
msgid "TestForANSIForScope"
msgstr "测试范围"

#: ../../cmake-prefix/src/cmake/Modules/TestForANSIForScope.cmake:8
msgid "Check for ANSI for scope support"
msgstr "检查 ANSI 范围支持"

#: ../../cmake-prefix/src/cmake/Modules/TestForANSIForScope.cmake:10
msgid ""
"Check if the compiler restricts the scope of variables declared in a for-"
"init-statement to the loop body."
msgstr "检查编译器是否将 for-init 语句中声明的变量范围限制在循环体中。"

#: ../../cmake-prefix/src/cmake/Modules/TestForANSIStreamHeaders.cmake:6
msgid "TestForANSIStreamHeaders"
msgstr "TestForANSIStreamHeaders"

#: ../../cmake-prefix/src/cmake/Modules/TestForANSIStreamHeaders.cmake:8
msgid "Test for compiler support of ANSI stream headers iostream, etc."
msgstr "测试编译器对 ANSI 流头​​ iostream 等的支持。"

#: ../../cmake-prefix/src/cmake/Modules/TestForANSIStreamHeaders.cmake:10
msgid ""
"check if the compiler supports the standard ANSI iostream header (without "
"the .h)"
msgstr "检查编译器是否支持标准 ANSI iostream 标头（不带 .h）"

#: ../../cmake-prefix/src/cmake/Modules/TestForSSTREAM.cmake:6
msgid "TestForSSTREAM"
msgstr "测试流"

#: ../../cmake-prefix/src/cmake/Modules/TestForSSTREAM.cmake:8
msgid "Test for compiler support of ANSI sstream header"
msgstr "测试编译器对 ANSI sstream 标头的支持"

#: ../../cmake-prefix/src/cmake/Modules/TestForSSTREAM.cmake:10
msgid "check if the compiler supports the standard ANSI sstream header"
msgstr "检查编译器是否支持标准 ANSI sstream 标头"

#: ../../cmake-prefix/src/cmake/Modules/TestForSTDNamespace.cmake:6
msgid "TestForSTDNamespace"
msgstr "TestForSTD命名空间"

#: ../../cmake-prefix/src/cmake/Modules/TestForSTDNamespace.cmake:8
msgid "Test for std:: namespace support"
msgstr "测试 std:: 命名空间支持"

#: ../../cmake-prefix/src/cmake/Modules/TestForSTDNamespace.cmake:10
msgid "check if the compiler supports std:: on stl classes"
msgstr "检查编译器是否支持 std:: on stl 类"

#: ../../cmake-prefix/src/cmake/Modules/UseEcos.cmake:6
msgid "UseEcos"
msgstr "使用Ecos"

#: ../../cmake-prefix/src/cmake/Modules/UseEcos.cmake:8
msgid ""
"This module defines variables and macros required to build eCos "
"application."
msgstr "该模块定义了构建 eCos 应用程序所需的变量和宏。"

#: ../../cmake-prefix/src/cmake/Modules/UseEcos.cmake:10
msgid ""
"This file contains the following macros: ECOS_ADD_INCLUDE_DIRECTORIES() - "
"add the eCos include dirs ECOS_ADD_EXECUTABLE(name source1 ...  sourceN ) "
"- create an eCos executable ECOS_ADJUST_DIRECTORY(VAR source1 ...  sourceN"
" ) - adjusts the path of the source files and puts the result into VAR"
msgstr ""
"该文件包含以下宏： ECOS_ADD_INCLUDE_DIRECTORIES() - 添加 eCos 包含目录 "
"ECOS_ADD_EXECUTABLE(name source1 ... sourceN ) - 创建一个 eCos 可执行文件 "
"ECOS_ADJUST_DIRECTORY(VAR source1 ... sourceN ) - 调整源文件的路径并将结果进入VAR"

#: ../../cmake-prefix/src/cmake/Modules/UseEcos.cmake:16
msgid ""
"Macros for selecting the toolchain: ECOS_USE_ARM_ELF_TOOLS() - enable the "
"ARM ELF toolchain for the directory where it is called "
"ECOS_USE_I386_ELF_TOOLS() - enable the i386 ELF toolchain for the "
"directory where it is called ECOS_USE_PPC_EABI_TOOLS() - enable the "
"PowerPC toolchain for the directory where it is called"
msgstr ""
"用于选择工具链的宏： ECOS_USE_ARM_ELF_TOOLS() - 为调用它的目录启用 ARM ELF 工具链 "
"ECOS_USE_I386_ELF_TOOLS() - 为调用它的目录启用 i386 ELF 工具链它被称为"

#: ../../cmake-prefix/src/cmake/Modules/UseEcos.cmake:22
msgid ""
"It contains the following variables: ECOS_DEFINITIONS "
"ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE - defaults to ecos.ecc, if your "
"eCos configuration file has a different name, adjust this variable for "
"internal use only:"
msgstr ""
"它包含以下变量： ECOS_DEFINITIONS ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE - 默认为 "
"ecos.ecc，如果您的 eCos 配置文件有不同的名称，调整此变量仅供内部使用："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:6
msgid "UseJava"
msgstr "使用Java"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:8
msgid ""
"This file provides support for ``Java``.  It is assumed that "
":module:`FindJava` has already been loaded.  See :module:`FindJava` for "
"information on how to load Java into your CMake project."
msgstr ""
"此文件提供对 ``Java`` 的支持。假设 :module:`FindJava` 已经被加载。有关如何将 Java 加载到您的 CMake "
"项目中的信息，请参见:module:`FindJava`。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:13
msgid "Synopsis"
msgstr "概要"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:36
msgid "Creating And Installing JARs"
msgstr "创建和安装 JAR"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:42
msgid ""
"Creates a jar file containing java objects and, optionally, resources::"
msgstr "创建一个包含 java 对象和可选资源的 jar 文件："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:57
msgid ""
"This command creates a ``<target_name>.jar``.  It compiles the given "
"``<source>`` files and adds the given ``<resource>`` files to the jar "
"file.  Source files can be java files or listing files (prefixed by "
"``@``).  If only resource files are given then just a jar file is created."
msgstr ""
"此命令创建一个 ``<target_name>.jar``。它编译给定的 ``<source>`` 文件并将给定的 ``<resource>`` "
"文件添加到 jar 文件中。源文件可以是 java 文件或列表文件（以``@`` 为前缀）。如果只给出资源文件，则只创建一个 jar 文件。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:67
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:124
msgid "``SOURCES``"
msgstr "``来源``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:64
msgid ""
"Compiles the specified source files and adds the result in the jar file."
msgstr "编译指定的源文件并将结果添加到 jar 文件中。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:66
msgid "Support for response files, prefixed by ``@``."
msgstr "支持以“@”为前缀的响应文件。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:95
msgid "``RESOURCES``"
msgstr "``资源``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:72
msgid ""
"Adds the named ``<resource>`` files to the jar by stripping the source "
"file path and placing the file beneath ``<ns>`` within the jar."
msgstr "通过剥离源文件路径并将文件放在 jar 中的 ``<ns>`` 下，将命名的 ``<resource>`` 文件添加到 jar。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:75
msgid "For example::"
msgstr "例如：："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:79
msgid ""
"results in a resource accessible via ``/com/my/namespace/resource.txt`` "
"within the jar."
msgstr "导致可通过 jar 中的“/com/my/namespace/resource.txt”访问资源。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:82
msgid ""
"Resources may be added without adjusting the namespace by adding them to "
"the list of ``SOURCES`` (original behavior), in this case, resource paths "
"must be relative to ``CMAKE_CURRENT_SOURCE_DIR``.  Adding resources "
"without using the ``RESOURCES`` parameter in out of source builds will "
"almost certainly result in confusion."
msgstr ""
"通过将资源添加到 ``SOURCES``（原始行为）列表中，可以在不调整命名空间的情况下添加资源，在这种情况下，资源路径必须相对于 "
"``CMAKE_CURRENT_SOURCE_DIR``。在非源构建中添加资源而不使用“RESOURCES”参数几乎肯定会导致混淆。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:90
msgid ""
"Adding resources via the ``SOURCES`` parameter relies upon a hard-coded "
"list of file extensions which are tested to determine whether they compile"
" (e.g. File.java). ``SOURCES`` files which match the extensions are "
"compiled. Files which do not match are treated as resources. To include "
"uncompiled resources matching those file extensions use the ``RESOURCES`` "
"parameter."
msgstr ""
"通过 ``SOURCES`` 参数添加资源依赖于一个硬编码的文件扩展名列表，这些文件扩展名经过测试以确定它们是否编译（例如 "
"File.java）。编译匹配扩展名的 ``SOURCES`` "
"文件。不匹配的文件被视为资源。要包含与这些文件扩展名匹配的未编译资源，请使用“RESOURCES”参数。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:102
msgid "``INCLUDE_JARS``"
msgstr "``INCLUDE_JARS``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:98
msgid ""
"The list of jars are added to the classpath when compiling the java "
"sources and also to the dependencies of the target. ``INCLUDE_JARS`` also "
"accepts other target names created by ``add_jar()``. For backwards "
"compatibility, jar files listed as sources are ignored (as they have been "
"since the first version of this module)."
msgstr ""
"jar 列表在编译 java 源代码时添加到类路径中，也添加到目标的依赖项中。 ``INCLUDE_JARS`` 还接受由 "
"``add_jar()`` 创建的其他目标名称。为了向后兼容，列为源的 jar 文件将被忽略（因为它们自本模块的第一个版本以来一直如此）。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:105
msgid "``ENTRY_POINT``"
msgstr "``入口点``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:105
msgid "Defines an entry point in the jar file."
msgstr "在 jar 文件中定义入口点。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:108
msgid "Adds a version to the target output name."
msgstr "将版本添加到目标输出名称。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:110
msgid ""
"The following example will create a jar file with the name "
"``shibboleet-1.2.0.jar`` and will create a symlink ``shibboleet.jar`` "
"pointing to the jar with the version information."
msgstr ""
"以下示例将创建一个名为“shibboleet-1.2.0.jar”的 jar "
"文件，并将创建一个符号链接“shibboleet.jar”指向带有版本信息的 jar。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:119
msgid "``MANIFEST``"
msgstr "``清单``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:119
msgid "Defines a custom manifest for the jar."
msgstr "为 jar 定义自定义清单。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:122
msgid "Specify a different output name for the target."
msgstr "为目标指定不同的输出名称。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:126
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:344
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:107
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:220
msgid "``OUTPUT_DIR``"
msgstr "``输出目录``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:125
msgid ""
"Sets the directory where the jar file will be generated. If not specified,"
" :variable:`CMAKE_CURRENT_BINARY_DIR` is used as the output directory."
msgstr ""
"设置将生成 jar 文件的目录。如果未指定，则使用 :variable:`CMAKE_CURRENT_BINARY_DIR` 作为输出目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:166
msgid "``GENERATE_NATIVE_HEADERS``"
msgstr "``GENERATE_NATIVE_HEADERS``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:131
msgid ""
"Generates native header files for methods declared as native. These files "
"provide the connective glue that allow your Java and C code to interact. "
"An INTERFACE target will be created for an easy usage of generated files. "
"Sub-option ``DESTINATION`` can be used to specify the output directory for"
" generated header files."
msgstr ""
"为声明为本机的方法生成本机头文件。这些文件提供了允许 Java 和 C 代码进行交互的连接胶水。将创建一个 INTERFACE "
"目标，以便轻松使用生成的文件。子选项 ``DESTINATION`` 可用于指定生成的头文件的输出目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:137
msgid "This option requires, at least, version 1.8 of the JDK."
msgstr "此选项至少需要 1.8 版的 JDK。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:139
msgid ""
"For an optimum usage of this option, it is recommended to include module "
"JNI before any call to ``add_jar()``. The produced target for native "
"headers can then be used to compile C/C++ sources with the "
":command:`target_link_libraries` command."
msgstr ""
"为了最佳使用此选项，建议在调用 add_jar() 之前包含模块 JNI。然后可以使用为本机头文件生成的目标来使用 "
":command:`target_link_libraries` 命令编译 C/C++ 源代码。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:151
msgid ""
"``DESTINATION`` sub-option now supports the possibility to specify "
"different output directories for ``BUILD`` and ``INSTALL`` steps. If "
"``BUILD`` directory is not specified, a default directory will be used."
msgstr ""
"``DESTINATION`` 子选项现在支持为 ``BUILD`` 和 ``INSTALL`` 步骤指定不同输出目录的可能性。如果未指定 "
"``BUILD`` 目录，将使用默认目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:156
msgid ""
"To export the interface target generated by ``GENERATE_NATIVE_HEADERS`` "
"option, sub-option ``INSTALL`` of ``DESTINATION`` is required:"
msgstr ""
"要导出由``GENERATE_NATIVE_HEADERS`` 选项生成的接口目标，需要``DESTINATION`` "
"的子选项``INSTALL``："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:168
msgid ""
"Some variables can be set to customize the behavior of ``add_jar()`` as "
"well as the java compiler:"
msgstr "可以设置一些变量来自定义 add_jar() 以及 java 编译器的行为："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:172
msgid "``CMAKE_JAVA_COMPILE_FLAGS``"
msgstr "``CMAKE_JAVA_COMPILE_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:172
msgid "Specify additional flags to java compiler."
msgstr "为 java 编译器指定附加标志。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:175
msgid "``CMAKE_JAVA_INCLUDE_PATH``"
msgstr "``CMAKE_JAVA_INCLUDE_PATH``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:175
msgid "Specify additional paths to the class path."
msgstr "指定类路径的附加路径。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:180
msgid "``CMAKE_JNI_TARGET``"
msgstr "``CMAKE_JNI_TARGET``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:178
msgid ""
"If the target is a JNI library, sets this boolean variable to ``TRUE`` to "
"enable creation of a JNI symbolic link (see also "
":ref:`install_jni_symlink() <install_jni_symlink>`)."
msgstr ""
"如果目标是 JNI 库，请将此布尔变量设置为“TRUE”以启用 JNI "
"符号链接的创建（另请参阅:ref:`install_jni_symlink() <install_jni_symlink>`）。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:193
msgid "``CMAKE_JAR_CLASSES_PREFIX``"
msgstr "``CMAKE_JAR_CLASSES_PREFIX``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:183
msgid ""
"If multiple jars should be produced from the same java source filetree, to"
" prevent the accumulation of duplicate class files in subsequent jars, "
"set/reset ``CMAKE_JAR_CLASSES_PREFIX`` prior to calling the ``add_jar()``:"
msgstr ""
"如果应该从同一个 java 源文件树中生成多个 jar，为了防止在后续 jar 中积累重复的类文件，请在调用 ``add_jar()`` "
"之前设置/重置 ``CMAKE_JAR_CLASSES_PREFIX``："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:195
msgid ""
"The ``add_jar()`` function sets the following target properties on "
"``<target_name>``:"
msgstr "``add_jar()`` 函数在 ``<target_name>`` 上设置以下目标属性："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:199
msgid "``INSTALL_FILES``"
msgstr "``安装文件``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:199
msgid ""
"The files which should be installed.  This is used by :ref:`install_jar() "
"<install_jar>`."
msgstr "应该安装的文件。这由 :ref:`install_jar() <install_jar>` 使用。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:202
msgid "``JNI_SYMLINK``"
msgstr "``JNI_SYMLINK``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:202
msgid ""
"The JNI symlink which should be installed.  This is used by "
":ref:`install_jni_symlink() <install_jni_symlink>`."
msgstr ""
"应该安装的 JNI 符号链接。这由 :ref:`install_jni_symlink() <install_jni_symlink>` 使用。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:204
msgid "``JAR_FILE``"
msgstr "``JAR_FILE``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:205
msgid "The location of the jar file so that you can include it."
msgstr "jar 文件的位置，以便您可以包含它。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:207
msgid "``CLASSDIR``"
msgstr "``CLASSDIR``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:207
msgid ""
"The directory where the class files can be found.  For example to use them"
" with ``javah``."
msgstr "可以找到类文件的目录。例如将它们与 ``javah`` 一起使用。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:212
msgid "``NATIVE_HEADERS_DIRECTORY``"
msgstr "``NATIVE_HEADERS_DIRECTORY``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:212
msgid ""
"The directory where native headers are generated. Defined when option "
"``GENERATE_NATIVE_HEADERS`` is specified."
msgstr "生成本机标头的目录。在指定选项``GENERATE_NATIVE_HEADERS`` 时定义。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:219
msgid "This command installs the jar file to the given destination::"
msgstr "此命令将 jar 文件安装到给定目标："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:224
msgid ""
"This command installs the ``<target_name>`` file to the given "
"``<destination>``.  It should be called in the same scope as "
":ref:`add_jar() <add_jar>` or it will fail."
msgstr ""
"此命令将 ``<target_name>`` 文件安装到给定的 ``<destination>``。它应该在与 :ref:`add_jar() "
"<add_jar>` 相同的范围内调用，否则它将失败。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:228
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:258
msgid "The second signature with ``DESTINATION`` and ``COMPONENT`` options."
msgstr "带有``DESTINATION`` 和``COMPONENT`` 选项的第二个签名。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:232
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:262
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:381
msgid "``DESTINATION``"
msgstr "``目的地``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:232
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:262
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:381
msgid "Specify the directory on disk to which a file will be installed."
msgstr "指定磁盘上将安装文件的目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:236
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:266
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:384
msgid "``COMPONENT``"
msgstr "``组件``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:235
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:265
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:384
msgid ""
"Specify an installation component name with which the install rule is "
"associated, such as \"runtime\" or \"development\"."
msgstr "指定与安装规则关联的安装组件名称，例如“runtime”或“development”。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:238
msgid ""
"The ``install_jar()`` command sets the following target properties on "
"``<target_name>``:"
msgstr "``install_jar()`` 命令在 ``<target_name>`` 上设置以下目标属性："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:242
msgid "``INSTALL_DESTINATION``"
msgstr "``安装目标``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:242
msgid ""
"Holds the ``<destination>`` as described above, and is used by "
":ref:`install_jar_exports() <install_jar_exports>`."
msgstr ""
"如上所述保存 ``<destination>``，并由 :ref:`install_jar_exports() "
"<install_jar_exports>` 使用。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:249
msgid ""
"Installs JNI symlinks for target generated by :ref:`add_jar() <add_jar>`::"
msgstr "为由 :ref:`add_jar() <add_jar>`:: 生成的目标安装 JNI 符号链接："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:254
msgid ""
"This command installs the ``<target_name>`` JNI symlinks to the given "
"``<destination>``.  It should be called in the same scope as "
":ref:`add_jar() <add_jar>` or it will fail."
msgstr ""
"此命令将``<target_name>`` JNI 符号链接安装到给定的``<destination>``。它应该在与 "
":ref:`add_jar() <add_jar>` 相同的范围内调用，否则它将失败。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:268
msgid "Utilize the following commands to create a JNI symbolic link:"
msgstr "使用以下命令创建 JNI 符号链接："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:278
msgid "Header Generation"
msgstr "标头生成"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:286
msgid "Generates C header files for java classes::"
msgstr "为 java 类生成 C 头文件 ::"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:295
msgid ""
"This command will no longer be supported starting with version 10 of the "
"JDK due to the `suppression of javah tool "
"<https://openjdk.java.net/jeps/313>`_. The "
":ref:`add_jar(GENERATE_NATIVE_HEADERS) <add_jar>` command should be used "
"instead."
msgstr ""
"由于 `suppression of javah tool <https://openjdk.java.net/jeps/313>`_，从 JDK "
"版本 10 开始将不再支持此命令。应该改用 :ref:`add_jar(GENERATE_NATIVE_HEADERS) <add_jar>` "
"命令。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:301
msgid ""
"Create C header files from java classes. These files provide the "
"connective glue that allow your Java and C code to interact."
msgstr "从 java 类创建 C 头文件。这些文件提供了允许 Java 和 C 代码进行交互的连接胶水。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:304
msgid ""
"There are two main signatures for ``create_javah()``.  The first signature"
" returns generated files through variable specified by the "
"``GENERATED_FILES`` option.  For example:"
msgstr ""
"``create_javah()`` 有两个主要的签名。第一个签名通过“GENERATED_FILES”选项指定的变量返回生成的文件。例如："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:315
msgid ""
"The second signature for ``create_javah()`` creates a target which "
"encapsulates header files generation. E.g."
msgstr "``create_javah()`` 的第二个签名创建了一个封装头文件生成的目标。例如。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:325
msgid "Both signatures share same options."
msgstr "两个签名共享相同的选项。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:328
msgid "``CLASSES``"
msgstr "``类``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:328
msgid "Specifies Java classes used to generate headers."
msgstr "指定用于生成标头的 Java 类。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:332
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:520
msgid "``CLASSPATH``"
msgstr "``类路径``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:331
msgid ""
"Specifies various paths to look up classes. Here ``.class`` files, jar "
"files or targets created by command add_jar can be used."
msgstr "指定查找类的各种路径。这里可以使用 ``.class`` 文件、jar 文件或通过命令 add_jar 创建的目标。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:335
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:182
msgid "``DEPENDS``"
msgstr "``取决于``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:335
msgid "Targets on which the javah target depends."
msgstr "javah 目标所依赖的目标。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:338
msgid ""
"Concatenates the resulting header files for all the classes listed by "
"option ``CLASSES`` into ``<path>``.  Same behavior as option ``-o`` of "
"``javah`` tool."
msgstr "将选项“CLASSES”列出的所有类的结果头文件连接到“<path>”。与 `javah`` 工具的选项 ``-o`` 行为相同。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:343
msgid ""
"Sets the directory where the header files will be generated.  Same "
"behavior as option ``-d`` of ``javah`` tool.  If not specified, "
":variable:`CMAKE_CURRENT_BINARY_DIR` is used as the output directory."
msgstr ""
"设置将生成头文件的目录。与 `javah`` 工具的选项 ``-d`` 行为相同。如果未指定，则使用 "
":variable:`CMAKE_CURRENT_BINARY_DIR` 作为输出目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:348
msgid "Exporting JAR Targets"
msgstr "导出 JAR 目标"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:356
msgid "Installs a target export file::"
msgstr "安装目标导出文件 ::"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:363
msgid ""
"This command installs a target export file ``<filename>`` for the named "
"jar targets to the given ``<destination>`` directory.  Its function is "
"similar to that of :command:`install(EXPORT)`."
msgstr ""
"此命令将命名 jar 目标的目标导出文件 ``<filename>`` 安装到给定的 ``<destination>`` "
"目录。它的功能类似于 :command:`install(EXPORT)`。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:368
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:403
msgid "``TARGETS``"
msgstr "``目标``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:368
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:403
msgid "List of targets created by :ref:`add_jar() <add_jar>` command."
msgstr ":ref:`add_jar() <add_jar>` 命令创建的目标列表。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:374
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:409
msgid "``NAMESPACE``"
msgstr "``命名空间``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:373
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:408
msgid ""
"The ``<namespace>`` value will be prepend to the target names as they are "
"written to the import file."
msgstr "``<namespace>`` 值将在写入导入文件时添加到目标名称之前。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:377
#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:412
msgid "Specify name of the export file."
msgstr "指定导出文件的名称。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:393
msgid "Writes a target export file::"
msgstr "写入目标导出文件 ::"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:399
msgid ""
"This command writes a target export file ``<filename>`` for the named "
"``<jars>`` targets.  Its function is similar to that of :command:`export`."
msgstr "此命令为命名的“<jars>”目标写入目标导出文件“<filename>”。它的功能类似于 :command:`export`。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:415
msgid "Finding JARs"
msgstr "查找 JAR"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:421
msgid "Finds the specified jar file::"
msgstr "查找指定的 jar 文件 ::"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:430
msgid ""
"This command is used to find a full path to the named jar.  A cache entry "
"named by ``<VAR>`` is created to store the result of this command. If the "
"full path to a jar is found the result is stored in the variable and the "
"search will not repeated unless the variable is cleared.  If nothing is "
"found, the result will be ``<VAR>-NOTFOUND``, and the search will be "
"attempted again next time ``find_jar()`` is invoked with the same "
"variable."
msgstr ""
"此命令用于查找指定 jar 的完整路径。创建一个名为 <VAR> 的缓存条目来存储此命令的结果。如果找到 jar "
"的完整路径，结果将存储在变量中，除非清除变量，否则不会重复搜索。如果没有找到，结果将是``<VAR>-NOTFOUND``，下次使用相同的变量调用``find_jar()``"
" 时将再次尝试搜索。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:439
msgid "``NAMES``"
msgstr "``名字``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:439
msgid "Specify one or more possible names for the jar file."
msgstr "为 jar 文件指定一个或多个可能的名称。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:443
msgid "``PATHS``"
msgstr "``路径``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:442
msgid ""
"Specify directories to search in addition to the default locations. The "
"``ENV`` var sub-option reads paths from a system environment variable."
msgstr "除默认位置外，还指定要搜索的目录。 ``ENV`` var 子选项从系统环境变量中读取路径。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:446
msgid "``VERSIONS``"
msgstr "``版本``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:446
msgid "Specify jar versions."
msgstr "指定 jar 版本。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:448
msgid "``DOC``"
msgstr "``文档``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:449
msgid "Specify the documentation string for the ``<VAR>`` cache entry."
msgstr "为 ``<VAR>`` 缓存条目指定文档字符串。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:452
msgid "Creating Java Documentation"
msgstr "创建 Java 文档"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:458
msgid "Creates java documentation based on files and packages::"
msgstr "基于文件和包创建 java 文档 ::"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:472
msgid ""
"The ``create_javadoc()`` command can be used to create java documentation."
" There are two main signatures for ``create_javadoc()``."
msgstr ""
"``create_javadoc()`` 命令可用于创建 java 文档。 ``create_javadoc()`` 有两个主要的签名。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:475
msgid ""
"The first signature works with package names on a path with source files:"
msgstr "第一个签名与源文件路径上的包名称一起使用："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:490
msgid ""
"The second signature for ``create_javadoc()`` works on a given list of "
"files:"
msgstr "``create_javadoc()`` 的第二个签名适用于给定的文件列表："

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:504
msgid ""
"Both signatures share most of the options. For more details please read "
"the javadoc manpage."
msgstr "两个签名共享大部分选项。有关详细信息，请阅读 javadoc 联机帮助页。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:508
msgid "``PACKAGES``"
msgstr "``包裹``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:508
msgid "Specify java packages."
msgstr "指定 java 包。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:512
msgid "``FILES``"
msgstr "``文件``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:511
msgid ""
"Specify java source files. If relative paths are specified, they are "
"relative to :variable:`CMAKE_CURRENT_SOURCE_DIR`."
msgstr "指定 java 源文件。如果指定了相对路径，它们是相对于 CMAKE_CURRENT_SOURCE_DIR 的。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:516
msgid "``SOURCEPATH``"
msgstr "``源路径``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:515
msgid ""
"Specify the directory where to look for packages. By default, "
":variable:`CMAKE_CURRENT_SOURCE_DIR` directory is used."
msgstr "指定查找包的目录。默认情况下，使用 :variable:`CMAKE_CURRENT_SOURCE_DIR` 目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:519
msgid ""
"Specify where to find user class files. Same behavior as option "
"``-classpath`` of ``javadoc`` tool."
msgstr "指定在何处查找用户类文件。与 ``javadoc`` 工具的选项 ``-classpath`` 行为相同。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:525
msgid "``INSTALLPATH``"
msgstr "``安装路径``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:523
msgid ""
"Specify where to install the java documentation. If you specified, the "
"documentation will be installed to "
"``${CMAKE_INSTALL_PREFIX}/share/javadoc/<VAR>``."
msgstr ""
"指定安装 java 文档的位置。如果您指定，文档将安装到“${CMAKE_INSTALL_PREFIX}/share/javadoc/<VAR>”。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:529
msgid "``DOCTITLE``"
msgstr "``DOCTITLE``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:528
msgid ""
"Specify the title to place near the top of the overview summary file. Same"
" behavior as option ``-doctitle`` of ``javadoc`` tool."
msgstr "指定要放在概览摘要文件顶部附近的标题。与 ``javadoc`` 工具的选项 ``-doctitle`` 行为相同。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:533
msgid "``WINDOWTITLE``"
msgstr "``窗口标题``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:532
msgid ""
"Specify the title to be placed in the HTML ``<title>`` tag. Same behavior "
"as option ``-windowtitle`` of ``javadoc`` tool."
msgstr ""
"指定要放置在 HTML ``<title>`` 标记中的标题。与 ``javadoc`` 工具的选项 ``-windowtitle`` 行为相同。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:537
msgid "``AUTHOR``"
msgstr "``作者``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:536
msgid ""
"When value ``TRUE`` is specified, includes the ``@author`` text in the "
"generated docs. Same behavior as option  ``-author`` of ``javadoc`` tool."
msgstr ""
"当指定值“TRUE”时，在生成的文档中包含“@author”文本。与 `javadoc`` 工具的选项 ``-author`` 行为相同。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:542
msgid "``USE``"
msgstr "``使用``"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:540
msgid ""
"When value ``TRUE`` is specified, creates class and package usage pages. "
"Includes one Use page for each documented class and package. Same behavior"
" as option ``-use`` of ``javadoc`` tool."
msgstr ""
"当指定值 ``TRUE`` 时，创建类和包使用页面。为每个记录的类和包包括一个使用页面。与“javadoc”工具的选项“-use”的行为相同。"

#: ../../cmake-prefix/src/cmake/Modules/UseJava.cmake:545
msgid ""
"When value ``TRUE`` is specified, includes the version text in the "
"generated docs. Same behavior as option ``-version`` of ``javadoc`` tool."
msgstr ""
"当指定值 ``TRUE`` 时，在生成的文档中包含版本文本。与 ``javadoc`` 工具的选项 ``-version`` 行为相同。"

#: ../../cmake-prefix/src/cmake/Help/module/UseJavaClassFilelist.rst:2
msgid "UseJavaClassFilelist"
msgstr "使用JavaClass文件列表"

#: ../../cmake-prefix/src/cmake/Help/module/UseJavaClassFilelist.rst:4
#: ../../cmake-prefix/src/cmake/Help/module/UseJavaSymlinks.rst:4
msgid ""
"This module was previously documented by mistake and was never meant for "
"direct inclusion by project code.  See the :module:`UseJava` module."
msgstr "该模块之前被错误地记录下来，从未打算直接包含在项目代码中。请参阅 :module:`UseJava` 模块。"

#: ../../cmake-prefix/src/cmake/Help/module/UseJavaSymlinks.rst:2
msgid "UseJavaSymlinks"
msgstr "使用JavaSymlinks"

#: ../../cmake-prefix/src/cmake/Modules/UsePkgConfig.cmake:6
msgid "UsePkgConfig"
msgstr "使用PkgConfig"

#: ../../cmake-prefix/src/cmake/Modules/UsePkgConfig.cmake:8
msgid "Obsolete pkg-config module for CMake, use FindPkgConfig instead."
msgstr "CMake 的过时 pkg-config 模块，请改用 FindPkgConfig。"

#: ../../cmake-prefix/src/cmake/Modules/UsePkgConfig.cmake:12
msgid "This module defines the following macro:"
msgstr "该模块定义了以下宏："

#: ../../cmake-prefix/src/cmake/Modules/UsePkgConfig.cmake:14
msgid "PKGCONFIG(package includedir libdir linkflags cflags)"
msgstr "PKGCONFIG（包内含dir libdir linkflags cflags）"

#: ../../cmake-prefix/src/cmake/Modules/UsePkgConfig.cmake:16
msgid ""
"Calling PKGCONFIG will fill the desired information into the 4 given "
"arguments, e.g.  PKGCONFIG(libart-2.0 LIBART_INCLUDE_DIR LIBART_LINK_DIR "
"LIBART_LINK_FLAGS LIBART_CFLAGS) if pkg-config was NOT found or the "
"specified software package doesn't exist, the variable will be empty when "
"the function returns, otherwise they will contain the respective "
"information"
msgstr ""
"调用 PKGCONFIG 会将所需信息填充到 4 个给定参数中，例如PKGCONFIG(libart-2.0 LIBART_INCLUDE_DIR "
"LIBART_LINK_DIR LIBART_LINK_FLAGS LIBART_CFLAGS) 如果没有找到pkg-"
"config或者指定的软件包不存在，函数返回时变量为空，否则包含各自的信息"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:6
msgid "UseSWIG"
msgstr "使用SWIG"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:8
msgid ""
"This file provides support for ``SWIG``. It is assumed that "
":module:`FindSWIG` module has already been loaded."
msgstr "此文件提供对 ``SWIG`` 的支持。假设 FindSWIG 模块已经加载。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:16
msgid "CMake Commands"
msgstr "命令"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:18
msgid "The following command is defined for use with ``SWIG``:"
msgstr "以下命令被定义为与 ``SWIG`` 一起使用："

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:24
msgid "Define swig module with given name and specified language::"
msgstr "使用给定名称和指定语言定义 swig 模块 ::"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:35
msgid ""
"Targets created with the ``swig_add_library`` command have the same "
"capabilities as targets created with the :command:`add_library` command, "
"so those targets can be used with any command expecting a target (e.g. "
":command:`target_link_libraries`)."
msgstr ""
"使用 ``swig_add_library`` 命令创建的目标与使用 :command:`add_library` "
"命令创建的目标具有相同的功能，因此这些目标可以与任何需要目标的命令一起使用（例如:command:`target_link_libraries`）。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:40
msgid ""
"This command creates a target with the specified ``<name>`` when policy "
":policy:`CMP0078` is set to ``NEW``.  Otherwise, the legacy behavior will "
"choose a different target name and store it in the "
"``SWIG_MODULE_<name>_REAL_NAME`` variable."
msgstr ""
"当策略 :policy:`CMP0078` 设置为 ``NEW`` 时，此命令创建一个具有指定 ``<name>`` "
"的目标。否则，遗留行为将选择不同的目标名称并将其存储在 ``SWIG_MODULE_<name>_REAL_NAME`` 变量中。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:46
msgid ""
"Alternate library name (set with the :prop_tgt:`OUTPUT_NAME` property, for"
" example) will be passed on to ``Python`` and ``CSharp`` wrapper "
"libraries."
msgstr ""
"备用库名称（例如，使用 :prop_tgt:`OUTPUT_NAME` 属性设置）将传递给 ``Python`` 和 ``CSharp`` "
"包装器库。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:51
msgid ""
"Generated library use standard naming conventions for ``CSharp`` language "
"when policy :policy:`CMP0122` is set to ``NEW``. Otherwise, the legacy "
"behavior is applied."
msgstr ""
"当策略:policy:`CMP0122` 设置为 ``NEW`` 时，生成的库使用 ``CSharp`` 语言的标准命名约定。否则，将应用遗留行为。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:58
msgid ""
"For multi-config generators, this module does not support configuration-"
"specific files generated by ``SWIG``. All build configurations must result"
" in the same generated source file."
msgstr "对于多配置生成器，此模块不支持由 SWIG 生成的特定于配置的文件。所有构建配置必须产生相同的生成源文件。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:64
msgid ""
"For :ref:`Makefile Generators`, if, for some sources, the "
"``USE_SWIG_DEPENDENCIES`` property is ``FALSE``, ``swig_add_library`` does"
" not track file dependencies, so depending on the "
"``<name>_swig_compilation`` custom target is required for targets which "
"require the ``swig``-generated files to exist. Other generators may depend"
" on the source files that would be generated by SWIG."
msgstr ""
"对于 :ref:`Makefile Generators`，如果对于某些来源，``USE_SWIG_DEPENDENCIES`` 属性为 "
"``FALSE``，``swig_add_library`` 不跟踪文件依赖项，因此取决于 ``<name>_swig_compilation ``"
" 自定义目标对于需要 ``swig`` 生成的文件存在的目标是必需的。其他生成器可能依赖于 SWIG 生成的源文件。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:76
msgid "``TYPE``"
msgstr "``类型``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:72
msgid ""
"``SHARED``, ``MODULE`` and ``STATIC`` have the same semantic as for the "
":command:`add_library` command. If ``USE_BUILD_SHARED_LIBS`` is specified,"
" the library type will be ``STATIC`` or ``SHARED`` based on whether the "
"current value of the :variable:`BUILD_SHARED_LIBS` variable is ``ON``. If "
"no type is specified, ``MODULE`` will be used."
msgstr ""
"``SHARED``、``MODULE`` 和 ``STATIC`` 与 :command:`add_library` "
"命令具有相同的语义。如果指定了 ``USE_BUILD_SHARED_LIBS``，则库类型将为 ``STATIC`` 或 "
"``SHARED``，具体取决于 :variable:`BUILD_SHARED_LIBS` 变量的当前值是否为 "
"``ON``。如果没有指定类型，将使用 ``MODULE``。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:79
msgid "Specify the target language."
msgstr "指定目标语言。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:81
msgid "Go and Lua language support."
msgstr "Go 和 Lua 语言支持。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:84
msgid "R language support."
msgstr "R 语言支持。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:87
msgid "Fortran language support."
msgstr "Fortran 语言支持。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:93
msgid "``NO_PROXY``"
msgstr "``NO_PROXY``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:93
msgid ""
"Prevent the generation of the wrapper layer (swig ``-noproxy`` option)."
msgstr "防止生成包装层（swig ``-noproxy`` 选项）。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:98
msgid ""
"Specify where to write the language specific files (swig ``-outdir`` "
"option). If not given, the ``CMAKE_SWIG_OUTDIR`` variable will be used. If"
" neither is specified, the default depends on the value of the "
"``UseSWIG_MODULE_VERSION`` variable as follows:"
msgstr ""
"指定语言特定文件的写入位置（swig ``-outdir`` 选项）。如果未给出，将使用 ``CMAKE_SWIG_OUTDIR`` "
"变量。如果两者均未指定，则默认值取决于 ``UseSWIG_MODULE_VERSION`` 变量的值，如下所示："

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:103
msgid ""
"If ``UseSWIG_MODULE_VERSION`` is 1 or is undefined, output is written to "
"the :variable:`CMAKE_CURRENT_BINARY_DIR` directory."
msgstr ""
"如果 ``UseSWIG_MODULE_VERSION`` 为 1 或未定义，则输出将写入 "
":variable:`CMAKE_CURRENT_BINARY_DIR` 目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:105
msgid ""
"If ``UseSWIG_MODULE_VERSION`` is 2, a dedicated directory will be used. "
"The path of this directory can be retrieved from the "
"``SWIG_SUPPORT_FILES_DIRECTORY`` target property."
msgstr ""
"如果 ``UseSWIG_MODULE_VERSION`` 为 2，将使用专用目录。可以从 SWIG_SUPPORT_FILES_DIRECTORY"
" 目标属性中检索此目录的路径。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:115
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:229
msgid "``OUTFILE_DIR``"
msgstr "``OUTFILE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:112
msgid ""
"Specify an output directory name where the generated source file will be "
"placed (swig ``-o`` option). If not specified, the ``SWIG_OUTFILE_DIR`` "
"variable will be used. If neither is specified, ``OUTPUT_DIR`` or "
"``CMAKE_SWIG_OUTDIR`` is used instead."
msgstr ""
"指定将放置生成的源文件的输出目录名称（swig ``-o`` 选项）。如果未指定，将使用 ``SWIG_OUTFILE_DIR`` "
"变量。如果两者均未指定，则使用 ``OUTPUT_DIR`` 或 ``CMAKE_SWIG_OUTDIR`` 代替。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:118
msgid ""
"List of sources for the library. Files with extension ``.i`` will be "
"identified as sources for the ``SWIG`` tool. Other files will be handled "
"in the standard way."
msgstr "库的源列表。扩展名为“.i”的文件将被识别为“SWIG”工具的来源。其他文件将以标准方式处理。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:122
msgid ""
"This behavior can be overridden by specifying the variable "
"``SWIG_SOURCE_FILE_EXTENSIONS``."
msgstr "可以通过指定变量“SWIG_SOURCE_FILE_EXTENSIONS”来覆盖此行为。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:128
msgid ""
"If ``UseSWIG_MODULE_VERSION`` is set to 2, it is **strongly** recommended "
"to use a dedicated directory unique to the target when either the "
"``OUTPUT_DIR`` option or the ``CMAKE_SWIG_OUTDIR`` variable are specified."
" The output directory contents are erased as part of the target build, so "
"to prevent interference between targets or losing other important files, "
"each target should have its own dedicated output directory."
msgstr ""
"如果 ``UseSWIG_MODULE_VERSION`` 设置为 2，则**强烈**建议在指定 ``OUTPUT_DIR`` 选项或 "
"``CMAKE_SWIG_OUTDIR`` "
"变量时使用目标唯一的专用目录。输出目录内容作为目标构建的一部分被删除，因此为了防止目标之间的干扰或丢失其他重要文件，每个目标都应该有自己的专用输出目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:136
msgid "Properties on Source Files"
msgstr "源文件的属性"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:138
msgid ""
"Source file properties on module files **must** be set before the "
"invocation of the ``swig_add_library`` command to specify special behavior"
" of SWIG and ensure generated files will receive the required settings."
msgstr ""
"模块文件的源文件属性**必须**在调用 ``swig_add_library`` 命令之前设置，以指定 SWIG "
"的特殊行为并确保生成的文件将接收所需的设置。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:148
msgid "``CPLUSPLUS``"
msgstr "``CPLUS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:143
msgid "Call SWIG in c++ mode.  For example:"
msgstr "在 C++ 模式下调用 SWIG。例如："

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:154
msgid "``SWIG_FLAGS``"
msgstr "``SWIG_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:151
msgid "Replaced with the fine-grained properties that follow."
msgstr "替换为后面的细粒度属性。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:154
msgid "Pass custom flags to the SWIG executable."
msgstr "将自定义标志传递给 SWIG 可执行文件。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:161
msgid ""
"``INCLUDE_DIRECTORIES``, ``COMPILE_DEFINITIONS`` and ``COMPILE_OPTIONS``"
msgstr ""
"``INCLUDE_DIRECTORIES``、``COMPILE_DEFINITIONS`` 和 ``COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:159
msgid ""
"Add custom flags to SWIG compiler and have same semantic as properties "
":prop_sf:`INCLUDE_DIRECTORIES`, :prop_sf:`COMPILE_DEFINITIONS` and "
":prop_sf:`COMPILE_OPTIONS`."
msgstr ""
"向 SWIG 编译器添加自定义标志，并与属性 INCLUDE_DIRECTORIES、COMPILE_DEFINITIONS 和 "
"COMPILE_OPTIONS 具有相同的语义。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:170
msgid "``USE_TARGET_INCLUDE_DIRECTORIES``"
msgstr "``USE_TARGET_INCLUDE_DIRECTORIES``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:166
msgid ""
"If set to ``TRUE``, contents of target property "
":prop_tgt:`INCLUDE_DIRECTORIES` will be forwarded to ``SWIG`` compiler. If"
" set to ``FALSE`` target property :prop_tgt:`INCLUDE_DIRECTORIES` will be "
"ignored. If not set, target property "
"``SWIG_USE_TARGET_INCLUDE_DIRECTORIES`` will be considered."
msgstr ""
"如果设置为 TRUE，目标属性 :prop_tgt:INCLUDE_DIRECTORIES 的内容将被转发到 SWIG 编译器。如果设置为 "
"``FALSE`` 目标属性 :prop_tgt:`INCLUDE_DIRECTORIES` "
"将被忽略。如果未设置，将考虑目标属性“SWIG_USE_TARGET_INCLUDE_DIRECTORIES”。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:177
msgid ""
"``GENERATED_INCLUDE_DIRECTORIES``, ``GENERATED_COMPILE_DEFINITIONS`` and "
"``GENERATED_COMPILE_OPTIONS``"
msgstr ""
"``GENERATED_INCLUDE_DIRECTORIES``、``GENERATED_COMPILE_DEFINITIONS`` 和 "
"``GENERATED_COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:175
msgid ""
"Add custom flags to the C/C++ generated source. They will fill, "
"respectively, properties :prop_sf:`INCLUDE_DIRECTORIES`, "
":prop_sf:`COMPILE_DEFINITIONS` and :prop_sf:`COMPILE_OPTIONS` of generated"
" C/C++ file."
msgstr ""
"将自定义标志添加到 C/C++ 生成的源代码。它们将分别填充生成的 C/C++ 文件的属性 "
":prop_sf:`INCLUDE_DIRECTORIES`、 :prop_sf:`COMPILE_DEFINITIONS` 和 "
":prop_sf:`COMPILE_OPTIONS`。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:182
msgid "Specify additional dependencies to the source file."
msgstr "指定对源文件的附加依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:199
msgid "``USE_SWIG_DEPENDENCIES``"
msgstr "``USE_SWIG_DEPENDENCIES``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:187
msgid ""
"If set to ``TRUE``, implicit dependencies are generated by the ``swig`` "
"tool itself. This property is only meaningful for :ref:`Makefile <Makefile"
" Generators>`, :ref:`Ninja <Ninja Generators>`, :generator:`Xcode`, and "
":ref:`Visual Studio <Visual Studio Generators>` (:generator:`Visual Studio"
" 11 2012` and above) generators. Default value is ``FALSE``."
msgstr ""
"如果设置为“TRUE”，则隐式依赖项由“swig”工具本身生成。此属性仅对 :ref:`Makefile <Makefile "
"Generators>`、 :ref:`Ninja <Ninja Generators>`、 :generator:`Xcode` "
"和 :ref:`Visual Studio <Visual Studio Generators>` 有意义（:generator:`Visual Studio "
"11 2012` 及以上）生成器。默认值为“假”。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:195
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:362
msgid "Added the support of :generator:`Xcode` generator."
msgstr "添加了对 :generator:`Xcode` 生成器的支持。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:198
#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:365
msgid "Added the support of :ref:`Visual Studio Generators`."
msgstr "添加了对 :ref:`Visual Studio Generators` 的支持。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:212
msgid "``SWIG_MODULE_NAME``"
msgstr "``SWIG_MODULE_NAME``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:202
msgid ""
"Specify the actual import name of the module in the target language. This "
"is required if it cannot be scanned automatically from source or different"
" from the module file basename.  For example:"
msgstr "以目标语言指定模块的实际导入名称。如果无法从源自动扫描或与模块文件基本名称不同，则这是必需的。例如："

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:210
msgid ""
"If policy :policy:`CMP0086` is set to ``NEW``, ``-module <module_name>`` "
"is passed to ``SWIG`` compiler."
msgstr ""
"如果策略:policy:`CMP0086` 设置为 ``NEW``，``-module <module_name>`` 将传递给 ``SWIG`` 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:217
msgid ""
"Specify where to write the language specific files (swig ``-outdir`` "
"option) for the considered source file. If not specified, the other ways "
"to define the output directory applies (see ``OUTPUT_DIR`` option of "
"``swig_add_library()`` command)."
msgstr ""
"为所考虑的源文件指定语言特定文件的写入位置（swig ``-outdir`` 选项）。如果未指定，则适用其他定义输出目录的方法（请参阅 "
"``swig_add_library()`` 命令的 ``OUTPUT_DIR`` 选项）。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:225
msgid ""
"Specify an output directory where the generated source file will be placed"
" (swig ``-o`` option) for the considered source file. If not specified, "
"``OUTPUT_DIR`` source property will be used. If neither are specified, the"
" other ways to define output file directory applies (see ``OUTFILE_DIR`` "
"option of ``swig_add_library()`` command)."
msgstr ""
"为所考虑的源文件指定一个输出目录，生成的源文件将放置在该目录中（swig ``-o`` 选项）。如果未指定，将使用 ``OUTPUT_DIR`` "
"源属性。如果两者均未指定，则适用其他定义输出文件目录的方法（请参阅 ``swig_add_library()`` 命令的 "
"``OUTFILE_DIR`` 选项）。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:232
msgid "Properties on Targets"
msgstr "目标属性"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:234
msgid ""
"Target library properties can be set to apply same configuration to all "
"SWIG input files."
msgstr "可以设置目标库属性以将相同的配置应用于所有 SWIG 输入文件。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:249
msgid ""
"``SWIG_INCLUDE_DIRECTORIES``, ``SWIG_COMPILE_DEFINITIONS`` and "
"``SWIG_COMPILE_OPTIONS``"
msgstr ""
"``SWIG_INCLUDE_DIRECTORIES``、``SWIG_COMPILE_DEFINITIONS`` 和 "
"``SWIG_COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:240
msgid ""
"These properties will be applied to all SWIG input files and have same "
"semantic as target properties :prop_tgt:`INCLUDE_DIRECTORIES`, "
":prop_tgt:`COMPILE_DEFINITIONS` and :prop_tgt:`COMPILE_OPTIONS`."
msgstr ""
"这些属性将应用于所有 SWIG "
"输入文件，并与目标属性具有相同的语义:prop_tgt:`INCLUDE_DIRECTORIES`、 :prop_tgt:`COMPILE_DEFINITIONS`"
" 和 :prop_tgt:`COMPILE_OPTIONS`。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:258
msgid "``SWIG_USE_TARGET_INCLUDE_DIRECTORIES``"
msgstr "``SWIG_USE_TARGET_INCLUDE_DIRECTORIES``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:254
msgid ""
"If set to ``TRUE``, contents of target property "
":prop_tgt:`INCLUDE_DIRECTORIES` will be forwarded to ``SWIG`` compiler. If"
" set to ``FALSE`` or not defined, target property "
":prop_tgt:`INCLUDE_DIRECTORIES` will be ignored. This behavior can be "
"overridden by specifying source property "
"``USE_TARGET_INCLUDE_DIRECTORIES``."
msgstr ""
"如果设置为 TRUE，目标属性 :prop_tgt:INCLUDE_DIRECTORIES 的内容将被转发到 SWIG "
"编译器。如果设置为``FALSE`` 或未定义，目标属性 :prop_tgt:`INCLUDE_DIRECTORIES` "
"将被忽略。可以通过指定源属性“USE_TARGET_INCLUDE_DIRECTORIES”来覆盖此行为。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:265
msgid ""
"``SWIG_GENERATED_INCLUDE_DIRECTORIES``, "
"``SWIG_GENERATED_COMPILE_DEFINITIONS`` and "
"``SWIG_GENERATED_COMPILE_OPTIONS``"
msgstr ""
"``SWIG_GENERATED_INCLUDE_DIRECTORIES``、``SWIG_GENERATED_COMPILE_DEFINITIONS``"
" 和 ``SWIG_GENERATED_COMPILE_OPTIONS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:263
msgid ""
"These properties will populate, respectively, properties "
":prop_sf:`INCLUDE_DIRECTORIES`, :prop_sf:`COMPILE_DEFINITIONS` and "
":prop_sf:`COMPILE_FLAGS` of all generated C/C++ files."
msgstr ""
"这些属性将分别填充所有生成的 C/C++ "
"文件的属性:prop_sf:`INCLUDE_DIRECTORIES`、 :prop_sf:`COMPILE_DEFINITIONS` 和 "
":prop_sf:`COMPILE_FLAGS`。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:270
msgid "``SWIG_DEPENDS``"
msgstr "``SWIG_DEPENDS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:270
msgid "Add dependencies to all SWIG input files."
msgstr "将依赖项添加到所有 SWIG 输入文件。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:273
msgid "Read-only Target Properties"
msgstr "只读目标属性"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:275
msgid ""
"The following target properties are output properties and can be used to "
"get information about support files generated by ``SWIG`` interface "
"compilation."
msgstr "以下目标属性是输出属性，可用于获取有关“SWIG”接口编译生成的支持文件的信息。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:294
msgid "``SWIG_SUPPORT_FILES``"
msgstr "``SWIG_SUPPORT_FILES``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:281
msgid ""
"This output property list of wrapper files generated during SWIG "
"compilation."
msgstr "SWIG 编译期间生成的包装文件的输出属性列表。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:291
msgid ""
"Only most principal support files are listed. In case some advanced "
"features of ``SWIG`` are used (for example ``%template``), associated "
"support files may not be listed. Prefer to use the "
"``SWIG_SUPPORT_FILES_DIRECTORY`` property to handle support files."
msgstr ""
"仅列出了大多数主要支持文件。如果使用了“SWIG”的某些高级功能（例如“%template”），则可能不会列出相关的支持文件。更喜欢使用 "
"``SWIG_SUPPORT_FILES_DIRECTORY`` 属性来处理支持文件。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:305
msgid "``SWIG_SUPPORT_FILES_DIRECTORY``"
msgstr "``SWIG_SUPPORT_FILES_DIRECTORY``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:299
msgid ""
"This output property specifies the directory where support files will be "
"generated."
msgstr "此输出属性指定将生成支持文件的目录。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:304
msgid ""
"When source property ``OUTPUT_DIR`` is defined, multiple directories can "
"be specified as part of ``SWIG_SUPPORT_FILES_DIRECTORY``."
msgstr "定义源属性“OUTPUT_DIR”时，可以将多个目录指定为“SWIG_SUPPORT_FILES_DIRECTORY”的一部分。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:308
msgid "CMake Variables"
msgstr "CMake 变量"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:310
msgid ""
"Some variables can be set to customize the behavior of "
"``swig_add_library`` as well as ``SWIG``:"
msgstr "可以设置一些变量来自定义 ``swig_add_library`` 和 ``SWIG`` 的行为："

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:320
msgid "``UseSWIG_MODULE_VERSION``"
msgstr "``使用 SWIG_MODULE_VERSION``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:316
msgid "Specify different behaviors for ``UseSWIG`` module."
msgstr "为“UseSWIG”模块指定不同的行为。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:318
msgid "Set to 1 or undefined: Legacy behavior is applied."
msgstr "设置为 1 或未定义：应用旧版行为。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:319
msgid ""
"Set to 2: A new strategy is applied regarding support files: the output "
"directory of support files is erased before ``SWIG`` interface "
"compilation."
msgstr "设置为 2：关于支持文件应用新策略：支持文件的输出目录在 SWIG 接口编译之前被擦除。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:323
msgid "``CMAKE_SWIG_FLAGS``"
msgstr "``CMAKE_SWIG_FLAGS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:323
msgid "Add flags to all swig calls."
msgstr "向所有 swig 调用添加标志。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:326
msgid "``CMAKE_SWIG_OUTDIR``"
msgstr "``CMAKE_SWIG_OUTDIR``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:326
msgid ""
"Specify where to write the language specific files (swig ``-outdir`` "
"option)."
msgstr "指定语言特定文件的写入位置（swig ``-outdir`` 选项）。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:332
msgid "``SWIG_OUTFILE_DIR``"
msgstr "``SWIG_OUTFILE_DIR``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:331
msgid ""
"Specify an output directory name where the generated source file will be "
"placed.  If not specified, ``CMAKE_SWIG_OUTDIR`` is used."
msgstr "指定将放置生成的源文件的输出目录名称。如果未指定，则使用 ``CMAKE_SWIG_OUTDIR``。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:335
msgid "``SWIG_MODULE_<name>_EXTRA_DEPS``"
msgstr "``SWIG_MODULE_<name>_EXTRA_DEPS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:335
msgid "Specify extra dependencies for the generated module for ``<name>``."
msgstr "为 ``<name>`` 的生成模块指定额外的依赖项。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:346
msgid "``SWIG_SOURCE_FILE_EXTENSIONS``"
msgstr "``SWIG_SOURCE_FILE_EXTENSIONS``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:340
msgid ""
"Specify a list of source file extensions to override the default behavior "
"of considering only ``.i`` files as sources for the ``SWIG`` tool. For "
"example:"
msgstr "指定源文件扩展名列表以覆盖仅将“.i”文件视为“SWIG”工具的源的默认行为。例如："

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:366
msgid "``SWIG_USE_SWIG_DEPENDENCIES``"
msgstr "``SWIG_USE_SWIG_DEPENDENCIES``"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:351
msgid ""
"If set to ``TRUE``, implicit dependencies are generated by the ``swig`` "
"tool itself. This variable is only meaningful for :ref:`Makefile <Makefile"
" Generators>`, :ref:`Ninja <Ninja Generators>`, :generator:`Xcode`, and "
":ref:`Visual Studio <Visual Studio Generators>` (:generator:`Visual Studio"
" 11 2012` and above) generators. Default value is ``FALSE``."
msgstr ""
"如果设置为“TRUE”，则隐式依赖项由“swig”工具本身生成。此变量仅对 :ref:`Makefile <Makefile "
"Generators>`、 :ref:`Ninja <Ninja Generators>`、 :generator:`Xcode` 和 "
":ref:`Visual Studio <Visual Studio Generators>` 有意义（:generator:`Visual Studio 11"
" 2012` 及以上）生成器。默认值为“假”。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:359
msgid ""
"Source file property ``USE_SWIG_DEPENDENCIES``, if not defined, will be "
"initialized with the value of this variable."
msgstr "源文件属性“USE_SWIG_DEPENDENCIES”如果未定义，将使用此变量的值进行初始化。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:369
msgid "Deprecated Commands"
msgstr "弃用的命令"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:373
msgid ""
"Use :command:`target_link_libraries` with the standard target name, or "
"with ``${SWIG_MODULE_<name>_REAL_NAME}`` for legacy target naming."
msgstr ""
"将 :command:`target_link_libraries` 与标准目标名称一起使用，或与 "
"``${SWIG_MODULE_<name>_REAL_NAME}`` 一起用于遗留目标命名。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:377
msgid "Link libraries to swig module::"
msgstr "将库链接到 swig 模块 ::"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:381
msgid ""
"This command has same capabilities as :command:`target_link_libraries` "
"command."
msgstr "此命令与 :command:`target_link_libraries` 命令具有相同的功能。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:385
msgid ""
"When policy :policy:`CMP0078` is set to ``NEW``, "
":command:`swig_add_library` creates a standard target with the specified "
"``<name>`` and :command:`target_link_libraries` must be used instead of "
"this command."
msgstr ""
"当策略 :policy:`CMP0078` 设置为 ``NEW`` 时， :command:`swig_add_library` 使用指定的 "
"``<name>`` 创建一个标准目标并且必须使用 :command:`target_link_libraries` 而不是这个命令。"

#: ../../cmake-prefix/src/cmake/Modules/UseSWIG.cmake:390
msgid ""
"With the legacy behavior (when :policy:`CMP0078` is set to ``OLD`` and the"
" ``UseSWIG_TARGET_NAME_PREFERENCE`` variable is set to ``\"LEGACY\"``, or "
"in CMake versions prior to 3.12), it is preferable to use "
"``target_link_libraries(${SWIG_MODULE_<name>_REAL_NAME} ...)`` instead of "
"this command."
msgstr ""
"对于遗留行为（当:policy:`CMP0078` 设置为``OLD`` 并且``UseSWIG_TARGET_NAME_PREFERENCE`` "
"变量设置为``\"LEGACY\"``，或者在 3.12 之前的 CMake "
"版本中），它是最好使用``target_link_libraries(${SWIG_MODULE_<name>_REAL_NAME} ...)`` "
"而不是这个命令。"

#: ../../cmake-prefix/src/cmake/Modules/Use_wxWindows.cmake:6
msgid "Use_wxWindows"
msgstr "使用_wxWindows"

#: ../../cmake-prefix/src/cmake/Modules/Use_wxWindows.cmake:10
msgid ""
"Use ``find_package(wxWidgets)`` and ``include(${wxWidgets_USE_FILE})`` "
"instead."
msgstr ""
"使用``find_package(wxWidgets)`` 和``include(${wxWidgets_USE_FILE})`` 代替。"

#: ../../cmake-prefix/src/cmake/Modules/Use_wxWindows.cmake:12
msgid ""
"This convenience include finds if wxWindows is installed and set the "
"appropriate libs, incdirs, flags etc.  author Jan Woetzel <jw -at- "
"mip.informatik.uni-kiel.de> (07/2003)"
msgstr ""
"这种便利包括查找是否安装了 wxWindows 并设置适当的库、incdirs、标志等。作者 Jan Woetzel <jw -at-"
"mip.informatik.uni-kiel.de> (07/2003)"

#: ../../cmake-prefix/src/cmake/Modules/Use_wxWindows.cmake:16
msgid "USAGE:"
msgstr "用法："

#: ../../cmake-prefix/src/cmake/Modules/Use_wxWindows.cmake:23
msgid "include( ${CMAKE_MODULE_PATH}/Use_wxWindows.cmake)"
msgstr "包括（${CMAKE_MODULE_PATH}/Use_wxWindows.cmake）"

#: ../../cmake-prefix/src/cmake/Modules/Use_wxWindows.cmake:29
msgid "set(WXWINDOWS_USE_GL 1)"
msgstr "设置（WXWINDOWS_USE_GL 1）"

#: ../../cmake-prefix/src/cmake/Modules/UsewxWidgets.cmake:6
msgid "UsewxWidgets"
msgstr "使用wxWidgets"

#: ../../cmake-prefix/src/cmake/Modules/UsewxWidgets.cmake:8
msgid "Convenience include for using wxWidgets library."
msgstr "便利包括使用 wxWidgets 库。"

#: ../../cmake-prefix/src/cmake/Modules/UsewxWidgets.cmake:10
msgid ""
"Determines if wxWidgets was FOUND and sets the appropriate libs, incdirs, "
"flags, etc.  INCLUDE_DIRECTORIES and LINK_DIRECTORIES are called."
msgstr ""
"确定是否找到 wxWidgets 并设置适当的库、incdirs、标志等。调用 INCLUDE_DIRECTORIES 和 "
"LINK_DIRECTORIES。"

#: ../../cmake-prefix/src/cmake/Modules/UsewxWidgets.cmake:34
msgid "AUTHOR"
msgstr "作者"

#: ../../cmake-prefix/src/cmake/Modules/WriteBasicConfigVersionFile.cmake:6
msgid "WriteBasicConfigVersionFile"
msgstr "写入基本配置版本文件"

#: ../../cmake-prefix/src/cmake/Modules/WriteBasicConfigVersionFile.cmake:10
msgid ""
"Use the identical command :command:`write_basic_package_version_file()` "
"from module :module:`CMakePackageConfigHelpers`."
msgstr ""
"使用模块 CMakePackageConfigHelpers 中的相同命令 write_basic_package_version_file() 。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:6
msgid "WriteCompilerDetectionHeader"
msgstr "WriteCompilerDetectionHeader"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:8
msgid ""
"This module is available only if policy :policy:`CMP0120` is not set to "
"``NEW``.  Do not use it in new code."
msgstr "此模块仅在政策:policy:`CMP0120` 未设置为``NEW`` 时可用。不要在新代码中使用它。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:14
msgid ""
"This module provides the function ``write_compiler_detection_header()``."
msgstr "该模块提供函数``write_compiler_detection_header()``。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:16
msgid ""
"This function can be used to generate a file suitable for preprocessor "
"inclusion which contains macros to be used in source code::"
msgstr "此函数可用于生成适合预处理器包含的文件，其中包含要在源代码中使用的宏："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:33
msgid ""
"This generates the file ``<file>`` with macros which all have the prefix "
"``<prefix>``."
msgstr "这会生成带有宏的文件 ``<file>``，这些宏都带有前缀 ``<prefix>``。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:36
msgid ""
"By default, all content is written directly to the ``<file>``.  The "
"``OUTPUT_FILES_VAR`` may be specified to cause the compiler-specific "
"content to be written to separate files.  The separate files are then "
"available in the ``<output_files_var>`` and may be consumed by the caller "
"for installation for example.  The ``OUTPUT_DIR`` specifies a relative "
"path from the main ``<file>`` to the compiler-specific files. For example:"
msgstr ""
"默认情况下，所有内容都直接写入 ``<file>``。可以指定 ``OUTPUT_FILES_VAR`` "
"以将特定于编译器的内容写入单独的文件。然后，单独的文件在 ``<output_files_var>`` 中可用，并且可以由调用者使用以进行安装等。 "
"``OUTPUT_DIR`` 指定从主``<file>`` 到编译器特定文件的相对路径。例如："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:63
msgid ""
"``VERSION`` may be used to specify the API version to be generated. Future"
" versions of CMake may introduce alternative APIs.  A given API is "
"selected by any ``<version>`` value greater than or equal to the version "
"of CMake that introduced the given API and less than the version of CMake "
"that introduced its succeeding API. The value of the "
":variable:`CMAKE_MINIMUM_REQUIRED_VERSION` variable is used if no explicit"
" version is specified. (As of CMake version |release| there is only one "
"API version.)"
msgstr ""
"``VERSION`` 可用于指定要生成的 API 版本。 CMake 的未来版本可能会引入替代 API。给定的 API 由大于或等于引入给定 "
"API 的 CMake 版本且小于引入其后续 API 的 CMake 版本的任何“<version>”值选择。如果未指定显式版本，则使用 "
":variable:`CMAKE_MINIMUM_REQUIRED_VERSION` 变量的值。 （从 CMake 版本 |release| "
"开始，只有一个 API 版本。）"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:72
msgid ""
"``PROLOG`` may be specified as text content to write at the start of the "
"header. ``EPILOG`` may be specified as text content to write at the end of"
" the header"
msgstr "``PROLOG`` 可以指定为要写在标题开头的文本内容。 ``EPILOG`` 可以指定为要写在标题末尾的文本内容"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:76
msgid ""
"At least one ``<compiler>`` and one ``<feature>`` must be listed.  "
"Compilers which are known to CMake, but not specified are detected and a "
"preprocessor ``#error`` is generated for them.  A preprocessor macro "
"matching ``<PREFIX>_COMPILER_IS_<compiler>`` is generated for each "
"compiler known to CMake to contain the value ``0`` or ``1``."
msgstr ""
"至少必须列出一个 ``<compiler>`` 和一个 ``<feature>``。检测到 CMake "
"已知但未指定的编译器，并为它们生成预处理器“#error”。为 CMake "
"已知的每个编译器生成匹配“<PREFIX>_COMPILER_IS_<compiler>”的预处理器宏，包含值“0”或“1”。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:82
msgid ""
"Possible compiler identifiers are documented with the "
":variable:`CMAKE_<LANG>_COMPILER_ID` variable. Available features in this "
"version of CMake are listed in the :prop_gbl:`CMAKE_C_KNOWN_FEATURES` and "
":prop_gbl:`CMAKE_CXX_KNOWN_FEATURES` global properties. See the "
":manual:`cmake-compile-features(7)` manual for information on compile "
"features."
msgstr ""
"可能的编译器标识符记录在 :variable:`CMAKE_<LANG>_COMPILER_ID` 变量中。此版本 CMake 中的可用功能列在 "
":prop_gbl:`CMAKE_C_KNOWN_FEATURES` 和 :prop_gbl:`CMAKE_CXX_KNOWN_FEATURES` "
"全局属性中。有关编译功能的信息，请参阅 :manual:`cmake-compile-features(7)` 手册。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:90
msgid "Added ``MSVC`` and ``AppleClang`` compiler support."
msgstr "添加了 ``MSVC`` 和 ``AppleClang`` 编译器支持。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:93
msgid "Added ``Intel`` compiler support."
msgstr "添加了 ``Intel`` 编译器支持。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:96
msgid "The ``{c,cxx}_std_*`` meta-features are ignored if requested."
msgstr "如果需要，``{c,cxx}_std_*`` 元特征将被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:99
msgid ""
"``ALLOW_UNKNOWN_COMPILERS`` and ``ALLOW_UNKNOWN_COMPILER_VERSIONS`` cause "
"the module to generate conditions that treat unknown compilers as simply "
"lacking all features.  Without these options the default behavior is to "
"generate a ``#error`` for unknown compilers and versions."
msgstr ""
"``ALLOW_UNKNOWN_COMPILERS`` 和 ``ALLOW_UNKNOWN_COMPILER_VERSIONS`` "
"导致模块生成将未知编译器视为缺少所有功能的条件。如果没有这些选项，默认行为是为未知的编译器和版本生成 ``#error``。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:105
msgid ""
"``BARE_FEATURES`` will define the compatibility macros with the name used "
"in newer versions of the language standard, so the code can use the new "
"feature name unconditionally."
msgstr "``BARE_FEATURES`` 将使用新版本语言标准中使用的名称定义兼容性宏，因此代码可以无条件地使用新功能名称。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:111
msgid "Feature Test Macros"
msgstr "功能测试宏"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:113
msgid ""
"For each compiler, a preprocessor macro is generated matching "
"``<PREFIX>_COMPILER_IS_<compiler>`` which has the content either ``0`` or "
"``1``, depending on the compiler in use. Preprocessor macros for compiler "
"version components are generated matching "
"``<PREFIX>_COMPILER_VERSION_MAJOR`` ``<PREFIX>_COMPILER_VERSION_MINOR`` "
"and ``<PREFIX>_COMPILER_VERSION_PATCH`` containing decimal values for the "
"corresponding compiler version components, if defined."
msgstr ""
"对于每个编译器，都会生成一个预处理器宏，匹配“<PREFIX>_COMPILER_IS_<compiler>”，其内容为“0”或“1”，具体取决于所使用的编译器。生成编译器版本组件的预处理器宏，匹配``<PREFIX>_COMPILER_VERSION_MAJOR``"
" ``<PREFIX>_COMPILER_VERSION_MINOR`` 和``<PREFIX>_COMPILER_VERSION_PATCH`` "
"包含相应编译器版本组件的十进制值（如果已定义）。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:121
msgid ""
"A preprocessor test is generated based on the compiler version denoting "
"whether each feature is enabled.  A preprocessor macro matching "
"``<PREFIX>_COMPILER_<FEATURE>``, where ``<FEATURE>`` is the upper-case "
"``<feature>`` name, is generated to contain the value ``0`` or ``1`` "
"depending on whether the compiler in use supports the feature:"
msgstr ""
"预处理器测试是根据编译器版本生成的，指示是否启用了每个功能。预处理器宏匹配 ``<PREFIX>_COMPILER_<FEATURE>``，其中 "
"``<FEATURE>`` 是大写的 ``<feature>`` 名称，生成包含值 ``0`` 或``1`` 取决于使用的编译器是否支持该功能："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:153
msgid "Symbol Macros"
msgstr "符号宏"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:155
msgid ""
"Some additional symbol-defines are created for particular features for use"
" as symbols which may be conditionally defined empty:"
msgstr "一些额外的符号定义是为特定特征创建的，用作可以有条件地定义为空的符号："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:165
msgid ""
"The ``ClimbingStats_FINAL`` macro will expand to ``final`` if the compiler"
" (and its flags) support the ``cxx_final`` feature, and the "
"``ClimbingStats_CONSTEXPR`` macro will expand to ``constexpr`` if "
"``cxx_constexpr`` is supported."
msgstr ""
"如果编译器（及其标志）支持“cxx_final”功能，“ClimbingStats_FINAL”宏将扩展为“final”，如果“ClimbingStats_CONSTEXPR”宏将扩展为“constexpr”支持`cxx_constexpr``。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:170
msgid ""
"If ``BARE_FEATURES cxx_final`` was given as argument the ``final`` keyword"
" will be defined for old compilers, too."
msgstr "如果 ``BARE_FEATURES cxx_final`` 作为参数给出，``final`` 关键字也将为旧编译器定义。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:173
msgid ""
"The following features generate corresponding symbol defines and if they "
"are available as ``BARE_FEATURES``:"
msgstr "以下功能生成相应的符号定义，如果它们作为“BARE_FEATURES”可用："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:177
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:222
msgid "Feature"
msgstr "特征"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:177
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:222
msgid "Define"
msgstr "定义"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:177
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:222
msgid "Symbol"
msgstr "象征"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:177
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:222
msgid "bare"
msgstr "裸"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:179
msgid "``c_restrict``"
msgstr "``c_restrict``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:179
msgid "``<PREFIX>_RESTRICT``"
msgstr "``<PREFIX>_RESTRICT``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:179
msgid "``restrict``"
msgstr "``限制``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:179
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:180
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:183
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:184
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:186
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:226
msgid "yes"
msgstr "是的"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:180
msgid "``cxx_constexpr``"
msgstr "``cxx_constexpr``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:180
msgid "``<PREFIX>_CONSTEXPR``"
msgstr "``<前缀>_CONSTEXPR``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:180
msgid "``constexpr``"
msgstr "``constexpr``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:181
msgid "``cxx_deleted_functions``"
msgstr "``cxx_deleted_functions``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:181
msgid "``<PREFIX>_DELETED_FUNCTION``"
msgstr "``<PREFIX>_DELETED_FUNCTION``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:181
msgid "``= delete``"
msgstr "``=删除``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:182
msgid "``cxx_extern_templates``"
msgstr "``cxx_extern_templates``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:182
msgid "``<PREFIX>_EXTERN_TEMPLATE``"
msgstr "``<前缀>_EXTERN_TEMPLATE``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:182
msgid "``extern``"
msgstr "``外部``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:183
msgid "``cxx_final``"
msgstr "``cxx_final``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:183
msgid "``<PREFIX>_FINAL``"
msgstr "``<PREFIX>_FINAL``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:183
msgid "``final``"
msgstr "``最后``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:184
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:185
msgid "``cxx_noexcept``"
msgstr "``cxx_noexcept``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:184
msgid "``<PREFIX>_NOEXCEPT``"
msgstr "``<PREFIX>_NOEXCEPT``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:184
msgid "``noexcept``"
msgstr "``没有例外``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:185
msgid "``<PREFIX>_NOEXCEPT_EXPR(X)``"
msgstr "``<PREFIX>_NOEXCEPT_EXPR(X)``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:185
msgid "``noexcept(X)``"
msgstr "``没有例外（X）``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:186
msgid "``cxx_override``"
msgstr "``cxx_override``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:186
msgid "``<PREFIX>_OVERRIDE``"
msgstr "``<PREFIX>_OVERRIDE``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:186
msgid "``override``"
msgstr "``覆盖``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:190
msgid "Compatibility Implementation Macros"
msgstr "兼容性实现宏"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:192
msgid ""
"Some features are suitable for wrapping in a macro with a backward "
"compatibility implementation if the compiler does not support the feature."
msgstr "如果编译器不支持某些功能，则某些功能适合包装在具有向后兼容性实现的宏中。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:195
msgid ""
"When the ``cxx_static_assert`` feature is not provided by the compiler, a "
"compatibility implementation is available via the "
"``<PREFIX>_STATIC_ASSERT(COND)`` and ``<PREFIX>_STATIC_ASSERT_MSG(COND, "
"MSG)`` function-like macros. The macros expand to ``static_assert`` where "
"that compiler feature is available, and to a compatibility implementation "
"otherwise. In the first form, the condition is stringified in the message "
"field of ``static_assert``.  In the second form, the message ``MSG`` is "
"passed to the message field of ``static_assert``, or ignored if using the "
"backward compatibility implementation."
msgstr ""
"当编译器未提供“cxx_static_assert”功能时，可通过“<PREFIX>_STATIC_ASSERT(COND)”和“<PREFIX>_STATIC_ASSERT_MSG(COND,"
" MSG)”函数实现兼容性实现宏。宏扩展到编译器功能可用的“static_assert”，否则扩展到兼容性实现。在第一种形式中，条件在 "
"static_assert 的消息字段中被字符串化。在第二种形式中，消息 ``MSG`` 被传递到 ``static_assert`` "
"的消息字段，或者如果使用向后兼容实现则被忽略。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:206
msgid ""
"The ``cxx_attribute_deprecated`` feature provides a macro definition "
"``<PREFIX>_DEPRECATED``, which expands to either the standard "
"``[[deprecated]]`` attribute or a compiler-specific decorator such as "
"``__attribute__((__deprecated__))`` used by GNU compilers."
msgstr ""
"``cxx_attribute_deprecated`` "
"特性提供了一个宏定义``<PREFIX>_DEPRECATED``，它扩展为标准的``[[deprecated]]`` "
"属性或特定于编译器的装饰器，例如``__attribute__((__deprecated__ ))`` 由 GNU 编译器使用。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:211
msgid ""
"The ``cxx_alignas`` feature provides a macro definition "
"``<PREFIX>_ALIGNAS`` which expands to either the standard ``alignas`` "
"decorator or a compiler-specific decorator such as ``__attribute__ "
"((__aligned__))`` used by GNU compilers."
msgstr ""
"``cxx_alignas`` 功能提供了一个宏定义``<PREFIX>_ALIGNAS``，它扩展为标准的``alignas`` "
"装饰器或特定于编译器的装饰器，例如使用的``__attribute__ ((__aligned__))``由 GNU 编译器。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:216
msgid ""
"The ``cxx_alignof`` feature provides a macro definition "
"``<PREFIX>_ALIGNOF`` which expands to either the standard ``alignof`` "
"decorator or a compiler-specific decorator such as ``__alignof__`` used by"
" GNU compilers."
msgstr ""
"``cxx_alignof`` 特性提供了一个宏定义``<PREFIX>_ALIGNOF``，它扩展为标准的``alignof`` "
"装饰器或特定于编译器的装饰器，例如 GNU 编译器使用的``__alignof__``。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:224
msgid "``cxx_alignas``"
msgstr "``cxx_alignas``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:224
msgid "``<PREFIX>_ALIGNAS``"
msgstr "``<PREFIX>_ALIGNAS``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:224
msgid "``alignas``"
msgstr "``alignas``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:225
msgid "``cxx_alignof``"
msgstr "``cxx_alignof``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:225
msgid "``<PREFIX>_ALIGNOF``"
msgstr "``<PREFIX>_ALIGNOF``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:225
msgid "``alignof``"
msgstr "``alignof``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:226
msgid "``cxx_nullptr``"
msgstr "``cxx_nullptr``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:226
msgid "``<PREFIX>_NULLPTR``"
msgstr "``<PREFIX>_NULLPTR``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:226
msgid "``nullptr``"
msgstr "``nullptr``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:227
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:228
msgid "``cxx_static_assert``"
msgstr "``cxx_static_assert``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:227
msgid "``<PREFIX>_STATIC_ASSERT``"
msgstr "``<PREFIX>_STATIC_ASSERT``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:227
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:228
msgid "``static_assert``"
msgstr "``static_assert``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:228
msgid "``<PREFIX>_STATIC_ASSERT_MSG``"
msgstr "``<PREFIX>_STATIC_ASSERT_MSG``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:229
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:230
msgid "``cxx_attribute_deprecated``"
msgstr "``cxx_attribute_deprecated``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:229
msgid "``<PREFIX>_DEPRECATED``"
msgstr "``<PREFIX>_DEPRECATED``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:229
#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:230
msgid "``[[deprecated]]``"
msgstr "``[[弃用]]``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:230
msgid "``<PREFIX>_DEPRECATED_MSG``"
msgstr "``<PREFIX>_DEPRECATED_MSG``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:231
msgid "``cxx_thread_local``"
msgstr "``cxx_thread_local``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:231
msgid "``<PREFIX>_THREAD_LOCAL``"
msgstr "``<PREFIX>_THREAD_LOCAL``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:231
msgid "``thread_local``"
msgstr "``thread_local``"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:234
msgid ""
"A use-case which arises with such deprecation macros is the deprecation of"
" an entire library.  In that case, all public API in the library may be "
"decorated with the ``<PREFIX>_DEPRECATED`` macro.  This results in very "
"noisy build output when building the library itself, so the macro may be "
"may be defined to empty in that case when building the deprecated library:"
msgstr ""
"这种弃用宏出现的一个用例是整个库的弃用。在这种情况下，库中的所有公共 API 都可以用 ``<PREFIX>_DEPRECATED`` "
"宏修饰。这会在构建库本身时产生非常嘈杂的构建输出，因此在构建已弃用的库时，宏可能会被定义为空："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:256
msgid ""
"This section was migrated from the :manual:`cmake-compile-features(7)` "
"manual since it relies on the ``WriteCompilerDetectionHeader`` module "
"which is removed by policy :policy:`CMP0120`."
msgstr ""
"本节是从 cmake-compile-features(7) 手册中迁移而来的，因为它依赖于被策略 CMP0120 删除的 "
"WriteCompilerDetectionHeader 模块。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:260
msgid ""
"Compile features may be preferred if available, without creating a hard "
"requirement.  For example, a library may provide alternative "
"implementations depending on whether the ``cxx_variadic_templates`` "
"feature is available:"
msgstr ""
"如果可用，编译功能可能是首选，而不会产生硬性要求。例如，库可能会根据“cxx_variadic_templates”功能是否可用提供替代实现："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:296
msgid ""
"Such an interface depends on using the correct preprocessor defines for "
"the compiler features.  CMake can generate a header file containing such "
"defines using the :module:`WriteCompilerDetectionHeader` module.  The "
"module contains the ``write_compiler_detection_header`` function which "
"accepts parameters to control the content of the generated header file:"
msgstr ""
"这样的接口取决于为编译器功能使用正确的预处理器定义。 CMake 可以使用 WriteCompilerDetectionHeader "
"模块生成包含此类定义的头文件。该模块包含 ``write_compiler_detection_header`` "
"函数，它接受参数来控制生成的头文件的内容："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:312
msgid ""
"Such a header file may be used internally in the source code of a project,"
" and it may be installed and used in the interface of library code."
msgstr "这样的头文件可能在项目源代码内部使用，也可能在库代码的接口中安装使用。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:315
msgid ""
"For each feature listed in ``FEATURES``, a preprocessor definition is "
"created in the header file, and defined to either ``1`` or ``0``."
msgstr "对于“FEATURES”中列出的每个功能，都会在头文件中创建预处理器定义，并将其定义为“1”或“0”。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:318
msgid ""
"Additionally, some features call for additional defines, such as the "
"``cxx_final`` and ``cxx_override`` features. Rather than being used in "
"``#ifdef`` code, the ``final`` keyword is abstracted by a symbol which is "
"defined to either ``final``, a compiler-specific equivalent, or to empty."
"  That way, C++ code can be written to unconditionally use the symbol, and"
" compiler support determines what it is expanded to:"
msgstr ""
"此外，一些功能需要额外的定义，例如“cxx_final”和“cxx_override”功能。 ``final`` 关键字不是在``#ifdef`` "
"代码中使用，而是通过一个符号抽象出来，该符号被定义为 ``final``（特定于编译器的等效项）或为空。这样，C++ "
"代码就可以无条件地使用这个符号，编译器支持决定它扩展到什么："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:335
msgid ""
"In this case, ``Foo_FINAL`` will expand to ``final`` if the compiler "
"supports the keyword, or to empty otherwise."
msgstr "在这种情况下，如果编译器支持该关键字，“Foo_FINAL”将扩展为“final”，否则为空。"

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:338
msgid ""
"In this use-case, the project code may wish to enable a particular "
"language standard if available from the compiler. The "
":prop_tgt:`CXX_STANDARD` target property may be set to the desired "
"language standard for a particular target, and the "
":variable:`CMAKE_CXX_STANDARD` variable may be set to influence all "
"following targets:"
msgstr ""
"在此用例中，项目代码可能希望启用特定语言标准（如果编译器可用）。 :prop_tgt:`CXX_STANDARD` "
"目标属性可以设置为特定目标所需的语言标准，并且 :variable:`CMAKE_CXX_STANDARD` 变量可以设置为影响以下所有目标："

#: ../../cmake-prefix/src/cmake/Modules/WriteCompilerDetectionHeader.cmake:368
msgid ""
"The ``write_compiler_detection_header`` function also creates "
"compatibility code for other features which have standard equivalents.  "
"For example, the ``cxx_static_assert`` feature is emulated with a template"
" and abstracted via the ``<PREFIX>_STATIC_ASSERT`` and "
"``<PREFIX>_STATIC_ASSERT_MSG`` function-macros."
msgstr ""
"``write_compiler_detection_header`` "
"函数还为具有标准等效项的其他功能创建兼容性代码。例如，``cxx_static_assert`` "
"功能使用模板进行模拟，并通过``<PREFIX>_STATIC_ASSERT`` 和``<PREFIX>_STATIC_ASSERT_MSG`` "
"函数宏进行抽象。"
