# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2000-2023 Kitware, Inc. and Contributors
# This file is distributed under the same license as the CMake package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CMake 3.26.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-01 00:02+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.12.1\n"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0000.rst:2
msgid "CMP0000"
msgstr "CMP0000"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0000.rst:4
msgid "A minimum required CMake version must be specified."
msgstr "必须指定最低要求的 CMake 版本。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0000.rst:6
msgid ""
"CMake requires that projects specify the version of CMake to which they "
"have been written.  This policy has been put in place so users trying to "
"build the project may be told when they need to update their CMake.  "
"Specifying a version also helps the project build with CMake versions "
"newer than that specified.  Use the :command:`cmake_minimum_required` "
"command at the top of your main ``CMakeLists.txt`` file:"
msgstr ""
"CMake 要求项目指定编写它们的 CMake 版本。此策略已到位，因此可以告知尝试构建项目的用户何时需要更新其 "
"CMake。指定版本还有助于使用比指定版本更新的 CMake 版本构建项目。在主 ``CMakeLists.txt`` 文件的顶部使用 "
":command:`cmake_minimum_required` 命令："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0000.rst:17
msgid ""
"where ``<major>.<minor>`` is the version of CMake you want to support "
"(such as ``3.14``).  The command will ensure that at least the given "
"version of CMake is running and help newer versions be compatible with the"
" project.  See documentation of :command:`cmake_minimum_required` for "
"details."
msgstr ""
"其中 ``<major>.<minor>`` 是您要支持的 CMake 版本（例如 ``3.14``）。该命令将确保至少给定版本的 CMake "
"正在运行，并帮助新版本与项目兼容。有关详细信息，请参阅 :command:`cmake_minimum_required` 的文档。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0000.rst:23
msgid ""
"Note that the command invocation must appear in the ``CMakeLists.txt`` "
"file itself; a call in an included file is not sufficient.  However, the  "
":command:`cmake_policy` command may be called to set policy ``CMP0000`` to"
" ``OLD`` or ``NEW`` behavior explicitly.  The ``OLD`` behavior is to "
"silently ignore the missing invocation.  The ``NEW`` behavior is to issue "
"an error instead of a warning.  An included file may set ``CMP0000`` "
"explicitly to affect how this policy is enforced for the main "
"``CMakeLists.txt`` file."
msgstr ""
"请注意，命令调用必须出现在“CMakeLists.txt”文件本身中；包含文件中的调用是不够的。但是，可以调用 "
":command:`cmake_policy` 命令将策略 ``CMP0000`` 显式设置为 ``OLD`` 或 ``NEW`` 行为。 "
"``OLD`` 行为是默默地忽略丢失的调用。 ``NEW`` "
"行为是发出错误而不是警告。包含的文件可能会显式设置“CMP0000”，以影响对主要“CMakeLists.txt”文件执行此策略的方式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0000.rst:32
msgid "This policy was introduced in CMake version 2.6.0."
msgstr "此策略是在 CMake 版本 2.6.0 中引入的。"

#: ../../cmake-prefix/src/cmake/Help/policy/DEPRECATED.txt:2
msgid ""
"The ``OLD`` behavior of a policy is :manual:`deprecated by definition "
"<cmake-policies(7)>` and may be removed in a future version of CMake."
msgstr "策略的“旧”行为是 :manual:根据定义 <cmake-policies(7)> 已弃用，并且可能会在未来版本的 CMake 中删除。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0001.rst:2
msgid "CMP0001"
msgstr "CMP0001"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0001.rst:4
msgid "``CMAKE_BACKWARDS_COMPATIBILITY`` should no longer be used."
msgstr "``CMAKE_BACKWARDS_COMPATIBILITY`` 不应再使用。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0001.rst:6
msgid ""
"The behavior is to check ``CMAKE_BACKWARDS_COMPATIBILITY`` and present it "
"to the user.  The ``NEW`` behavior is to ignore "
"CMAKE_BACKWARDS_COMPATIBILITY completely."
msgstr ""
"行为是检查“CMAKE_BACKWARDS_COMPATIBILITY”并将其呈现给用户。 ``NEW`` 行为是完全忽略 "
"CMAKE_BACKWARDS_COMPATIBILITY。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0001.rst:10
msgid ""
"In CMake 2.4 and below the variable ``CMAKE_BACKWARDS_COMPATIBILITY`` was "
"used to request compatibility with earlier versions of CMake.  In CMake "
"2.6 and above all compatibility issues are handled by policies and the "
":command:`cmake_policy` command.  However, CMake must still check "
"``CMAKE_BACKWARDS_COMPATIBILITY`` for projects written for CMake 2.4 and "
"below."
msgstr ""
"在 CMake 2.4 及以下版本中，变量“CMAKE_BACKWARDS_COMPATIBILITY”用于请求与早期版本的 CMake "
"的兼容性。在 CMake 2.6 及更高版本中，所有兼容性问题均由策略和 :command:`cmake_policy` 命令处理。但是，对于为 "
"CMake 2.4 及以下版本编写的项目，CMake 仍必须检查“CMAKE_BACKWARDS_COMPATIBILITY”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0001.rst:17
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0002.rst:24
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:100
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0004.rst:22
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0005.rst:22
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0006.rst:20
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0007.rst:13
msgid ""
"This policy was introduced in CMake version 2.6.0.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.6.0 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0002.rst:2
msgid "CMP0002"
msgstr "CMP0002"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0002.rst:4
msgid "Logical target names must be globally unique."
msgstr "逻辑目标名称必须是全局唯一的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0002.rst:6
msgid ""
"Targets names created with :command:`add_executable`, "
":command:`add_library`, or :command:`add_custom_target` are logical build "
"target names.  Logical target names must be globally unique because:"
msgstr ""
"使用 :command:`add_executable`、 :command:`add_library` 或 "
":command:`add_custom_target` 创建的目标名称是逻辑构建目标名称。逻辑目标名称必须是全局唯一的，因为："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0002.rst:17
msgid ""
"The logical name of executable and library targets does not have to "
"correspond to the physical file names built.  Consider using the "
":prop_tgt:`OUTPUT_NAME` target property to create two targets with the "
"same physical name while keeping logical names distinct.  Custom targets "
"must simply have globally unique names (unless one uses the global "
"property :prop_gbl:`ALLOW_DUPLICATE_CUSTOM_TARGETS` with a Makefiles "
"generator)."
msgstr ""
"可执行文件和库目标的逻辑名称不必与构建的物理文件名相对应。考虑使用 :prop_tgt:`OUTPUT_NAME` "
"目标属性创建两个具有相同物理名称的目标，同时保持逻辑名称不同。自定义目标必须具有全局唯一的名称（除非将全局属性 "
":prop_gbl:`ALLOW_DUPLICATE_CUSTOM_TARGETS` 与 Makefile 生成器一起使用）。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:2
msgid "CMP0003"
msgstr "CMP0003"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:4
msgid ""
"Libraries linked via full path no longer produce linker search paths."
msgstr "通过完整路径链接的库不再生成链接器搜索路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:6
msgid ""
"This policy affects how libraries whose full paths are NOT known are found"
" at link time, but was created due to a change in how CMake deals with "
"libraries whose full paths are known.  Consider the code"
msgstr "此策略会影响在链接时如何找到其完整路径未知的库，但由于 CMake 处理其完整路径已知的库的方式发生变化而创建。考虑代码"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:14
msgid ""
"CMake 2.4 and below implemented linking to libraries whose full paths are "
"known by splitting them on the link line into separate components "
"consisting of the linker search path and the library name.  The example "
"code might have produced something like"
msgstr ""
"CMake 2.4 及以下版本通过将链接行上的库拆分为由链接器搜索路径和库名称组成的单独组件，实现了对已知完整路径的库的链接。示例代码可能产生了类似"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:23
msgid ""
"in order to link to library A.  An analysis was performed to order "
"multiple link directories such that the linker would find library A in the"
" desired location, but there are cases in which this does not work. CMake "
"versions 2.6 and above use the more reliable approach of passing the full "
"path to libraries directly to the linker in most cases.  The example code "
"now produces something like"
msgstr ""
"为了链接到库 A。执行了对多个链接目录进行排序的分析，以便链接器可以在所需位置找到库 A，但在某些情况下这不起作用。在大多数情况下，CMake "
"2.6 及更高版本使用更可靠的方法将库的完整路径直接传递给链接器。示例代码现在产生类似"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:34
msgid "Unfortunately this change can break code like"
msgstr "不幸的是，此更改可能会破坏代码，例如"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:40
msgid ""
"where ``B`` is meant to find ``/path/to/libB.so``.  This code is wrong "
"because the user is asking the linker to find library B but has not "
"provided a linker search path (which may be added with the "
"link_directories command).  However, with the old linking implementation "
"the code would work accidentally because the linker search path added for "
"library A allowed library B to be found."
msgstr ""
"其中 ``B`` 用于查找 ``/path/to/libB.so``。此代码是错误的，因为用户要求链接器查找库 B 但未提供链接器搜索路径（可以使用"
" link_directories 命令添加）。但是，对于旧的链接实现，代码会意外运行，因为为库 A 添加的链接器搜索路径允许找到库 B。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:47
msgid ""
"In order to support projects depending on linker search paths added by "
"linking to libraries with known full paths, the ``OLD`` behavior for this "
"policy will add the linker search paths even though they are not needed "
"for their own libraries.  When this policy is set to ``OLD``, CMake will "
"produce a link line such as"
msgstr ""
"为了支持依赖于通过链接到具有已知完整路径的库添加的链接器搜索路径的项目，此策略的“旧”行为将添加链接器搜索路径，即使它们自己的库不需要它们。当此策略设置为"
" ``OLD`` 时，CMake 将生成一个链接行，例如"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:57
msgid ""
"which will allow library B to be found as it was previously.  When this "
"policy is set to NEW, CMake will produce a link line such as"
msgstr "这将允许像以前一样找到库 B。当此策略设置为 NEW 时，CMake 将生成一个链接行，例如"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:64
msgid "which more accurately matches what the project specified."
msgstr "哪个更准确地匹配项目指定的内容。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:66
msgid ""
"The setting for this policy used when generating the link line is that in "
"effect when the target is created by an add_executable or add_library "
"command.  For the example described above, the code"
msgstr "生成链接行时使用的此策略设置在通过 add_executable 或 add_library 命令创建目标时生效。对于上述示例，代码"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:76
msgid ""
"will work and suppress the warning for this policy.  It may also be "
"updated to work with the corrected linking approach:"
msgstr "将起作用并抑制针对此策略的警告。它也可能会更新以使用更正的链接方法："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:86
msgid "Even better, library B may be specified with a full path:"
msgstr "更好的是，可以使用完整路径指定库 B："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:93
msgid ""
"When all items on the link line have known paths CMake does not check this"
" policy so it has no effect."
msgstr "当链接行上的所有项目都具有已知路径时，CMake 不会检查此策略，因此它无效。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0003.rst:96
msgid ""
"Note that the warning for this policy will be issued for at most one "
"target.  This avoids flooding users with messages for every target when "
"setting the policy once will probably fix all targets."
msgstr "请注意，最多将针对一个目标发出此策略的警告。这避免了在设置一次策略可能会修复所有目标时，向用户发送每个目标的消息。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0004.rst:2
msgid "CMP0004"
msgstr "CMP0004"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0004.rst:4
msgid "Libraries linked may not have leading or trailing whitespace."
msgstr "链接的库可能没有前导或尾随空格。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0004.rst:6
msgid ""
"CMake versions 2.4 and below silently removed leading and trailing "
"whitespace from libraries linked with code like"
msgstr "CMake 2.4 及以下版本默默地从与代码链接的库中删除了前导和尾随空格"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0004.rst:13
msgid "This could lead to subtle errors in user projects."
msgstr "这可能会导致用户项目中出现细微的错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0004.rst:15
msgid ""
"The ``OLD`` behavior for this policy is to silently remove leading and "
"trailing whitespace.  The ``NEW`` behavior for this policy is to diagnose "
"the existence of such whitespace as an error.  The setting for this policy"
" used when checking the library names is that in effect when the target is"
" created by an :command:`add_executable` or :command:`add_library` "
"command."
msgstr ""
"此策略的“旧”行为是静默删除前导和尾随空格。此策略的“新”行为是将此类空格的存在诊断为错误。检查库名称时使用的此策略设置是在通过 "
"add_executable 或 add_library 命令创建目标时生效的设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0005.rst:2
msgid "CMP0005"
msgstr "CMP0005"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0005.rst:4
msgid "Preprocessor definition values are now escaped automatically."
msgstr "预处理器定义值现在自动转义。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0005.rst:6
msgid ""
"This policy determines whether or not CMake should generate escaped "
"preprocessor definition values added via add_definitions.  CMake versions "
"2.4 and below assumed that only trivial values would be given for macros "
"in add_definitions calls.  It did not attempt to escape non-trivial values"
" such as string literals in generated build rules. CMake versions 2.6 and "
"above support escaping of most values, but cannot assume the user has not "
"added escapes already in an attempt to work around limitations in earlier "
"versions."
msgstr ""
"此策略确定 CMake 是否应生成通过 add_definitions 添加的转义预处理器定义值。 CMake 2.4 及以下版本假定在 "
"add_definitions 调用中只会为宏提供微不足道的值。它没有尝试转义生成的构建规则中的重要值，例如字符串文字。 CMake 版本 2.6 "
"及更高版本支持转义大多数值，但不能假定用户尚未添加转义以尝试解决早期版本中的限制。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0005.rst:15
msgid ""
"The ``OLD`` behavior for this policy is to place definition values given "
"to add_definitions directly in the generated build rules without "
"attempting to escape anything.  The ``NEW`` behavior for this policy is to"
" generate correct escapes for all native build tools automatically. See "
"documentation of the ``COMPILE_DEFINITIONS`` target property for "
"limitations of the escaping implementation."
msgstr ""
"此策略的“旧”行为是将赋予 add_definitions "
"的定义值直接放置在生成的构建规则中，而不尝试转义任何内容。此策略的“新”行为是自动为所有本机构建工具生成正确的转义符。有关转义实现的限制，请参阅“COMPILE_DEFINITIONS”目标属性的文档。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0006.rst:2
msgid "CMP0006"
msgstr "CMP0006"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0006.rst:4
msgid ""
"Installing :prop_tgt:`MACOSX_BUNDLE` targets requires a ``BUNDLE "
"DESTINATION``."
msgstr "安装 :prop_tgt:`MACOSX_BUNDLE` 目标需要一个 ``BUNDLE DESTINATION``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0006.rst:6
msgid ""
"This policy determines whether the :command:`install(TARGETS)` command "
"must be given a ``BUNDLE DESTINATION`` when asked to install a target with"
" the :prop_tgt:`MACOSX_BUNDLE` property set.  CMake 2.4 and below did not "
"distinguish application bundles from normal executables when installing "
"targets. CMake 2.6 provides a ``BUNDLE`` option to the "
":command:`install(TARGETS)` command that specifies rules specific to "
"application bundles on the Mac. Projects should use this option when "
"installing a target with the :prop_tgt:`MACOSX_BUNDLE` property set."
msgstr ""
"此策略确定:command:`install(TARGETS)` 命令在被要求安装具有 :prop_tgt:`MACOSX_BUNDLE` "
"属性集的目标时是否必须提供 ``BUNDLE DESTINATION``。 CMake 2.4 "
"及以下版本在安装目标时不区分应用程序包和普通可执行文件。 CMake 2.6 为 :command:`install(TARGETS)` "
"命令提供了一个 ``BUNDLE`` 选项，用于指定特定于 Mac 上应用程序包的规则。在安装带有 "
":prop_tgt:`MACOSX_BUNDLE` 属性集的目标时，项目应该使用此选项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0006.rst:15
msgid ""
"The ``OLD`` behavior for this policy is to fall back to the ``RUNTIME "
"DESTINATION`` if a ``BUNDLE DESTINATION`` is not given.  The ``NEW`` "
"behavior for this policy is to produce an error if a bundle target is "
"installed without a ``BUNDLE DESTINATION``."
msgstr ""
"如果未给出“BUNDLE DESTINATION”，则此策略的“旧”行为是退回到“RUNTIME "
"DESTINATION”。如果安装的包目标没有“BUNDLE DESTINATION”，则此策略的“新”行为会产生错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0007.rst:2
msgid "CMP0007"
msgstr "CMP0007"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0007.rst:4
msgid "list command no longer ignores empty elements."
msgstr "list 命令不再忽略空元素。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0007.rst:6
msgid ""
"This policy determines whether the list command will ignore empty elements"
" in the list.  CMake 2.4 and below list commands ignored all empty "
"elements in the list.  For example, ``a;b;;c`` would have length 3 and not"
" 4.  The ``OLD`` behavior for this policy is to ignore empty list "
"elements.  The ``NEW`` behavior for this policy is to correctly count "
"empty elements in a list."
msgstr ""
"此策略确定列表命令是否将忽略列表中的空元素。 CMake 2.4 及以下列表命令忽略列表中的所有空元素。例如，``a;b;;c`` 的长度为 3 "
"而不是 4。此策略的 ``OLD`` 行为是忽略空列表元素。此策略的“新”行为是正确计算列表中的空元素。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0008.rst:2
msgid "CMP0008"
msgstr "CMP0008"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0008.rst:4
msgid "Libraries linked by full-path must have a valid library file name."
msgstr "通过全路径链接的库必须具有有效的库文件名。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0008.rst:6
msgid "In CMake 2.4 and below it is possible to write code like"
msgstr "在 CMake 2.4 及以下版本中，可以编写如下代码"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0008.rst:12
msgid ""
"where ``somelib`` is supposed to be a valid library file name such as "
"``libsomelib.a`` or ``somelib.lib``.  For Makefile generators this "
"produces an error at build time because the dependency on the full path "
"cannot be found.  For :ref:`Visual Studio Generators` IDE and "
":generator:`Xcode` generators this used to work by accident because CMake "
"would always split off the library directory and ask the linker to search "
"for the library by name (``-lsomelib`` or ``somelib.lib``).  Despite the "
"failure with Makefiles, some projects have code like this and build only "
"with Visual Studio and/or Xcode. This version of CMake prefers to pass the"
" full path directly to the native build tool, which will fail in this case"
" because it does not name a valid library file."
msgstr ""
"其中 ``somelib`` 应该是一个有效的库文件名，例如 ``libsomelib.a`` 或 ``somelib.lib``。对于 "
"Makefile 生成器，这会在构建时产生错误，因为无法找到对完整路径的依赖。对于 :ref:`Visual Studio Generators` "
"IDE 和 :generator:`Xcode` 生成器，这曾经是偶然工作的，因为 CMake "
"总是会拆分库目录并要求链接器按名称搜索库（``-lsomelib` ` 或 ``somelib.lib``）。尽管 Makefiles "
"失败了，一些项目有这样的代码并且只用 Visual Studio 和/或 Xcode 构建。此版本的 CMake "
"更喜欢将完整路径直接传递给本机构建工具，在这种情况下会失败，因为它没有命名有效的库文件。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0008.rst:25
msgid ""
"This policy determines what to do with full paths that do not appear to "
"name a valid library file.  The ``OLD`` behavior for this policy is to "
"split the library name from the path and ask the linker to search for it."
"  The ``NEW`` behavior for this policy is to trust the given path and pass"
" it directly to the native build tool unchanged."
msgstr ""
"此策略确定如何处理似乎未命名有效库文件的完整路径。此策略的“旧”行为是从路径中拆分库名称并要求链接器搜索它。此策略的“新”行为是信任给定路径并将其直接传递给本机构建工具而不更改。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0008.rst:31
msgid ""
"This policy was introduced in CMake version 2.6.1.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.6.1 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0009.rst:2
msgid "CMP0009"
msgstr "CMP0009"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0009.rst:4
msgid "FILE GLOB_RECURSE calls should not follow symlinks by default."
msgstr "默认情况下，FILE GLOB_RECURSE 调用不应遵循符号链接。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0009.rst:6
msgid ""
"In CMake 2.6.1 and below, :command:`file(GLOB_RECURSE)` calls would follow"
" through symlinks, sometimes coming up with unexpectedly large result sets"
" because of symlinks to top level directories that contain hundreds of "
"thousands of files."
msgstr ""
"在 CMake 2.6.1 及以下版本中， :command:`file(GLOB_RECURSE)` "
"调用将通过符号链接进行，有时会产生出乎意料的大结果集，因为符号链接指向包含数十万个文件的顶级目录。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0009.rst:11
msgid ""
"This policy determines whether or not to follow symlinks encountered "
"during a :command:`file(GLOB_RECURSE)` call.  The ``OLD`` behavior for "
"this policy is to follow the symlinks.  The ``NEW`` behavior for this "
"policy is not to follow the symlinks by default, but only if "
"``FOLLOW_SYMLINKS`` is given as an additional argument to the ``FILE`` "
"command."
msgstr ""
"此策略确定是否遵循 :command:`file(GLOB_RECURSE)` "
"调用期间遇到的符号链接。此策略的“旧”行为是遵循符号链接。此策略的“新”行为默认情况下不遵循符号链接，但前提是将“FOLLOW_SYMLINKS”作为附加参数提供给“文件”命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0009.rst:17
msgid ""
"This policy was introduced in CMake version 2.6.2.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.6.2 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0010.rst:2
msgid "CMP0010"
msgstr "CMP0010"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0010.rst:4
msgid "Bad variable reference syntax is an error."
msgstr "错误的变量引用语法是一个错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0010.rst:6
msgid ""
"In CMake 2.6.2 and below, incorrect variable reference syntax such as a "
"missing close-brace (``${FOO``) was reported but did not stop processing "
"of CMake code.  This policy determines whether a bad variable reference is"
" an error.  The ``OLD`` behavior for this policy is to warn about the "
"error, leave the string untouched, and continue. The ``NEW`` behavior for "
"this policy is to report an error."
msgstr ""
"在 CMake 2.6.2 及更低版本中，报告了不正确的变量引用语法，例如缺少大括号 (``${FOO``)，但并未停止 CMake "
"代码的处理。此策略确定错误的变量引用是否是错误。此策略的“旧”行为是警告错误，保持字符串不变，然后继续。此策略的“新”行为是报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0010.rst:13
msgid ""
"If :policy:`CMP0053` is set to ``NEW``, this policy has no effect and is "
"treated as always being ``NEW``."
msgstr "如果 :policy:`CMP0053` 设置为 ``NEW``，则此策略无效，并被视为始终为 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0010.rst:16
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0011.rst:21
msgid ""
"This policy was introduced in CMake version 2.6.3.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.6.3 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0011.rst:2
msgid "CMP0011"
msgstr "CMP0011"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0011.rst:4
msgid "Included scripts do automatic :command:`cmake_policy` PUSH and POP."
msgstr "包含的脚本执行自动 :command:`cmake_policy` PUSH 和 POP。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0011.rst:6
msgid ""
"In CMake 2.6.2 and below, CMake Policy settings in scripts loaded by the "
":command:`include` and :command:`find_package` commands would affect the "
"includer.  Explicit invocations of ``cmake_policy(PUSH)`` and "
"``cmake_policy(POP)`` were required to isolate policy changes and protect "
"the includer.  While some scripts intend to affect the policies of their "
"includer, most do not.  In CMake 2.6.3 and above, :command:`include` and "
":command:`find_package` by default ``PUSH`` and ``POP`` an entry on the "
"policy stack around an included script, but provide a ``NO_POLICY_SCOPE`` "
"option to disable it.  This policy determines whether or not to imply "
"``NO_POLICY_SCOPE`` for compatibility.  The ``OLD`` behavior for this "
"policy is to imply ``NO_POLICY_SCOPE`` for :command:`include` and "
":command:`find_package` commands. The ``NEW`` behavior for this policy is "
"to allow the commands to do their default cmake_policy ``PUSH`` and "
"``POP``."
msgstr ""
"在 CMake 2.6.2 及以下版本中，由 :command:`include` 和 :command:`find_package` "
"命令加载的脚本中的 CMake Policy 设置会影响包含器。需要显式调用 ``cmake_policy(PUSH)`` 和 "
"``cmake_policy(POP)`` 来隔离策略更改并保护包含程序。虽然一些脚本打算影响其包含器的策略，但大多数不会。在 CMake "
"2.6.3 及更高版本中， :command:`include` 和 :command:`find_package` 默认情况下 ``PUSH`` 和"
" ``POP`` 是包含脚本的策略堆栈上的一个条目，但提供一个 `` NO_POLICY_SCOPE`` "
"选项来禁用它。此策略确定是否暗示“NO_POLICY_SCOPE”以实现兼容性。此策略的“旧”行为是为 :command:`include` 和 "
":command:`find_package` 命令暗示 ``NO_POLICY_SCOPE``。此策略的“新”行为是允许命令执行其默认的 "
"cmake_policy ``PUSH`` 和 ``POP``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0012.rst:2
msgid "CMP0012"
msgstr "CMP0012"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0012.rst:4
msgid ":command:`if` recognizes numbers and boolean constants."
msgstr ":command:`if` 识别数字和布尔常量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0012.rst:6
msgid ""
"In CMake versions 2.6.4 and lower the :command:`if` command implicitly "
"dereferenced arguments corresponding to variables, even those named like "
"numbers or boolean constants, except for ``0`` and ``1``.  Numbers and "
"boolean constants such as ``true``, ``false``, ``yes``, ``no``, ``on``, "
"``off``, ``y``, ``n``, ``notfound``, ``ignore`` (all case insensitive) "
"were recognized in some cases but not all.  For example, the code "
"``if(TRUE)`` might have evaluated as ``false``. Numbers such as 2 were "
"recognized only in boolean expressions like ``if(NOT 2)`` (leading to "
"``false``) but not as a single-argument like ``if(2)`` (also leading to "
"``false``).  Later versions of CMake prefer to treat numbers and boolean "
"constants literally, so they should not be used as variable names."
msgstr ""
"在 CMake 版本 2.6.4 和更低版本中， :command:`if` "
"命令隐式取消引用与变量对应的参数，即使是那些命名为数字或布尔常量的参数，除了 ``0`` 和 ``1``。数字和布尔常量，例如 "
"``true``、``false``、``yes``、``no``、``on``、``off``、``y``、`` "
"n``、``notfound``、``ignore``（所有大小写不敏感）在某些情况下被识别，但不是全部。例如，代码“if(TRUE)”可能被评估为“false”。诸如"
" 2 之类的数字仅在布尔表达式中被识别，如 ``if(NOT 2)``（导致 ``false``），而不是像 ``if(2)`` "
"这样的单一参数（也导致 ` `假``）。更高版本的 CMake 更喜欢按字面意思处理数字和布尔常量，因此不应将它们用作变量名。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0012.rst:19
msgid ""
"The ``OLD`` behavior for this policy is to implicitly dereference "
"variables named like numbers and boolean constants.  The ``NEW`` behavior "
"for this policy is to recognize numbers and boolean constants without "
"dereferencing variables with such names."
msgstr "此策略的“旧”行为是隐式取消引用以数字和布尔常量命名的变量。此策略的“新”行为是识别数字和布尔常量而不取消引用具有此类名称的变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0012.rst:24
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0013.rst:17
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0014.rst:13
msgid ""
"This policy was introduced in CMake version 2.8.0.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.8.0 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0013.rst:2
msgid "CMP0013"
msgstr "CMP0013"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0013.rst:4
msgid "Duplicate binary directories are not allowed."
msgstr "不允许重复的二进制目录。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0013.rst:6
msgid ""
"CMake 2.6.3 and below silently permitted add_subdirectory() calls to "
"create the same binary directory multiple times.  During build system "
"generation files would be written and then overwritten in the build tree "
"and could lead to strange behavior.  CMake 2.6.4 and above explicitly "
"detect duplicate binary directories.  CMake 2.6.4 always considers this "
"case an error.  In CMake 2.8.0 and above this policy determines whether or"
" not the case is an error.  The ``OLD`` behavior for this policy is to "
"allow duplicate binary directories.  The NEW behavior for this policy is "
"to disallow duplicate binary directories with an error."
msgstr ""
"CMake 2.6.3 及以下版本默默地允许 add_subdirectory() "
"调用多次创建相同的二进制目录。在构建系统期间，生成文件将被写入，然后在构建树中被覆盖，这可能会导致奇怪的行为。 CMake 2.6.4 "
"及更高版本明确检测重复的二进制目录。 CMake 2.6.4 始终将这种情况视为错误。在 CMake 2.8.0 "
"及更高版本中，此策略确定大小写是否为错误。此策略的“旧”行为是允许重复的二进制目录。此策略的新行为是不允许出现错误的重复二进制目录。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0014.rst:2
msgid "CMP0014"
msgstr "CMP0014"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0014.rst:4
msgid "Input directories must have ``CMakeLists.txt``."
msgstr "输入目录必须有“CMakeLists.txt”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0014.rst:6
msgid ""
"CMake versions before 2.8 silently ignored missing ``CMakeLists.txt`` "
"files in directories referenced by :command:`add_subdirectory` or  "
":command:`subdirs`, treating them as if present but empty.  In CMake 2.8.0"
" and above this :command:`cmake_policy` determines whether or not the case"
" is an error. The ``OLD`` behavior for this policy is to silently ignore "
"the problem. The ``NEW`` behavior for this policy is to report an error."
msgstr ""
"2.8 之前的 CMake 版本默默地忽略了由 :command:`add_subdirectory` 或 :command:`subdirs` "
"引用的目录中丢失的 ``CMakeLists.txt`` 文件，将它们视为存在但为空。在 CMake 2.8.0 及更高版本中，此 "
":command:`cmake_policy` 确定大小写是否为错误。此策略的“旧”行为是默默地忽略该问题。此策略的“新”行为是报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0015.rst:2
msgid "CMP0015"
msgstr "CMP0015"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0015.rst:4
msgid ":command:`link_directories` treats paths relative to the source dir."
msgstr ":command:`link_directories` 处理相对于源目录的路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0015.rst:6
msgid ""
"In CMake 2.8.0 and lower the :command:`link_directories` command passed "
"relative paths unchanged to the linker.  In CMake 2.8.1 and above the "
":command:`link_directories` command prefers to interpret relative paths "
"with respect to ``CMAKE_CURRENT_SOURCE_DIR``, which is consistent with "
":command:`include_directories` and other commands.  The ``OLD`` behavior "
"for this policy is to use relative paths verbatim in the linker command.  "
"The ``NEW`` behavior for this policy is to convert relative paths to "
"absolute paths by appending the relative path to "
"``CMAKE_CURRENT_SOURCE_DIR``."
msgstr ""
"在 CMake 2.8.0 和更低版本中， :command:`link_directories` 命令将相对路径不变地传递给链接器。在 CMake "
"2.8.1 及更高版本中， :command:`link_directories` 命令倾向于解释相对于 "
"``CMAKE_CURRENT_SOURCE_DIR`` 的相对路径，这与 :command:`include_directories` "
"和其他命令一致。此策略的“旧”行为是在链接器命令中逐字使用相对路径。此策略的“新”行为是通过将相对路径附加到“CMAKE_CURRENT_SOURCE_DIR”来将相对路径转换为绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0015.rst:15
msgid ""
"This policy was introduced in CMake version 2.8.1.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.8.1 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0016.rst:2
msgid "CMP0016"
msgstr "CMP0016"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0016.rst:4
msgid ""
":command:`target_link_libraries` reports error if its only argument is not"
" a target."
msgstr ":command:`target_link_libraries` 如果它的唯一参数不是目标则报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0016.rst:7
msgid ""
"In CMake 2.8.2 and lower the :command:`target_link_libraries` command "
"silently ignored if it was called with only one argument, and this "
"argument wasn't a valid target.  In CMake 2.8.3 and above it reports an "
"error in this case."
msgstr ""
"在 CMake 2.8.2 和更低版本中，如果仅使用一个参数调用它，则 :command:`target_link_libraries` "
"命令将被静默忽略，并且该参数不是有效目标。在 CMake 2.8.3 及更高版本中，它会在这种情况下报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0016.rst:12
msgid ""
"This policy was introduced in CMake version 2.8.3.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.8.3 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0017.rst:2
msgid "CMP0017"
msgstr "CMP0017"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0017.rst:4
msgid ""
"Prefer files from the CMake module directory when including from there."
msgstr "从那里包含时，首选 CMake 模块目录中的文件。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0017.rst:6
msgid ""
"Starting with CMake 2.8.4, if a cmake-module shipped with CMake (i.e. "
"located in the CMake module directory) calls :command:`include` or "
":command:`find_package`, the files located in the CMake module directory "
"are preferred over the files in :variable:`CMAKE_MODULE_PATH`.  This makes"
" sure that the modules belonging to CMake always get those files included "
"which they expect, and against which they were developed and tested.  In "
"all other cases, the files found in :variable:`CMAKE_MODULE_PATH` still "
"take precedence over the ones in the CMake module directory.  The ``OLD`` "
"behavior is to always prefer files from CMAKE_MODULE_PATH over files from "
"the CMake modules directory."
msgstr ""
"从 CMake 2.8.4 开始，如果 CMake 附带的 cmake 模块（即位于 CMake 模块目录中）调用 "
":command:`include` 或 :command:`find_package`，则位于 CMake "
"模块目录中的文件优先于 :variable:`CMAKE_MODULE_PATH` 中的文件。这确保属于 CMake "
"的模块始终包含它们期望的那些文件，以及它们是针对这些文件开发和测试的。在所有其他情况下，在 "
":variable:`CMAKE_MODULE_PATH` 中找到的文件仍然优先于 CMake 模块目录中的文件。 ``OLD`` "
"行为总是优先选择来自 CMAKE_MODULE_PATH 的文件而不是来自 CMake 模块目录的文件。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0017.rst:17
msgid ""
"This policy was introduced in CMake version 2.8.4.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.8.4 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0018.rst:2
msgid "CMP0018"
msgstr "CMP0018"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0018.rst:4
msgid "Ignore ``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS`` variable."
msgstr "忽略 ``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS`` 变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0018.rst:6
msgid ""
"CMake 2.8.8 and lower compiled sources in ``SHARED`` and ``MODULE`` "
"libraries using the value of the undocumented "
"``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS`` platform variable.  The variable "
"contained platform-specific flags needed to compile objects for shared "
"libraries.  Typically it included a flag such as ``-fPIC`` for position "
"independent code but also included other flags needed on certain "
"platforms.  CMake 2.8.9 and higher prefer instead to use the "
":prop_tgt:`POSITION_INDEPENDENT_CODE` target property to determine what "
"targets should be position independent, and new undocumented platform "
"variables to select flags while ignoring "
"``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS`` completely."
msgstr ""
"``SHARED`` 和 ``MODULE`` 库中的 CMake 2.8.8 及更低编译源使用未记录的 "
"``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS`` "
"平台变量的值。该变量包含为共享库编译对象所需的特定于平台的标志。通常它包括一个标志，例如用于位置无关代码的“-fPIC”，但也包括某些平台所需的其他标志。"
" CMake 2.8.9 及更高版本更喜欢使用 :prop_tgt:`POSITION_INDEPENDENT_CODE` "
"目标属性来确定哪些目标应该与位置无关，并使用新的未记录的平台变量来选择标志，同时完全忽略 "
"``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0018.rst:17
msgid ""
"The default for either approach produces identical compilation flags, but "
"if a project modifies ``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS`` from its "
"original value this policy determines which approach to use."
msgstr ""
"这两种方法的默认值都会产生相同的编译标志，但如果项目从其原始值修改了“CMAKE_SHARED_LIBRARY_<Lang>_FLAGS”，则此策略决定使用哪种方法。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0018.rst:21
msgid ""
"The ``OLD`` behavior for this policy is to ignore the "
":prop_tgt:`POSITION_INDEPENDENT_CODE` property for all targets and use the"
" modified value of ``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS`` for ``SHARED`` "
"and ``MODULE`` libraries."
msgstr ""
"此策略的“旧”行为是忽略所有目标的 POSITION_INDEPENDENT_CODE "
"属性，并为“共享”和“模块”使用修改后的“CMAKE_SHARED_LIBRARY_<Lang>_FLAGS”值`图书馆。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0018.rst:26
msgid ""
"The ``NEW`` behavior for this policy is to ignore "
"``CMAKE_SHARED_LIBRARY_<Lang>_FLAGS`` whether it is modified or not and "
"honor the :prop_tgt:`POSITION_INDEPENDENT_CODE` target property."
msgstr ""
"此策略的“新”行为是忽略“CMAKE_SHARED_LIBRARY_<Lang>_FLAGS”，无论它是否被修改，并遵守 "
"POSITION_INDEPENDENT_CODE 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0018.rst:30
msgid ""
"This policy was introduced in CMake version 2.8.9.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.8.9 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0019.rst:2
msgid "CMP0019"
msgstr "CMP0019"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0019.rst:4
msgid "Do not re-expand variables in include and link information."
msgstr "不要重新扩展包含和链接信息中的变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0019.rst:6
msgid ""
"CMake 2.8.10 and lower re-evaluated values given to the "
"include_directories, link_directories, and link_libraries commands to "
"expand any leftover variable references at the end of the configuration "
"step.  This was for strict compatibility with VERY early CMake versions "
"because all variable references are now normally evaluated during CMake "
"language processing.  CMake 2.8.11 and higher prefer to skip the extra "
"evaluation."
msgstr ""
"CMake 2.8.10 及更低版本重新评估了 include_directories、link_directories 和 "
"link_libraries 命令的值，以在配置步骤结束时扩展任何剩余的变量引用。这是为了与非常早期的 CMake "
"版本严格兼容，因为所有变量引用现在通常在 CMake 语言处理期间进行评估。 CMake 2.8.11 及更高版本倾向于跳过额外的评估。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0019.rst:14
msgid ""
"The ``OLD`` behavior for this policy is to re-evaluate the values for "
"strict compatibility.  The ``NEW`` behavior for this policy is to leave "
"the values untouched."
msgstr "此策略的“旧”行为是重新评估严格兼容性的值。此策略的“新”行为是保持值不变。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0019.rst:18
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0020.rst:23
msgid ""
"This policy was introduced in CMake version 2.8.11.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.8.11 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0020.rst:2
msgid "CMP0020"
msgstr "CMP0020"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0020.rst:4
msgid "Automatically link Qt executables to ``qtmain`` target on Windows."
msgstr "自动将 Qt 可执行文件链接到 Windows 上的“qtmain”目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0020.rst:6
msgid ""
"CMake 2.8.10 and lower required users of Qt to always specify a link "
"dependency to the ``qtmain.lib`` static library manually on Windows. CMake"
" 2.8.11 gained the ability to evaluate generator expressions while "
"determining the link dependencies from ``IMPORTED`` targets.  This allows "
"CMake itself to automatically link executables which link to Qt to the "
"``qtmain.lib`` library when using ``IMPORTED`` Qt targets.  For "
"applications already linking to ``qtmain.lib``, this should have little "
"impact.  For applications which supply their own alternative WinMain "
"implementation and for applications which use the QAxServer library, this "
"automatic linking will need to be disabled as per the documentation."
msgstr ""
"CMake 2.8.10 及更低版本要求 Qt 用户始终在 Windows 上手动指定对 ``qtmain.lib`` 静态库的链接依赖性。 "
"CMake 2.8.11 获得了评估生成器表达式的能力，同时确定来自“IMPORTED”目标的链接依赖性。这允许 CMake 在使用 "
"``IMPORTED`` Qt 目标时自动将链接到 Qt 的可执行文件链接到 ``qtmain.lib`` 库。对于已经链接到 "
"``qtmain.lib`` 的应用程序，这应该影响不大。对于提供自己的替代 WinMain 实现的应用程序和使用 QAxServer "
"库的应用程序，需要根据文档禁用此自动链接。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0020.rst:18
msgid ""
"The ``OLD`` behavior for this policy is not to link executables to "
"``qtmain.lib`` automatically when they link to the QtCore ``IMPORTED`` "
"target. The ``NEW`` behavior for this policy is to link executables to "
"``qtmain.lib`` automatically when they link to QtCore ``IMPORTED`` target."
msgstr ""
"此策略的“旧”行为是当可执行文件链接到 QtCore "
"的“IMPORTED”目标时，不会自动将它们链接到“qtmain.lib”。此策略的“新”行为是在可执行文件链接到 QtCore "
"``IMPORTED`` 目标时自动将它们链接到 ``qtmain.lib``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0021.rst:2
msgid "CMP0021"
msgstr "CMP0021"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0021.rst:4
msgid ""
"Fatal error on relative paths in :prop_tgt:`INCLUDE_DIRECTORIES` target "
"property."
msgstr ":prop_tgt:`INCLUDE_DIRECTORIES` 目标属性中相对路径的致命错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0021.rst:7
msgid ""
"CMake 2.8.10.2 and lower allowed the :prop_tgt:`INCLUDE_DIRECTORIES` "
"target property to contain relative paths.  The base path for such "
"relative entries is not well defined.  CMake 2.8.12 issues a "
"``FATAL_ERROR`` if the :prop_tgt:`INCLUDE_DIRECTORIES` property contains a"
" relative path."
msgstr ""
"CMake 2.8.10.2 及更低版本允许 :prop_tgt:`INCLUDE_DIRECTORIES` "
"目标属性包含相对路径。此类相对条目的基本路径未明确定义。如果 :prop_tgt:`INCLUDE_DIRECTORIES` "
"属性包含相对路径，CMake 2.8.12 会发出 ``FATAL_ERROR``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0021.rst:12
msgid ""
"The ``OLD`` behavior for this policy is not to warn about relative paths "
"in the ``INCLUDE_DIRECTORIES`` target property.  The ``NEW`` behavior for "
"this policy is to issue a ``FATAL_ERROR`` if ``INCLUDE_DIRECTORIES`` "
"contains a relative path."
msgstr ""
"此策略的“旧”行为不会警告“INCLUDE_DIRECTORIES”目标属性中的相对路径。如果 INCLUDE_DIRECTORIES "
"包含相对路径，则此策略的“新”行为是发出“FATAL_ERROR”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0021.rst:17
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0022.rst:35
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0023.rst:31
msgid ""
"This policy was introduced in CMake version 2.8.12.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior.  Use"
" the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 2.8.12 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0022.rst:2
msgid "CMP0022"
msgstr "CMP0022"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0022.rst:4
msgid ":prop_tgt:`INTERFACE_LINK_LIBRARIES` defines the link interface."
msgstr ":prop_tgt:`INTERFACE_LINK_LIBRARIES` 定义链接接口。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0022.rst:6
msgid ""
"CMake 2.8.11 constructed the 'link interface' of a target from properties "
"matching ``(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?``. The modern "
"way to specify config-sensitive content is to use generator expressions "
"and the ``IMPORTED_`` prefix makes uniform processing of the link "
"interface with generator expressions impossible.  The "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` target property was introduced as a "
"replacement in CMake 2.8.12.  This new property is named consistently with"
" the ``INTERFACE_COMPILE_DEFINITIONS``, ``INTERFACE_INCLUDE_DIRECTORIES`` "
"and ``INTERFACE_COMPILE_OPTIONS`` properties.  For in-build targets, CMake"
" will use the INTERFACE_LINK_LIBRARIES property as the source of the link "
"interface only if policy ``CMP0022`` is ``NEW``.  When exporting a target "
"which has this policy set to ``NEW``, only the "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` property will be processed and "
"generated for the ``IMPORTED`` target by default.  A new option to the "
":command:`install(EXPORT)` and export commands allows export of the old-"
"style properties for compatibility with downstream users of CMake versions"
" older than 2.8.12.  The :command:`target_link_libraries` command will no "
"longer populate the properties matching "
"``LINK_INTERFACE_LIBRARIES(_<CONFIG>)?`` if this policy is ``NEW``."
msgstr ""
"CMake 2.8.11 从匹配``(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?`` "
"的属性构造目标的“链接接口”。指定配置敏感内容的现代方法是使用生成器表达式，而 ``IMPORTED_`` "
"前缀使得无法使用生成器表达式统一处理链接接口。 :prop_tgt:`INTERFACE_LINK_LIBRARIES` 目标属性作为 CMake "
"2.8.12 "
"中的替代品引入。这个新属性的命名与“INTERFACE_COMPILE_DEFINITIONS”、“INTERFACE_INCLUDE_DIRECTORIES”和“INTERFACE_COMPILE_OPTIONS”属性一致。对于内置目标，仅当策略“CMP0022”为“NEW”时，CMake"
" 才会使用 INTERFACE_LINK_LIBRARIES 属性作为链接接口的源。导出将此策略设置为 ``NEW`` 的目标时，默认情况下只会为 "
"``IMPORTED`` 目标处理和生成 :prop_tgt:`INTERFACE_LINK_LIBRARIES` 属性。 "
":command:`install(EXPORT)` 和 export 命令的新选项允许导出旧式属性，以便与 2.8.12 之前的 CMake "
"版本的下游用户兼容。 :command:`target_link_libraries` "
"命令将不再填充与``LINK_INTERFACE_LIBRARIES(_<CONFIG>)?`` 匹配的属性，如果此策略是``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0022.rst:25
msgid ""
"Warning-free future-compatible code which works with CMake 2.8.7 onwards "
"can be written by using the ``LINK_PRIVATE`` and ``LINK_PUBLIC`` keywords "
"of :command:`target_link_libraries`."
msgstr ""
"可以使用 :command:`target_link_libraries` 的 ``LINK_PRIVATE`` 和 ``LINK_PUBLIC``"
" 关键字编写适用于 CMake 2.8.7 以上的无警告未来兼容代码。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0022.rst:29
msgid ""
"The ``OLD`` behavior for this policy is to ignore the "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` property for in-build targets. The "
"``NEW`` behavior for this policy is to use the "
"``INTERFACE_LINK_LIBRARIES`` property for in-build targets, and ignore the"
" old properties matching "
"``(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?``."
msgstr ""
"此策略的“旧”行为是忽略内置目标的 :prop_tgt:`INTERFACE_LINK_LIBRARIES` "
"属性。此策略的“新”行为是对内置目标使用“INTERFACE_LINK_LIBRARIES”属性，并忽略匹配“(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?”的旧属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0023.rst:2
msgid "CMP0023"
msgstr "CMP0023"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0023.rst:4
msgid ""
"Plain and keyword :command:`target_link_libraries` signatures cannot be "
"mixed."
msgstr "普通签名和关键字 :command:`target_link_libraries` 签名不能混合。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0023.rst:6
msgid ""
"CMake 2.8.12 introduced the :command:`target_link_libraries` signature "
"using the ``PUBLIC``, ``PRIVATE``, and ``INTERFACE`` keywords to "
"generalize the ``LINK_PUBLIC`` and ``LINK_PRIVATE`` keywords introduced in"
" CMake 2.8.7. Use of signatures with any of these keywords sets the link "
"interface of a target explicitly, even if empty.  This produces confusing "
"behavior when used in combination with the historical behavior of the "
"plain :command:`target_link_libraries` signature.  For example, consider "
"the code:"
msgstr ""
"CMake 2.8.12 使用 ``PUBLIC``、``PRIVATE`` 和 ``INTERFACE`` "
"关键字引入了 :command:`target_link_libraries` 签名，以概括引入的 ``LINK_PUBLIC`` 和 "
"``LINK_PRIVATE`` 关键字在 CMake 2.8.7 "
"中。将签名与这些关键字中的任何一个一起使用会显式设置目标的链接接口，即使是空的。当与普通 "
":command:`target_link_libraries` 签名的历史行为结合使用时，这会产生令人困惑的行为。例如，考虑以下代码："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0023.rst:19
msgid ""
"After the first line the link interface has not been set explicitly so "
"CMake would use the link implementation, A, as the link interface. "
"However, the second line sets the link interface to empty.  In order to "
"avoid this subtle behavior CMake now prefers to disallow mixing the plain "
"and keyword signatures of :command:`target_link_libraries` for a single "
"target."
msgstr ""
"在第一行之后，链接接口没有明确设置，因此 CMake 将使用链接实现 A "
"作为链接接口。但是，第二行将链接界面设置为空。为了避免这种微妙的行为，CMake 现在更倾向于禁止将 "
":command:`target_link_libraries` 的普通签名和关键字签名混合用于单个目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0023.rst:26
msgid ""
"The ``OLD`` behavior for this policy is to allow keyword and plain "
":command:`target_link_libraries` signatures to be mixed.  The ``NEW`` "
"behavior for this policy is to not to allow mixing of the keyword and "
"plain signatures."
msgstr ""
"此策略的“旧”行为是允许混合使用关键字和纯 :command:`target_link_libraries` "
"签名。此策略的“新”行为是不允许混合使用关键字和普通签名。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0024.rst:2
msgid "CMP0024"
msgstr "CMP0024"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0024.rst:4
msgid "Disallow include export result."
msgstr "不允许包含导出结果。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0024.rst:6
msgid ""
"CMake 2.8.12 and lower allowed use of the :command:`include` command with "
"the result of the :command:`export` command.  This relies on the "
"assumption that the :command:`export` command has an immediate effect at "
"configure-time during a cmake run.  Certain properties of targets are not "
"fully determined until later at generate-time, such as the link language "
"and complete list of link libraries.  Future refactoring will change the "
"effect of the :command:`export` command to be executed at generate-time.  "
"Use ``ALIAS`` targets instead in cases where the goal is to refer to "
"targets by another name."
msgstr ""
"CMake 2.8.12 及更低版本允许使用 :command:`include` 命令和 :command:`export` 命令的结果。这依赖于"
" :command:`export` 命令在 cmake "
"运行期间的配置时立即生效的假设。目标的某些属性直到稍后在生成时才完全确定，例如链接语言和链接库的完整列表。未来的重构将改变在生成时执行的 "
":command:`export` 命令的效果。在目标是通过另一个名称引用目标的情况下，请使用 ``ALIAS`` 目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0024.rst:16
msgid ""
"The ``OLD`` behavior for this policy is to allow including the result of "
"an :command:`export` command.  The ``NEW`` behavior for this policy is not"
" to allow including the result of an :command:`export` command."
msgstr ""
"此策略的“旧”行为是允许包含 :command:`export` 命令的结果。此策略的“新”行为是不允许包含 :command:`export` "
"命令的结果。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0024.rst:20
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0026.rst:25
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0027.rst:23
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0028.rst:23
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0037.rst:30
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0038.rst:14
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0039.rst:15
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0041.rst:23
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0042.rst:17
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0043.rst:43
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0044.rst:17
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0045.rst:15
msgid ""
"This policy was introduced in CMake version 3.0.  CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 3.0 版中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0025.rst:2
msgid "CMP0025"
msgstr "CMP0025"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0025.rst:4
msgid "Compiler id for Apple Clang is now ``AppleClang``."
msgstr "Apple Clang 的编译器 ID 现在是 ``AppleClang``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0025.rst:6
msgid ""
"CMake 3.0 and above recognize that Apple Clang is a different compiler "
"than upstream Clang and that they have different version numbers. CMake "
"now prefers to present this to projects by setting the "
":variable:`CMAKE_<LANG>_COMPILER_ID` variable to ``AppleClang`` instead of"
" ``Clang``.  However, existing projects may assume the compiler id for "
"Apple Clang is just ``Clang`` as it was in CMake versions prior to 3.0. "
"Therefore this policy determines for Apple Clang which compiler id to "
"report in the :variable:`CMAKE_<LANG>_COMPILER_ID` variable after language"
" ``<LANG>`` is enabled by the :command:`project` or "
":command:`enable_language` command.  The policy must be set prior to the "
"invocation of either command."
msgstr ""
"CMake 3.0 及更高版本识别 Apple Clang 是与上游 Clang 不同的编译器，并且它们具有不同的版本号。 CMake "
"现在更喜欢通过将 :variable:`CMAKE_<LANG>_COMPILER_ID` 变量设置为 ``AppleClang`` 而不是 "
"``Clang`` 来将其呈现给项目。然而，现有项目可能假设 Apple Clang 的编译器 ID 只是 ``Clang``，因为它在 3.0 "
"之前的 CMake 版本中。因此，此策略为 Apple Clang 确定在 :command:`project` 或 "
":command:`enable_language 启用语言 ``<LANG>`` 后，在 "
":variable:`CMAKE_<LANG>_COMPILER_ID` 变量中报告哪个编译器 ID `命令。该策略必须在调用任一命令之前设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0025.rst:18
msgid ""
"The ``OLD`` behavior for this policy is to use compiler id ``Clang``.  The"
" ``NEW`` behavior for this policy is to use compiler id ``AppleClang``."
msgstr "此策略的“旧”行为是使用编译器 ID“Clang”。此政策的“新”行为是使用编译器 ID“AppleClang”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0025.rst:21
msgid ""
"This policy was introduced in CMake version 3.0.  Use the "
":command:`cmake_policy` command to set this policy to ``OLD`` or ``NEW`` "
"explicitly.  Unlike most policies, CMake version |release| does *not* warn"
" by default when this policy is not set and simply uses ``OLD`` behavior. "
"See documentation of the :variable:`CMAKE_POLICY_WARNING_CMP0025 "
"<CMAKE_POLICY_WARNING_CMP<NNNN>>` variable to control the warning."
msgstr ""
"此策略是在 CMake 3.0 版中引入的。使用 :command:`cmake_policy` 命令将此策略显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0025 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0026.rst:2
msgid "CMP0026"
msgstr "CMP0026"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0026.rst:4
msgid "Disallow use of the LOCATION property for build targets."
msgstr "禁止对构建目标使用 LOCATION 属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0026.rst:6
msgid ""
"CMake 2.8.12 and lower allowed reading the :prop_tgt:`LOCATION` target "
"property (and configuration-specific variants) to determine the eventual "
"location of build targets.  This relies on the assumption that all "
"necessary information is available at configure-time to determine the "
"final location and filename of the target.  However, this property is not "
"fully determined until later at generate-time.  At generate time, the "
":genex:`$<TARGET_FILE>` generator expression can be used to determine the "
"eventual :prop_tgt:`LOCATION` of a target output."
msgstr ""
"CMake 2.8.12 及更低版本允许读取 :prop_tgt:`LOCATION` "
"目标属性（和特定于配置的变体）以确定构建目标的最终位置。这依赖于所有必要信息在配置时可用以确定目标的最终位置和文件名的假设。但是，此属性直到稍后在生成时才完全确定。在生成时， :genex:`$<TARGET_FILE>`"
" 生成器表达式可用于确定目标输出的最终位置 :prop_tgt:`LOCATION`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0026.rst:16
msgid ""
"Code which reads the :prop_tgt:`LOCATION` target property can be ported to"
" use the :genex:`$<TARGET_FILE>` generator expression together with the "
":command:`file(GENERATE)` subcommand to generate a file containing the "
"target location."
msgstr ""
"读取 :prop_tgt:`LOCATION` 目标属性的代码可以移植为使用 :genex:`$<TARGET_FILE>` 生成器表达式和 "
":command:`file(GENERATE)` 子命令来生成包含目标位置的文件."

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0026.rst:21
msgid ""
"The ``OLD`` behavior for this policy is to allow reading the "
":prop_tgt:`LOCATION` properties from build-targets.  The ``NEW`` behavior "
"for this policy is to not to allow reading the :prop_tgt:`LOCATION` "
"properties from build-targets."
msgstr ""
"此策略的“旧”行为是允许从构建目标读取 :prop_tgt:`LOCATION` 属性。此策略的“新”行为是不允许从构建目标读取 "
":prop_tgt:`LOCATION` 属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0027.rst:2
msgid "CMP0027"
msgstr "CMP0027"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0027.rst:4
msgid ""
"Conditionally linked imported targets with missing include directories."
msgstr "有条件地链接缺少包含目录的导入目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0027.rst:6
msgid ""
"CMake 2.8.11 introduced introduced the concept of "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES`, and a check at cmake time that "
"the entries in the :prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` of an "
"``IMPORTED`` target actually exist.  CMake 2.8.11 also introduced "
"generator expression support in the :command:`target_link_libraries` "
"command.  However, if an imported target is linked as a result of a "
"generator expression evaluation, the entries in the "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` of that target were not checked "
"for existence as they should be."
msgstr ""
"CMake 2.8.11 引入了 INTERFACE_INCLUDE_DIRECTORIES 的概念，并在 cmake 时检查 IMPORTED "
"目标的 INTERFACE_INCLUDE_DIRECTORIES 中的条目是否实际存在。 CMake 2.8.11 还在 "
":command:`target_link_libraries` "
"命令中引入了生成器表达式支持。但是，如果作为生成器表达式评估的结果链接导入的目标，则不会检查该目标的 "
"INTERFACE_INCLUDE_DIRECTORIES 中的条目是否存在，因为它们应该是。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0027.rst:15
msgid ""
"The ``OLD`` behavior of this policy is to report a warning if an entry in "
"the :prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` of a generator-expression "
"conditionally linked ``IMPORTED`` target does not exist."
msgstr ""
"如果生成器表达式有条件链接的“IMPORTED”目标的 INTERFACE_INCLUDE_DIRECTORIES "
"中的条目不存在，则此策略的“旧”行为是报告警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0027.rst:19
msgid ""
"The ``NEW`` behavior of this policy is to report an error if an entry in "
"the :prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` of a generator-expression "
"conditionally linked ``IMPORTED`` target does not exist."
msgstr ""
"如果生成器表达式有条件链接的“IMPORTED”目标的 INTERFACE_INCLUDE_DIRECTORIES "
"中的条目不存在，则此策略的“新”行为是报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0028.rst:2
msgid "CMP0028"
msgstr "CMP0028"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0028.rst:4
msgid "Double colon in target name means ``ALIAS`` or ``IMPORTED`` target."
msgstr "目标名称中的双冒号表示“ALIAS”或“IMPORTED”目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0028.rst:6
msgid ""
"CMake 2.8.12 and lower allowed the use of targets and files with double "
"colons in :command:`target_link_libraries`, with some buildsystem "
"generators."
msgstr ""
"CMake 2.8.12 及更低版本允许在 :command:`target_link_libraries` "
"中使用带有双冒号的目标和文件，以及一些构建系统生成器。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0028.rst:9
msgid ""
"The use of double-colons is a common pattern used to namespace "
"``IMPORTED`` targets and ``ALIAS`` targets.  When computing the link "
"dependencies of a target, the name of each dependency could either be a "
"target, or a file on disk.  Previously, if a target was not found with a "
"matching name, the name was considered to refer to a file on disk.  This "
"can lead to confusing error messages if there is a typo in what should be "
"a target name."
msgstr ""
"双冒号的使用是用于命名“IMPORTED”目标和“ALIAS”目标的常见模式。在计算目标的链接依赖时，每个依赖的名称可以是目标，也可以是磁盘上的文件。以前，如果找不到具有匹配名称的目标，该名称将被认为是指磁盘上的文件。如果应该是目标名称的内容有拼写错误，这可能会导致出现令人困惑的错误消息。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0028.rst:16
msgid ""
"See also the :prop_tgt:`LINK_LIBRARIES_ONLY_TARGETS` target property."
msgstr "另请参阅:prop_tgt:`LINK_LIBRARIES_ONLY_TARGETS` 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0028.rst:18
msgid ""
"The ``OLD`` behavior for this policy is to search for targets, then files "
"on disk, even if the search term contains double-colons.  The ``NEW`` "
"behavior for this policy is to issue a ``FATAL_ERROR`` if a link "
"dependency contains double-colons but is not an ``IMPORTED`` target or an "
"``ALIAS`` target."
msgstr ""
"此策略的“旧”行为是搜索目标，然后是磁盘上的文件，即使搜索词包含双冒号。如果链接依赖项包含双冒号但不是“IMPORTED”目标或“ALIAS”目标，则此策略的“新”行为是发出“FATAL_ERROR”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0029.rst:2
msgid "CMP0029"
msgstr "CMP0029"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0029.rst:4
msgid "The :command:`subdir_depends` command should not be called."
msgstr "不应调用 :command:`subdir_depends` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0029.rst:6
msgid ""
"The implementation of this command has been empty since December 2001 but "
"was kept in CMake for compatibility for a long time."
msgstr "该命令的实现自 2001 年 12 月以来一直是空的，但为了兼容在 CMake 中保留了很长时间。"

#: ../../cmake-prefix/src/cmake/Help/policy/DISALLOWED_COMMAND.txt:1
msgid ""
"CMake >= |disallowed_version| prefer that this command never be called. "
"The ``OLD`` behavior for this policy is to allow the command to be called."
" The ``NEW`` behavior for this policy is to issue a ``FATAL_ERROR`` when "
"the command is called."
msgstr ""
"CMake >= "
"|disallowed_version|最好永远不要调用此命令。此策略的“旧”行为是允许调用命令。此策略的“新”行为是在调用命令时发出“致命错误”。"

#: ../../cmake-prefix/src/cmake/Help/policy/DISALLOWED_COMMAND.txt:6
msgid ""
"This policy was introduced in CMake version |disallowed_version|. CMake "
"version |release| warns when the policy is not set and uses ``OLD`` "
"behavior.  Use the :command:`cmake_policy` command to set it to ``OLD`` or"
" ``NEW`` explicitly."
msgstr ""
"此策略是在 CMake 版本 |disallowed_version| 中引入的。 CMake 版本 "
"|发布|当未设置策略并使用“旧”行为时发出警告。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0030.rst:2
msgid "CMP0030"
msgstr "CMP0030"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0030.rst:4
msgid "The :command:`use_mangled_mesa` command should not be called."
msgstr "不应调用 :command:`use_mangled_mesa` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0030.rst:6
msgid ""
"This command was created in September 2001 to support VTK before modern "
"CMake language and custom command capabilities.  VTK has not used it in "
"years."
msgstr "此命令创建于 2001 年 9 月，用于支持现代 CMake 语言和自定义命令功能之前的 VTK。 VTK 已经很多年没有使用它了。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0031.rst:2
msgid "CMP0031"
msgstr "CMP0031"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0031.rst:4
msgid "The :command:`load_command` command should not be called."
msgstr "不应调用 :command:`load_command` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0031.rst:6
msgid ""
"This command was added in August 2002 to allow projects to add arbitrary "
"commands implemented in C or C++.  However, it does not work when the "
"toolchain in use does not match the ABI of the CMake process.  It has been"
" mostly superseded by the :command:`macro` and :command:`function` "
"commands."
msgstr ""
"此命令于 2002 年 8 月添加，以允许项目添加以 C 或 C++ 实现的任意命令。但是，当使用的工具链与 CMake 进程的 ABI "
"不匹配时，它不起作用。它大部分已被 :command:`macro` 和 :command:`function` 命令取代。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0032.rst:2
msgid "CMP0032"
msgstr "CMP0032"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0032.rst:4
msgid "The :command:`output_required_files` command should not be called."
msgstr "不应调用 :command:`output_required_files` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0032.rst:6
msgid ""
"This command was added in June 2001 to expose the then-current CMake "
"implicit dependency scanner.  CMake's real implicit dependency scanner has"
" evolved since then but is not exposed through this command.  The scanning"
" capabilities of this command are very limited and this functionality is "
"better achieved through dedicated outside tools."
msgstr ""
"此命令于 2001 年 6 月添加，以公开当时的 CMake 隐式依赖扫描器。 CMake "
"的真正隐式依赖扫描器从那时起已经发展，但不会通过此命令公开。这个命令的扫描能力非常有限，这个功能最好通过专用的外部工具来实现。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0033.rst:2
msgid "CMP0033"
msgstr "CMP0033"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0033.rst:4
msgid ""
"The :command:`export_library_dependencies` command should not be called."
msgstr "不应调用 :command:`export_library_dependencies` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0033.rst:6
msgid ""
"This command was added in January 2003 to export ``<tgt>_LIB_DEPENDS`` "
"internal CMake cache entries to a file for installation with a project. "
"This was used at the time to allow transitive link dependencies to work "
"for applications outside of the original build tree of a project. The "
"functionality has been superseded by the :command:`export` and "
":command:`install(EXPORT)` commands."
msgstr ""
"此命令于 2003 年 1 月添加，用于将 ``<tgt>_LIB_DEPENDS`` 内部 CMake "
"缓存条目导出到文件，以便与项目一起安装。这在当时用于允许传递链接依赖项适用于项目原始构建树之外的应用程序。该功能已被 "
":command:`export` 和 :command:`install(EXPORT)` 命令取代。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0034.rst:2
msgid "CMP0034"
msgstr "CMP0034"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0034.rst:4
msgid "The :command:`utility_source` command should not be called."
msgstr "不应调用 :command:`utility_source` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0034.rst:6
msgid ""
"This command was introduced in March 2001 to help build executables used "
"to generate other files.  This approach has long been replaced by "
":command:`add_executable` combined with :command:`add_custom_command`."
msgstr ""
"此命令于 2001 年 3 月引入，以帮助构建用于生成其他文件的可执行文件。这种方法早已被 :command:`add_executable` 结合"
" :command:`add_custom_command` 所取代。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0035.rst:2
msgid "CMP0035"
msgstr "CMP0035"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0035.rst:4
msgid "The :command:`variable_requires` command should not be called."
msgstr "不应调用 :command:`variable_requires` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0035.rst:6
msgid ""
"This command was introduced in November 2001 to perform some conditional "
"logic.  It has long been replaced by the :command:`if` command."
msgstr "该命令于 2001 年 11 月引入，用于执行某些条件逻辑。它早已被 :command:`if` 命令取代。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0036.rst:2
msgid "CMP0036"
msgstr "CMP0036"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0036.rst:4
msgid "The :command:`build_name` command should not be called."
msgstr "不应调用 :command:`build_name` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0036.rst:6
msgid ""
"This command was added in May 2001 to compute a name for the current "
"operating system and compiler combination.  The command has long been "
"documented as discouraged and replaced by the :variable:`CMAKE_SYSTEM` and"
" :variable:`CMAKE_<LANG>_COMPILER` variables."
msgstr ""
"该命令于 2001 年 5 月添加，用于计算当前操作系统和编译器组合的名称。该命令长期以来一直被记录为不鼓励使用，并被 "
":variable:`CMAKE_SYSTEM` 和 :variable:`CMAKE_<LANG>_COMPILER` 变量取代。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0037.rst:2
msgid "CMP0037"
msgstr "CMP0037"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0037.rst:4
msgid ""
"Target names should not be reserved and should match a validity pattern."
msgstr "目标名称不应保留，并且应与有效性模式相匹配。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0037.rst:6
msgid ""
"CMake 2.8.12 and lower allowed creating targets using "
":command:`add_library`, :command:`add_executable` and "
":command:`add_custom_target` with unrestricted choice for the target name."
"  Newer cmake features such as :manual:`cmake-generator-expressions(7)` "
"and some diagnostics expect target names to match a restricted pattern."
msgstr ""
"CMake 2.8.12 及更低版本允许使用 :command:`add_library`、 :command:`add_executable` 和 "
":command:`add_custom_target` 创建目标，目标名称不受限制。较新的 cmake 功能，如 :manual:`cmake-"
"generator-expressions(7)` 和一些诊断期望目标名称匹配受限模式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0037.rst:12
msgid ""
"Target names may contain upper and lower case letters, numbers, the "
"underscore character (``_``), dot(``.``), plus(``+``) and minus(``-``). As"
" a special case, ``ALIAS`` and ``IMPORTED`` targets may contain two "
"consecutive colons."
msgstr ""
"目标名称可以包含大小写字母、数字、下划线字符 (``_``)、点 (``.``)、加号 (``+``) 和减号 "
"(``-``)。作为一种特殊情况，``ALIAS`` 和 ``IMPORTED`` 目标可能包含两个连续的冒号。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0037.rst:17
msgid ""
"Target names reserved by one or more CMake generators are not allowed. "
"Among others these include ``all``, ``clean``, ``help``, and ``install``."
msgstr ""
"不允许使用一个或多个 CMake 生成器保留的目标名称。其中包括``all``、``clean``、``help`` 和``install``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0037.rst:20
msgid ""
"Target names associated with optional features, such as ``test`` and "
"``package``, may also be reserved.  CMake 3.10 and below always reserve "
"them. CMake 3.11 and above reserve them only when the corresponding "
"feature is enabled (e.g. by including the :module:`CTest` or "
":module:`CPack` modules)."
msgstr ""
"与可选功能相关的目标名称，例如 ``test`` 和 ``package``，也可以保留。 CMake 3.10 及以下版本始终保留它们。 "
"CMake 3.11 及更高版本仅在启用相应功能时保留它们（例如，通过包含 :module:`CTest` 或 :module:`CPack` 模块）。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0037.rst:25
msgid ""
"The ``OLD`` behavior for this policy is to allow creating targets with "
"reserved names or which do not match the validity pattern. The ``NEW`` "
"behavior for this policy is to report an error if an add_* command is used"
" with an invalid target name."
msgstr ""
"此策略的“旧”行为是允许创建具有保留名称或与有效性模式不匹配的目标。如果 add_* 命令与无效的目标名称一起使用，此策略的“新”行为将报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0038.rst:2
msgid "CMP0038"
msgstr "CMP0038"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0038.rst:4
msgid "Targets may not link directly to themselves."
msgstr "目标可能不会直接链接到它们自己。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0038.rst:6
msgid ""
"CMake 2.8.12 and lower allowed a build target to link to itself directly "
"with a :command:`target_link_libraries` call. This is an indicator of a "
"bug in user code."
msgstr ""
"CMake 2.8.12 及更低版本允许构建目标通过调用 target_link_libraries 直接链接到自身。这是用户代码中错误的指示器。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0038.rst:10
msgid ""
"The ``OLD`` behavior for this policy is to ignore targets which list "
"themselves in their own link implementation.  The ``NEW`` behavior for "
"this policy is to report an error if a target attempts to link to itself."
msgstr "此策略的“旧”行为是忽略在自己的链接实现中列出自己的目标。此策略的“新”行为是在目标尝试链接到自身时报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0039.rst:2
msgid "CMP0039"
msgstr "CMP0039"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0039.rst:4
msgid "Utility targets may not have link dependencies."
msgstr "实用程序目标可能没有链接依赖性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0039.rst:6
msgid ""
"CMake 2.8.12 and lower allowed using utility targets in the left hand side"
" position of the :command:`target_link_libraries` command. This is an "
"indicator of a bug in user code."
msgstr ""
"CMake 2.8.12 及更低版本允许在 :command:`target_link_libraries` "
"命令的左侧位置使用实用程序目标。这是用户代码中错误的指示器。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0039.rst:10
msgid ""
"The ``OLD`` behavior for this policy is to ignore attempts to set the link"
" libraries of utility targets.  The ``NEW`` behavior for this policy is to"
" report an error if an attempt is made to set the link libraries of a "
"utility target."
msgstr "此策略的“旧”行为是忽略设置实用程序目标链接库的尝试。此策略的“新”行为是在尝试设置实用程序目标的链接库时报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0040.rst:2
msgid "CMP0040"
msgstr "CMP0040"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0040.rst:4
msgid ""
"The target in the ``TARGET`` signature of :command:`add_custom_command` "
"must exist and must be defined in the current directory."
msgstr ":command:`add_custom_command` 的``TARGET`` 签名中的目标必须存在并且必须在当前目录中定义。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0040.rst:7
msgid ""
"CMake 2.8.12 and lower silently ignored a custom command created with the "
"``TARGET`` signature of :command:`add_custom_command` if the target is "
"unknown or was defined outside the current directory."
msgstr ""
"如果目标未知或在当前目录外定义，CMake 2.8.12 及更低版本会默默地忽略使用 add_custom_command 的 ``TARGET``"
" 签名创建的自定义命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0040.rst:11
msgid ""
"The ``OLD`` behavior for this policy is to ignore custom commands for "
"unknown targets.  The ``NEW`` behavior for this policy is to report an "
"error if the target referenced in :command:`add_custom_command` is unknown"
" or was defined outside the current directory."
msgstr ""
"此策略的“旧”行为是忽略未知目标的自定义命令。如果在 :command:`add_custom_command` "
"中引用的目标未知或在当前目录之外定义，则此策略的“新”行为是报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0040.rst:16
msgid ""
"This policy was introduced in CMake version 3.0.  CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 3.0 版中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0041.rst:2
msgid "CMP0041"
msgstr "CMP0041"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0041.rst:4
msgid "Error on relative include with generator expression."
msgstr "生成器表达式的相对包含错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0041.rst:6
msgid ""
"Diagnostics in CMake 2.8.12 and lower silently ignored an entry in the "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` of a target if it contained a "
"generator expression at any position."
msgstr ""
"CMake 2.8.12 及更低版本中的诊断会默默地忽略目标的 INTERFACE_INCLUDE_DIRECTORIES "
"中的条目，如果它在任何位置包含生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0041.rst:10
msgid ""
"The path entries in that target property should not be relative. High-"
"level API should ensure that by adding either a source directory or a "
"install directory prefix, as appropriate."
msgstr "该目标属性中的路径条目不应是相对的。高级 API 应确保通过适当地添加源目录或安装目录前缀。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0041.rst:14
msgid ""
"As an additional diagnostic, the :prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES`"
" generated on an :prop_tgt:`IMPORTED` target for the install location "
"should not contain paths in the source directory or the build directory."
msgstr ""
"作为附加诊断，在安装位置的 IMPORTED 目标上生成的 INTERFACE_INCLUDE_DIRECTORIES "
"不应包含源目录或构建目录中的路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0041.rst:18
msgid ""
"The ``OLD`` behavior for this policy is to ignore relative path entries if"
" they contain a generator expression. The ``NEW`` behavior for this policy"
" is to report an error if a generator expression appears in another "
"location and the path is relative."
msgstr ""
"此策略的“旧”行为是忽略包含生成器表达式的相对路径条目。如果生成器表达式出现在另一个位置并且路径是相对的，则此策略的“新”行为是报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0042.rst:2
msgid "CMP0042"
msgstr "CMP0042"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0042.rst:4
msgid ":prop_tgt:`MACOSX_RPATH` is enabled by default."
msgstr ":prop_tgt:`MACOSX_RPATH` 默认启用。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0042.rst:6
msgid ""
"CMake 2.8.12 and newer has support for using ``@rpath`` in a target's "
"install name.  This was enabled by setting the target property "
":prop_tgt:`MACOSX_RPATH`.  The ``@rpath`` in an install name is a more "
"flexible and powerful mechanism than ``@executable_path`` or "
"``@loader_path`` for locating shared libraries."
msgstr ""
"CMake 2.8.12 "
"及更新版本支持在目标的安装名称中使用“@rpath”。这是通过设置目标属性启用的:prop_tgt:`MACOSX_RPATH`。安装名称中的“@rpath”是一种比“@executable_path”或“@loader_path”更灵活、更强大的定位共享库的机制。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0042.rst:12
msgid ""
"CMake 3.0 and later prefer this property to be ON by default.  Projects "
"wanting ``@rpath`` in a target's install name may remove any setting of "
"the :prop_tgt:`INSTALL_NAME_DIR` and :variable:`CMAKE_INSTALL_NAME_DIR` "
"variables."
msgstr ""
"CMake 3.0 及更高版本更喜欢此属性默认为 ON。在目标的安装名称中需要 ``@rpath`` 的项目可能会删除 "
":prop_tgt:`INSTALL_NAME_DIR` 和 :variable:`CMAKE_INSTALL_NAME_DIR` 变量的任何设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0043.rst:2
msgid "CMP0043"
msgstr "CMP0043"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0043.rst:4
msgid "Ignore COMPILE_DEFINITIONS_<Config> properties"
msgstr "忽略 COMPILE_DEFINITIONS_<Config> 属性"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0043.rst:6
msgid ""
"CMake 2.8.12 and lower allowed setting the "
":prop_tgt:`COMPILE_DEFINITIONS_<CONFIG>` target property and "
":prop_dir:`COMPILE_DEFINITIONS_<CONFIG>` directory property to apply "
"configuration-specific compile definitions."
msgstr ""
"CMake 2.8.12 及更低版本允许设置 :prop_tgt:`COMPILE_DEFINITIONS_<CONFIG>` 目标属性和 "
":prop_dir:`COMPILE_DEFINITIONS_<CONFIG>` 目录属性以应用特定于配置的编译定义。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0043.rst:11
msgid ""
"Since CMake 2.8.10, the :prop_tgt:`COMPILE_DEFINITIONS` property has "
"supported :manual:`generator expressions <cmake-generator-expressions(7)>`"
" for setting configuration-dependent content.  The continued existence of "
"the suffixed variables is redundant, and causes a maintenance burden.  "
"Population of the :prop_tgt:`COMPILE_DEFINITIONS_DEBUG "
"<COMPILE_DEFINITIONS_<CONFIG>>` property may be replaced with a population"
" of :prop_tgt:`COMPILE_DEFINITIONS` directly or via "
":command:`target_compile_definitions`:"
msgstr ""
"从 CMake 2.8.10 开始， :prop_tgt:`COMPILE_DEFINITIONS` 属性支持 :manual:`generator "
"expressions <cmake-generator-expressions(7)>` "
"用于设置依赖于配置的内容。后缀变量的继续存在是多余的，并且造成维护负担。 :prop_tgt:`COMPILE_DEFINITIONS_DEBUG "
"<COMPILE_DEFINITIONS_<CONFIG>>` "
"属性的填充可以直接或通过 :command:`target_compile_definitions` 替换为 "
":prop_tgt:`COMPILE_DEFINITIONS` 的填充："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0043.rst:38
msgid ""
"The ``OLD`` behavior for this policy is to consume the content of the "
"suffixed :prop_tgt:`COMPILE_DEFINITIONS_<CONFIG>` target property when "
"generating the compilation command. The ``NEW`` behavior for this policy "
"is to ignore the content of the :prop_tgt:`COMPILE_DEFINITIONS_<CONFIG>` "
"target property ."
msgstr ""
"此策略的“旧”行为是在生成编译命令时使用后缀 :prop_tgt:`COMPILE_DEFINITIONS_<CONFIG>` "
"目标属性的内容。此策略的“新”行为是忽略 :prop_tgt:`COMPILE_DEFINITIONS_<CONFIG>` 目标属性的内容。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0044.rst:2
msgid "CMP0044"
msgstr "CMP0044"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0044.rst:4
msgid "Case sensitive ``<LANG>_COMPILER_ID`` generator expressions"
msgstr "区分大小写的``<LANG>_COMPILER_ID`` 生成器表达式"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0044.rst:6
msgid ""
"CMake 2.8.12 introduced the ``<LANG>_COMPILER_ID`` :manual:`generator "
"expressions <cmake-generator-expressions(7)>` to allow comparison of the "
":variable:`CMAKE_<LANG>_COMPILER_ID` with a test value.  The possible "
"valid values are lowercase, but the comparison with the test value was "
"performed case-insensitively."
msgstr ""
"CMake 2.8.12 引入了``<LANG>_COMPILER_ID`` :manual:`generator expressions "
"<cmake-generator-expressions(7)>` 以允许比较 "
":variable:`CMAKE_<LANG>_COMPILER_ID` 与测试值.可能的有效值是小写的，但与测试值的比较是不区分大小写的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0044.rst:12
msgid ""
"The ``OLD`` behavior for this policy is to perform a case-insensitive "
"comparison with the value in the ``<LANG>_COMPILER_ID`` expression. The "
"``NEW`` behavior for this policy is to perform a case-sensitive comparison"
" with the value in the ``<LANG>_COMPILER_ID`` expression."
msgstr ""
"此策略的“旧”行为是与“<LANG>_COMPILER_ID”表达式中的值执行不区分大小写的比较。此策略的“新”行为是与“<LANG>_COMPILER_ID”表达式中的值进行区分大小写的比较。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0045.rst:2
msgid "CMP0045"
msgstr "CMP0045"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0045.rst:4
msgid "Error on non-existent target in get_target_property."
msgstr "get_target_property 中不存在的目标出错。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0045.rst:6
msgid ""
"In CMake 2.8.12 and lower, the :command:`get_target_property` command "
"accepted a non-existent target argument without issuing any error or "
"warning.  The result variable is set to a ``-NOTFOUND`` value."
msgstr ""
"在 CMake 2.8.12 及更低版本中， :command:`get_target_property` "
"命令接受了一个不存在的目标参数，而没有发出任何错误或警告。结果变量设置为“-NOTFOUND”值。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0045.rst:10
msgid ""
"The ``OLD`` behavior for this policy is to issue no warning and set the "
"result variable to a ``-NOTFOUND`` value.  The ``NEW`` behavior for this "
"policy is to issue a ``FATAL_ERROR`` if the command is called with a non-"
"existent target."
msgstr ""
"此策略的“旧”行为是不发出警告并将结果变量设置为“-NOTFOUND”值。如果使用不存在的目标调用命令，则此策略的“新”行为是发出“致命错误”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0046.rst:2
msgid "CMP0046"
msgstr "CMP0046"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0046.rst:4
msgid "Error on non-existent dependency in add_dependencies."
msgstr "add_dependencies 中不存在的依赖项出错。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0046.rst:6
msgid ""
"CMake 2.8.12 and lower silently ignored non-existent dependencies listed "
"in the :command:`add_dependencies` command."
msgstr "CMake 2.8.12 及更低版本默默地忽略了 :command:`add_dependencies` 命令中列出的不存在的依赖项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0046.rst:9
msgid ""
"The ``OLD`` behavior for this policy is to silently ignore non-existent "
"dependencies. The ``NEW`` behavior for this policy is to report an error "
"if non-existent dependencies are listed in the :command:`add_dependencies`"
" command."
msgstr ""
"此策略的“旧”行为是默默地忽略不存在的依赖项。如果在 :command:`add_dependencies` "
"命令中列出了不存在的依赖项，此策略的“新”行为是报告错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0046.rst:14
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0048.rst:19
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0049.rst:20
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0050.rst:15
msgid ""
"This policy was introduced in CMake version 3.0. CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 3.0 版中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0047.rst:2
msgid "CMP0047"
msgstr "CMP0047"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0047.rst:4
msgid "Use ``QCC`` compiler id for the qcc drivers on QNX."
msgstr "为 QNX 上的 qcc 驱动程序使用 ``QCC`` 编译器 ID。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0047.rst:6
msgid ""
"CMake 3.0 and above recognize that the QNX qcc compiler driver is "
"different from the GNU compiler. CMake now prefers to present this to "
"projects by setting the :variable:`CMAKE_<LANG>_COMPILER_ID` variable to "
"``QCC`` instead of ``GNU``.  However, existing projects may assume the "
"compiler id for QNX qcc is just ``GNU`` as it was in CMake versions prior "
"to 3.0. Therefore this policy determines for QNX qcc which compiler id to "
"report in the :variable:`CMAKE_<LANG>_COMPILER_ID` variable after language"
" ``<LANG>`` is enabled by the :command:`project` or "
":command:`enable_language` command.  The policy must be set prior to the "
"invocation of either command."
msgstr ""
"CMake 3.0 及以上版本识别 QNX qcc 编译器驱动程序与 GNU 编译器不同。 CMake 现在更喜欢通过将 "
":variable:`CMAKE_<LANG>_COMPILER_ID` 变量设置为 ``QCC`` 而不是 ``GNU`` "
"来将其呈现给项目。然而，现有项目可能假设 QNX qcc 的编译器 ID 只是“GNU”，因为它在 3.0 之前的 CMake "
"版本中。因此，此策略为 QNX qcc 确定在 :command:`project` 或 :command:`enable_language "
"启用语言 ``<LANG>`` 后，在 :variable:`CMAKE_<LANG>_COMPILER_ID` 变量中报告哪个编译器 ID "
"`命令。该策略必须在调用任一命令之前设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0047.rst:18
msgid ""
"The ``OLD`` behavior for this policy is to use the ``GNU`` compiler id for"
" the qcc and QCC compiler drivers. The ``NEW`` behavior for this policy is"
" to use the ``QCC`` compiler id for those drivers."
msgstr ""
"此策略的“旧”行为是对 qcc 和 QCC 编译器驱动程序使用“GNU”编译器 ID。此策略的“新”行为是为这些驱动程序使用“QCC”编译器 ID。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0047.rst:22
msgid ""
"This policy was introduced in CMake version 3.0.  Use the "
":command:`cmake_policy` command to set this policy to ``OLD`` or ``NEW`` "
"explicitly.  Unlike most policies, CMake version |release| does *not* warn"
" by default when this policy is not set and simply uses ``OLD`` behavior. "
"See documentation of the :variable:`CMAKE_POLICY_WARNING_CMP0047 "
"<CMAKE_POLICY_WARNING_CMP<NNNN>>` variable to control the warning."
msgstr ""
"此策略是在 CMake 3.0 版中引入的。使用 :command:`cmake_policy` 命令将此策略显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0047 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0048.rst:2
msgid "CMP0048"
msgstr "CMP0048"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0048.rst:4
msgid "The :command:`project` command manages ``VERSION`` variables."
msgstr ":command:`project` 命令管理 ``VERSION`` 变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0048.rst:6
msgid ""
"CMake version 3.0 introduced the ``VERSION`` option of the "
":command:`project` command to specify a project version as well as the "
"name.  In order to keep :variable:`PROJECT_VERSION` and related variables "
"consistent with variable :variable:`PROJECT_NAME` it is necessary to set "
"the ``VERSION`` variables to the empty string when no ``VERSION`` is given"
" to :command:`project`. However, this can change behavior for existing "
"projects that set ``VERSION`` variables themselves since "
":command:`project` may now clear them. This policy controls the behavior "
"for compatibility with such projects."
msgstr ""
"CMake 3.0 版引入了 :command:`project` 命令的 ``VERSION`` 选项来指定项目版本和名称。为了保持 "
":variable:`PROJECT_VERSION` 和相关变量与变量 :variable:`PROJECT_NAME` 一致，当没有 "
"``VERSION`` 给 :command 时，有必要将 ``VERSION`` "
"变量设置为空字符串：`项目`。但是，这可能会改变现有项目的行为，这些项目本身设置了 ``VERSION`` 变量，因为 "
":command:`project` 现在可以清除它们。此策略控制与此类项目兼容的行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0048.rst:15
msgid ""
"The ``OLD`` behavior for this policy is to leave ``VERSION`` variables "
"untouched. The ``NEW`` behavior for this policy is to set ``VERSION`` as "
"documented by the :command:`project` command."
msgstr "此策略的“旧”行为是保持“VERSION”变量不变。此策略的“新”行为是设置“版本”，如 :command:“项目”命令所记录。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0049.rst:2
msgid "CMP0049"
msgstr "CMP0049"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0049.rst:4
msgid "Do not expand variables in target source entries."
msgstr "不要扩展目标源条目中的变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0049.rst:6
msgid ""
"CMake 2.8.12 and lower performed an extra layer of variable expansion when"
" evaluating source file names::"
msgstr "CMake 2.8.12 及更低版本在评估源文件名时执行额外的变量扩展层 ::"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0049.rst:14
msgid "This was undocumented behavior."
msgstr "这是无证行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0049.rst:16
msgid ""
"The ``OLD`` behavior for this policy is to expand such variables when "
"processing the target sources.  The ``NEW`` behavior for this policy is to"
" issue an error if such variables need to be expanded."
msgstr "此策略的“旧”行为是在处理目标源时扩展此类变量。此策略的“新”行为是在需要扩展此类变量时发出错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0050.rst:2
msgid "CMP0050"
msgstr "CMP0050"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0050.rst:4
msgid "Disallow add_custom_command SOURCE signatures."
msgstr "禁止 add_custom_command SOURCE 签名。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0050.rst:6
msgid ""
"CMake 2.8.12 and lower allowed a signature for "
":command:`add_custom_command` which specified an input to a command.  This"
" was undocumented behavior. Modern use of CMake associates custom commands"
" with their output, rather than their input."
msgstr ""
"CMake 2.8.12 及更低版本允许 :command:`add_custom_command` 的签名指定命令的输入。这是无证行为。 "
"CMake 的现代使用将自定义命令与其输出相关联，而不是与它们的输入相关联。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0050.rst:11
msgid ""
"The ``OLD`` behavior for this policy is to allow the use of "
":command:`add_custom_command` SOURCE signatures.  The ``NEW`` behavior for"
" this policy is to issue an error if such a signature is used."
msgstr ""
"此策略的“旧”行为是允许使用 :command:`add_custom_command` SOURCE "
"签名。如果使用这样的签名，此策略的“新”行为是发出错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0051.rst:2
msgid "CMP0051"
msgstr "CMP0051"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0051.rst:6
msgid "List :genex:`TARGET_OBJECTS` in SOURCES target property."
msgstr "在 SOURCES 目标属性中列出 :genex:`TARGET_OBJECTS`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0051.rst:8
msgid ""
"CMake 3.0 and lower did not include the ``TARGET_OBJECTS`` "
":manual:`generator expression <cmake-generator-expressions(7)>` when "
"returning the :prop_tgt:`SOURCES` target property."
msgstr ""
"CMake 3.0 及更低版本在返回 :prop_tgt:`SOURCES` 目标属性时不包含 ``TARGET_OBJECTS`` "
":manual:`generator expression <cmake-generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0051.rst:12
msgid ""
"Configure-time CMake code is not able to handle generator expressions.  If"
" using the :prop_tgt:`SOURCES` target property at configure time, it may "
"be necessary to first remove generator expressions using the "
":command:`string(GENEX_STRIP)` command.  Generate-time CMake code such as "
":command:`file(GENERATE)` can handle the content without stripping."
msgstr ""
"配置时 CMake 代码无法处理生成器表达式。如果在配置时使用 :prop_tgt:`SOURCES` 目标属性，可能需要先使用 "
":command:`string(GENEX_STRIP)` 命令删除生成器表达式。生成时的 CMake 代码，如 "
":command:`file(GENERATE)` 可以处理内容而无需剥离。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0051.rst:18
msgid ""
"The ``OLD`` behavior for this policy is to omit ``TARGET_OBJECTS`` "
"expressions from the :prop_tgt:`SOURCES` target property.  The ``NEW`` "
"behavior for this policy is to include ``TARGET_OBJECTS`` expressions in "
"the output."
msgstr ""
"此策略的“旧”行为是从 :prop_tgt:`SOURCES` 目标属性中省略 ``TARGET_OBJECTS`` "
"表达式。此策略的“新”行为是在输出中包含“TARGET_OBJECTS”表达式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0051.rst:23
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0052.rst:24
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:47
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:49
msgid ""
"This policy was introduced in CMake version 3.1. CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.1 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0052.rst:2
msgid "CMP0052"
msgstr "CMP0052"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0052.rst:6
msgid ""
"Reject source and build dirs in installed "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES`."
msgstr "在已安装的 :prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` 中拒绝源和构建目录。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0052.rst:9
msgid ""
"CMake 3.0 and lower allowed subdirectories of the source directory or "
"build directory to be in the :prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` of "
"installed and exported targets, if the directory was also a subdirectory "
"of the installation prefix.  This makes the installation depend on the "
"existence of the source dir or binary dir, and the installation will be "
"broken if either are removed after installation."
msgstr ""
"CMake 3.0 及更低版本允许源目录或构建目录的子目录位于安装和导出目标的 INTERFACE_INCLUDE_DIRECTORIES "
"中，前提是该目录也是安装前缀的子目录。这使得安装依赖于源目录或二进制目录的存在，如果在安装后删除其中一个，安装将被破坏。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0052.rst:16
msgid ""
"See :ref:`Include Directories and Usage Requirements` for more on "
"specifying include directories for targets."
msgstr "有关为目标指定包含目录的更多信息，请参阅:ref:`包含目录和使用要求`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0052.rst:19
msgid ""
"The ``OLD`` behavior for this policy is to export the content of the "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` with the source or binary "
"directory.  The ``NEW`` behavior for this policy is to issue an error if "
"such a directory is used."
msgstr ""
"此策略的“旧”行为是使用源目录或二进制目录导出 :prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` "
"的内容。如果使用这样的目录，此策略的“新”行为是发出错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:2
msgid "CMP0053"
msgstr "CMP0053"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:6
msgid "Simplify variable reference and escape sequence evaluation."
msgstr "简化变量引用和转义序列评估。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:8
msgid ""
"CMake 3.1 introduced a much faster implementation of evaluation of the "
":ref:`Variable References` and :ref:`Escape Sequences` documented in the "
":manual:`cmake-language(7)` manual.  While the behavior is identical to "
"the legacy implementation in most cases, some corner cases were cleaned up"
" to simplify the behavior.  Specifically:"
msgstr ""
"CMake 3.1 引入了一个更快的评估 :ref:`Variable References` 和 :ref:`Escape Sequences` "
"的实现，记录在 :manual:`cmake-language(7)` "
"手册中。虽然在大多数情况下行为与遗留实现相同，但清理了一些极端情况以简化行为。具体来说："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:14
msgid ""
"Expansion of ``@VAR@`` reference syntax defined by the "
":command:`configure_file` and :command:`string(CONFIGURE)` commands is no "
"longer performed in other contexts."
msgstr ""
"由 :command:`configure_file` 和 :command:`string(CONFIGURE)` 命令定义的``@VAR@`` "
"引用语法的扩展不再在其他上下文中执行。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:18
msgid ""
"Literal ``${VAR}`` reference syntax may contain only alphanumeric "
"characters (``A-Z``, ``a-z``, ``0-9``) and the characters ``_``, ``.``, "
"``/``, ``-``, and ``+``. Note that ``$`` is technically allowed in the "
"``NEW`` behavior, but is invalid for ``OLD`` behavior.  This is due to an "
"oversight during the implementation of ``CMP0053`` and its use as a "
"literal variable reference is discouraged for this reason. Variables with "
"other characters in their name may still be referenced indirectly, e.g."
msgstr ""
"文字“${VAR}”参考语法只能包含字母数字字符（“A-Z”、“a-z”、“0-9”）和字符“_”、“.” `、``/``、``-`` "
"和``+``。请注意，``$`` 在``NEW`` 行为中在技术上是允许的，但对于``OLD`` "
"行为是无效的。这是由于在实施“CMP0053”期间的疏忽，因此不鼓励将其用作文字变量引用。名称中带有其他字符的变量仍可能被间接引用，例如"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:33
msgid ""
"The setting of policy :policy:`CMP0010` is not considered, so improper "
"variable reference syntax is always an error."
msgstr "不考虑策略 :policy:`CMP0010` 的设置，所以不正确的变量引用语法总是错误的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:36
msgid ""
"More characters are allowed to be escaped in variable names. Previously, "
"only ``()#\" \\@^`` were valid characters to escape. Now any non-"
"alphanumeric, non-semicolon, non-NUL character may be escaped following "
"the ``escape_identity`` production in the :ref:`Escape Sequences` section "
"of the :manual:`cmake-language(7)` manual."
msgstr ""
"允许在变量名中转义更多字符。以前，只有 ``()#\" \\@^`` 是要转义的有效字符。现在任何非字母数字、非分号、非 NUL 字符都可以在 "
":ref 中的 ``escape_identity`` 生成之后转义： :manual:`cmake-language(7)` 手册的`Escape"
" Sequences` 部分。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0053.rst:43
msgid ""
"The ``OLD`` behavior for this policy is to honor the legacy behavior for "
"variable references and escape sequences.  The ``NEW`` behavior is to use "
"the simpler variable expansion and escape sequence evaluation rules."
msgstr "此政策的“旧”行为是为了尊重变量引用和转义序列的旧行为。 ``NEW`` 行为是使用更简单的变量扩展和转义序列评估规则。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:2
msgid "CMP0054"
msgstr "CMP0054"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:6
msgid ""
"Only interpret :command:`if` arguments as variables or keywords when "
"unquoted."
msgstr "仅在未加引号时将 :command:`if` 参数解释为变量或关键字。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:8
msgid ""
"CMake 3.1 and above no longer implicitly dereference variables or "
"interpret keywords in an :command:`if` command argument when it is a "
":ref:`Quoted Argument` or a :ref:`Bracket Argument`."
msgstr ""
"CMake 3.1 及更高版本不再隐式取消引用变量或解释 :command:`if` 命令参数中的关键字，当它是 :ref:`Quoted "
"Argument` 或 :ref:`Bracket Argument` 时。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:12
msgid ""
"The ``OLD`` behavior for this policy is to dereference variables and "
"interpret keywords even if they are quoted or bracketed. The ``NEW`` "
"behavior is to not dereference variables or interpret keywords that have "
"been quoted or bracketed."
msgstr ""
"此策略的“旧”行为是取消引用变量并解释关键字，即使它们被引号或括号括起来。 ``NEW`` 行为是不取消引用变量或解释已被引用或括起来的关键字。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:17
msgid "Given the following partial example:"
msgstr "给定以下部分示例："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:30
msgid "After explicit expansion of variables this gives:"
msgstr "在显式扩展变量后，这给出："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:36
msgid ""
"With the policy set to ``OLD`` implicit expansion reduces this "
"semantically to:"
msgstr "将策略设置为“OLD”后，隐式扩展在语义上将其减少为："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0054.rst:42
msgid ""
"With the policy set to ``NEW`` the quoted arguments will not be further "
"dereferenced:"
msgstr "将策略设置为“NEW”后，引用的参数将不会被进一步取消引用："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0055.rst:2
msgid "CMP0055"
msgstr "CMP0055"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0055.rst:6
msgid "Strict checking for the :command:`break` command."
msgstr "严格检查 :command:`break` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0055.rst:8
msgid ""
"CMake 3.1 and lower allowed calls to the :command:`break` command outside "
"of a loop context and also ignored any given arguments. This was undefined"
" behavior."
msgstr "CMake 3.1 及更低版本允许在循环上下文之外调用 :command:`break` 命令并忽略任何给定的参数。这是未定义的行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0055.rst:12
msgid ""
"The ``OLD`` behavior for this policy is to allow :command:`break` to be "
"placed outside of loop contexts and ignores any arguments.  The ``NEW`` "
"behavior for this policy is to issue an error if a misplaced break or any "
"arguments are found."
msgstr ""
"此策略的“旧”行为是允许将 :command:`break` "
"置于循环上下文之外并忽略任何参数。此策略的“新”行为是在发现放错位置的中断或任何参数时发出错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0055.rst:16
msgid ""
"This policy was introduced in CMake version 3.2. CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.2 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0056.rst:2
msgid "CMP0056"
msgstr "CMP0056"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0056.rst:6
msgid "Honor link flags in :command:`try_compile` source-file signature."
msgstr "尊重 :command:`try_compile` 源文件签名中的链接标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0056.rst:8
msgid ""
"The :command:`try_compile` command source-file signature generates a "
"``CMakeLists.txt`` file to build the source file into an executable. In "
"order to compile the source the same way as it might be compiled by the "
"calling project, the generated project sets the value of the "
":variable:`CMAKE_<LANG>_FLAGS` variable to that in the calling project. "
"The value of the :variable:`CMAKE_EXE_LINKER_FLAGS` variable may be needed"
" in some cases too, but CMake 3.1 and lower did not set it in the "
"generated project.  CMake 3.2 and above prefer to set it so that linker "
"flags are honored as well as compiler flags.  This policy provides "
"compatibility with the pre-3.2 behavior."
msgstr ""
":command:`try_compile` 命令源文件签名生成一个 ``CMakeLists.txt`` "
"文件以将源文件构建为可执行文件。为了以与调用项目可能编译的方式相同的方式编译源代码，生成的项目将 "
":variable:`CMAKE_<LANG>_FLAGS` 变量的值设置为调用项目中的值。 "
":variable:`CMAKE_EXE_LINKER_FLAGS` 变量的值在某些情况下可能也需要，但 CMake 3.1 "
"及更低版本未在生成的项目中设置它。 CMake 3.2 及更高版本更喜欢设置它，以便链接器标志和编译器标志都得到尊重。此策略提供与 3.2 "
"之前的行为的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0056.rst:19
msgid ""
"The ``OLD`` behavior for this policy is to not set the value of the "
":variable:`CMAKE_EXE_LINKER_FLAGS` variable in the generated test project."
"  The ``NEW`` behavior for this policy is to set the value of the "
":variable:`CMAKE_EXE_LINKER_FLAGS` variable in the test project to the "
"same as it is in the calling project."
msgstr ""
"此策略的“旧”行为是不在生成的测试项目中设置 CMAKE_EXE_LINKER_FLAGS 变量的值。此策略的“新”行为是将测试项目中的 "
"CMAKE_EXE_LINKER_FLAGS 变量的值设置为与调用项目中的值相同。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0056.rst:25
msgid ""
"If the project code does not set the policy explicitly, users may set it "
"on the command line by defining the "
":variable:`CMAKE_POLICY_DEFAULT_CMP0056 <CMAKE_POLICY_DEFAULT_CMP<NNNN>>` "
"variable in the cache."
msgstr ""
"如果项目代码没有明确设置策略，用户可以通过在缓存中定义 :variable:`CMAKE_POLICY_DEFAULT_CMP0056 "
"<CMAKE_POLICY_DEFAULT_CMP<NNNN>>` 变量在命令行上进行设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0056.rst:30
msgid ""
"This policy was introduced in CMake version 3.2.  Unlike most policies, "
"CMake version |release| does *not* warn by default when this policy is not"
" set and simply uses ``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0056 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.2 中引入的。与大多数政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0056 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0057.rst:2
msgid "CMP0057"
msgstr "CMP0057"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0057.rst:6
msgid "Support new :command:`if` IN_LIST operator."
msgstr "支持新的 :command:`if` IN_LIST 运算符。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0057.rst:8
msgid "CMake 3.3 adds support for the new IN_LIST operator."
msgstr "CMake 3.3 添加了对新 IN_LIST 运算符的支持。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0057.rst:10
msgid ""
"The ``OLD`` behavior for this policy is to ignore the IN_LIST operator. "
"The ``NEW`` behavior is to interpret the IN_LIST operator."
msgstr "此策略的“旧”行为是忽略 IN_LIST 运算符。 ``NEW`` 行为是解释 IN_LIST 运算符。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0057.rst:13
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0059.rst:16
msgid ""
"This policy was introduced in CMake version 3.3. CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.3 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:2
msgid "CMP0058"
msgstr "CMP0058"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:6
msgid "Ninja requires custom command byproducts to be explicit."
msgstr "Ninja 需要明确的自定义命令副产品。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:8
msgid ""
"When an intermediate file generated during the build is consumed by an "
"expensive operation or a large tree of dependents, one may reduce the work"
" needed for an incremental rebuild by updating the file timestamp only "
"when its content changes.  With this approach the generation rule must "
"have a separate output file that is always updated with a new timestamp "
"that is newer than any dependencies of the rule so that the build tool re-"
"runs the rule only when the input changes.  We refer to the separate "
"output file as a rule's *witness* and the generated file as a rule's "
"*byproduct*."
msgstr ""
"当构建期间生成的中间文件被昂贵的操作或大型依赖树消耗时，可以通过仅在其内容更改时更新文件时间戳来减少增量重建所需的工作。使用这种方法，生成规则必须有一个单独的输出文件，该文件始终使用比规则的任何依赖项更新的新时间戳进行更新，以便构建工具仅在输入更改时重新运行规则。我们将单独的输出文件称为规则的*见证*，将生成的文件称为规则的*副产品*。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:18
msgid ""
"Byproducts may not be listed as outputs because their timestamps are "
"allowed to be older than the inputs.  No build tools (like ``make``) that "
"existed when CMake was designed have a way to express byproducts. "
"Therefore CMake versions prior to 3.2 had no way to specify them. Projects"
" typically left byproducts undeclared in the rules that generate them.  "
"For example:"
msgstr ""
"副产品可能不会列为输出，因为允许它们的时间戳早于输入。在设计 CMake 时存在的构建工具（如“make”）没有一种方法可以表达副产品。因此 3.2"
" 之前的 CMake 版本无法指定它们。项目通常会在生成它们的规则中留下未声明的副产品。例如："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:44
msgid ""
"This works well for all generators except :generator:`Ninja`. The Ninja "
"build tool sees a rule listing ``byproduct.txt`` as a dependency and no "
"rule listing it as an output.  Ninja then complains that there is no way "
"to satisfy the dependency and stops building even though there are order-"
"only dependencies that ensure ``byproduct.txt`` will exist before its "
"consumers need it.  See discussion of this problem in `Ninja Issue 760`_ "
"for further details on why Ninja works this way."
msgstr ""
"这适用于除 Ninja 之外的所有生成器。 Ninja 构建工具看到将“byproduct.txt”列为依赖项的规则，但没有将其列为输出的规则。 "
"Ninja 然后抱怨没有办法满足依赖关系并停止构建，即使存在确保 ``byproduct.txt`` 在其消费者需要它之前存在的仅顺序依赖关系。有关"
" Ninja 为何以这种方式工作的更多详细信息，请参阅“Ninja Issue 760”中对此问题的讨论。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:55
msgid ""
"Instead of leaving byproducts undeclared in the rules that generate them, "
"Ninja expects byproducts to be listed along with other outputs. Such rules"
" may be marked with a ``restat`` option that tells Ninja to check the "
"timestamps of outputs after the rules run.  This prevents byproducts whose"
" timestamps do not change from causing their dependents to re-build "
"unnecessarily."
msgstr ""
"Ninja 希望副产品与其他输出一起列出，而不是在生成它们的规则中未声明副产品。此类规则可能会标有“restat”选项，告诉 Ninja "
"在规则运行后检查输出的时间戳。这可以防止时间戳未更改的副产品导致其依赖项不必要地重新构建。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:62
msgid ""
"Since the above approach does not tell CMake what custom command generates"
" ``byproduct.txt``, the Ninja generator does not have enough information "
"to add the byproduct as an output of any rule. CMake 2.8.12 and above work"
" around this problem and allow projects using the above approach to build "
"by generating ``phony`` build rules to tell Ninja to tolerate such missing"
" files.  However, this workaround prevents Ninja from diagnosing a "
"dependency that is really missing.  It also works poorly in in-source "
"builds where every custom command dependency, even on source files, needs "
"to be treated this way because CMake does not have enough information to "
"know which files are generated as byproducts of custom commands."
msgstr ""
"由于上述方法没有告诉 CMake 什么自定义命令生成“byproduct.txt”，因此 Ninja "
"生成器没有足够的信息将副产品添加为任何规则的输出。 CMake 2.8.12 "
"及更高版本解决了这个问题，并允许使用上述方法的项目通过生成“虚假”构建规则来告诉 Ninja 容忍此类丢失的文件。但是，此解决方法会阻止 Ninja"
" 诊断真正缺失的依赖项。它在源代码构建中也表现不佳，其中每个自定义命令依赖项，甚至是源文件，都需要以这种方式处理，因为 CMake "
"没有足够的信息来知道哪些文件是自定义命令的副产品。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:75
msgid "Introducing Byproducts"
msgstr "介绍副产品"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:77
msgid ""
"CMake 3.2 introduced the ``BYPRODUCTS`` option to the "
":command:`add_custom_command` and :command:`add_custom_target` commands.  "
"This option allows byproducts to be specified explicitly:"
msgstr ""
"CMake 3.2 为 add_custom_command 和 add_custom_target 命令引入了 ``BYPRODUCTS`` "
"选项。此选项允许明确指定副产品："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:91
msgid ""
"The ``BYPRODUCTS`` option is used by the :generator:`Ninja` generator to "
"list byproducts among the outputs of the custom commands that generate "
"them, and is ignored by other generators."
msgstr "Ninja 生成器使用 ``BYPRODUCTS`` 选项在生成它们的自定义命令的输出中列出副产品，并被其他生成器忽略。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:95
msgid ""
"CMake 3.3 and above prefer to require projects to specify custom command "
"byproducts explicitly so that it can avoid using the ``phony`` rule "
"workaround altogether.  Policy ``CMP0058`` was introduced to provide "
"compatibility with existing projects that still need the workaround."
msgstr ""
"CMake 3.3 "
"及更高版本更倾向于要求项目明确指定自定义命令副产品，以便它可以避免完全使用“虚假”规则解决方法。引入了策略“CMP0058”以提供与仍然需要解决方法的现有项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:101
msgid ""
"This policy has no effect on generators other than :generator:`Ninja`. The"
" ``OLD`` behavior for this policy is to generate Ninja ``phony`` rules for"
" unknown dependencies in the build tree.  The ``NEW`` behavior for this "
"policy is to not generate these and instead require projects to specify "
"custom command ``BYPRODUCTS`` explicitly."
msgstr ""
"此策略对 :generator:`Ninja` "
"以外的生成器没有影响。此策略的“旧”行为是为构建树中的未知依赖项生成忍者“虚假”规则。此策略的“新”行为是不生成这些，而是​​要求项目明确指定自定义命令“BYPRODUCTS”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0058.rst:107
msgid ""
"This policy was introduced in CMake version 3.3. CMake version |release| "
"warns when it sees unknown dependencies in out-of-source build trees if "
"the policy is not set and then uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set the policy to ``OLD`` or ``NEW`` "
"explicitly.  The policy setting must be in scope at the end of the top-"
"level ``CMakeLists.txt`` file of the project and has global effect."
msgstr ""
"此策略是在 CMake 版本 3.3 中引入的。 CMake 版本 "
"|发布|如果未设置策略然后使用“旧”行为，当它在源外构建树中看到未知依赖项时发出警告。使用 :command:`cmake_policy` "
"命令将策略显式设置为 ``OLD`` 或 "
"``NEW``。策略设置必须在项目的顶级“CMakeLists.txt”文件末尾的范围内，并且具有全局效果。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0059.rst:2
msgid "CMP0059"
msgstr "CMP0059"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0059.rst:6
msgid "Do not treat ``DEFINITIONS`` as a built-in directory property."
msgstr "不要将 ``DEFINITIONS`` 视为内置目录属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0059.rst:8
msgid ""
"CMake 3.3 and above no longer make a list of definitions available through"
" the :prop_dir:`DEFINITIONS` directory property.  The "
":prop_dir:`COMPILE_DEFINITIONS` directory property may be used instead."
msgstr ""
"CMake 3.3 及更高版本不再通过 :prop_dir:`DEFINITIONS` 目录属性提供定义列表。可以改用 "
":prop_dir:`COMPILE_DEFINITIONS` 目录属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0059.rst:12
msgid ""
"The ``OLD`` behavior for this policy is to provide the list of flags given"
" so far to the :command:`add_definitions` command.  The ``NEW`` behavior "
"is to behave as a normal user-defined directory property."
msgstr ""
"此策略的“旧”行为是提供到目前为止给 :command:`add_definitions` 命令的标志列表。 ``NEW`` "
"行为是作为一个普通的用户定义的目录属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:2
msgid "CMP0060"
msgstr "CMP0060"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:6
msgid "Link libraries by full path even in implicit directories."
msgstr "即使在隐式目录中，也可以通过完整路径链接库。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:8
msgid ""
"Policy :policy:`CMP0003` was introduced with the intention of always "
"linking library files by full path when a full path is given to the "
":command:`target_link_libraries` command.  However, on some platforms "
"(e.g. HP-UX) the compiler front-end adds alternative library search paths "
"for the current architecture (e.g. ``/usr/lib/<arch>`` has alternatives to"
" libraries in ``/usr/lib`` for the current architecture). On such "
"platforms the :command:`find_library` may find a library such as "
"``/usr/lib/libfoo.so`` that does not belong to the current architecture."
msgstr ""
"引入策略:policy:`CMP0003` 的目的是在为 :command:`target_link_libraries` "
"命令提供完整路径时始终通过完整路径链接库文件。但是，在某些平台（例如 HP-"
"UX）上，编译器前端为当前架构添加了替代库搜索路径（例如，``/usr/lib/<arch>`` 有替代库的``/usr/lib `` "
"对于当前架构）。在这样的平台上， :command:`find_library` 可能会找到不属于当前架构的库，例如 "
"``/usr/lib/libfoo.so``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:17
msgid ""
"Prior to policy :policy:`CMP0003` projects would still build in such cases"
" because the incorrect library path would be converted to ``-lfoo`` on the"
" link line and the linker would find the proper library in the arch-"
"specific search path provided by the compiler front-end implicitly. At the"
" time we chose to remain compatible with such projects by always "
"converting library files found in implicit link directories to ``-lfoo`` "
"flags to ask the linker to search for them.  This approach allowed "
"existing projects to continue to build while still linking to libraries "
"outside implicit link directories via full path (such as those in the "
"build tree)."
msgstr ""
"在 policy:policy:`CMP0003` 之前，项目仍然会在这种情况下构建，因为不正确的库路径将在链接行上转换为 "
"``-lfoo``，并且链接器会在特定于 arch "
"的搜索路径中找到正确的库由编译器前端隐式提供。当时我们选择通过始终将隐式链接目录中找到的库文件转换为“-lfoo”标志以要求链接器搜索它们来保持与此类项目的兼容性。这种方法允许现有项目继续构建，同时仍然通过完整路径（例如构建树中的那些）链接到隐式链接目录之外的库。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:27
msgid ""
"CMake does allow projects to override this behavior by using an "
":ref:`IMPORTED library target <Imported Targets>` with its "
":prop_tgt:`IMPORTED_LOCATION` property set to the desired full path to a "
"library file.  In fact, many :ref:`Find Modules` are learning to provide "
":ref:`Imported Targets` instead of just the traditional ``Foo_LIBRARIES`` "
"variable listing library files.  However, this makes the link line "
"generated for a library found by a Find Module depend on whether it is "
"linked through an imported target or not, which is inconsistent. "
"Furthermore, this behavior has been a source of confusion because the "
"generated link line for a library file depends on its location.  It is "
"also problematic for projects trying to link statically because flags like"
" ``-Wl,-Bstatic -lfoo -Wl,-Bdynamic`` may be used to help the linker "
"select ``libfoo.a`` instead of ``libfoo.so`` but then leak dynamic linking"
" to following libraries.  (See the :prop_tgt:`LINK_SEARCH_END_STATIC` "
"target property for a solution typically used for that problem.)"
msgstr ""
"CMake 确实允许项目通过使用 :ref:`IMPORTED 库目标 <Imported Targets>` 并将其 "
":prop_tgt:`IMPORTED_LOCATION` 属性设置为库文件的所需完整路径来覆盖此行为。事实上，许多 :ref:`Find "
"Modules` 正在学习提供 :ref:`Imported Targets` 而不仅仅是传统的 ``Foo_LIBRARIES`` "
"变量列表库文件。但是，这使得为查找模块找到的库生成的链接行取决于它是否通过导入的目标链接，这是不一致的。此外，这种行为一直是混淆的根源，因为为库文件生成的链接行取决于它的位置。对于试图静态链接的项目来说，这也是有问题的，因为像“-Wl,-Bstatic"
" -lfoo "
"-Wl,-Bdynamic”这样的标志可能被用来帮助链接器选择“libfoo.a”而不是“libfoo.a”。所以``但随后会泄漏到以下库的动态链接。"
" （有关通常用于该问题的解决方案，请参阅 :prop_tgt:`LINK_SEARCH_END_STATIC` 目标属性。）"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:43
msgid ""
"When the special case for libraries in implicit link directories was first"
" introduced the list of implicit link directories was simply hard-coded "
"(e.g. ``/lib``, ``/usr/lib``, and a few others).  Since that time, CMake "
"has learned to detect the implicit link directories used by the compiler "
"front-end.  If necessary, the :command:`find_library` command could be "
"taught to use this information to help find libraries of the proper "
"architecture."
msgstr ""
"当首次引入隐式链接目录中的库的特殊情况时，隐式链接目录列表只是硬编码的（例如 ``/lib``、``/usr/lib`` "
"和其他一些）。从那时起，CMake 学会了检测编译器前端使用的隐式链接目录。如有必要，可以教导 :command:`find_library` "
"命令使用此信息来帮助查找具有适当架构的库。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:51
msgid ""
"For these reasons, CMake 3.3 and above prefer to drop the special case and"
" link libraries by full path even when they are in implicit link "
"directories.  Policy ``CMP0060`` provides compatibility for existing "
"projects."
msgstr ""
"由于这些原因，CMake 3.3 "
"及更高版本更喜欢通过完整路径删除特殊情况和链接库，即使它们位于隐式链接目录中。政策“CMP0060”为现有项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:56
msgid ""
"The ``OLD`` behavior for this policy is to ask the linker to search for "
"libraries whose full paths are known to be in implicit link directories. "
"The ``NEW`` behavior for this policy is to link libraries by full path "
"even if they are in implicit link directories."
msgstr ""
"此策略的“旧”行为是要求链接器搜索其完整路径已知位于隐式链接目录中的库。此策略的“新”行为是通过完整路径链接库，即使它们位于隐式链接目录中。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0060.rst:61
msgid ""
"This policy was introduced in CMake version 3.3.  Unlike most policies, "
"CMake version |release| does *not* warn by default when this policy is not"
" set and simply uses ``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0060 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.3 中引入的。与大多数政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0060 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0061.rst:2
msgid "CMP0061"
msgstr "CMP0061"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0061.rst:6
msgid "CTest does not by default tell ``make`` to ignore errors (``-i``)."
msgstr "默认情况下，CTest 不会告诉“make”忽略错误（“-i”）。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0061.rst:8
msgid ""
"The :command:`ctest_build` and :command:`build_command` commands no longer"
" generate build commands for :ref:`Makefile Generators` with the ``-i`` "
"option.  Previously this was done to help build as much of tested projects"
" as possible.  However, this behavior is not consistent with other "
"generators and also causes the return code of the ``make`` tool to be "
"meaningless."
msgstr ""
":command:`ctest_build` 和 :command:`build_command` 命令不再为带有 ``-i`` 选项的 "
":ref:`Makefile Generators` "
"生成构建命令。以前这样做是为了帮助构建尽可能多的测试项目。但是，此行为与其他生成器不一致，也会导致“make”工具的返回码无意义。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0061.rst:15
msgid ""
"Of course users may still add this option manually by setting "
":variable:`CTEST_BUILD_COMMAND` or the ``MAKECOMMAND`` cache entry. See "
"the :ref:`CTest Build Step` ``MakeCommand`` setting documentation for "
"their effects."
msgstr ""
"当然，用户仍然可以通过设置 CTEST_BUILD_COMMAND 或 MAKECOMMAND 缓存条目来手动添加此选项。请参阅 "
":ref:`CTest Build Step` `MakeCommand`` 设置文档了解它们的效果。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0061.rst:20
msgid ""
"The ``OLD`` behavior for this policy is to add ``-i`` to ``make`` calls in"
" CTest.  The ``NEW`` behavior for this policy is to not add ``-i``."
msgstr "此策略的“旧”行为是将“-i”添加到 CTest 中的“make”调用。此策略的“新”行为是不添加“-i”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0061.rst:24
msgid ""
"This policy was introduced in CMake version 3.3.  Unlike most policies, "
"CMake version |release| does *not* warn when this policy is not set and "
"simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.3 中引入的。与大多数政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0062.rst:2
msgid "CMP0062"
msgstr "CMP0062"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0062.rst:6
msgid "Disallow :command:`install` of :command:`export` result."
msgstr "禁止 :command:`install` 的 :command:`export` 结果。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0062.rst:8
msgid ""
"The :command:`export()` command generates a file containing :ref:`Imported"
" Targets`, which is suitable for use from the build directory.  It is not "
"suitable for installation because it contains absolute paths to "
"buildsystem locations, and is particular to a single build configuration."
msgstr ""
":command:`export()` 命令生成一个包含 :ref:`Imported Targets` "
"的文件，适合从构建目录使用。它不适合安装，因为它包含构建系统位置的绝对路径，并且特定于单个构建配置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0062.rst:14
msgid ""
"The :command:`install(EXPORT)` generates and installs files which contain "
":ref:`Imported Targets`.  These files are generated with relative paths "
"(unless the user specifies absolute paths), and are designed for multi-"
"configuration use.  See :ref:`Creating Packages` for more."
msgstr ""
":command:`install(EXPORT)` 生成并安装包含 :ref:`Imported Targets` "
"的文件。这些文件是使用相对路径生成的（除非用户指定绝对路径），并且专为多配置使用而设计。有关更多信息，请参阅 :ref:`Creating "
"Packages`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0062.rst:19
msgid ""
"CMake 3.3 no longer allows the use of the :command:`install(FILES)` "
"command with the result of the :command:`export()` command."
msgstr ""
"CMake 3.3 不再允许将 :command:`install(FILES)` 命令与 :command:`export()` "
"命令的结果一起使用。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0062.rst:22
msgid ""
"The ``OLD`` behavior for this policy is to allow installing the result of "
"an :command:`export()` command.  The ``NEW`` behavior for this policy is "
"not to allow installing the result of an :command:`export()` command."
msgstr ""
"此策略的“旧”行为是允许安装 :command:`export()` 命令的结果。此策略的“新”行为是不允许安装 "
":command:`export()` 命令的结果。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0062.rst:26
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0063.rst:25
msgid ""
"This policy was introduced in CMake version 3.3.  CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy()` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.3 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy()` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0063.rst:2
msgid "CMP0063"
msgstr "CMP0063"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0063.rst:6
msgid "Honor visibility properties for all target types."
msgstr "尊重所有目标类型的可见性属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0063.rst:8
msgid ""
"The :prop_tgt:`<LANG>_VISIBILITY_PRESET` and "
":prop_tgt:`VISIBILITY_INLINES_HIDDEN` target properties affect visibility "
"of symbols during dynamic linking.  When first introduced these properties"
" affected compilation of sources only in shared libraries, module "
"libraries, and executables with the :prop_tgt:`ENABLE_EXPORTS` property "
"set.  This was sufficient for the basic use cases of shared libraries and "
"executables with plugins.  However, some sources may be compiled as part "
"of static libraries or object libraries and then linked into a shared "
"library later. CMake 3.3 and above prefer to honor these properties for "
"sources compiled in all target types.  This policy preserves compatibility"
" for projects expecting the properties to work only for some target types."
msgstr ""
":prop_tgt:`<LANG>_VISIBILITY_PRESET` 和 "
":prop_tgt:`VISIBILITY_INLINES_HIDDEN` "
"目标属性影响动态链接期间符号的可见性。首次引入时，这些属性仅影响共享库、模块库和具有 :prop_tgt:`ENABLE_EXPORTS` "
"属性集的可执行文件中的源代码编译。这对于带有插件的共享库和可执行文件的基本用例来说已经足够了。但是，某些源代码可能会编译为静态库或对象库的一部分，然后再链接到共享库中。"
" CMake 3.3 及更高版本更愿意为在所有目标类型中编译的源提供这些属性。此策略为期望属性仅适用于某些目标类型的项目保留兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0063.rst:20
msgid ""
"The ``OLD`` behavior for this policy is to ignore the visibility "
"properties for static libraries, object libraries, and executables without"
" exports. The ``NEW`` behavior for this policy is to honor the visibility "
"properties for all target types."
msgstr "此策略的“旧”行为是忽略静态库、对象库和没有导出的可执行文件的可见性属性。此策略的“新”行为是尊重所有目标类型的可见性属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0064.rst:2
msgid "CMP0064"
msgstr "CMP0064"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0064.rst:6
msgid "Recognize ``TEST`` as a operator for the :command:`if` command."
msgstr "将 ``TEST`` 识别为 :command:`if` 命令的运算符。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0064.rst:8
msgid ""
"The ``TEST`` operator was added to the :command:`if` command to determine "
"if a given test name was created by the :command:`add_test` command."
msgstr ""
"``TEST`` 运算符被添加到 :command:`if` 命令以确定给定的测试名称是否由 :command:`add_test` 命令创建。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0064.rst:11
msgid ""
"The ``OLD`` behavior for this policy is to ignore the ``TEST`` operator. "
"The ``NEW`` behavior is to interpret the ``TEST`` operator."
msgstr "此策略的“旧”行为是忽略“测试”运算符。 ``NEW`` 行为是解释 ``TEST`` 运算符。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0064.rst:14
msgid ""
"This policy was introduced in CMake version 3.4.  CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy()` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.4 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy()` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0065.rst:2
msgid "CMP0065"
msgstr "CMP0065"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0065.rst:6
msgid ""
"Do not add flags to export symbols from executables without the "
":prop_tgt:`ENABLE_EXPORTS` target property."
msgstr "不要添加标志以从没有 :prop_tgt:`ENABLE_EXPORTS` 目标属性的可执行文件中导出符号。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0065.rst:9
msgid ""
"CMake 3.3 and below, for historical reasons, always linked executables on "
"some platforms with flags like ``-rdynamic`` to export symbols from the "
"executables for use by any plugins they may load via ``dlopen``. CMake 3.4"
" and above prefer to do this only for executables that are explicitly "
"marked with the :prop_tgt:`ENABLE_EXPORTS` target property."
msgstr ""
"CMake 3.3 "
"及以下版本，出于历史原因，总是在某些平台上使用诸如“-rdynamic”之类的标志链接可执行文件，以从可执行文件中导出符号，以供它们可能通过“dlopen”加载的任何插件使用。"
" CMake 3.4 及更高版本更喜欢仅对明确标记有 :prop_tgt:`ENABLE_EXPORTS` 目标属性的可执行文件执行此操作。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0065.rst:15
msgid ""
"The ``OLD`` behavior of this policy is to always use the additional link "
"flags when linking executables regardless of the value of the "
":prop_tgt:`ENABLE_EXPORTS` target property."
msgstr ""
"此策略的“旧”行为是在链接可执行文件时始终使用附加链接标志，而不管 :prop_tgt:`ENABLE_EXPORTS` 目标属性的值如何。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0065.rst:19
msgid ""
"The ``NEW`` behavior of this policy is to only use the additional link "
"flags when linking executables if the :prop_tgt:`ENABLE_EXPORTS` target "
"property is set to ``True``."
msgstr ""
"如果 :prop_tgt:`ENABLE_EXPORTS` 目标属性设置为 "
"``True``，此策略的“新”行为是仅在链接可执行文件时使用附加链接标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0065.rst:23
msgid ""
"This policy was introduced in CMake version 3.4.  Unlike most policies, "
"CMake version |release| does *not* warn by default when this policy is not"
" set and simply uses ``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0065 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.4 中引入的。与大多数政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0065 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0066.rst:2
msgid "CMP0066"
msgstr "CMP0066"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0066.rst:6
msgid ""
"Honor per-config flags in :command:`try_compile` source-file signature."
msgstr "尊重 :command:`try_compile` 源文件签名中的每个配置标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0066.rst:8
msgid ""
"The source file signature of the :command:`try_compile` command uses the "
"value of the :variable:`CMAKE_<LANG>_FLAGS` variable in the test project "
"so that the test compilation works as it would in the main project.  "
"However, CMake 3.6 and below do not also honor config-specific compiler "
"flags such as those in the :variable:`CMAKE_<LANG>_FLAGS_DEBUG` variable."
"  CMake 3.7 and above prefer to honor config-specific compiler flags too."
"  This policy provides compatibility for projects that do not expect "
"config-specific compiler flags to be used."
msgstr ""
":command:`try_compile` 命令的源文件签名使用测试项目中的 :variable:`CMAKE_<LANG>_FLAGS` "
"变量的值，以便测试编译像在主项目中一样工作。但是，CMake 3.6 及更低版本也不支持特定于配置的编译器标志，例如 "
"CMAKE_<LANG>_FLAGS_DEBUG 变量中的标志。 CMake 3.7 "
"及更高版本也更喜欢使用特定于配置的编译器标志。此策略为不希望使用特定于配置的编译器标志的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0066.rst:16
msgid ""
"The ``OLD`` behavior of this policy is to ignore config-specific flag "
"variables like :variable:`CMAKE_<LANG>_FLAGS_DEBUG` and only use CMake's "
"built-in defaults for the current compiler and platform."
msgstr ""
"此策略的“旧”行为是忽略配置特定的标志变量，如 :variable:`CMAKE_<LANG>_FLAGS_DEBUG`，并且仅使用 CMake "
"的内置默认值用于当前编译器和平台。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0066.rst:20
msgid ""
"The ``NEW`` behavior of this policy is to honor config-specific flag "
"variabldes like :variable:`CMAKE_<LANG>_FLAGS_DEBUG`."
msgstr "此策略的“新”行为是尊重配置特定的标志变量，如 :variable:`CMAKE_<LANG>_FLAGS_DEBUG`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0066.rst:23
msgid ""
"This policy was introduced in CMake version 3.7.  Unlike most policies, "
"CMake version |release| does *not* warn by default when this policy is not"
" set and simply uses ``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0066 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.7 中引入的。与大多数政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0066 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:2
msgid "CMP0067"
msgstr "CMP0067"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:6
msgid ""
"Honor language standard in :command:`try_compile` source-file signature."
msgstr "在 :command:`try_compile` 源文件签名中遵循语言标准。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:8
msgid ""
"The :command:`try_compile` source file signature is intended to allow "
"callers to check whether they will be able to compile a given source file "
"with the current toolchain.  In order to match compiler behavior, any "
"language standard mode should match.  However, CMake 3.7 and below did not"
" do this.  CMake 3.8 and above prefer to honor the language standard "
"settings for ``C``, ``CXX`` (C++), and ``CUDA`` using the values of the "
"variables:"
msgstr ""
":command:`try_compile` "
"源文件签名旨在允许调用者检查他们是否能够使用当前工具链编译给定的源文件。为了匹配编译器行为，任何语言标准模式都应该匹配。但是，CMake 3.7 "
"及以下版本并没有这样做。 CMake 3.8 及更高版本更喜欢使用变量的值来遵循 ``C``、``CXX`` (C++) 和 ``CUDA`` "
"的语言标准设置："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:15
msgid ":variable:`CMAKE_C_STANDARD`"
msgstr ":variable:`CMAKE_C_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:16
msgid ":variable:`CMAKE_C_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_C_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:17
msgid ":variable:`CMAKE_C_EXTENSIONS`"
msgstr ":variable:`CMAKE_C_EXTENSIONS`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:18
msgid ":variable:`CMAKE_CXX_STANDARD`"
msgstr ":variable:`CMAKE_CXX_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:19
msgid ":variable:`CMAKE_CXX_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_CXX_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:20
msgid ":variable:`CMAKE_CXX_EXTENSIONS`"
msgstr ":variable:`CMAKE_CXX_EXTENSIONS`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:21
msgid ":variable:`CMAKE_CUDA_STANDARD`"
msgstr ":variable:`CMAKE_CUDA_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:22
msgid ":variable:`CMAKE_CUDA_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_CUDA_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:23
msgid ":variable:`CMAKE_CUDA_EXTENSIONS`"
msgstr ":variable:`CMAKE_CUDA_EXTENSIONS`"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:25
msgid ""
"This policy provides compatibility for projects that do not expect the "
"language standard settings to be used automatically."
msgstr "此策略为不希望自动使用语言标准设置的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:28
msgid ""
"The ``OLD`` behavior of this policy is to ignore language standard setting"
" variables when generating the ``try_compile`` test project. The ``NEW`` "
"behavior of this policy is to honor language standard setting variables."
msgstr "此策略的“旧”行为是在生成“try_compile”测试项目时忽略语言标准设置变量。此政策的“新”行为是遵守语言标准设置变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0067.rst:33
msgid ""
"This policy was introduced in CMake version 3.8.  Unlike most policies, "
"CMake version |release| does *not* warn by default when this policy is not"
" set and simply uses ``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0067 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.8 中引入的。与大多数政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0067 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:2
msgid "CMP0068"
msgstr "CMP0068"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:6
msgid "``RPATH`` settings on macOS do not affect ``install_name``."
msgstr "macOS 上的``RPATH`` 设置不影响``install_name``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:8
msgid ""
"CMake 3.9 and newer remove any effect the following settings may have on "
"the ``install_name`` of a target on macOS:"
msgstr "CMake 3.9 及更新版本删除了以下设置可能对 macOS 上目标的“install_name”产生的任何影响："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:11
msgid ":prop_tgt:`BUILD_WITH_INSTALL_RPATH` target property"
msgstr ":prop_tgt:`BUILD_WITH_INSTALL_RPATH` 目标属性"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:12
msgid ":prop_tgt:`SKIP_BUILD_RPATH` target property"
msgstr ":prop_tgt:`SKIP_BUILD_RPATH` 目标属性"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:13
msgid ":variable:`CMAKE_SKIP_RPATH` variable"
msgstr ":variable:`CMAKE_SKIP_RPATH` 变量"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:14
msgid ":variable:`CMAKE_SKIP_INSTALL_RPATH` variable"
msgstr ":variable:`CMAKE_SKIP_INSTALL_RPATH` 变量"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:16
msgid ""
"Previously, setting :prop_tgt:`BUILD_WITH_INSTALL_RPATH` had the effect of"
" setting both the ``install_name`` of a target to "
":prop_tgt:`INSTALL_NAME_DIR` and the ``RPATH`` to "
":prop_tgt:`INSTALL_RPATH`.  In CMake 3.9, it only affects setting of "
"``RPATH``.  However, if one wants :prop_tgt:`INSTALL_NAME_DIR` to apply to"
" the target in the build tree, one may set "
":prop_tgt:`BUILD_WITH_INSTALL_NAME_DIR`."
msgstr ""
"以前，设置 :prop_tgt:`BUILD_WITH_INSTALL_RPATH` 的效果是将目标的 ``install_name`` 设置为 "
":prop_tgt:`INSTALL_NAME_DIR` 并将 ``RPATH`` 设置为 :prop_tgt:`INSTALL_RPATH`。在 "
"CMake 3.9 中，它只影响 ``RPATH`` 的设置。但是，如果想要 :prop_tgt:`INSTALL_NAME_DIR` "
"应用于构建树中的目标，可以设置 :prop_tgt:`BUILD_WITH_INSTALL_NAME_DIR`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:23
msgid ""
"If :prop_tgt:`SKIP_BUILD_RPATH`, :variable:`CMAKE_SKIP_RPATH` or "
":variable:`CMAKE_SKIP_INSTALL_RPATH` were used to strip the directory "
"portion of the ``install_name`` of a target, one may set "
"``INSTALL_NAME_DIR=\"\"`` instead."
msgstr ""
"如果 :prop_tgt:`SKIP_BUILD_RPATH`、 :variable:`CMAKE_SKIP_RPATH` 或 "
":variable:`CMAKE_SKIP_INSTALL_RPATH` 用于剥离目标的 ``install_name`` 的目录部分，可以设置 "
"``INSTALL_NAME_DIR=\"\"``反而。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:28
msgid ""
"The ``OLD`` behavior of this policy is to use the ``RPATH`` settings for "
"``install_name`` on macOS.  The ``NEW`` behavior of this policy is to "
"ignore the ``RPATH`` settings for ``install_name`` on macOS."
msgstr ""
"此策略的“旧”行为是在 macOS 上使用“安装名称”的“RPATH”设置。此策略的“新”行为是忽略 macOS "
"上“install_name”的“RPATH”设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0068.rst:32
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:29
msgid ""
"This policy was introduced in CMake version 3.9.  CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.9 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:2
msgid "CMP0069"
msgstr "CMP0069"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:6
msgid ":prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` is enforced when enabled."
msgstr ":prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` 在启用时强制执行。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:8
msgid ""
"CMake 3.9 and newer prefer to add IPO flags whenever the "
":prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` target property is enabled and "
"produce an error if flags are not known to CMake for the current compiler."
" Since a given compiler may not support IPO flags in all environments in "
"which it is used, it is now the project's responsibility to use the "
":module:`CheckIPOSupported` module to check for support before enabling "
"the :prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` target property.  This "
"approach allows a project to conditionally activate IPO when supported.  "
"It also allows an end user to set the "
":variable:`CMAKE_INTERPROCEDURAL_OPTIMIZATION` variable in an environment "
"known to support IPO even if the project does not enable the property."
msgstr ""
"CMake 3.9 和更新版本喜欢在 :prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` 目标属性启用时添加 IPO "
"标志，如果当前编译器的 CMake 不知道标志，则会产生错误。由于给定的编译器可能不会在所有使用它的环境中都支持 IPO "
"标志，因此现在项目有责任在启用 :prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` 目标属性之前使用 "
"CheckIPOsupported 模块检查支持。这种方法允许项目在支持时有条件地激活 IPO。它还允许最终用户在已知支持 IPO 的环境中设置 "
"CMAKE_INTERPROCEDURAL_OPTIMIZATION 变量，即使项目未启用该属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:20
msgid ""
"Since CMake 3.8 and lower only honored "
":prop_tgt:`INTERPROCEDURAL_OPTIMIZATION` for the Intel compiler on Linux, "
"some projects may unconditionally enable the target property.  Policy "
"``CMP0069`` provides compatibility with such projects."
msgstr ""
"由于 CMake 3.8 及更低版本仅支持 Linux 上的 Intel 编译器的 "
":prop_tgt:`INTERPROCEDURAL_OPTIMIZATION`，因此某些项目可能会无条件启用目标属性。政策“CMP0069”提供与此类项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:24
msgid ""
"This policy takes effect whenever the IPO property is enabled.  The "
"``OLD`` behavior for this policy is to add IPO flags only for Intel "
"compiler on Linux. The ``NEW`` behavior for this policy is to add IPO "
"flags for the current compiler or produce an error if CMake does not know "
"the flags."
msgstr ""
"只要启用 IPO 属性，此策略就会生效。此策略的“旧”行为是仅为 Linux 上的英特尔编译器添加 IPO "
"标志。此策略的“新”行为是为当前编译器添加 IPO 标志，或者如果 CMake 不知道这些标志则产生错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:37
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:42
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:40
msgid "Examples"
msgstr "例子"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:39
msgid ""
"Behave like CMake 3.8 and do not apply any IPO flags except for Intel "
"compiler on Linux:"
msgstr "表现得像 CMake 3.8，不应用任何 IPO 标志，Linux 上的 Intel 编译器除外："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:51
msgid ""
"Use the :module:`CheckIPOSupported` module to detect whether IPO is "
"supported by the current compiler, environment, and CMake version. Produce"
" a fatal error if support is not available:"
msgstr ""
"使用 :module:`CheckIPOsupported` 模块检测当前编译器、环境和 CMake 版本是否支持 "
"IPO。如果支持不可用，则产生致命错误："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:67
msgid "Apply IPO flags only if compiler supports it:"
msgstr "仅当编译器支持时应用 IPO 标志："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0069.rst:83
msgid ""
"Apply IPO flags without any checks.  This may lead to build errors if IPO "
"is not supported by the compiler in the current environment.  Produce an "
"error if CMake does not know IPO flags for the current compiler:"
msgstr ""
"在没有任何检查的情况下应用 IPO 标志。如果当前环境中的编译器不支持 IPO，这可能会导致构建错误。如果 CMake 不知道当前编译器的 IPO "
"标志，则会产生错误："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0070.rst:2
msgid "CMP0070"
msgstr "CMP0070"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0070.rst:6
msgid "Define :command:`file(GENERATE)` behavior for relative paths."
msgstr "为相对路径定义 :command:`file(GENERATE)` 行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0070.rst:8
msgid ""
"CMake 3.10 and newer define that relative paths given to ``INPUT`` and "
"``OUTPUT`` arguments of ``file(GENERATE)`` are interpreted relative to the"
" current source and binary directories, respectively.  CMake 3.9 and lower"
" did not define any behavior for relative paths but did not diagnose them "
"either and accidentally treated them relative to the process working "
"directory. Policy ``CMP0070`` provides compatibility with projects that "
"used the old undefined behavior."
msgstr ""
"CMake 3.10 及更新版本定义了赋予 ``file(GENERATE)`` 的 ``INPUT`` 和 ``OUTPUT`` "
"参数的相对路径分别相对于当前源目录和二进制目录进行解释。 CMake 3.9 "
"及更低版本没有为相对路径定义任何行为，但也没有对其进行诊断，并且意外地将它们相对于进程工作目录进行了处理。策略“CMP0070”提供与使用旧的未定义行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0070.rst:16
msgid ""
"This policy affects behavior of relative paths given to "
"``file(GENERATE)``. The ``OLD`` behavior for this policy is to treat the "
"paths relative to the working directory of CMake.  The ``NEW`` behavior "
"for this policy is to interpret relative paths with respect to the current"
" source or binary directory of the caller."
msgstr ""
"此策略会影响给予 ``file(GENERATE)`` 的相对路径的行为。此策略的“旧”行为是处理相对于 CMake "
"工作目录的路径。此策略的“新”行为是解释相对于调用者当前源或二进制目录的相对路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0070.rst:22
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:39
msgid ""
"This policy was introduced in CMake version 3.10.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.10 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:2
msgid "CMP0071"
msgstr "CMP0071"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:6
msgid ""
"Let :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC` process "
":prop_sf:`GENERATED` files."
msgstr ""
"让 :prop_tgt:`AUTOMOC` 和 :prop_tgt:`AUTOUIC` 处理 :prop_sf:`GENERATED` 文件。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:9
msgid ""
"Since version 3.10, CMake processes **regular** and :prop_sf:`GENERATED` "
"source files in :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC`. In earlier "
"CMake versions, only **regular** source files were processed. "
":prop_sf:`GENERATED` source files were ignored silently."
msgstr ""
"从 3.10 版开始，CMake 处理 **regular** 和 :prop_sf:`AUTOMOC` 和 :prop_tgt:`AUTOUIC`"
" 中的 :prop_sf:`GENERATED` 源文件。在早期的 CMake 版本中，仅处理**常规**源文件。 "
":prop_sf:`GENERATED` 源文件被静默忽略。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:14
msgid ""
"This policy affects how source files that are :prop_sf:`GENERATED` get "
"treated in :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC`."
msgstr ""
"此策略影响:prop_sf:`GENERATED` 的源文件在 :prop_tgt:`AUTOMOC` 和 :prop_tgt:`AUTOUIC` "
"中的处理方式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:17
msgid ""
"The ``OLD`` behavior for this policy is to ignore :prop_sf:`GENERATED` "
"source files in :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC`."
msgstr ""
"此策略的“旧”行为是忽略 :prop_sf:`AUTOMOC` 和 :prop_tgt:`AUTOUIC` 中的 :prop_sf:`GENERATED`"
" 源文件。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:20
msgid ""
"The ``NEW`` behavior for this policy is to process :prop_sf:`GENERATED` "
"source files in :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC` just like "
"regular source files."
msgstr ""
"此策略的“新”行为是处理 :prop_sf:`AUTOMOC` 和 :prop_tgt:`AUTOUIC` 中的 "
":prop_sf:`GENERATED` 源文件，就像处理常规源文件一样。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:26
msgid ""
"To silence the ``CMP0071`` warning source files can be excluded from "
":prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC` processing by setting the "
"source file properties :prop_sf:`SKIP_AUTOMOC`, :prop_sf:`SKIP_AUTOUIC` or"
" :prop_sf:`SKIP_AUTOGEN`."
msgstr ""
"要使“CMP0071”警告源文件静音，可以通过设置源文件属性:prop_sf:`SKIP_AUTOMOC`、 :prop_sf:`SKIP_AUTOUIC`"
" 或： prop_sf:`SKIP_AUTOGEN`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0071.rst:31
msgid "Source skip example::"
msgstr "源代码跳过示例 ::"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0072.rst:2
msgid "CMP0072"
msgstr "CMP0072"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0072.rst:6
msgid ":module:`FindOpenGL` prefers GLVND by default when available."
msgstr ":module:`FindOpenGL` 在可用时默认首选 GLVND。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0072.rst:8
msgid ""
"The :module:`FindOpenGL` module provides an ``OpenGL::GL`` target and an "
"``OPENGL_LIBRARIES`` variable for projects to use for legacy GL "
"interfaces. When both a legacy GL library (e.g. ``libGL.so``) and GLVND "
"libraries for OpenGL and GLX (e.g. ``libOpenGL.so`` and ``libGLX.so``) are"
" available, the module must choose between them.  It documents an "
"``OpenGL_GL_PREFERENCE`` variable that can be used to specify an explicit "
"preference.  When no such preference is set, the module must choose a "
"default preference."
msgstr ""
":module:`FindOpenGL` 模块为项目提供一个 ``OpenGL::GL`` 目标和一个 ``OPENGL_LIBRARIES`` "
"变量以用于遗留 GL 接口。当遗留 GL 库（例如 ``libGL.so``）和用于 OpenGL 和 GLX 的 GLVND 库（例如 "
"``libOpenGL.so`` 和 ``libGLX.so``）都可用时，模块必须在它们之间进行选择.它记录了一个 "
"``OpenGL_GL_PREFERENCE`` 变量，可用于指定显式首选项。当没有设置这样的首选项时，模块必须选择一个默认首选项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0072.rst:16
msgid ""
"CMake 3.11 and above prefer to choose GLVND libraries.  This policy "
"provides compatibility with projects that expect the legacy GL library to "
"be used."
msgstr "CMake 3.11 及以上版本优先选择 GLVND 库。此策略提供与期望使用旧版 GL 库的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0072.rst:19
msgid ""
"The ``OLD`` behavior for this policy is to set ``OpenGL_GL_PREFERENCE`` to"
" ``LEGACY``.  The ``NEW`` behavior for this policy is to set "
"``OpenGL_GL_PREFERENCE`` to ``GLVND``."
msgstr ""
"此策略的“旧”行为是将“OpenGL_GL_PREFERENCE”设置为“LEGACY”。此策略的“新”行为是将“OpenGL_GL_PREFERENCE”设置为“GLVND”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0072.rst:23
msgid ""
"This policy was introduced in CMake version 3.11.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.11 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0073.rst:2
msgid "CMP0073"
msgstr "CMP0073"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0073.rst:6
msgid "Do not produce legacy ``_LIB_DEPENDS`` cache entries."
msgstr "不要产生遗留的 ``_LIB_DEPENDS`` 缓存条目。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0073.rst:8
msgid ""
"Ancient CMake versions once used ``<tgt>_LIB_DEPENDS`` cache entries to "
"propagate library link dependencies.  This has long been done by other "
"means, leaving the :command:`export_library_dependencies` command as the "
"only user of these values.  That command has long been disallowed by "
"policy :policy:`CMP0033`, but the ``<tgt>_LIB_DEPENDS`` cache entries were"
" left for compatibility with possible non-standard uses by projects."
msgstr ""
"古代 CMake 版本曾经使用“<tgt>_LIB_DEPENDS”缓存条目来传播库链接依赖项。长期以来，这一直是通过其他方式完成的，将 "
":command:`export_library_dependencies` "
"命令作为这些值的唯一用户。该命令长期以来一直被政策禁止:policy:`CMP0033`，但是``<tgt>_LIB_DEPENDS``缓存条目被保留以与项目可能的非标准使用兼容。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0073.rst:15
msgid ""
"CMake 3.12 and above now prefer to not produce these cache entries at all."
"  This policy provides compatibility with projects that have not been "
"updated to avoid using them."
msgstr "CMake 3.12 及更高版本现在更愿意根本不生成这些缓存条目。此策略提供与尚未更新的项目的兼容性，以避免使用它们。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0073.rst:19
msgid ""
"The ``OLD`` behavior for this policy is to set ``<tgt>_LIB_DEPENDS`` cache"
" entries.  The ``NEW`` behavior for this policy is to not set them."
msgstr "此策略的“旧”行为是设置“<tgt>_LIB_DEPENDS”缓存条目。此策略的“新”行为是不设置它们。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0073.rst:22
msgid ""
"This policy was introduced in CMake version 3.12.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike most policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.12 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0074.rst:2
msgid "CMP0074"
msgstr "CMP0074"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0074.rst:6
msgid ":command:`find_package` uses ``<PackageName>_ROOT`` variables."
msgstr ":command:`find_package` 使用``<PackageName>_ROOT`` 变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0074.rst:8
msgid ""
"In CMake 3.12 and above the :command:`find_package(<PackageName>)` command"
" now searches prefixes specified by the :variable:`<PackageName>_ROOT` "
"CMake variable and the :envvar:`<PackageName>_ROOT` environment variable. "
"Package roots are maintained as a stack so nested calls to all ``find_*`` "
"commands inside find modules and config packages also search the roots as "
"prefixes.  This policy provides compatibility with projects that have not "
"been updated to avoid using ``<PackageName>_ROOT`` variables for other "
"purposes."
msgstr ""
"在 CMake 3.12 及更高版本中， :command:`find_package(<PackageName>)` "
"命令现在搜索由 :variable:`<PackageName>_ROOT` CMake "
"变量和 :envvar:`<PackageName>_ROOT` "
"环境变量指定的前缀。包根以堆栈形式维护，因此对查找模块和配置包中所有“find_*”命令的嵌套调用也将根作为前缀进行搜索。此策略提供与尚未更新的项目的兼容性，以避免将“<PackageName>_ROOT”变量用于其他目的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0074.rst:16
msgid ""
"The ``OLD`` behavior for this policy is to ignore ``<PackageName>_ROOT`` "
"variables.  The ``NEW`` behavior for this policy is to use "
"``<PackageName>_ROOT`` variables."
msgstr ""
"此策略的“旧”行为是忽略“<PackageName>_ROOT”变量。此策略的“新”行为是使用“<PackageName>_ROOT”变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0074.rst:20
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:23
msgid ""
"This policy was introduced in CMake version 3.12.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.12 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:2
msgid "CMP0075"
msgstr "CMP0075"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:6
msgid "Include file check macros honor ``CMAKE_REQUIRED_LIBRARIES``."
msgstr "包含文件检查宏支持 ``CMAKE_REQUIRED_LIBRARIES``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:8
msgid "In CMake 3.12 and above, the"
msgstr "在 CMake 3.12 及更高版本中，"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:10
msgid ""
"``check_include_file`` macro in the :module:`CheckIncludeFile` module, the"
msgstr ":module:`CheckIncludeFile` 模块中的 ``check_include_file`` 宏，"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:11
msgid ""
"``check_include_file_cxx`` macro in the :module:`CheckIncludeFileCXX` "
"module, and the"
msgstr ":module:`CheckIncludeFileCXX` 模块中的``check_include_file_cxx`` 宏，以及"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:13
msgid ""
"``check_include_files`` macro in the :module:`CheckIncludeFiles` module"
msgstr ":module:`CheckIncludeFiles` 模块中的``check_include_files`` 宏"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:15
msgid ""
"now prefer to link the check executable to the libraries listed in the "
"``CMAKE_REQUIRED_LIBRARIES`` variable.  This policy provides compatibility"
" with projects that have not been updated to expect this behavior."
msgstr ""
"现在更喜欢将检查可执行文件链接到“CMAKE_REQUIRED_LIBRARIES”变量中列出的库。此策略提供与尚未更新以预期此行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0075.rst:19
msgid ""
"The ``OLD`` behavior for this policy is to ignore "
"``CMAKE_REQUIRED_LIBRARIES`` in the include file check macros.  The "
"``NEW`` behavior of this policy is to honor ``CMAKE_REQUIRED_LIBRARIES`` "
"in the include file check macros."
msgstr ""
"此策略的“旧”行为是忽略包含文件检查宏中的“CMAKE_REQUIRED_LIBRARIES”。此策略的“新”行为是在包含文件检查宏中遵守“CMAKE_REQUIRED_LIBRARIES”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0076.rst:2
msgid "CMP0076"
msgstr "CMP0076"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0076.rst:6
msgid ""
"The :command:`target_sources` command converts relative paths to absolute."
msgstr ":command:`target_sources` 命令将相对路径转换为绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0076.rst:8
msgid ""
"In CMake 3.13 and above, the :command:`target_sources` command now "
"converts relative source file paths to absolute paths in the following "
"cases:"
msgstr ""
"在 CMake 3.13 及更高版本中， :command:`target_sources` 命令现在在以下情况下将相对源文件路径转换为绝对路径："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0076.rst:11
msgid ""
"Source files are added to the target's :prop_tgt:`INTERFACE_SOURCES` "
"property."
msgstr "源文件被添加到目标的 :prop_tgt:`INTERFACE_SOURCES` 属性中。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0076.rst:13
msgid ""
"The target's :prop_tgt:`SOURCE_DIR` property differs from "
":variable:`CMAKE_CURRENT_SOURCE_DIR`."
msgstr ""
"目标的 :prop_tgt:`SOURCE_DIR` 属性不同于 :variable:`CMAKE_CURRENT_SOURCE_DIR`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0076.rst:16
msgid ""
"A path that begins with a generator expression is always left unmodified."
msgstr "以生成器表达式开头的路径始终保持不变。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0076.rst:18
msgid ""
"This policy provides compatibility with projects that have not been "
"updated to expect this behavior.  The ``OLD`` behavior for this policy is "
"to leave all relative source file paths unmodified.  The ``NEW`` behavior "
"of this policy is to convert relative paths to absolute according to above"
" rules."
msgstr ""
"此策略提供与尚未更新以预期此行为的项目的兼容性。此策略的“旧”行为是保留所有相对源文件路径不变。此策略的“新”行为是根据上述规则将相对路径转换为绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0076.rst:23
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0078.rst:21
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0079.rst:37
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0080.rst:22
msgid ""
"This policy was introduced in CMake version 3.13.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.13 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:2
msgid "CMP0077"
msgstr "CMP0077"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:6
msgid ":command:`option` honors normal variables."
msgstr ":command:`option` 支持普通变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:8
msgid ""
"The :command:`option` command is typically used to create a cache entry to"
" allow users to set the option.  However, there are cases in which a "
"normal (non-cached) variable of the same name as the option may be defined"
" by the project prior to calling the :command:`option` command. For "
"example, a project that embeds another project as a subdirectory may want "
"to hard-code options of the subproject to build the way it needs."
msgstr ""
":command:`option` 命令通常用于创建缓存条目以允许用户设置选项。但是，在某些情况下，项目可能会在调用 "
":command:`option` "
"命令之前定义与选项同名的普通（非缓存）变量。例如，将另一个项目作为子目录嵌入的项目可能希望对子项目的选项进行硬编码以构建它需要的方式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:15
msgid ""
"For historical reasons in CMake 3.12 and below the :command:`option` "
"command *removes* a normal (non-cached) variable of the same name when:"
msgstr ""
"由于历史原因，在 CMake 3.12 及以下版本中， :command:`option` 命令 *删除* 一个正常的（非缓存的）同名变量，当："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:18
msgid "a cache entry of the specified name does not exist at all, or"
msgstr "指定名称的缓存条目根本不存在，或者"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:19
msgid ""
"a cache entry of the specified name exists but has not been given a type "
"(e.g. via ``-D<name>=ON`` on the command line)."
msgstr "指定名称的缓存条目存在但尚未指定类型（例如，通过命令行上的“-D<name>=ON”）。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:22
msgid ""
"In both of these cases (typically on the first run in a new build tree), "
"the :command:`option` command gives the cache entry type ``BOOL`` and "
"removes any normal (non-cached) variable of the same name.  In the "
"remaining case that the cache entry of the specified name already exists "
"and has a type (typically on later runs in a build tree), the "
":command:`option` command changes nothing and any normal variable of the "
"same name remains set."
msgstr ""
"在这两种情况下（通常是在新构建树中第一次运行时）， :command:`option` 命令给出缓存条目类型 ``BOOL`` "
"并删除任何同名的普通（非缓存）变量.在其余情况下，指定名称的缓存条目已经存在并且具有类型（通常在构建树中稍后运行）， :command:`option`"
" 命令不做任何更改，任何同名的普通变量保持设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:30
msgid ""
"In CMake 3.13 and above the :command:`option` command prefers to do "
"nothing when a normal variable of the given name already exists. It does "
"not create or update a cache entry or remove the normal variable. The new "
"behavior is consistent between the first and later runs in a build tree.  "
"This policy provides compatibility with projects that have not been "
"updated to expect the new behavior."
msgstr ""
"在 CMake 3.13 及更高版本中，当给定名称的普通变量已经存在时， :command:`option` "
"命令倾向于不执行任何操作。它不会创建或更新缓存条目或删除普通变量。新行为在构建树中的第一次和后来的运行之间是一致的。此策略提供与尚未更新以期待新行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:37
msgid ""
"When the :command:`option` command sees a normal variable of the given "
"name:"
msgstr "当 :command:`option` 命令看到给定名称的普通变量时："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:40
msgid ""
"The ``OLD`` behavior for this policy is to proceed even when a normal "
"variable of the same name exists.  If the cache entry does not already "
"exist and have a type then it is created and/or given a type and the "
"normal variable is removed."
msgstr "即使存在同名的普通变量，此策略的“旧”行为也会继续。如果缓存条目尚不存在且没有类型，则创建它和/或为其指定类型，然后删除普通变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:45
msgid ""
"The ``NEW`` behavior for this policy is to do nothing when a normal "
"variable of the same name exists.  The normal variable is not removed. The"
" cache entry is not created or updated and is ignored if it exists."
msgstr "此策略的“新”行为是在存在同名普通变量时不执行任何操作。不删除普通变量。缓存条目不会被创建或更新，如果存在则被忽略。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:49
msgid ""
"See :policy:`CMP0126` for a similar policy for the :command:`set(CACHE)` "
"command, but note that there are some differences in ``NEW`` behavior "
"between the two policies."
msgstr ""
"有关 set(CACHE) 命令的类似策略，请参阅:policy:`CMP0126`，但请注意，这两个策略之间的“NEW”行为存在一些差异。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0077.rst:53
msgid ""
"This policy was introduced in CMake version 3.13.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` explicitly"
" within a project.  Use the :variable:`CMAKE_POLICY_DEFAULT_CMP0077 "
"<CMAKE_POLICY_DEFAULT_CMP\\<NNNN\\>>` variable to set the policy for a "
"third-party project in a subdirectory without modifying it."
msgstr ""
"此策略是在 CMake 版本 3.13 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令在项目中明确地将其设置为 ``OLD`` 或 ``NEW``。使用 "
":variable:`CMAKE_POLICY_DEFAULT_CMP0077 "
"<CMAKE_POLICY_DEFAULT_CMP\\<NNNN\\>>` 变量为子目录中的第三方项目设置策略而不修改它。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0078.rst:2
msgid "CMP0078"
msgstr "CMP0078"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0078.rst:6
msgid ":module:`UseSWIG` generates standard target names."
msgstr ":module:`UseSWIG` 生成标准目标名称。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0078.rst:8
msgid ""
"Starting with CMake 3.13, :module:`UseSWIG` generates now standard target "
"names. This policy provides compatibility with projects that expect the "
"legacy behavior."
msgstr "从 CMake 3.13 开始，UseSWIG 现在生成标准目标名称。此策略提供与期望遗留行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0078.rst:12
msgid ""
"The ``OLD`` behavior for this policy relies on "
"``UseSWIG_TARGET_NAME_PREFERENCE`` variable that can be used to specify an"
" explicit preference.  The value may be one of:"
msgstr ""
"此策略的“旧”行为依赖于“UseSWIG_TARGET_NAME_PREFERENCE”变量，该变量可用于指定显式首选项。该值可能是以下之一："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0078.rst:16
msgid ""
"``LEGACY``: legacy strategy is applied. Variable "
"``SWIG_MODULE_<name>_REAL_NAME`` must be used to get real target name. "
"This is the default if not specified."
msgstr ""
"``LEGACY``：应用了遗留策略。必须使用变量 ``SWIG_MODULE_<name>_REAL_NAME`` "
"来获取真实的目标名称。如果未指定，这是默认值。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0078.rst:19
msgid "``STANDARD``: target name matches specified name."
msgstr "``STANDARD``：目标名称匹配指定的名称。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0079.rst:2
msgid "CMP0079"
msgstr "CMP0079"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0079.rst:6
msgid ""
":command:`target_link_libraries` allows use with targets in other "
"directories."
msgstr ":command:`target_link_libraries` 允许与其他目录中的目标一起使用。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0079.rst:8
msgid ""
"Prior to CMake 3.13 the :command:`target_link_libraries` command did not "
"accept targets not created in the calling directory as its first argument "
"for calls that update the :prop_tgt:`LINK_LIBRARIES` of the target itself."
" It did accidentally accept targets from other directories on calls that "
"only update the :prop_tgt:`INTERFACE_LINK_LIBRARIES`, but would simply add"
" entries to the property as if the call were made in the original "
"directory.  Thus link interface libraries specified this way were always "
"looked up by generators in the scope of the original target rather than in"
" the scope that called :command:`target_link_libraries`."
msgstr ""
"在 CMake 3.13 之前， :command:`target_link_libraries` "
"命令不接受未在调用目录中创建的目标作为更新目标本身的 :prop_tgt:`LINK_LIBRARIES` 的调用的第一个参数。它确实在仅更新 "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` "
"的调用中不小心接受了来自其他目录的目标，但只是将条目添加到属性中，就好像调用是在原​​始目录中进行的一样。因此，以这种方式指定的链接接口库总是由生成器在原始目标范围内查找，而不是在调用"
" :command:`target_link_libraries` 的范围内查找。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0079.rst:18
msgid ""
"CMake 3.13 now allows the :command:`target_link_libraries` command to be "
"called from any directory to add link dependencies and link interface "
"libraries to targets created in other directories.  The entries are added "
"to :prop_tgt:`LINK_LIBRARIES` and :prop_tgt:`INTERFACE_LINK_LIBRARIES` "
"using a special (internal) suffix to tell the generators to look up the "
"names in the calling scope rather than the scope that created the target."
msgstr ""
"CMake 3.13 现在允许从任何目录调用 :command:`target_link_libraries` "
"命令，以将链接依赖项和链接接口库添加到在其他目录中创建的目标。这些条目被添加到 :prop_tgt:`LINK_LIBRARIES` 和 "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` 使用特殊（内部）后缀告诉生成器在调用范围而不是创建目标的范围中查找名称。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0079.rst:25
msgid ""
"This policy provides compatibility with projects that already use "
":command:`target_link_libraries` with the ``INTERFACE`` keyword on a "
"target in another directory to add :prop_tgt:`INTERFACE_LINK_LIBRARIES` "
"entries to be looked up in the target's directory.  Such projects should "
"be updated to be aware of the new scoping rules in that case."
msgstr ""
"此策略提供与已经在另一个目录中的目标上使用 :command:`target_link_libraries` 和 ``INTERFACE`` "
"关键字的项目的兼容性，以添加 :prop_tgt:`INTERFACE_LINK_LIBRARIES` "
"条目以在目标目录中查找。在这种情况下，应更新此类项目以了解新的范围界定规则。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0079.rst:31
msgid ""
"The ``OLD`` behavior of this policy is to disallow "
":command:`target_link_libraries` calls naming targets from another "
"directory except in the previously accidentally allowed case of using the "
"``INTERFACE`` keyword only.  The ``NEW`` behavior of this policy is to "
"allow all such calls but use the new scoping rules."
msgstr ""
"此策略的“旧”行为是禁止 :command:`target_link_libraries` 从另一个目录调用命名目标，除非在以前意外允许的情况下仅使用 "
"``INTERFACE`` 关键字。此策略的“新”行为是允许所有此类调用但使用新的范围规则。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0080.rst:2
msgid "CMP0080"
msgstr "CMP0080"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0080.rst:6
msgid ":module:`BundleUtilities` cannot be included at configure time."
msgstr ":module:`BundleUtilities` 不能在配置时包含。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0080.rst:8
msgid ""
"The macros provided by :module:`BundleUtilities` are intended to be "
"invoked at install time rather than at configure time, because they depend"
" on the listed targets already existing at the time they are invoked. If "
"they are invoked at configure time, the targets haven't been built yet, "
"and the commands will fail."
msgstr ""
":module:`BundleUtilities` "
"提供的宏旨在在安装时而不是在配置时调用，因为它们依赖于在它们被调用时已经存在的列出的目标。如果在配置时调用它们，则目标尚未构建，命令将失败。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0080.rst:14
msgid ""
"This policy restricts the inclusion of :module:`BundleUtilities` to "
"``cmake -P`` style scripts and install rules. Specifically, it looks for "
"the presence of :variable:`CMAKE_GENERATOR` and throws a fatal error if it"
" exists."
msgstr ""
"此策略将 BundleUtilities 的包含限制为 cmake -P 样式脚本和安装规则。具体来说，它会查找 "
":variable:`CMAKE_GENERATOR` 的存在，如果存在则抛出致命错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0080.rst:18
msgid ""
"The ``OLD`` behavior of this policy is to allow :module:`BundleUtilities` "
"to be included at configure time. The ``NEW`` behavior of this policy is "
"to disallow such inclusion."
msgstr "此策略的“旧”行为是允许在配置时包含:module:`BundleUtilities`。此政策的“新”行为是不允许此类包含。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0081.rst:2
msgid "CMP0081"
msgstr "CMP0081"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0081.rst:6
msgid ""
"Relative paths not allowed in :prop_tgt:`LINK_DIRECTORIES` target "
"property."
msgstr ":prop_tgt:`LINK_DIRECTORIES` 目标属性中不允许使用相对路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0081.rst:8
msgid ""
"CMake 3.12 and lower allowed the :prop_dir:`LINK_DIRECTORIES` directory "
"property to contain relative paths.  The base path for such relative "
"entries is not well defined.  CMake 3.13 and later will issue a "
"``FATAL_ERROR`` if the :prop_tgt:`LINK_DIRECTORIES` target property (which"
" is initialized by the :prop_dir:`LINK_DIRECTORIES` directory property) "
"contains a relative path."
msgstr ""
"CMake 3.12 及更低版本允许 LINK_DIRECTORIES 目录属性包含相对路径。此类相对条目的基本路径未明确定义。如果 "
":prop_tgt:`LINK_DIRECTORIES` 目标属性（由 :prop_dir:`LINK_DIRECTORIES` "
"目录属性初始化）包含相对路径，CMake 3.13 及更高版本将发出 ``FATAL_ERROR``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0081.rst:15
msgid ""
"The ``OLD`` behavior for this policy is not to warn about relative paths "
"in the :prop_tgt:`LINK_DIRECTORIES` target property.  The ``NEW`` behavior"
" for this policy is to issue a ``FATAL_ERROR`` if "
":prop_tgt:`LINK_DIRECTORIES` contains a relative path."
msgstr ""
"此策略的“旧”行为不会警告 :prop_tgt:`LINK_DIRECTORIES` "
"目标属性中的相对路径。如果 :prop_tgt:`LINK_DIRECTORIES` "
"包含相对路径，此策略的“新”行为是发出“FATAL_ERROR”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0081.rst:20
msgid ""
"This policy was introduced in CMake version 3.13.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.13 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0082.rst:2
msgid "CMP0082"
msgstr "CMP0082"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0082.rst:6
msgid ""
"Install rules from :command:`add_subdirectory` calls are interleaved with "
"those in caller."
msgstr "来自 :command:`add_subdirectory` 调用的安装规则与调用者中的规则交错。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0082.rst:9
msgid ""
"CMake 3.13 and lower ran the install rules from "
":command:`add_subdirectory` after all other install rules, even if "
":command:`add_subdirectory` was called before the other install rules.  "
"CMake 3.14 and above prefer to interleave these "
":command:`add_subdirectory` install rules with the others so that they are"
" run in the order they are declared.  This policy provides compatibility "
"for projects that have not been updated to expect the new behavior."
msgstr ""
"CMake 3.13 及更低版本在所有其他安装规则之后运行来自 :command:`add_subdirectory` 的安装规则，即使 "
":command:`add_subdirectory` 在其他安装规则之前被调用。 CMake 3.14 及更高版本更喜欢将这些 "
":command:`add_subdirectory` "
"安装规则与其他规则交织在一起，以便它们按照声明的顺序运行。此策略为尚未更新以期待新行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0082.rst:17
msgid ""
"The ``OLD`` behavior for this policy is to run the install rules from "
":command:`add_subdirectory` after the other install rules.  The ``NEW`` "
"behavior for this policy is to run all install rules in the order they are"
" declared."
msgstr ""
"此策略的“旧”行为是在其他安装规则之后从 :command:`add_subdirectory` "
"运行安装规则。此策略的“新”行为是按照声明的顺序运行所有安装规则。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0082.rst:22
msgid ""
"This policy was introduced in CMake version 3.14.  Unlike most policies, "
"CMake version |release| does *not* warn by default when this policy is not"
" set and simply uses ``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0082 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.14 中引入的。与大多数政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0082 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:2
msgid "CMP0083"
msgstr "CMP0083"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:6
msgid ""
"To control generation of Position Independent Executable (``PIE``) or not,"
" some flags are required at link time."
msgstr "要控制是否生成位置独立可执行文件（``PIE``），链接时需要一些标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:9
msgid ""
"CMake 3.13 and lower did not add these link flags when "
":prop_tgt:`POSITION_INDEPENDENT_CODE` is set."
msgstr ""
"设置 :prop_tgt:`POSITION_INDEPENDENT_CODE` 时，CMake 3.13 及更低版本未添加这些链接标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:12
msgid ""
"The ``OLD`` behavior for this policy is to not manage ``PIE`` link flags. "
"The ``NEW`` behavior is to add link flags if "
":prop_tgt:`POSITION_INDEPENDENT_CODE` is set:"
msgstr ""
"此策略的“旧”行为是不管理“PIE”链接标志。如果 :prop_tgt:`POSITION_INDEPENDENT_CODE` "
"被设置，``NEW`` 行为是添加链接标志："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:16
msgid ""
"Set to ``TRUE``: flags to produce a position independent executable are "
"passed to the linker step. For example ``-pie`` for ``GCC``."
msgstr "设置为“真”：生成位置独立可执行文件的标志被传递到链接器步骤。例如 ``-pie`` 用于 ``GCC``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:18
msgid ""
"Set to ``FALSE``: flags not to produce a position independent executable "
"are passed to the linker step. For example ``-no-pie`` for ``GCC``."
msgstr "设置为“FALSE”：不生成与位置无关的可执行文件的标志将传递到链接器步骤。例如，``-no-pie`` 用于``GCC``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:20
msgid "Not set: no flags are passed to the linker step."
msgstr "未设置：没有标志传递给链接器步骤。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:22
msgid ""
"Since a given linker may not support ``PIE`` flags in all environments in "
"which it is used, it is the project's responsibility to use the "
":module:`CheckPIESupported` module to check for support to ensure that the"
" :prop_tgt:`POSITION_INDEPENDENT_CODE` target property for executables "
"will be honored at link time."
msgstr ""
"由于给定的链接器可能不会在所有使用它的环境中都支持``PIE``标志，因此项目有责任使用 CheckPIESupported 模块来检查支持以确保 "
"POSITION_INDEPENDENT_CODE ` 可执行文件的目标属性将在链接时生效。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:28
msgid ""
"This policy was introduced in CMake version 3.14. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike most policies, CMake version |release| does not warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.14 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|未设置此策略时不会发出警告，只是使用“旧”行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:35
msgid ""
"Android platform has a special handling of ``PIE`` so it is not required "
"to use the :module:`CheckPIESupported` module to ensure flags are passed "
"to the linker."
msgstr "Android 平台对 ``PIE`` 有特殊处理，因此不需要使用 CheckPIESupported 模块来确保将标志传递给链接器。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:44
msgid ""
"Behave like CMake 3.13 and do not apply any ``PIE`` flags at link stage."
msgstr "表现得像 CMake 3.13，并且不要在链接阶段应用任何“PIE”标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0083.rst:56
msgid ""
"Use the :module:`CheckPIESupported` module to detect whether ``PIE`` is "
"supported by the current linker and environment.  Apply ``PIE`` flags only"
" if the linker supports them."
msgstr ""
"使用 :module:`CheckPIESupported` 模块检测当前链接器和环境是否支持``PIE``。仅当链接器支持时才应用 ``PIE`` "
"标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0084.rst:2
msgid "CMP0084"
msgstr "CMP0084"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0084.rst:6
msgid ""
"The :module:`FindQt` module does not exist for :command:`find_package`."
msgstr ":module:`FindQt` 模块对于 :command:`find_package` 不存在。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0084.rst:8
msgid ""
"The existence of :module:`FindQt` means that for Qt upstream to provide "
"package config files that can be found by ``find_package(Qt)``, the "
"consuming project has to explicitly specify ``find_package(Qt CONFIG)``. "
"Removing this module gives Qt a path forward for exporting its own config "
"files which can easily be found by consuming projects."
msgstr ""
":module:`FindQt` 的存在意味着 Qt 上游要提供可以通过``find_package(Qt)`` "
"找到的包配置文件，消费项目必须明确指定``find_package(Qt CONFIG)``。删除此模块为 Qt "
"提供了导出其自己的配置文件的路径，这些文件可以通过使用项目轻松找到。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0084.rst:14
msgid ""
"This policy pretends that CMake's internal :module:`FindQt` module does "
"not exist for :command:`find_package`. If a project really wants to use Qt"
" 3 or 4, it can call ``find_package(Qt[34])``, ``include(FindQt)``, or add"
" :module:`FindQt` to their :variable:`CMAKE_MODULE_PATH`."
msgstr ""
"该策略假装 CMake 的内部 FindQt 模块对于 :command:`find_package` 不存在。如果一个项目真的想使用 Qt 3 或"
" "
"4，它可以调用``find_package(Qt[34])``，``include(FindQt)``，或者添加:module:`FindQt`到他们的:variable:`"
" CMAKE_MODULE_PATH`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0084.rst:19
msgid ""
"The ``OLD`` behavior of this policy is for :module:`FindQt` to exist for "
":command:`find_package`. The ``NEW`` behavior is to pretend that it "
"doesn't exist for :command:`find_package`."
msgstr ""
"此策略的“旧”行为是:module:`FindQt` 存在于:command:`find_package`。 ``NEW`` 行为是假装它对于 "
":command:`find_package` 不存在。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0084.rst:23
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0085.rst:18
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0086.rst:17
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0087.rst:26
msgid ""
"This policy was introduced in CMake version 3.14.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.14 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0085.rst:2
msgid "CMP0085"
msgstr "CMP0085"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0085.rst:6
msgid "``$<IN_LIST:...>`` handles empty list items."
msgstr "``$<IN_LIST:...>`` 处理空列表项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0085.rst:8
msgid ""
"In CMake 3.13 and lower, the ``$<IN_LIST:...>`` generator expression "
"always returned ``0`` if the first argument was empty, even if the list "
"contained an empty item. This behavior is inconsistent with the "
"``IN_LIST`` behavior of :command:`if`, which this generator expression is "
"meant to emulate. CMake 3.14 and later handles this case correctly."
msgstr ""
"在 CMake 3.13 及更低版本中，如果第一个参数为空，``$<IN_LIST:...>`` 生成器表达式总是返回 "
"``0``，即使列表包含一个空项。此行为与 :command:`if` 的 ``IN_LIST`` 行为不一致，此生成器表达式旨在模拟。 CMake"
" 3.14 及更高版本可以正确处理这种情况。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0085.rst:14
msgid ""
"The ``OLD`` behavior of this policy is for ``$<IN_LIST:...>`` to always "
"return ``0`` if the first argument is empty. The ``NEW`` behavior is to "
"return ``1`` if the first argument is empty and the list contains an empty"
" item."
msgstr ""
"如果第一个参数为空，此策略的“旧”行为是“$<IN_LIST:...>”总是返回“0”。 ``NEW`` 行为是在第一个参数为空且列表包含空项时返回"
" ``1``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0086.rst:2
msgid "CMP0086"
msgstr "CMP0086"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0086.rst:6
msgid ":module:`UseSWIG` honors ``SWIG_MODULE_NAME`` via ``-module`` flag."
msgstr ":module:`UseSWIG` 通过``-module`` 标志支持``SWIG_MODULE_NAME``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0086.rst:8
msgid ""
"Starting with CMake 3.14, :module:`UseSWIG` passes option ``-module "
"<module_name>`` to ``SWIG`` compiler if the file property "
"``SWIG_MODULE_NAME`` is specified. This policy provides compatibility with"
" projects that expect the legacy behavior."
msgstr ""
"从 CMake 3.14 开始，如果指定了文件属性“SWIG_MODULE_NAME”，UseSWIG 会将选项“-module "
"<module_name>”传递给“SWIG”编译器。此策略提供与期望遗留行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0086.rst:13
msgid ""
"The ``OLD`` behavior for this policy is to never pass ``-module`` option. "
"The ``NEW`` behavior is to pass ``-module`` option to ``SWIG`` compiler if"
" ``SWIG_MODULE_NAME`` is specified."
msgstr ""
"此策略的“旧”行为是永远不会传递“-module”选项。如果指定了“SWIG_MODULE_NAME”，“新”行为是将“-module”选项传递给“SWIG”编译器。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0087.rst:2
msgid "CMP0087"
msgstr "CMP0087"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0087.rst:6
msgid ""
":command:`install(CODE)` and :command:`install(SCRIPT)` support generator "
"expressions."
msgstr ":command:`install(CODE)` 和 :command:`install(SCRIPT)` 支持生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0087.rst:9
msgid ""
"In CMake 3.13 and earlier, :command:`install(CODE)` and "
":command:`install(SCRIPT)` did not evaluate generator expressions.  CMake "
"3.14 and later will evaluate generator expressions for "
":command:`install(CODE)` and :command:`install(SCRIPT)`."
msgstr ""
"在 CMake 3.13 及更早版本中， :command:`install(CODE)` 和 :command:`install(SCRIPT)` "
"不计算生成器表达式。 CMake 3.14 及更高版本将为 :command:`install(CODE)` 和 "
":command:`install(SCRIPT)` 计算生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0087.rst:14
msgid ""
"The ``OLD`` behavior of this policy is for :command:`install(CODE)` and "
":command:`install(SCRIPT)` to not evaluate generator expressions.  The "
"``NEW`` behavior is to evaluate generator expressions for "
":command:`install(CODE)` and :command:`install(SCRIPT)`."
msgstr ""
"此策略的“旧”行为是为了 :command:`安装（代码）`和 :command:`安装（脚本）`不评估生成器表达式。 ``NEW`` 行为是评估 "
":command:`install(CODE)` 和 :command:`install(SCRIPT)` 的生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0087.rst:19
msgid ""
"Note that it is the value of this policy setting at the end of the "
"directory scope that is important, not its setting at the time of the call"
" to :command:`install(CODE)` or :command:`install(SCRIPT)`.  This has "
"implications for calling these commands from places that have their own "
"policy scope but not their own directory scope (e.g. from files brought in"
" via :command:`include()` rather than :command:`add_subdirectory()`)."
msgstr ""
"请注意，重要的是目录范围末尾的此策略设置的值，而不是调用 install(CODE) 或 install(SCRIPT) "
"时的设置.这对从具有自己的策略范围但不具有自己的目录范围的地方调用这些命令有影响（例如，从通过 :command:`include()` 而不是 "
":command:`add_subdirectory()` 引入的文件）。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0088.rst:2
msgid "CMP0088"
msgstr "CMP0088"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0088.rst:6
msgid ""
":module:`FindBISON` runs bison in :variable:`CMAKE_CURRENT_BINARY_DIR` "
"when executing."
msgstr ""
":module:`FindBISON` 在执行时在 :variable:`CMAKE_CURRENT_BINARY_DIR` 中运行 bison。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0088.rst:9
msgid ""
"The module provides a ``BISON_TARGET`` macro which generates BISON output."
" In CMake 3.13 and below the macro would generate a custom command that "
"runs ``bison`` in the source directory.  CMake 3.14 and later prefer to "
"run it in the build directory and use :variable:`CMAKE_CURRENT_BINARY_DIR`"
" as the ``WORKING_DIRECTORY`` of its :command:`add_custom_command` "
"invocation. This ensures that any implicitly generated file is written to "
"the build tree rather than the source."
msgstr ""
"该模块提供了一个生成 BISON 输出的 ``BISON_TARGET`` 宏。在 CMake 3.13 "
"及以下版本中，宏将生成一个在源目录中运行“bison”的自定义命令。 CMake 3.14 及更高版本更喜欢在构建目录中运行它，并使用 "
":variable:`CMAKE_CURRENT_BINARY_DIR` 作为其 :command:`add_custom_command` 调用的"
" ``WORKING_DIRECTORY``。这确保任何隐式生成的文件都写入构建树而不是源。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0088.rst:17
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0097.rst:16
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0098.rst:18
msgid ""
"This policy provides compatibility for projects that have not been updated"
" to expect the new behavior."
msgstr "此策略为尚未更新以期待新行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0088.rst:20
msgid ""
"The ``OLD`` behavior for this policy is for ``BISON_TARGET`` to use the "
"current source directory for the ``WORKING_DIRECTORY`` and where to "
"generate implicit files. The ``NEW`` behavior of this policy is to use the"
" current binary directory for the ``WORKING_DIRECTORY`` and where to "
"generate implicit files."
msgstr ""
"此策略的“旧”行为是针对“BISON_TARGET”使用“工作目录”的当前源目录以及生成隐式文件的位置。此策略的“新”行为是将当前二进制目录用于“WORKING_DIRECTORY”以及生成隐式文件的位置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0088.rst:26
msgid ""
"This policy was introduced in CMake version 3.14.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike most policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.14 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0089.rst:2
msgid "CMP0089"
msgstr "CMP0089"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0089.rst:6
msgid "Compiler id for IBM Clang-based XL compilers is now ``XLClang``."
msgstr "基于 IBM Clang 的 XL 编译器的编译器 ID 现在是“XLClang”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0089.rst:8
msgid ""
"CMake 3.15 and above recognize that IBM's Clang-based XL compilers that "
"define ``__ibmxl__`` are a new front-end distinct from ``xlc`` with a "
"different command line and set of capabilities. CMake now prefers to "
"present this to projects by setting the "
":variable:`CMAKE_<LANG>_COMPILER_ID` variable to ``XLClang`` instead of "
"``XL``.  However, existing projects may assume the compiler id for Clang-"
"based XL is just ``XL`` as it was in CMake versions prior to 3.15. "
"Therefore this policy determines for Clang-based XL compilers which "
"compiler id to report in the :variable:`CMAKE_<LANG>_COMPILER_ID` variable"
" after language ``<LANG>`` is enabled by the :command:`project` or "
":command:`enable_language` command.  The policy must be set prior to the "
"invocation of either command."
msgstr ""
"CMake 3.15 及更高版本认识到 IBM 的基于 Clang 的 XL 编译器定义了``__ibmxl__`` "
"是一种新的前端，不同于``xlc``，具有不同的命令行和功能集。 CMake 现在更喜欢通过将 "
":variable:`CMAKE_<LANG>_COMPILER_ID` 变量设置为 ``XLClang`` 而不是 ``XL`` "
"来将其呈现给项目。然而，现有项目可能假设基于 Clang 的 XL 的编译器 ID 只是“XL”，因为它在 3.15 之前的 CMake "
"版本中。因此，此策略为基于 Clang 的 XL 编译器确定在 :command:`project` 或 :command 启用语言 "
"``<LANG>`` 后，在 :variable:`CMAKE_<LANG>_COMPILER_ID` 变量中报告哪个编译器 ID "
":`enable_language` 命令。该策略必须在调用任一命令之前设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0089.rst:21
msgid ""
"The ``OLD`` behavior for this policy is to use compiler id ``XL``.  The "
"``NEW`` behavior for this policy is to use compiler id ``XLClang``."
msgstr "此策略的“旧”行为是使用编译器 ID“XL”。此政策的“新”行为是使用编译器 ID“XLClang”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0089.rst:24
msgid ""
"This policy was introduced in CMake version 3.15.  Use the "
":command:`cmake_policy` command to set this policy to ``OLD`` or ``NEW`` "
"explicitly. Unlike most policies, CMake version |release| does *not* warn "
"by default when this policy is not set and simply uses ``OLD`` behavior. "
"See documentation of the :variable:`CMAKE_POLICY_WARNING_CMP0089 "
"<CMAKE_POLICY_WARNING_CMP<NNNN>>` variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.15 中引入的。使用 :command:`cmake_policy` 命令将此策略显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0089 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0090.rst:2
msgid "CMP0090"
msgstr "CMP0090"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0090.rst:6
msgid ""
":command:`export(PACKAGE)` does not populate package registry by default."
msgstr ":command:`export(PACKAGE)` 默认情况下不填充包注册表。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0090.rst:8
msgid ""
"In CMake 3.14 and below the :command:`export(PACKAGE)` command populated "
"the user package registry by default and users needed to set the "
":variable:`CMAKE_EXPORT_NO_PACKAGE_REGISTRY` to disable it, e.g. in "
"automated build and packaging environments.  Since the user package "
"registry is stored outside the build tree, this side effect should not be "
"enabled by default. Therefore CMake 3.15 and above prefer that "
":command:`export(PACKAGE)` does nothing unless an explicit "
":variable:`CMAKE_EXPORT_PACKAGE_REGISTRY` variable is set to enable it.  "
"This policy provides compatibility with projects that have not been "
"updated."
msgstr ""
"在 CMake 3.14 及以下版本中，export(PACKAGE) 命令默认填充用户包注册表，用户需要设置 "
"CMAKE_EXPORT_NO_PACKAGE_REGISTRY "
"来禁用它，例如在自动化构建和打包环境中。由于用户包注册表存储在构建树之外，因此默认情况下不应启用此副作用。因此 CMake 3.15 "
"及更高版本更喜欢 :command:`export(PACKAGE)` 不执行任何操作，除非显式 "
":variable:`CMAKE_EXPORT_PACKAGE_REGISTRY` 变量设置为启用它。此策略提供与尚未更新的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0090.rst:18
msgid ""
"The ``OLD`` behavior for this policy is for :command:`export(PACKAGE)` "
"command to populate the user package registry unless "
":variable:`CMAKE_EXPORT_NO_PACKAGE_REGISTRY` is enabled. The ``NEW`` "
"behavior is for :command:`export(PACKAGE)` command to do nothing unless "
"the :variable:`CMAKE_EXPORT_PACKAGE_REGISTRY` is enabled."
msgstr ""
"除非启用 :variable:`CMAKE_EXPORT_NO_PACKAGE_REGISTRY`，否则此策略的 ``OLD`` "
"行为用于:command:`export（PACKAGE）` 命令填充用户包注册表。 ``NEW`` "
"行为是为了 :command:`export（PACKAGE）` 命令不执行任何操作，除非 :variable:`CMAKE_EXPORT_PACKAGE_REGISTRY`"
" 已启用。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0090.rst:24
msgid ""
"This policy was introduced in CMake version 3.15.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike most policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.15 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:2
msgid "CMP0091"
msgstr "CMP0091"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:6
msgid "MSVC runtime library flags are selected by an abstraction."
msgstr "MSVC 运行时库标志由抽象选择。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:8
msgid ""
"Compilers targeting the MSVC ABI have flags to select the MSVC runtime "
"library. Runtime library selection typically varies with build "
"configuration because there is a separate runtime library for Debug "
"builds."
msgstr ""
"针对 MSVC ABI 的编译器具有选择 MSVC 运行时库的标志。运行时库的选择通常因构建配置而异，因为调试构建有一个单独的运行时库。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:12
msgid ""
"In CMake 3.14 and below, MSVC runtime library selection flags are added to"
" the default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` cache entries by "
"CMake automatically.  This allows users to edit their cache entries to "
"adjust the flags.  However, the presence of such default flags is "
"problematic for projects that want to choose a different runtime library "
"programmatically. In particular, it requires string editing of the "
":variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` variables with knowledge of the "
"CMake builtin defaults so they can be replaced."
msgstr ""
"在 CMake 3.14 及以下版本中，CMake 会自动将 MSVC 运行时库选择标志添加到默认的 "
"CMAKE_<LANG>_FLAGS_<CONFIG> "
"缓存条目中。这允许用户编辑他们的缓存条目以调整标志。但是，对于想要以编程方式选择不同的运行时库的项目，此类默认标志的存在是有问题的。特别是，它需要在了解"
" CMake 内置默认值的情况下对 CMAKE_<LANG>_FLAGS_<CONFIG> 变量进行字符串编辑，以便替换它们。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:21
msgid ""
"CMake 3.15 and above prefer to leave the MSVC runtime library selection "
"flags out of the default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` values "
"and instead offer a first-class abstraction.  The "
":variable:`CMAKE_MSVC_RUNTIME_LIBRARY` variable and "
":prop_tgt:`MSVC_RUNTIME_LIBRARY` target property may be set to select the "
"MSVC runtime library.  If they are not set then CMake uses the default "
"value ``MultiThreaded$<$<CONFIG:Debug>:Debug>DLL`` which is equivalent to "
"the original flags."
msgstr ""
"CMake 3.15 及更高版本倾向于将 MSVC "
"运行时库选择标志保留在默认值之外 :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` 值，而是提供一流的抽象。 "
":variable:`CMAKE_MSVC_RUNTIME_LIBRARY` 变量和 "
":prop_tgt:`MSVC_RUNTIME_LIBRARY` 目标属性可以设置为选择 MSVC 运行时库。如果未设置它们，则 CMake "
"使用默认值 ``MultiThreaded$<$<CONFIG:Debug>:Debug>DLL`` 等同于原始标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:29
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:31
msgid ""
"This policy provides compatibility with projects that have not been "
"updated to be aware of the abstraction.  The policy setting takes effect "
"as of the first :command:`project` or :command:`enable_language` command "
"that enables a language whose compiler targets the MSVC ABI."
msgstr ""
"此策略提供与尚未更新以了解抽象的项目的兼容性。该策略设置从第一个 :command:`project` 或 "
":command:`enable_language` 命令开始生效，该命令启用其编译器以 MSVC ABI 为目标的语言。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:36
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:35
msgid ""
"Once the policy has taken effect at the top of a project, that choice must"
" be used throughout the tree.  In projects that have nested projects in "
"subdirectories, be sure to convert everything together."
msgstr "一旦策略在项目的顶部生效，该选择就必须在整个树中使用。在子目录中具有嵌套项目的项目中，请确保将所有内容一起转换。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:40
msgid ""
"The ``OLD`` behavior for this policy is to place MSVC runtime library "
"flags in the default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` cache entries"
" and ignore the :variable:`CMAKE_MSVC_RUNTIME_LIBRARY` abstraction. The "
"``NEW`` behavior for this policy is to *not* place MSVC runtime library "
"flags in the default cache entries and use the abstraction instead."
msgstr ""
"此策略的“旧”行为是将 MSVC 运行时库标志放置在默认的 CMAKE_<LANG>_FLAGS_<CONFIG> 缓存条目中并忽略 "
"CMAKE_MSVC_RUNTIME_LIBRARY 抽象。此策略的“新”行为是*不*将 MSVC 运行时库标志放在默认缓存条目中，而是使用抽象。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0091.rst:46
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0092.rst:35
msgid ""
"This policy was introduced in CMake version 3.15.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.15 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0092.rst:2
msgid "CMP0092"
msgstr "CMP0092"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0092.rst:6
msgid ""
"MSVC warning flags are not in :variable:`CMAKE_<LANG>_FLAGS` by default."
msgstr "默认情况下，MSVC 警告标志不在 CMAKE_<LANG>_FLAGS 中。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0092.rst:8
msgid ""
"When using MSVC-like compilers in CMake 3.14 and below, warning flags like"
" ``/W3`` are added to :variable:`CMAKE_<LANG>_FLAGS` by default. This is "
"problematic for projects that want to choose a different warning level "
"programmatically.  In particular, it requires string editing of the "
":variable:`CMAKE_<LANG>_FLAGS` variables with knowledge of the CMake "
"builtin defaults so they can be replaced."
msgstr ""
"在 CMake 3.14 及更低版本中使用类似 MSVC 的编译器时，默认情况下会将像 ``/W3`` 这样的警告标志添加到 "
":variable:`CMAKE_<LANG>_FLAGS` 中。这对于想要以编程方式选择不同警告级别的项目来说是有问题的。特别是，它需要在了解 "
"CMake 内置默认值的情况下对 :variable:`CMAKE_<LANG>_FLAGS` 变量进行字符串编辑，以便替换它们。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0092.rst:15
msgid ""
"CMake 3.15 and above prefer to leave out warning flags from the value of "
":variable:`CMAKE_<LANG>_FLAGS` by default."
msgstr ""
"默认情况下，CMake 3.15 及更高版本倾向于从 :variable:`CMAKE_<LANG>_FLAGS` 的值中省略警告标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0092.rst:18
msgid ""
"This policy provides compatibility with projects that have not been "
"updated to expect the lack of warning flags.  The policy setting takes "
"effect as of the first :command:`project` or :command:`enable_language` "
"command that initializes :variable:`CMAKE_<LANG>_FLAGS` for a given "
"language ``<LANG>``."
msgstr ""
"此政策提供与尚未更新的项目的兼容性，以预期缺少警告标志。策略设置从第一个 :command:`project` 或 "
":command:`enable_language` 命令开始生效，该命令为给定语言 ``<LANG>`` 初始化 "
":variable:`CMAKE_<LANG>_FLAGS`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0092.rst:25
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0117.rst:28
msgid ""
"Once the policy has taken effect at the top of a project for a given "
"language, that choice must be used throughout the tree for that language. "
"In projects that have nested projects in subdirectories, be sure to "
"convert everything together."
msgstr "一旦该策略在给定语言的项目顶部生效，该选择必须在该语言的整个树中使用。在子目录中具有嵌套项目的项目中，请确保将所有内容一起转换。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0092.rst:30
msgid ""
"The ``OLD`` behavior for this policy is to place MSVC warning flags in the"
" default :variable:`CMAKE_<LANG>_FLAGS` cache entries.  The ``NEW`` "
"behavior for this policy is to *not* place MSVC warning flags in the "
"default cache entries."
msgstr ""
"此策略的“旧”行为是将 MSVC 警告标志放置在默认的 CMAKE_<LANG>_FLAGS "
"缓存条目中。此策略的“新”行为是*不*在默认缓存条目中放置 MSVC 警告标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0093.rst:2
msgid "CMP0093"
msgstr "CMP0093"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0093.rst:6
msgid ":module:`FindBoost` reports ``Boost_VERSION`` in ``x.y.z`` format."
msgstr ":module:`FindBoost` 以 ``x.y.z`` 格式报告 ``Boost_VERSION``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0093.rst:8
msgid ""
"In CMake 3.14 and below the module would report the Boost version number "
"as specified in the preprocessor definition ``BOOST_VERSION`` in the "
"``boost/version.hpp`` file. In CMake 3.15 and later it is preferred that "
"the reported version number matches the ``x.y.z`` format reported by the "
"CMake package shipped with Boost ``1.70.0`` and later. The macro value is "
"still reported in the ``Boost_VERSION_MACRO`` variable."
msgstr ""
"在 CMake 3.14 及以下版本中，模块将报告 Boost 版本号，如 ``boost/version.hpp`` 文件中的预处理器定义 "
"``BOOST_VERSION`` 中指定的那样。在 CMake 3.15 及更高版本中，报告的版本号最好与 Boost 1.70.0 "
"及更高版本随附的 CMake 包报告的 ``x.y.z`` 格式匹配。宏值仍然在“Boost_VERSION_MACRO”变量中报告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0093.rst:15
msgid ""
"The ``OLD`` behavior for this policy is for :module:`FindBoost` to report "
"``Boost_VERSION`` as specified in the preprocessor definition "
"``BOOST_VERSION`` in ``boost/version.hpp``. The ``NEW`` behavior for this "
"policy is for :module:`FindBoost` to report ``Boost_VERSION`` in ``x.y.z``"
" format."
msgstr ""
"此策略的 ``OLD`` 行为是:module:`FindBoost` 报告 ``Boost_VERSION``，如 "
"``boost/version.hpp`` 中预处理器定义 ``BOOST_VERSION`` "
"中指定的那样。此策略的“新”行为是 :module:`FindBoost` 以 ``x.y.z`` 格式报告 ``Boost_VERSION``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0093.rst:21
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0094.rst:19
msgid ""
"This policy was introduced in CMake version 3.15.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses the ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.15 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0094.rst:2
msgid "CMP0094"
msgstr "CMP0094"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0094.rst:6
msgid ""
"Modules :module:`FindPython3`, :module:`FindPython2` and "
":module:`FindPython` use ``LOCATION`` for lookup strategy."
msgstr ""
"模块 :module:`FindPython3`、 :module:`FindPython2` 和 :module:`FindPython` 使用 "
"``LOCATION`` 作为查找策略。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0094.rst:9
msgid ""
"Starting with CMake 3.15, Modules :module:`FindPython3`, "
":module:`FindPython2` and :module:`FindPython` set value ``LOCATION`` for,"
" respectively, variables ``Python3_FIND_STRATEGY``, "
"``Python2_FIND_STRATEGY`` and ``Python_FIND_STRATEGY``. This policy "
"provides compatibility with projects that expect the legacy behavior."
msgstr ""
"从 CMake 3.15 开始，模块 :module:`FindPython3`、 :module:`FindPython2` 和 "
":module:`FindPython` 分别为变量 "
"``Python3_FIND_STRATEGY``、``Python2_FIND_STRATEGY`` 和 ``LOCATION`` 设置值 "
"``LOCATION`` ``Python_FIND_STRATEGY``。此策略提供与期望遗留行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0094.rst:15
msgid ""
"The ``OLD`` behavior for this policy set value ``VERSION`` for variables "
"``Python3_FIND_STRATEGY``, ``Python2_FIND_STRATEGY`` and "
"``Python_FIND_STRATEGY``."
msgstr ""
"此策略的“旧”行为为变量“Python3_FIND_STRATEGY”、“Python2_FIND_STRATEGY”和“Python_FIND_STRATEGY”设置值“VERSION”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0095.rst:2
msgid "CMP0095"
msgstr "CMP0095"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0095.rst:6
msgid ""
"``RPATH`` entries are properly escaped in the intermediary CMake install "
"script."
msgstr "``RPATH`` 条目在中间 CMake 安装脚本中被正确转义。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0095.rst:8
msgid ""
"In CMake 3.15 and earlier, ``RPATH`` entries set via "
":variable:`CMAKE_INSTALL_RPATH` or via :prop_tgt:`INSTALL_RPATH` have not "
"been escaped before being inserted into the ``cmake_install.cmake`` "
"script. Dynamic linkers on ELF-based systems (e.g. Linux and FreeBSD) "
"allow certain keywords in ``RPATH`` entries, such as ``${ORIGIN}`` (More "
"details are available in the ``ld.so`` man pages on those systems). The "
"syntax of these keywords can match CMake's variable syntax. In order to "
"not be substituted (usually to an empty string) already by the "
"intermediary ``cmake_install.cmake`` script, the user had to double-escape"
" such ``RPATH`` keywords, e.g. ``set(CMAKE_INSTALL_RPATH "
"\"\\\\\\${ORIGIN}/../lib\")``. Since the intermediary "
"``cmake_install.cmake`` script is an implementation detail of CMake, CMake"
" 3.16 and later will make sure ``RPATH`` entries are inserted literally by"
" escaping any coincidental CMake syntax."
msgstr ""
"在 CMake 3.15 及更早版本中，通过 :variable:`CMAKE_INSTALL_RPATH` 或通过 "
":prop_tgt:`INSTALL_RPATH` 设置的 ``RPATH`` 条目在插入到 ``cmake_install.cmake`` "
"脚本之前没有被转义。基于 ELF 的系统（例如 Linux 和 FreeBSD）上的动态链接器允许在 ``RPATH`` 条目中使用某些关键字，例如"
" ``${ORIGIN}``（更多详细信息可在 ``ld.so`` 手册页中找到在那些系统上）。这些关键字的语法可以匹配 CMake "
"的变量语法。为了不被中间``cmake_install.cmake``脚本替换（通常为空字符串），用户必须双重转义这样的``RPATH``关键字，例如``设置（CMAKE_INSTALL_RPATH"
" \"\\\\\\${ORIGIN}/../lib\"）``。由于中间的“cmake_install.cmake”脚本是 CMake "
"的一个实现细节，CMake 3.16 及更高版本将通过转义任何巧合的 CMake 语法来确保按字面插入“RPATH”条目。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0095.rst:22
msgid ""
"The ``OLD`` behavior of this policy is to not escape ``RPATH`` entries in "
"the intermediary ``cmake_install.cmake`` script. The ``NEW`` behavior is "
"to properly escape coincidental CMake syntax in ``RPATH`` entries when "
"generating the intermediary ``cmake_install.cmake`` script."
msgstr ""
"此策略的“旧”行为是不转义中间“cmake_install.cmake”脚本中的“RPATH”条目。 ``NEW`` "
"行为是在生成中间``cmake_install.cmake`` 脚本时正确地转义``RPATH`` 条目中巧合的 CMake 语法。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0095.rst:27
msgid ""
"This policy was introduced in CMake version 3.16. CMake version |release| "
"warns when the policy is not set and detected usage of CMake-like syntax "
"and uses ``OLD`` behavior. Use the :command:`cmake_policy` command to set "
"it to ``OLD`` or ``NEW`` explicitly."
msgstr ""
"此策略是在 CMake 版本 3.16 中引入的。 CMake 版本 |发布|当未设置策略并检测到使用类似 CMake "
"的语法并使用“旧”行为时发出警告。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0096.rst:2
msgid "CMP0096"
msgstr "CMP0096"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0096.rst:6
msgid ""
"The :command:`project` command preserves leading zeros in version "
"components."
msgstr ":command:`project` 命令保留版本组件中的前导零。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0096.rst:8
msgid ""
"When a ``VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]`` argument is "
"given to the :command:`project` command, it stores the version string in "
"the ``PROJECT_VERSION`` variable and stores individual integer version "
"components in ``PROJECT_VERSION_{MAJOR,MINOR,PATCH,TWEAK}`` variables (see"
" policy :policy:`CMP0048`).  CMake 3.15 and below dropped leading zeros "
"from each component.  CMake 3.16 and higher prefer to preserve leading "
"zeros.  This policy provides compatibility for projects that have not been"
" updated to expect the new behavior."
msgstr ""
"当 ``VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]`` 参数被提供给 "
":command:`project` 命令时，它将版本字符串存储在 ` `PROJECT_VERSION`` "
"变量并将各个整数版本组件存储在``PROJECT_VERSION_{MAJOR,MINOR,PATCH,TWEAK}`` "
"变量中（参见策略:policy:`CMP0048`）。 CMake 3.15 及更低版本从每个组件中删除了前导零。 CMake 3.16 "
"及更高版本倾向于保留前导零。此策略为尚未更新以期待新行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0096.rst:17
msgid ""
"The ``OLD`` behavior of this policy drops leading zeros in all components,"
" e.g.  such that version ``1.07.06`` becomes ``1.7.6``.  The ``NEW`` "
"behavior of this policy preserves the leading zeros in all components, "
"such that version ``1.07.06`` remains unchanged."
msgstr ""
"该策略的“旧”行为会在所有组件中删除前导零，例如这样版本 ``1.07.06`` 就变成了 "
"``1.7.6``。此策略的“新”行为保留所有组件中的前导零，因此版本“1.07.06”保持不变。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0096.rst:22
msgid ""
"This policy was introduced in CMake version 3.16.  Unlike many policies, "
"CMake version |release| does *not* warn when this policy is not set and "
"simply uses the ``OLD`` behavior.  Use the :command:`cmake_policy` command"
" to set it to ``OLD`` or ``NEW`` explicitly."
msgstr ""
"此策略是在 CMake 版本 3.16 中引入的。与许多政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时*不*发出警告。使用 :command:`cmake_policy` 命令将其显式设置为 "
"``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0097.rst:2
msgid "CMP0097"
msgstr "CMP0097"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0097.rst:6
msgid ""
":command:`ExternalProject_Add` with ``GIT_SUBMODULES \"\"`` initializes no"
" submodules.  The policy also applies to :command:`FetchContent_Declare`, "
"which uses the same download and update features as "
":command:`ExternalProject_Add`."
msgstr ""
":command:`ExternalProject_Add` with ``GIT_SUBMODULES \"\"`` "
"不初始化任何子模块。该政策也适用于 FetchContent_Declare，它使用与 ExternalProject_Add "
"相同的下载和更新功能。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0097.rst:11
msgid ""
"The commands provide a ``GIT_SUBMODULES`` option which controls what "
"submodules to initialize and update. Starting with CMake 3.16, explicitly "
"setting ``GIT_SUBMODULES`` to an empty string means no submodules will be "
"initialized or updated."
msgstr ""
"这些命令提供了一个 ``GIT_SUBMODULES`` 选项来控制要初始化和更新的子模块。从 CMake 3.16 开始，将 "
"``GIT_SUBMODULES`` 显式设置为空字符串意味着不会初始化或更新任何子模块。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0097.rst:19
msgid ""
"The ``OLD`` behavior for this policy is for ``GIT_SUBMODULES`` when set to"
" an empty string to initialize and update all git submodules. The ``NEW`` "
"behavior for this policy is for ``GIT_SUBMODULES`` when set to an empty "
"string to initialize and update no git submodules."
msgstr ""
"当设置为空字符串以初始化和更新所有 git 子模块时，此策略的 ``OLD`` 行为适用于 "
"``GIT_SUBMODULES``。当设置为空字符串以初始化和更新任何 git 子模块时，此策略的 ``NEW`` 行为适用于 "
"``GIT_SUBMODULES``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0097.rst:24
msgid ""
"This policy was introduced in CMake version 3.16.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike most policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.16 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0098.rst:2
msgid "CMP0098"
msgstr "CMP0098"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0098.rst:6
msgid ""
":module:`FindFLEX` runs ``flex`` in directory "
":variable:`CMAKE_CURRENT_BINARY_DIR` when executing."
msgstr ""
":module:`FindFLEX` 在执行时在目录 :variable:`CMAKE_CURRENT_BINARY_DIR` 中运行 "
"``flex``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0098.rst:9
msgid ""
"The module provides a ``FLEX_TARGET`` macro which generates FLEX output. "
"In CMake 3.16 and below the macro would generate a custom command that "
"runs ``flex`` in the current source directory.  CMake 3.17 and later "
"prefer to run it in the build directory and use "
":variable:`CMAKE_CURRENT_BINARY_DIR` as the ``WORKING_DIRECTORY`` of its "
":command:`add_custom_command` invocation. This ensures that any implicitly"
" generated file is written relative to the build tree rather than the "
"source tree, unless the generated file is provided as absolute path."
msgstr ""
"该模块提供了一个生成 FLEX 输出的 ``FLEX_TARGET`` 宏。在 CMake 3.16 及以下版本中，宏将生成一个在当前源目录中运行 "
"``flex`` 的自定义命令。 CMake 3.17 及更高版本更喜欢在构建目录中运行它，并使用 "
":variable:`CMAKE_CURRENT_BINARY_DIR` 作为其 :command:`add_custom_command` 调用的"
" ``WORKING_DIRECTORY``。这确保任何隐式生成的文件都是相对于构建树而不是源树写入的，除非生成的文件作为绝对路径提供。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0098.rst:21
msgid ""
"The ``OLD`` behavior for this policy is for ``FLEX_TARGET`` to use the "
"current source directory for the ``WORKING_DIRECTORY`` and where to "
"generate implicit files. The ``NEW`` behavior of this policy is to use the"
" current binary directory for the ``WORKING_DIRECTORY`` relative to which "
"implicit files are generated unless provided as absolute path."
msgstr ""
"此策略的 ``OLD`` 行为是 ``FLEX_TARGET`` 将当前源目录用于 ``WORKING_DIRECTORY`` "
"以及生成隐式文件的位置。此策略的“新”行为是将当前二进制目录用于相对于生成隐式文件的“WORKING_DIRECTORY”，除非作为绝对路径提供。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0098.rst:27
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0099.rst:21
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0101.rst:25
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0107.rst:16
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0108.rst:16
msgid ""
"This policy was introduced in CMake version 3.17.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.17 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0099.rst:2
msgid "CMP0099"
msgstr "CMP0099"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0099.rst:6
msgid ""
"Target link properties :prop_tgt:`INTERFACE_LINK_OPTIONS`, "
":prop_tgt:`INTERFACE_LINK_DIRECTORIES` and "
":prop_tgt:`INTERFACE_LINK_DEPENDS` are now transitive over private "
"dependencies of static libraries."
msgstr ""
"目标链接属性 "
":prop_tgt:`INTERFACE_LINK_OPTIONS`、 :prop_tgt:`INTERFACE_LINK_DIRECTORIES` "
"和 :prop_tgt:`INTERFACE_LINK_DEPENDS` 现在可以通过静态库的私有依赖项传递。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0099.rst:10
msgid ""
"In CMake 3.16 and below the interface link properties attached to "
"libraries are not propagated for private dependencies of static libraries."
" Only the libraries themselves are propagated to link the dependent "
"binary. CMake 3.17 and later prefer to propagate all interface link "
"properties. This policy provides compatibility for projects that have not "
"been updated to expect the new behavior."
msgstr ""
"在 CMake 3.16 及以下版本中，附加到库的接口链接属性不会为静态库的私有依赖项传播。只有库本身会被传播以链接依赖的二进制文件。 CMake "
"3.17 及更高版本更喜欢传播所有接口链接属性。此策略为尚未更新以期待新行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0099.rst:17
msgid ""
"The ``OLD`` behavior for this policy is to not propagate interface link "
"properties. The ``NEW`` behavior of this policy is to propagate interface "
"link properties."
msgstr "此策略的“旧”行为是不传播​​接口链接属性。此策略的“新”行为是传播接口链接属性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0100.rst:2
msgid "CMP0100"
msgstr "CMP0100"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0100.rst:6
msgid ""
"Let :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC` process header files that "
"end with a ``.hh`` extension."
msgstr "让 :prop_tgt:`AUTOMOC` 和 :prop_tgt:`AUTOUIC` 处理以 .hh 扩展名结尾的头文件。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0100.rst:9
msgid ""
"Since version 3.17, CMake processes header files that end with a ``.hh`` "
"extension in :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC`. In earlier CMake"
" versions, these header files were ignored by :prop_tgt:`AUTOMOC` and "
":prop_tgt:`AUTOUIC`."
msgstr ""
"从 3.17 版开始，CMake 处理以 ``.hh`` 扩展名结尾的头文件，包括:prop_tgt:`AUTOMOC` 和 "
":prop_tgt:`AUTOUIC`。在早期的 CMake 版本中，这些头文件被 :prop_tgt:`AUTOMOC` 和 "
":prop_tgt:`AUTOUIC` 忽略。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0100.rst:14
msgid ""
"This policy affects how header files that end with a ``.hh`` extension get"
" treated in :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC`."
msgstr ""
"此策略会影响以 .hh 扩展名结尾的头文件在 :prop_tgt:`AUTOMOC` 和 :prop_tgt:`AUTOUIC` 中的处理方式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0100.rst:17
msgid ""
"The ``OLD`` behavior for this policy is to ignore ``.hh`` header files in "
":prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC`."
msgstr ""
"此策略的“旧”行为是忽略 :prop_tgt:`AUTOMOC` 和 :prop_tgt:`AUTOUIC` 中的 `.hh`` 头文件。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0100.rst:20
msgid ""
"The ``NEW`` behavior for this policy is to process ``.hh`` header files in"
" :prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC` just like other header files."
msgstr ""
"此策略的“新”行为是处理 :prop_tgt:`AUTOMOC` 和 :prop_tgt:`AUTOUIC` 中的 `.hh`` "
"头文件，就像处理其他头文件一样。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0100.rst:25
msgid ""
"To silence the ``CMP0100`` warning source files can be excluded from "
":prop_tgt:`AUTOMOC` and :prop_tgt:`AUTOUIC` processing by setting the "
"source file properties :prop_sf:`SKIP_AUTOMOC`, :prop_sf:`SKIP_AUTOUIC` or"
" :prop_sf:`SKIP_AUTOGEN`."
msgstr ""
"要使“CMP0100”警告源文件静音，可以通过设置源文件属性:prop_sf:`SKIP_AUTOMOC`、 :prop_sf:`SKIP_AUTOUIC`"
" 或： prop_sf:`SKIP_AUTOGEN`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0100.rst:37
msgid ""
"This policy was introduced in CMake version 3.17.0.  CMake version "
"|release| warns when the policy is not set and uses ``OLD`` behavior. Use "
"the :command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.17.0 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0101.rst:2
msgid "CMP0101"
msgstr "CMP0101"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0101.rst:6
msgid ""
":command:`target_compile_options` now always honors the ``BEFORE`` "
"keyword."
msgstr ":command:`target_compile_options` 现在总是支持 ``BEFORE`` 关键字。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0101.rst:8
msgid ""
"In CMake 3.16 and below, the :command:`target_compile_options` command "
"ignores the ``BEFORE`` keyword when inserting items into the "
":prop_tgt:`COMPILE_OPTIONS` target property (``PRIVATE`` and ``PUBLIC`` "
"items).  CMake 3.17 and later honors the ``BEFORE`` keyword in all cases. "
"This policy provides compatibility for projects that have not been updated"
" to expect the new behavior."
msgstr ""
"在 CMake 3.16 及以下版本中， :command:`target_compile_options` 命令在将项目插入 "
":prop_tgt:`COMPILE_OPTIONS` 目标属性（``PRIVATE`` 和 ``PUBLIC`` 项目）时忽略 "
"``BEFORE`` 关键字。 CMake 3.17 及更高版本在所有情况下都支持 ``BEFORE`` "
"关键字。此策略为尚未更新以期待新行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0101.rst:15
msgid ""
"The behavior of inserting items into the "
":prop_tgt:`INTERFACE_COMPILE_OPTIONS` target property (``PUBLIC`` and "
"``INTERFACE`` items) is not affected by this policy.  The ``BEFORE`` "
"keyword has always been honored when adding items to "
":prop_tgt:`INTERFACE_COMPILE_OPTIONS`."
msgstr ""
"将项目插入 INTERFACE_COMPILE_OPTIONS 目标属性（``PUBLIC`` 和 ``INTERFACE`` "
"项目）的行为不受此策略的影响。将项目添加到 :prop_tgt:`INTERFACE_COMPILE_OPTIONS` 时，始终遵循 "
"``BEFORE`` 关键字。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0101.rst:20
msgid ""
"The ``OLD`` behavior for this policy is to not honor the ``BEFORE`` "
"keyword when inserting into the :prop_tgt:`COMPILE_OPTIONS` property. The "
"``NEW`` behavior for this policy is to honor the ``BEFORE`` keyword in all"
" cases."
msgstr ""
"此策略的“旧”行为是在插入 COMPILE_OPTIONS "
"属性时不遵守“BEFORE”关键字。此策略的“新”行为是在所有情况下都遵循“BEFORE”关键字。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0102.rst:2
msgid "CMP0102"
msgstr "CMP0102"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0102.rst:6
msgid ""
"The :command:`mark_as_advanced` command no longer creates a cache entry if"
" one does not already exist."
msgstr ":command:`mark_as_advanced` 命令不再创建不存在的缓存条目。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0102.rst:9
msgid ""
"In CMake 3.16 and below, if a variable was not defined at all or just "
"defined locally, the :command:`mark_as_advanced` command would create a "
"new cache entry with an ``UNINITIALIZED`` type and no value. When a "
":command:`find_path` (or other similar ``find_`` command) would next run, "
"it would find this undefined cache entry and set it up with an empty "
"string value. This process would end up deleting the local variable in the"
" process (due to the way the cache works), effectively clearing any stored"
" ``find_`` results that were only available in the local scope."
msgstr ""
"在 CMake 3.16 及以下版本中，如果变量根本未定义或仅在本地定义，则 :command:`mark_as_advanced` "
"命令将创建一个具有 ``UNINITIALIZED`` 类型且没有值的新缓存条目。当 :command:`find_path`（或其他类似的 "
"``find_`` "
"命令）下次运行时，它会找到这个未定义的缓存条目并将其设置为空字符串值。这个过程最终会删除过程中的局部变量（由于缓存的工作方式），有效地清除所有仅在局部范围内可用的存储的“find_”结果。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0102.rst:18
msgid ""
"The ``OLD`` behavior for this policy is to create the empty cache "
"definition. The ``NEW`` behavior of this policy is to ignore variables "
"which do not already exist in the cache."
msgstr "此策略的“旧”行为是创建空缓存定义。此策略的“新”行为是忽略缓存中尚不存在的变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0102.rst:22
msgid ""
"This policy was introduced in CMake version 3.17.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior.  See "
"documentation of the :variable:`CMAKE_POLICY_WARNING_CMP0102 "
"<CMAKE_POLICY_WARNING_CMP<NNNN>>` variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.17 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0102 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0103.rst:2
msgid "CMP0103"
msgstr "CMP0103"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0103.rst:6
msgid ""
"Multiple calls to :command:`export` command with same ``FILE`` without "
"``APPEND`` is no longer allowed."
msgstr "不再允许使用相同的 FILE 而没有 APPEND 多次调用 export 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0103.rst:9
msgid ""
"In CMake 3.17 and below, multiple calls to :command:`export` command with "
"the same ``FILE`` without ``APPEND`` are accepted silently but only the "
"last occurrence is taken into account during the generation."
msgstr ""
"在 CMake 3.17 及以下版本中，使用相同的 FILE 而没有 APPEND 对 :command:`export` "
"命令的多次调用被静默接受，但在生成过程中只考虑最后一次出现的情况。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0103.rst:14
msgid ""
"The ``OLD`` behavior for this policy is to ignore the multiple occurrences"
" of"
msgstr "此策略的“旧”行为是忽略多次出现的"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0103.rst:14
msgid ":command:`export` command except the last one."
msgstr ":command:`export` 命令，除了最后一个。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0103.rst:16
msgid ""
"The ``NEW`` behavior of this policy is to raise an error on second call to"
" :command:`export` command with same ``FILE`` without ``APPEND``."
msgstr ""
"此策略的“新”行为是在第二次调用 :command:`export` 命令时使用相同的 ``FILE`` 而没有 ``APPEND`` 时引发错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0103.rst:19
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:32
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0106.rst:17
msgid ""
"This policy was introduced in CMake version 3.18.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.18 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:2
msgid "CMP0104"
msgstr "CMP0104"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:6
msgid ""
"Initialize :variable:`CMAKE_CUDA_ARCHITECTURES` when "
":variable:`CMAKE_CUDA_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID>` is "
"``NVIDIA``. Raise an error if :prop_tgt:`CUDA_ARCHITECTURES` is empty."
msgstr ""
"当 CMAKE_CUDA_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID> 是 NVIDIA 时初始化 "
"CMAKE_CUDA_ARCHITECTURES。如果 :prop_tgt:`CUDA_ARCHITECTURES` 为空，则引发错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:10
msgid ""
":variable:`CMAKE_CUDA_ARCHITECTURES` introduced in CMake 3.18 is used to "
"initialize :prop_tgt:`CUDA_ARCHITECTURES`, which passes correct code "
"generation flags to the CUDA compiler."
msgstr ""
"CMake 3.18 中引入的 :variable:`CMAKE_CUDA_ARCHITECTURES` 用于初始化 "
":prop_tgt:`CUDA_ARCHITECTURES`，它将正确的代码生成标志传递给 CUDA 编译器。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:14
msgid ""
"Previous to this users had to manually specify the code generation flags. "
"This policy is for backwards compatibility with manually specifying code "
"generation flags."
msgstr "在此之前，用户必须手动指定代码生成标志。此策略是为了向后兼容手动指定代码生成标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:18
msgid ""
"The ``OLD`` behavior for this policy is to not initialize "
":variable:`CMAKE_CUDA_ARCHITECTURES` when "
":variable:`CMAKE_CUDA_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID>` is "
"``NVIDIA``. Empty :prop_tgt:`CUDA_ARCHITECTURES` is allowed."
msgstr ""
"当 CMAKE_CUDA_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID> 为 ``NVIDIA`` "
"时，此策略的“旧”行为是不初始化 CMAKE_CUDA_ARCHITECTURES。空的 "
":prop_tgt:`CUDA_ARCHITECTURES` 是允许的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:23
msgid ""
"The ``NEW`` behavior of this policy is to initialize "
":variable:`CMAKE_CUDA_ARCHITECTURES` when "
":variable:`CMAKE_CUDA_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID>` is "
"``NVIDIA`` and raise an error if :prop_tgt:`CUDA_ARCHITECTURES` is empty "
"during generation."
msgstr ""
"此策略的“新”行为是在 CMAKE_CUDA_COMPILER_ID <CMAKE_<LANG>_COMPILER_ID> "
"为“NVIDIA”时初始化 CMAKE_CUDA_ARCHITECTURES，如果 CUDA_ARCHITECTURES 则引发错误在生成期间为空。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:28
msgid ""
"If :prop_tgt:`CUDA_ARCHITECTURES` is set to a false value no architectures"
" flags are passed to the compiler. This is intended to support packagers "
"and the rare cases where full control over the passed flags is required."
msgstr ""
"如果 :prop_tgt:`CUDA_ARCHITECTURES` 设置为 false "
"值，则不会将架构标志传递给编译器。这是为了支持打包程序和需要完全控制传递的标志的罕见情况。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:46
msgid ""
"Generates code for real and virtual architectures ``30``, ``50`` and "
"``72``."
msgstr "为真实和虚拟架构“30”、“50”和“72”生成代码。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:52
msgid ""
"Generates code for real architecture ``70`` and virtual architecture "
"``72``."
msgstr "为真实架构“70”和虚拟架构“72”生成代码。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0104.rst:58
msgid "CMake will not pass any architecture flags to the compiler."
msgstr "CMake 不会将任何架构标志传递给编译器。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0105.rst:2
msgid "CMP0105"
msgstr "CMP0105"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0105.rst:6
msgid ""
":prop_tgt:`LINK_OPTIONS` and :prop_tgt:`INTERFACE_LINK_OPTIONS` target "
"properties are now used for the device link step."
msgstr ""
":prop_tgt:`LINK_OPTIONS` 和 :prop_tgt:`INTERFACE_LINK_OPTIONS` "
"目标属性现在用于设备链接步骤。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0105.rst:9
msgid ""
"In CMake 3.17 and below, link options are not used by the device link "
"step."
msgstr "在 CMake 3.17 及以下版本中，设备链接步骤不使用链接选项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0105.rst:11
msgid ""
"The ``OLD`` behavior for this policy is to ignore the link options during "
"the device link step."
msgstr "此策略的“旧”行为是在设备链接步骤中忽略链接选项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0105.rst:14
msgid ""
"The ``NEW`` behavior of this policy is to use the link options during the "
"device link step."
msgstr "此策略的“新”行为是在设备链接步骤中使用链接选项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0105.rst:17
msgid ""
"This policy was introduced in CMake version 3.18.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.18 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0106.rst:2
msgid "CMP0106"
msgstr "CMP0106"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0106.rst:6
msgid "The :module:`Documentation` module is removed."
msgstr ":module:`Documentation` 模块被移除。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0106.rst:8
msgid ""
"The :module:`Documentation` was added as a support mechanism for the VTK "
"project and was tuned for that project. Instead of CMake providing this "
"module with (now old) VTK patterns for cache variables and required "
"packages, the module is now deprecated by CMake itself."
msgstr ""
"添加 :module:`Documentation` 作为 VTK 项目的支持机制，并针对该项目进行了调整。 CMake "
"不再为该模块提供用于缓存变量和所需包的（现在是旧的）VTK 模式，而是该模块现在已被 CMake 本身弃用。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0106.rst:13
msgid ""
"The ``OLD`` behavior of this policy is for :module:`Documentation` to add "
"cache variables and find VTK documentation dependent packages. The ``NEW``"
" behavior is to act as an empty module."
msgstr ""
"此策略的“旧”行为是为 :module:`Documentation 添加缓存变量并查找 VTK 文档依赖包。 ``NEW`` "
"行为是作为一个空模块。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0107.rst:2
msgid "CMP0107"
msgstr "CMP0107"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0107.rst:6
msgid ""
"It is not allowed to create an ``ALIAS`` target with the same name as an "
"another target."
msgstr "不允许创建与另一个目标同名的 ``ALIAS`` 目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0107.rst:9
msgid ""
"In CMake 3.17 and below, an ``ALIAS`` target can overwrite silently an "
"existing target with the same name."
msgstr "在 CMake 3.17 及以下版本中，“ALIAS”目标可以静默覆盖具有相同名称的现有目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0107.rst:12
msgid "The ``OLD`` behavior for this policy is to allow target overwrite."
msgstr "此策略的“旧”行为是允许目标覆盖。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0107.rst:14
msgid ""
"The ``NEW`` behavior of this policy is to prevent target overwriting."
msgstr "此策略的“新”行为是为了防止目标覆盖。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0108.rst:2
msgid "CMP0108"
msgstr "CMP0108"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0108.rst:6
msgid ""
"A target is not allowed to link to itself even through an ``ALIAS`` "
"target."
msgstr "即使通过“ALIAS”目标，也不允许目标链接到自身。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0108.rst:8
msgid ""
"In CMake 3.17 and below, a target can link to a target aliased to itself."
msgstr "在 CMake 3.17 及以下版本中，目标可以链接到别名为自身的目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0108.rst:10
msgid ""
"The ``OLD`` behavior for this policy is to allow a target to link to a "
"target aliased to itself."
msgstr "此策略的“旧”行为是允许目标链接到别名为自身的目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0108.rst:13
msgid ""
"The ``NEW`` behavior of this policy is to prevent a target to link to "
"itself through an ``ALIAS`` target."
msgstr "此策略的“新”行为是防止目标通过“别名”目标链接到自身。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0109.rst:2
msgid "CMP0109"
msgstr "CMP0109"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0109.rst:6
msgid ""
":command:`find_program` requires permission to execute but not to read."
msgstr ":command:`find_program` 需要执行权限而不是读取权限。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0109.rst:8
msgid ""
"In CMake 3.18 and below, the :command:`find_program` command on UNIX would"
" find files that are readable without requiring execute permission, and "
"would not find files that are executable without read permission. In CMake"
" 3.19 and above, ``find_program`` now prefers to require execute "
"permission but not read permission.  This policy provides compatibility "
"with projects that have not been updated to expect the new behavior."
msgstr ""
"在 CMake 3.18 及以下版本中，UNIX 上的 :command:`find_program` "
"命令会查找无需执行权限即可读取的文件，而不会查找无需读取权限即可执行的文件。在 CMake 3.19 及更高版本中，``find_program``"
" 现在更倾向于要求执行权限而不是读取权限。此策略提供与尚未更新以期待新行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0109.rst:15
msgid ""
"The ``OLD`` behavior for this policy is for ``find_program`` to require "
"read permission but not execute permission. The ``NEW`` behavior for this "
"policy is for ``find_program`` to require execute permission but not read "
"permission."
msgstr ""
"此策略的“旧”行为是“find_program”需要读取权限但不需要执行权限。此策略的“新”行为是“find_program”需要执行权限但不需要读取权限。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0109.rst:20
msgid ""
"This policy was introduced in CMake version 3.19.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.19 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0110.rst:2
msgid "CMP0110"
msgstr "CMP0110"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0110.rst:6
msgid ":command:`add_test` supports arbitrary characters in test names."
msgstr ":command:`add_test` 支持测试名称中的任意字符。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0110.rst:8
msgid ""
":command:`add_test` can now (officially) create tests with whitespace and "
"other special characters in its name.  Before CMake version 3.19 that was "
"not allowed, however, it was possible to work around this limitation by "
"explicitly putting escaped quotes around the test's name in the "
"``add_test`` command."
msgstr ""
":command:`add_test` 现在可以（正式）创建名称中包含空格和其他特殊字符的测试。然而，在不允许的 CMake 3.19 "
"版之前，可以通过在“add_test”命令中明确地将转义引号放在测试名称周围来解决此限制。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0110.rst:13
msgid ""
"Although never officially supported several projects in the wild found and"
" implemented this workaround.  However, the new change which officially "
"allows the ``add_test`` command to support whitespace and other special "
"characters in test names now breaks that workaround.  In order for these "
"projects to work smoothly with newer CMake versions, this policy was "
"introduced."
msgstr ""
"尽管从未正式支持过几个野外项目，但发现并实施了此解决方法。但是，正式允许 ``add_test`` "
"命令支持测试名称中的空格和其他特殊字符的新更改现在打破了该解决方法。为了使这些项目能够与较新的 CMake 版本顺利协作，引入了此策略。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0110.rst:19
msgid ""
"The ``OLD`` behavior of this policy is to still prevent ``add_test`` from "
"handling whitespace and special characters properly (if not using the "
"mentioned workaround).  The ``NEW`` behavior on the other hand allows "
"names with whitespace and special characters for tests created by "
"``add_test``."
msgstr ""
"此策略的“旧”行为仍然阻止“add_test”正确处理空格和特殊字符（如果不使用上述解决方法）。另一方面，``NEW`` "
"行为允许带有空格和特殊字符的名称用于由``add_test`` 创建的测试。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0110.rst:24
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0111.rst:23
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:82
msgid ""
"This policy was introduced in CMake version 3.19.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.19 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0111.rst:2
msgid "CMP0111"
msgstr "CMP0111"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0111.rst:6
msgid ""
"An imported target missing its location property fails during generation."
msgstr "缺少其位置属性的导入目标在生成过程中失败。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0111.rst:8
msgid ""
":ref:`Imported Targets` for library files and executables require that "
"their location on disk is specified in a target property such as "
":prop_tgt:`IMPORTED_LOCATION`, :prop_tgt:`IMPORTED_IMPLIB`, or a per-"
"configuration equivalent.  If a needed location property is not set, CMake"
" 3.18 and below generate the string ``<TARGET_NAME>-NOTFOUND`` in its "
"place, which results in failures of the corresponding rules at build time."
"  CMake 3.19 and above prefer instead to raise an error during generation."
"  This policy provides compatibility for projects that have not been "
"updated to expect the new behavior."
msgstr ""
"库文件和可执行文件的导入目标要求它们在磁盘上的位置在目标属性中指定，例如:prop_tgt:`IMPORTED_LOCATION`、 :prop_tgt:`IMPORTED_IMPLIB`"
" 或每个配置的等效项。如果未设置所需的位置属性，CMake 3.18 "
"及以下版本会在其位置生成字符串“<TARGET_NAME>-NOTFOUND”，这会导致构建时相应规则失败。 CMake 3.19 "
"及更高版本更喜欢在生成期间引发错误。此策略为尚未更新以期待新行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0111.rst:18
msgid ""
"The ``OLD`` behavior of this policy is to generate the location of an "
"imported unknown, static or shared library target as "
"``<TARGET_NAME>-NOTFOUND`` if not set. The ``NEW`` behavior is to raise an"
" error."
msgstr ""
"如果未设置，此策略的“旧”行为是将导入的未知、静态或共享库目标的位置生成为“<TARGET_NAME>-NOTFOUND”。 ``NEW`` "
"行为是引发错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:2
msgid "CMP0112"
msgstr "CMP0112"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:6
msgid ""
"Target file component generator expressions do not add target "
"dependencies."
msgstr "目标文件组件生成器表达式不添加目标依赖项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:8
msgid ""
"The following target-based generator expressions that query for directory "
"or file name components no longer add a dependency on the evaluated "
"target."
msgstr "以下查询目录或文件名组件的基于目标的生成器表达式不再添加对评估目标的依赖性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:11
msgid "``TARGET_FILE_NAME``"
msgstr "``TARGET_FILE_NAME``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:12
msgid "``TARGET_FILE_DIR``"
msgstr "``TARGET_FILE_DIR``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:13
msgid "``TARGET_LINKER_FILE_BASE_NAME``"
msgstr "``TARGET_LINKER_FILE_BASE_NAME``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:14
msgid "``TARGET_LINKER_FILE_NAME``"
msgstr "``TARGET_LINKER_FILE_NAME``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:15
msgid "``TARGET_LINKER_FILE_DIR``"
msgstr "``TARGET_LINKER_FILE_DIR``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:16
msgid "``TARGET_SONAME_FILE_NAME``"
msgstr "``TARGET_SONAME_FILE_NAME``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:17
msgid "``TARGET_SONAME_FILE_DIR``"
msgstr "``TARGET_SONAME_FILE_DIR``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:18
msgid "``TARGET_PDB_FILE_NAME``"
msgstr "``TARGET_PDB_FILE_NAME``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:19
msgid "``TARGET_PDB_FILE_DIR``"
msgstr "``TARGET_PDB_FILE_DIR``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:20
msgid "``TARGET_BUNDLE_DIR``"
msgstr "``TARGET_BUNDLE_DIR``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:21
msgid "``TARGET_BUNDLE_DIR_NAME``"
msgstr "``TARGET_BUNDLE_DIR_NAME``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:22
msgid "``TARGET_BUNDLE_CONTENT_DIR``"
msgstr "``TARGET_BUNDLE_CONTENT_DIR``"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:25
msgid ""
"In CMake 3.18 and lower a dependency on the evaluated target of the above "
"generator expressions would always be added.  CMake 3.19 and above prefer "
"to not add this dependency.  This policy provides compatibility for "
"projects that have not been updated to expect the new behavior.  The "
"policy setting is recorded on each target when it is created, and decides "
"whether generator expressions referencing that target imply a dependency "
"on it."
msgstr ""
"在 CMake 3.18 及更低版本中，将始终添加对上述生成器表达式的评估目标的依赖。 CMake 3.19 "
"及更高版本倾向于不添加此依赖项。此策略为尚未更新以期待新行为的项目提供兼容性。策略设置在创建目标时记录在每个目标上，并决定引用该目标的生成器表达式是否暗示对它的依赖。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:32
msgid ""
"The ``OLD`` behavior for this policy is to add a dependency on the "
"evaluated target for the above generator expressions.  The ``NEW`` "
"behavior of this policy is to not add a dependency on the evaluated target"
" for the above generator expressions."
msgstr "此策略的“旧”行为是为上述生成器表达式添加对评估目标的依赖。此策略的“新”行为是不为上述生成器表达式添加对评估目标的依赖。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0112.rst:37
msgid ""
"This policy was introduced in CMake version 3.19.  Unlike many policies, "
"CMake version |release| does *not* warn by default when this policy is not"
" set and simply uses ``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0112 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.19 中引入的。与许多政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0112 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0113.rst:2
msgid "CMP0113"
msgstr "CMP0113"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0113.rst:6
msgid ""
":ref:`Makefile Generators` do not repeat custom commands from target "
"dependencies."
msgstr ":ref:`Makefile Generators` 不会重复来自目标依赖项的自定义命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0113.rst:9
msgid ""
"Consider a chain of custom commands split across two dependent targets:"
msgstr "考虑拆分为两个相关目标的自定义命令链："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0113.rst:22
msgid ""
"In CMake 3.18 and lower, the Makefile generators put a copy of both custom"
" commands in the Makefile for target ``second`` even though its dependency"
" on target ``first`` ensures that the first custom command runs before the"
" second. Running ``make second`` would cause the first custom command to "
"run once in the ``first`` target and then again in the ``second`` target."
msgstr ""
"在 CMake 3.18 及更低版本中，Makefile 生成器将两个自定义命令的副本放入目标“second”的 Makefile "
"中，即使它对目标“first”的依赖确保第一个自定义命令在第二个之前运行。运行“make "
"second”会导致第一个自定义命令在“first”目标中运行一次，然后在“second”目标中再次运行。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0113.rst:28
msgid ""
"CMake 3.19 and above prefer to not duplicate custom commands in a target "
"that are already generated in other targets on which the target depends "
"(directly or indirectly).  This policy provides compatibility for projects"
" that have not been updated to expect the new behavior.  In particular, "
"projects that relied on the duplicate execution or that did not properly "
"set the :prop_sf:`SYMBOLIC` source file property may be affected."
msgstr ""
"CMake 3.19 "
"及更高版本倾向于不在目标中复制已经在该目标所依赖的其他目标（直接或间接）中生成的自定义命令。此策略为尚未更新以期待新行为的项目提供兼容性。特别是，依赖重复执行或未正确设置"
" SYMBOLIC 源文件属性的项目可能会受到影响。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0113.rst:35
msgid ""
"The ``OLD`` behavior for this policy is to duplicate custom commands in "
"dependent targets.  The ``NEW`` behavior of this policy is to not "
"duplicate custom commands in dependent targets."
msgstr "此策略的“旧”行为是在相关目标中复制自定义命令。此策略的“新”行为是不在依赖目标中复制自定义命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0113.rst:39
msgid ""
"This policy was introduced in CMake version 3.19.  Unlike many policies, "
"CMake version |release| does *not* warn when this policy is not set and "
"simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.19 中引入的。与许多政策不同，CMake 版本 "
"|release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:2
msgid "CMP0114"
msgstr "CMP0114"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:6
msgid ":module:`ExternalProject` step targets fully adopt their steps."
msgstr ":module:`ExternalProject` 步骤目标完全采用他们的步骤。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:8
msgid ""
"The :command:`ExternalProject_Add` ``STEP_TARGETS`` option, and the "
":command:`ExternalProject_Add_StepTargets` function, can be used to create"
" build targets for individual steps of an external project."
msgstr ""
":command:`ExternalProject_Add` ``STEP_TARGETS`` 选项和 "
":command:`ExternalProject_Add_StepTargets` 函数可用于为外部项目的各个步骤创建构建目标。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:12
msgid "In CMake 3.18 and below, step targets have some limitations:"
msgstr "在 CMake 3.18 及以下版本中，步骤目标有一些限制："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:14
msgid ""
"Step targets always depend on targets named by the "
":command:`ExternalProject_Add` ``DEPENDS`` option even though not all "
"steps need them.  In order to allow step targets to be created without "
"those dependencies, the :command:`ExternalProject_Add` "
"``INDEPENDENT_STEP_TARGETS`` option or the "
":command:`ExternalProject_Add_StepTargets` ``NO_DEPENDS`` option may be "
"used.  However, adding such \"independent\" step targets makes sense only "
"for specific steps such as ``download``, ``update``, and ``patch`` because"
" they do not need any of the external project's build dependencies. "
"Furthermore, it does not make sense to create independent step targets for"
" steps that depend on non-independent steps.  Such rules are not enforced,"
" and projects that do not follow them can generate build systems with "
"confusing and generator-specific behavior."
msgstr ""
"步骤目标始终取决于由 :command:`ExternalProject_Add` ``DEPENDS`` "
"选项命名的目标，即使并非所有步骤都需要它们。为了允许在没有这些依赖项的情况下创建步骤目标，可以使用 "
":command:`ExternalProject_Add` ``INDEPENDENT_STEP_TARGETS`` 选项或 "
":command:`ExternalProject_Add_StepTargets` ``NO_DEPENDS`` "
"选项。但是，添加此类“独立”步骤目标仅对特定步骤（例如“下载”、“更新”和“补丁”）有意义，因为它们不需要任何外部项目的构建依赖项。此外，为依赖于非独立步骤的步骤创建独立步骤目标没有意义。此类规则并未强制执行，不遵循这些规则的项目可能会生成具有混乱且特定于生成器行为的构建系统。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:28
msgid ""
"Step targets hold copies of the custom commands implementing their steps "
"that are separate from the copies in the primary target created by "
":command:`ExternalProject_Add`, and the primary target does not depend on "
"the step targets.  In parallel builds that drive the primary target and "
"step targets concurrently, multiple copies of the steps' commands may run "
"concurrently and race each other."
msgstr ""
"步骤目标包含实现其步骤的自定义命令的副本，这些副本与由 :command:`ExternalProject_Add` "
"创建的主要目标中的副本分开，并且主要目标不依赖于步骤目标。在同时驱动主要目标和步骤目标的并行构建中，步骤命令的多个副本可能同时运行并相互竞争。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:35
msgid ""
"Also, prior to policy :policy:`CMP0113`, the step targets generated by "
":ref:`Makefile Generators` also contain all the custom commands on which "
"their step depends.  This can lead to repeated execution of those steps "
"even in serial builds."
msgstr ""
"此外，在策略 CMP0113 之前，由 Makefile Generators "
"生成的步骤目标还包含其步骤所依赖的所有自定义命令。即使在串行构建中，这也可能导致重复执行这些步骤。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:40
msgid ""
"In CMake 3.19 and above, the :module:`ExternalProject` module prefers a "
"revised design to address these problems:"
msgstr "在 CMake 3.19 及更高版本中， :module:`ExternalProject` 模块更喜欢修改设计来解决这些问题："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:43
msgid ""
"Each step is classified as \"independent\" if it does not depend on other "
"targets named by the :command:`ExternalProject_Add` ``DEPENDS``. The "
"predefined steps are automatically classified by default:"
msgstr ""
"如果每个步骤不依赖于由 ExternalProject_Add ``DEPENDS`` "
"命名的其他目标，则它被归类为“独立”。预定义步骤默认自动分类："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:47
msgid "The ``download``, ``update``, and ``patch`` steps are independent."
msgstr "“下载”、“更新”和“补丁”步骤是独立的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:48
msgid ""
"The ``configure``, ``build``, ``test``, and ``install`` steps are not."
msgstr "“配置”、“构建”、“测试”和“安装”步骤不是。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:50
msgid ""
"For custom steps, the :command:`ExternalProject_Add_Step` command provides"
" an ``INDEPENDENT`` option to mark them as independent.  It is an error to"
" mark a step as independent if it depends on other steps that are not.  "
"Note that this use of the term \"independent\" refers only to independence"
" from external targets and is orthogonal to a step's dependencies on other"
" steps."
msgstr ""
"对于自定义步骤， :command:`ExternalProject_Add_Step` 命令提供了一个 ``INDEPENDENT`` "
"选项来将它们标记为独立的。如果某个步骤依赖于其他非独立步骤，则将其标记为独立步骤是错误的。请注意，术语“独立”的这种使用仅指独立于外部目标并且与步骤对其他步骤的依赖性正交。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:56
msgid ""
"Step targets created by the :command:`ExternalProject_Add` "
"``STEP_TARGETS`` option or the :command:`ExternalProject_Add_Step` "
"function are now independent if and only if their steps are marked as "
"independent. The :command:`ExternalProject_Add` "
"``INDEPENDENT_STEP_TARGETS`` option and "
":command:`ExternalProject_Add_StepTargets` ``NO_DEPENDS`` option are no "
"longer allowed."
msgstr ""
"由 :command:`ExternalProject_Add` ``STEP_TARGETS`` 选项或 "
":command:`ExternalProject_Add_Step` 函数创建的步骤目标现在是独立的，当且仅当它们的步骤被标记为独立时。 "
":command:`ExternalProject_Add` ``INDEPENDENT_STEP_TARGETS`` 选项和 "
":command:`ExternalProject_Add_StepTargets` ``NO_DEPENDS`` 选项不再被允许。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:63
msgid ""
"Step targets, when created, are fully responsible for holding the custom "
"commands implementing their steps.  The primary target created by "
":command:`ExternalProject_Add` depends on the step targets, and the step "
"targets depend on each other.  The target-level dependencies match the "
"file-level dependencies used by the custom commands for each step."
msgstr ""
"步骤目标在创建时完全负责保存实现其步骤的自定义命令。 :command:`ExternalProject_Add` "
"创建的主要目标依赖于步骤目标，步骤目标相互依赖。目标级依赖项与每个步骤的自定义命令使用的文件级依赖项相匹配。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:69
msgid ""
"When the :command:`ExternalProject_Add` ``UPDATE_DISCONNECTED`` or "
"``TEST_EXCLUDE_FROM_MAIN`` option is used, or the "
":command:`ExternalProject_Add_Step` ``EXCLUDE_FROM_MAIN`` option is used "
"for a custom step, some step targets may be created automatically. These "
"are needed to hold the steps commonly depended upon by the primary target "
"and the disconnected step targets."
msgstr ""
"当使用 :command:`ExternalProject_Add` ``UPDATE_DISCONNECTED`` 或 "
"``TEST_EXCLUDE_FROM_MAIN`` 选项，或 :command:`ExternalProject_Add_Step` "
"``EXCLUDE_FROM_MAIN`` "
"选项用于自定义步骤时，可能会创建一些步骤目标自动地。需要这些来保存主要目标和断开连接的步骤目标通常依赖的步骤。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0114.rst:76
msgid ""
"Policy ``CMP0114`` provides compatibility for projects that have not been "
"updated to expect the new behavior.  The ``OLD`` behavior for this policy "
"is to use the above-documented behavior from 3.18 and below.  The ``NEW`` "
"behavior for this policy is to use the above-documented behavior preferred"
" by 3.19 and above."
msgstr ""
"策略“CMP0114”为尚未更新以期待新行为的项目提供兼容性。此策略的“旧”行为是使用 3.18 "
"及以下版本中记录的上述行为。此策略的“新”行为是使用 3.19 及更高版本首选的上述记录行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0115.rst:2
msgid "CMP0115"
msgstr "CMP0115"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0115.rst:6
msgid "Source file extensions must be explicit."
msgstr "源文件扩展名必须是明确的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0115.rst:8
msgid ""
"In CMake 3.19 and below, if a source file could not be found by the name "
"specified, it would append a list of known extensions to the name to see "
"if the file with the extension could be found. For example, this would "
"allow the user to run:"
msgstr ""
"在 CMake 3.19 "
"及以下版本中，如果无法通过指定的名称找到源文件，它将在名称后附加一个已知扩展名的列表，以查看是否可以找到具有该扩展名的文件。例如，这将允许用户运行："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0115.rst:17
msgid ""
"and put ``main.c`` in the executable without specifying the extension."
msgstr "并在不指定扩展名的情况下将 ``main.c`` 放入可执行文件中。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0115.rst:19
msgid ""
"Starting in CMake 3.20, CMake prefers all source files to have their "
"extensions explicitly listed:"
msgstr "从 CMake 3.20 开始，CMake 更喜欢所有源文件都明确列出其扩展名："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0115.rst:26
msgid ""
"The ``OLD`` behavior for this policy is to implicitly append known "
"extensions to source files if they can't be found. The ``NEW`` behavior of"
" this policy is to not append known extensions and require them to be "
"explicit."
msgstr "此策略的“旧”行为是在找不到源文件时隐式将已知扩展名附加到源文件。此策略的“新”行为是不附加已知扩展并要求它们是显式的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0115.rst:30
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:41
msgid ""
"This policy was introduced in CMake version 3.20.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.20 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0116.rst:2
msgid "CMP0116"
msgstr "CMP0116"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0116.rst:6
msgid ""
"Ninja generators transform ``DEPFILE`` s from "
":command:`add_custom_command`."
msgstr "Ninja 生成器从 :command:`add_custom_command` 转换``DEPFILE``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0116.rst:8
msgid ""
"In CMake 3.19 and below, files given to the ``DEPFILE`` argument of "
":command:`add_custom_command` were passed directly to Ninja's ``depfile`` "
"variable without any path resolution. This meant that if "
":command:`add_custom_command` was called from a subdirectory (created by "
":command:`add_subdirectory`), the ``DEPFILE`` argument would have to be "
"either an absolute path or a path relative to "
":variable:`CMAKE_BINARY_DIR`, rather than "
":variable:`CMAKE_CURRENT_BINARY_DIR`. In addition, no transformation was "
"done on the file listed in ``DEPFILE``, which meant that the paths within "
"the ``DEPFILE`` had the same restrictions."
msgstr ""
"在 CMake 3.19 及以下版本中，提供给 add_custom_command 的 ``DEPFILE`` 参数的文件直接传递给 Ninja "
"的 ``depfile`` 变量，没有任何路径解析。这意味着如果从子目录（由 add_subdirectory 创建）调用 "
"add_custom_command，则 DEPFILE 参数必须是绝对路径或相对于 :variable: "
"的路径CMAKE_BINARY_DIR`，而不是 :variable:`CMAKE_CURRENT_BINARY_DIR`。此外，没有对 ``DEPFILE`` "
"中列出的文件进行任何转换，这意味着 ``DEPFILE`` 中的路径具有相同的限制。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0116.rst:18
msgid ""
"Starting with CMake 3.20, the ``DEPFILE`` argument is relative to "
":variable:`CMAKE_CURRENT_BINARY_DIR` (unless it is absolute), and the "
"paths in the ``DEPFILE`` are also relative to "
":variable:`CMAKE_CURRENT_BINARY_DIR`. CMake automatically transforms the "
"paths in the ``DEPFILE`` (unless they are absolute) after the custom "
"command is run. The file listed in ``DEPFILE`` is not modified in any way."
" Instead, CMake writes the transformation to its own internal file, and "
"passes this internal file to Ninja's ``depfile`` variable. This "
"transformation happens regardless of whether or not ``DEPFILE`` is "
"relative, and regardless of whether or not :command:`add_custom_command` "
"is called from a subdirectory."
msgstr ""
"从 CMake 3.20 开始，``DEPFILE`` 参数与 :variable:`CMAKE_CURRENT_BINARY_DIR` "
"相关（除非它是绝对的），``DEPFILE`` 中的路径也与 :variable:`CMAKE_CURRENT_BINARY_DIR` "
"相关。运行自定义命令后，CMake 会自动转换 DEPFILE 中的路径（除非它们是绝对路径）。 ``DEPFILE`` "
"中列出的文件未以任何方式修改。相反，CMake 将转换写入其自己的内部文件，并将该内部文件传递给 Ninja "
"的“depfile”变量。无论``DEPFILE`` 是否是相对的，也不管是否从子目录调用 add_custom_command 都会发生这种转换。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0116.rst:29
msgid ""
"The ``OLD`` behavior for this policy is to pass the ``DEPFILE`` to Ninja "
"unaltered. The ``NEW`` behavior for this policy is to transform the "
"``DEPFILE`` after running the custom command. The status of ``CMP0116`` is"
" recorded at the time of the custom command's creation, and you can have "
"custom commands in the same directory with different values for "
"``CMP0116`` by setting the policy before each custom command."
msgstr ""
"此策略的“旧”行为是将“DEPFILE”原封不动地传递给 Ninja。此策略的“新”行为是在运行自定义命令后转换“DEPFILE”。 "
"``CMP0116`` 的状态在创建自定义命令时被记录下来，您可以通过在每个自定义命令之前设置策略，在同一目录中为 ``CMP0116`` "
"设置不同值的自定义命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0116.rst:36
msgid ""
"This policy was introduced in CMake version 3.20.  Unlike most policies, "
"CMake version |release| does *not* warn by default when this policy is not"
" set (unless ``DEPFILE`` is used in a subdirectory) and simply uses "
"``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0116 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.20 中引入的。与大多数政策不同，CMake 版本 "
"|release|当此策略未设置时（除非在子目录中使用了``DEPFILE``）并且仅使用``OLD``行为，*不会*默认发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0116 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0117.rst:2
msgid "CMP0117"
msgstr "CMP0117"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0117.rst:6
msgid ""
"MSVC RTTI flag ``/GR`` is not added to :variable:`CMAKE_CXX_FLAGS "
"<CMAKE_<LANG>_FLAGS>` by default."
msgstr ""
"默认情况下，MSVC RTTI 标志 ``/GR`` 未添加到 :variable:`CMAKE_CXX_FLAGS "
"<CMAKE_<LANG>_FLAGS>`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0117.rst:9
msgid ""
"When using MSVC-like compilers in CMake 3.19 and below, the RTTI flag "
"``/GR`` is added to :variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>` by "
"default.  This behavior is left from support for MSVC versions from Visual"
" Studio 2003 and below that did not enable RTTI by default.  It is no "
"longer necessary.  Furthermore, it is problematic for projects that want "
"to change to ``/GR-`` programmatically.  In particular, it requires string"
" editing of the :variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>` variable "
"with knowledge of the CMake builtin default so it can be replaced."
msgstr ""
"在 CMake 3.19 及更低版本中使用类似 MSVC 的编译器时，RTTI 标志 ``/GR`` 默认添加到 "
":variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>`。此行为是由于对 Visual Studio "
"2003 及以下版本的 MSVC 版本的支持而遗留的，默认情况下未启用 "
"RTTI。不再需要了。此外，对于想要以编程方式更改为“/GR-”的项目来说，这是有问题的。特别是，它需要使用 CMake 内置默认值知识对 "
"CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS> 变量进行字符串编辑，以便可以替换它。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0117.rst:18
msgid ""
"CMake 3.20 and above prefer to leave out ``/GR`` from the value of "
":variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>` by default."
msgstr ""
"默认情况下，CMake 3.20 及更高版本倾向于从 :variable:`CMAKE_CXX_FLAGS "
"<CMAKE_<LANG>_FLAGS>` 的值中省略 ``/GR``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0117.rst:21
msgid ""
"This policy provides compatibility with projects that have not been "
"updated to expect the lack of the ``/GR`` flag.  The policy setting takes "
"effect as of the first :command:`project` or :command:`enable_language` "
"command that initializes :variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>`."
msgstr ""
"此策略提供与尚未更新的项目的兼容性，以预期缺少 ``/GR`` 标志。策略设置从初始化 CMAKE_CXX_FLAGS "
"<CMAKE_<LANG>_FLAGS> 的第一个 :command:`project` 或 :command:`enable_language` "
"命令开始生效。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0117.rst:33
msgid ""
"The ``OLD`` behavior for this policy is to place the MSVC ``/GR`` flag in "
"the default :variable:`CMAKE_CXX_FLAGS <CMAKE_<LANG>_FLAGS>` cache entry."
"  The ``NEW`` behavior for this policy is to *not* place the MSVC ``/GR`` "
"flag in the default cache entry."
msgstr ""
"此策略的 ``OLD`` 行为是将 MSVC ``/GR`` 标志放置在默认的 :variable:`CMAKE_CXX_FLAGS "
"<CMAKE_<LANG>_FLAGS>` 缓存条目中。此策略的“新”行为是*不*将 MSVC ``/GR`` 标志放在默认缓存条目中。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0117.rst:38
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0119.rst:31
msgid ""
"This policy was introduced in CMake version 3.20.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.20 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0118.rst:2
msgid "CMP0118"
msgstr "CMP0118"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0118.rst:6
msgid ""
"The :prop_sf:`GENERATED` source file property is now visible in all "
"directories."
msgstr ":prop_sf:`GENERATED` 源文件属性现在在所有目录中都可见。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0118.rst:8
msgid ""
"Whether or not a source file is generated is an all-or-nothing global "
"property of the source.  Consequently, the associated ``GENERATED`` "
"property is now visible from any directory scope, not only from the scope "
"for which it was set."
msgstr ""
"是否生成源文件是源文件的全有或全无的全局属性。因此，关联的“GENERATED”属性现在在任何目录范围内都是可见的，而不仅仅是在设置它的范围内。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0118.rst:13
msgid ""
"Additionally, the ``GENERATED`` property may now be set only to boolean "
"values, and may not be turned off once turned on."
msgstr "此外，``GENERATED`` 属性现在只能设置为布尔值，并且一旦打开就不能关闭。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0118.rst:16
msgid ""
"The ``OLD`` behavior of this policy is to only allow ``GENERATED`` to be "
"visible from the directory scope for which it was set.  The ``NEW`` "
"behavior on the other hand allows it to be visible from any scope."
msgstr "此策略的“旧”行为是仅允许“已生成”在设置它的目录范围内可见。另一方面，``NEW`` 行为允许它从任何范围可见。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0118.rst:20
msgid ""
"This policy was introduced in CMake version 3.20.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior with regard "
"to visibility of the ``GENERATED`` property.  However, CMake does warn "
"about setting the ``GENERATED`` property to a non-boolean value."
msgstr ""
"此策略是在 CMake 版本 3.20 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 "
"|release|当此策略未设置时*不*发出警告，并且只是使用关于“GENERATED”属性可见性的“OLD”行为。但是，CMake "
"会警告将“GENERATED”属性设置为非布尔值。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0119.rst:2
msgid "CMP0119"
msgstr "CMP0119"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0119.rst:6
msgid ""
":prop_sf:`LANGUAGE` source file property explicitly compiles as specified "
"language."
msgstr ":prop_sf:`LANGUAGE` 源文件属性明确编译为指定语言。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0119.rst:9
msgid ""
"The :prop_sf:`LANGUAGE` source file property is documented to mean that "
"the source file is written in the specified language.  In CMake 3.19 and "
"below, setting this property causes CMake to compile the source file using"
" the compiler for the specified language.  However, it only passes an "
"explicit flag to tell the compiler to treat the source as the specified "
"language for MSVC-like, XL, and Embarcadero compilers for the ``CXX`` "
"language. CMake 3.20 and above prefer to also explicitly tell the compiler"
" to use the specified language using a flag such as ``-x c`` on all "
"compilers for which such flags are known."
msgstr ""
":prop_sf:`LANGUAGE` 源文件属性被记录为意味着源文件是用指定语言编写的。在 CMake 3.19 及以下版本中，设置此属性会导致 "
"CMake 使用指定语言的编译器编译源文件。但是，它只传递一个显式标志，告诉编译器将源代码视为“CXX”语言的 MSVC 类、XL 和 "
"Embarcadero 编译器的指定语言。 CMake 3.20 及更高版本更喜欢在所有已知此类标志的编译器上使用诸如“-x "
"c”之类的标志明确告诉编译器使用指定的语言。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0119.rst:19
msgid ""
"This policy provides compatibility for projects that have not been updated"
" to expect this behavior.  For example, some projects were setting the "
"``LANGUAGE`` property to ``C`` on assembly-language ``.S`` source files in"
" order to compile them using the C compiler.  Such projects should be "
"updated to use ``enable_language(ASM)``, for which CMake will often choose"
" the C compiler as the assembler on relevant platforms anyway."
msgstr ""
"此策略为尚未更新以期望此行为的项目提供兼容性。例如，一些项目在汇编语言“.S”源文件上将“LANGUAGE”属性设置为“C”，以便使用 C "
"编译器编译它们。此类项目应更新为使用 ``enable_language(ASM)``，为此 CMake 通常会选择 C "
"​​编译器作为相关平台上的汇编器。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0119.rst:26
msgid ""
"The ``OLD`` behavior for this policy is to interpret the ``LANGUAGE "
"<LANG>`` property using its undocumented meaning to \"use the ``<LANG>`` "
"compiler\". The ``NEW`` behavior for this policy is to interpret the "
"``LANGUAGE <LANG>`` property using its documented meaning to \"compile as "
"a ``<LANG>`` source\"."
msgstr ""
"此策略的“旧”行为是使用其未记录的含义解释“LANGUAGE "
"<LANG>”属性以“使用”<LANG>“编译器”。此策略的“新”行为是使用其文档含义解释“LANGUAGE "
"<LANG>”属性以“编译为”<LANG>“源”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:2
msgid "CMP0120"
msgstr "CMP0120"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:6
msgid "The :module:`WriteCompilerDetectionHeader` module is removed."
msgstr ":module:`WriteCompilerDetectionHeader` 模块已删除。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:8
msgid ""
"CMake versions 3.1 through 3.19 provide this module to generate a C++ "
"compatibility layer by re-using information from CMake's table of "
"preprocessor checks for :manual:`cmake-compile-features(7)`.  However:"
msgstr ""
"CMake 版本 3.1 到 3.19 提供此模块，通过重新使用 CMake 的预处理器检查表中的信息来生成 C++ "
"兼容层:manual:`cmake-compile-features(7)`。然而："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:12
msgid ""
"Those granular features have been superseded by meta-features for "
":ref:`Requiring Language Standards` such as ``cxx_std_11``.  Therefore no "
"new granular feature checks will be added and projects will need to use "
"other means to conditionally use new C++ features."
msgstr ""
"这些细粒度特性已被元特性所取代:ref:`Requiring Language Standards` "
"例如``cxx_std_11``。因此，不会添加新的细粒度功能检查，项目将需要使用其他方式有条件地使用新的 C++ 功能。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:17
msgid ""
"The module exposes some of CMake's implementation details directly to C++ "
"translation units."
msgstr "该模块将 CMake 的一些实现细节直接暴露给 C++ 翻译单元。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:20
msgid ""
"The module's approach effectively provides a header file with CMake, thus "
"tying the version of the header to the version of CMake. Many projects "
"found that the :module:`WriteCompilerDetectionHeader` was best used by "
"manually generating its header locally with a recent version of CMake and "
"then bundling it with the project source so that it could be used with "
"older CMake versions."
msgstr ""
"该模块的方法有效地为 CMake 提供了一个头文件，从而将头文件的版本与 CMake "
"的版本联系起来。许多项目发现:module:`WriteCompilerDetectionHeader` 的最佳使用方法是使用最新版本的 CMake"
" 在本地手动生成其标头，然后将其与项目源捆绑在一起，以便它可以与旧 CMake 版本一起使用。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:27
msgid ""
"For reasons including the above, CMake 3.20 and above prefer to not "
"provide the :module:`WriteCompilerDetectionHeader` module.  This policy "
"provides compatibility for projects that have not been ported away from "
"it.  Projects using the module should be updated to stop using it. "
"Alternatives include:"
msgstr ""
"由于上述原因，CMake 3.20 及更高版本倾向于不提供 WriteCompilerDetectionHeader "
"模块。此策略为尚未从中移植的项目提供兼容性。使用该模块的项目应该更新以停止使用它。备选方案包括："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:33
msgid "Bundle a copy of the generated header in the project's source."
msgstr "在项目的源代码中捆绑生成的标头的副本。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:34
msgid "Use a third-party alternative, such as the CC0-licensed `Hedley`_."
msgstr "使用第三方替代方案，例如 CC0 许可的“Hedley”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:35
msgid "Drop support for compilers too old to provide the features natively."
msgstr "放弃对太旧而无法提供本机功能的编译器的支持。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0120.rst:37
msgid ""
"The ``OLD`` behavior of this policy is for inclusion of the deprecated "
":module:`WriteCompilerDetectionHeader` module to work.  The ``NEW`` "
"behavior is for inclusion of the module to fail as if it does not exist."
msgstr ""
"此策略的“旧”行为是为了包含已弃用的 WriteCompilerDetectionHeader 模块。 ``NEW`` "
"行为是为了包含模块失败，就好像它不存在一样。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0121.rst:2
msgid "CMP0121"
msgstr "CMP0121"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0121.rst:6
msgid "The :command:`list` command now detects invalid indices."
msgstr ":command:`list` 命令现在可以检测无效索引。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0121.rst:8
msgid ""
"Prior to CMake version 3.21, the :command:`list` command's ``GET``, "
"``INSERT``, ``SUBLIST``, and ``REMOVE_AT`` subcommands did not detect "
"invalid index arguments."
msgstr ""
"在 CMake 版本 3.21 之前， :command:`list` 命令的 ``GET``、``INSERT``、``SUBLIST`` 和 "
"``REMOVE_AT`` 子命令没有检测到无效的索引参数。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0121.rst:12
msgid ""
"The ``OLD`` behavior of this policy is for invalid indices to be treated "
"as their integer value (if any) at the start of the string. For example, "
"``2good4you`` is a ``2`` and ``not_an_integer`` is a ``0``. The ``NEW`` "
"behavior is for invalid indices to trigger an error."
msgstr ""
"此策略的“旧”行为是将无效索引视为字符串开头的整数值（如果有）。例如，``2good4you`` 是一个 ``2`` 而 "
"``not_an_integer`` 是一个 ``0``。 ``NEW`` 行为用于无效索引触发错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0121.rst:17
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0122.rst:12
msgid ""
"This policy was introduced in CMake version 3.21.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.21 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0122.rst:2
msgid "CMP0122"
msgstr "CMP0122"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0122.rst:6
msgid ""
":module:`UseSWIG` use library name conventions for ``CSharp`` language."
msgstr ":module:`UseSWIG` 使用 ``CSharp`` 语言的库名称约定。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0122.rst:8
msgid ""
"Starting with CMake 3.21, :module:`UseSWIG` generates now a library using "
"default naming conventions. This policy provides compatibility with "
"projects that expect the legacy behavior."
msgstr "从 CMake 3.21 开始，UseSWIG 现在使用默认命名约定生成一个库。此策略提供与期望遗留行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0123.rst:2
msgid "CMP0123"
msgstr "CMP0123"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0123.rst:6
msgid "``ARMClang`` cpu/arch compile and link flags must be set explicitly."
msgstr "``ARMClang`` cpu/arch 编译和链接标志必须显式设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0123.rst:8
msgid ""
"CMake 3.20 and lower automatically maps the "
":variable:`CMAKE_SYSTEM_PROCESSOR` variable and an undocumented "
"``CMAKE_SYSTEM_ARCH`` to compile and link options for ``ARMClang``.  For "
"example, the ``-mcpu=cortex-m33`` flag is added when "
":variable:`CMAKE_SYSTEM_PROCESSOR` equals ``cortex-m33``.  CMake requires "
"projects to set either variable or it raises a fatal error.  However, the "
"project may need to additionally specify CPU features using e.g. "
"``-mcpu=cortex-m33+nodsp``, conflicting with the ``-mcpu=cortex-m33`` "
"added by CMake.  This results in either link errors or unusable binaries."
msgstr ""
"CMake 3.20 及更低版本自动映射 :variable:`CMAKE_SYSTEM_PROCESSOR` 变量和未记录的 "
"``CMAKE_SYSTEM_ARCH`` 以编译和链接 `ARMClang`` 选项。例如，当 CMAKE_SYSTEM_PROCESSOR 等于"
" cortex-m33 时，将添加 `-mcpu=cortex-m33` 标志。 CMake "
"要求项目设置变量，否则会引发致命错误。然而，该项目可能需要额外指定 CPU "
"功能，例如使用``-mcpu=cortex-m33+nodsp``，与CMake添加的``-mcpu=cortex-m33``冲突。这会导致链接错误或二进制文件不可用。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0123.rst:17
msgid ""
"CMake 3.21 and above prefer instead to not add any cpu/arch compile and "
"link flags automatically.  Instead, projects must specify them explicitly."
" This policy provides compatibility for projects that have not been "
"updated."
msgstr ""
"CMake 3.21 及更高版本更喜欢不自动添加任何 cpu/arch "
"编译和链接标志。相反，项目必须明确指定它们。此策略为尚未更新的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0123.rst:21
msgid ""
"The ``OLD`` behavior of this policy requires projects that use "
"``ARMClang`` to set either :variable:`CMAKE_SYSTEM_PROCESSOR` or "
"``CMAKE_SYSTEM_ARCH`` and it automatically adds a compile option "
"``-mcpu=`` or ``-march=`` and a link option ``--cpu=`` based on those "
"variables.  The ``NEW`` behavior does not add compile or link options, and"
" projects are responsible for setting correct options."
msgstr ""
"此策略的“旧”行为要求使用“ARMClang”的项目设置 :variable:“CMAKE_SYSTEM_PROCESSOR”或“CMAKE_SYSTEM_ARCH”，它会自动添加编译选项“-mcpu=”或“"
" `-march=`` 和基于这些变量的链接选项 ``--cpu=``。 ``NEW`` 行为不添加编译或链接选项，项目负责设置正确的选项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0123.rst:28
msgid ""
"This policy was introduced in CMake version 3.21.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.21 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0124.rst:2
msgid "CMP0124"
msgstr "CMP0124"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0124.rst:6
msgid ""
"When this policy is set to ``NEW``, the scope of loop variables defined by"
" the :command:`foreach` command is restricted to the loop only.  They will"
" be unset at the end of the loop."
msgstr "当此策略设置为 ``NEW`` 时，由 foreach 命令定义的循环变量的范围仅限于循环。它们将在循环结束时取消设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0124.rst:10
msgid ""
"The ``OLD`` behavior for this policy still clears the loop variables at "
"the end of the loop, but does not unset them.  This leaves them as "
"defined, but empty."
msgstr "此策略的“旧”行为仍会在循环结束时清除循环变量，但不会取消设置它们。这使它们保持定义状态，但为空。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0124.rst:13
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0125.rst:37
msgid ""
"This policy was introduced in CMake version 3.21. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when the policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.21 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当政策未设置时 *不* 发出警告，只是使用“旧”行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0125.rst:2
msgid "CMP0125"
msgstr "CMP0125"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0125.rst:6
msgid ""
"The :command:`find_file`, :command:`find_path`, :command:`find_library` "
"and :command:`find_program` commands cache their result in the variable "
"specified by their first argument.  Prior to CMake 3.21, if a cache "
"variable of that name already existed before the call but the cache "
"variable had no type, any non-cache variable of the same name would be "
"discarded and the cache variable was always used (see also "
":policy:`CMP0126` for a different but similar behavior).  This contradicts"
" the convention that a non-cache variable should take precedence over a "
"cache variable of the same name.  Such a situation can arise if a user "
"sets a cache variable on the command line without specifying a type, such "
"as ``cmake -DMYVAR=blah ...`` instead of ``cmake -DMYVAR:FILEPATH=blah``."
msgstr ""
":command:`find_file`、 :command:`find_path`、 :command:`find_library` 和 "
":command:`find_program` 命令将它们的结果缓存在第一个参数指定的变量中。在 CMake 3.21 "
"之前，如果该名称的缓存变量在调用之前已经存在但缓存变量没有类型，则任何同名的非缓存变量都将被丢弃并且始终使用缓存变量（另请参阅:policy: "
"`CMP0126` "
"用于不同但相似的行为）。这与非缓存变量应优先于同名缓存变量的约定相矛盾。如果用户在命令行上设置缓存变量而不指定类型，例如“cmake "
"-DMYVAR=blah ...”而不是“cmake -DMYVAR:FILEPATH=blah”，就会出现这种情况。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0125.rst:18
msgid ""
"Related to the above, if a cache variable of the specified name already "
"exists and it *does* have a type, the various ``find_...()`` commands "
"would return that value unchanged.  In particular, if it contained a "
"relative path, it would not be converted to an absolute path in this "
"situation."
msgstr ""
"与上述相关，如果指定名称的缓存变量已经存在并且它*确实*具有类型，则各种 ``find_...()`` "
"命令将返回该值不变。特别是，如果它包含相对路径，则在这种情况下不会转换为绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0125.rst:23
msgid ""
"When policy ``CMP0125`` is set to ``OLD`` or is unset, the behavior is as "
"described above.  When it is set to ``NEW``, the behavior is as follows:"
msgstr "当策略“CMP0125”设置为“旧”或未设置时，行为如上所述。当它设置为 ``NEW`` 时，行为如下："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0125.rst:26
msgid ""
"If a non-cache variable of the specified name exists when the "
"``find_...()`` command is called, its value will be used regardless of "
"whether a cache variable of the same name already exists or not.  A cache "
"variable will not be created in this case if no such cache variable "
"existed before. If a cache variable of the specified name did already "
"exist, the cache will be updated to match the non-cache variable."
msgstr ""
"如果调用``find_...()`` "
"命令时存在指定名称的非缓存变量，则无论是否存在同名缓存变量，都将使用其值。如果之前不存在这样的缓存变量，则在这种情况下不会创建缓存变量。如果指定名称的缓存变量已经存在，则缓存将被更新以匹配非缓存变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0125.rst:33
msgid ""
"The various ``find...()`` commands will always provide an absolute path in"
" the result variable, except where a relative path provided by a cache or "
"non-cache variable cannot be resolved to an existing path."
msgstr "各种 ``find...()`` 命令将始终在结果变量中提供绝对路径，除非缓存或非缓存变量提供的相对路径无法解析为现有路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0126.rst:2
msgid "CMP0126"
msgstr "CMP0126"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0126.rst:6
msgid ""
"When this policy is set to ``NEW``, the :command:`set(CACHE)` command does"
" not remove any normal variable of the same name from the current scope. "
"The ``OLD`` behavior removes any normal variable of the same name from the"
" current scope in the following situations:"
msgstr ""
"当此策略设置为 ``NEW`` 时， :command:`set(CACHE)` "
"命令不会从当前作用域中删除任何同名的普通变量。在以下情况下，``OLD`` 行为会从当前作用域中删除任何同名的普通变量："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0126.rst:11
msgid "No cache variable of that name existed previously."
msgstr "以前不存在该名称的缓存变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0126.rst:13
msgid ""
"A cache variable of that name existed previously, but it had no type. This"
" can occur when the variable was set on the command line using a form like"
" ``cmake -DMYVAR=blah`` instead of ``cmake -DMYVAR:STRING=blah``."
msgstr ""
"该名称的缓存变量以前存在，但它没有类型。当在命令行上使用类似“cmake -DMYVAR=blah”而不是“cmake "
"-DMYVAR:STRING=blah”的形式设置变量时，可能会发生这种情况。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0126.rst:17
msgid ""
"The ``FORCE`` or ``INTERNAL`` keywords were used when setting the cache "
"variable."
msgstr "设置缓存变量时使用了``FORCE`` 或``INTERNAL`` 关键字。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0126.rst:20
msgid ""
"Note that the ``NEW`` behavior has an important difference to the similar "
"``NEW`` behavior of policy :policy:`CMP0077`.  The :command:`set(CACHE)` "
"command always sets the cache variable if it did not exist previously, "
"regardless of the ``CMP0126`` policy setting.  The :command:`option` "
"command will *not* set the cache variable if a non-cache variable of the "
"same name already exists and :policy:`CMP0077` is set to ``NEW``."
msgstr ""
"请注意，``NEW`` 行为与策略的类似``NEW`` 行为有重要区别 :policy:`CMP0077`。 "
":command:`set(CACHE)` 命令总是设置缓存变量，如果它以前不存在，不管``CMP0126`` "
"策略设置。如果同名的非缓存变量已经存在并且 CMP0077 设置为 NEW，则 :command:`option` 命令将 *不* 设置缓存变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0126.rst:27
msgid ""
"Policy ``CMP0126`` was introduced in CMake version 3.21. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` explicitly"
" within a project.  Use the :variable:`CMAKE_POLICY_DEFAULT_CMP0126 "
"<CMAKE_POLICY_DEFAULT_CMP\\<NNNN\\>>` variable to set the policy for a "
"third-party project in a subdirectory without modifying it. Unlike many "
"policies, CMake version |release| does *not* warn when the policy is not "
"set and simply uses ``OLD`` behavior.  See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0126 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"CMake 版本 3.21 中引入了策略“CMP0126”。使用 :command:`cmake_policy` 命令在项目中明确地将其设置为 "
"``OLD`` 或 ``NEW``。使用 :variable:`CMAKE_POLICY_DEFAULT_CMP0126 "
"<CMAKE_POLICY_DEFAULT_CMP\\<NNNN\\>>` 变量为子目录中的第三方项目设置策略而不修改它。与许多政策不同，CMake"
" 版本 |release|当政策未设置时 *不* 发出警告，只是使用“旧”行为。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0126 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0127.rst:2
msgid "CMP0127"
msgstr "CMP0127"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0127.rst:6
msgid ""
":command:`cmake_dependent_option` supports full :ref:`Condition Syntax`."
msgstr ":command:`cmake_dependent_option` 支持完整的 :ref:`Condition Syntax`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0127.rst:8
msgid ""
"The ``<depends>`` parameter accepts a :ref:`semicolon-separated list "
"<CMake Language Lists>` of conditions.  CMake 3.21 and lower evaluates "
"each ``condition`` as ``if(${condition})``, which does not properly handle"
" conditions with nested paren groups.  CMake 3.22 and above instead prefer"
" to evaluate each ``condition`` as ``if(<condition>)``, where "
"``<condition>`` is re-parsed as if literally written in a call to "
":command:`if`.  This allows expressions like::"
msgstr ""
"``<depends>`` 参数接受 :ref:`分号分隔的条件列表 <CMake Language Lists>`。 CMake 3.21 "
"及更低版本将每个 ``condition`` 评估为 ``if(${condition})``，这不能正确处理嵌套 paren 组的条件。 "
"CMake 3.22 及更高版本更喜欢将每个 ``condition`` 评估为 ``if(<condition>)``，其中 "
"``<condition>`` 被重新解析，就好像字面上写在对 :command: 的调用中一样如果`。这允许像 :: 这样的表达式"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0127.rst:18
msgid "but requires expressions like::"
msgstr "但需要像 :: 这样的表达式"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0127.rst:22
msgid "to be re-written as::"
msgstr "重写为：："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0127.rst:26
msgid ""
"Policy ``CMP0127`` provides compatibility for projects that have not been "
"updated to expect the new behavior."
msgstr "策略“CMP0127”为尚未更新以期待新行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0127.rst:29
msgid ""
"This policy was introduced in CMake version 3.22.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.22 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:2
msgid "CMP0128"
msgstr "CMP0128"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:6
msgid "When this policy is set to ``NEW``:"
msgstr "当此策略设置为“NEW”时："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:8
msgid ""
":prop_tgt:`<LANG>_EXTENSIONS` is initialized to "
":variable:`CMAKE_<LANG>_EXTENSIONS` if set, otherwise falling back to "
":variable:`CMAKE_<LANG>_EXTENSIONS_DEFAULT`."
msgstr ""
":prop_tgt:`<LANG>_EXTENSIONS` 初始化为 :variable:`CMAKE_<LANG>_EXTENSIONS` "
"如果设置，否则回落到 :variable:`CMAKE_<LANG>_EXTENSIONS_DEFAULT`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:12
msgid ""
"Extensions are correctly enabled/disabled if :prop_tgt:`<LANG>_STANDARD` "
"is unset or satisfied by the default."
msgstr "如果 :prop_tgt:`<LANG>_STANDARD` 未设置或默认满足，则可以正确启用/禁用扩展。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:15
msgid ""
"Standard mode-affecting flags aren't added unless necessary to achieve the"
" specified mode."
msgstr "除非需要实现指定模式，否则不会添加影响标准模式的标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:18
msgid "The ``OLD`` behavior:"
msgstr "``OLD`` 行为："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:20
msgid ""
"Initializes :prop_tgt:`<LANG>_EXTENSIONS` to "
":variable:`CMAKE_<LANG>_EXTENSIONS` if set, otherwise falling back to "
"``ON``."
msgstr ""
"如果已设置，则将 :prop_tgt:`<LANG>_EXTENSIONS` 初始化为 "
":variable:`CMAKE_<LANG>_EXTENSIONS`，否则返回到 ``ON``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:23
msgid ""
"Always adds a flag if :prop_tgt:`<LANG>_STANDARD` is set and "
":prop_tgt:`<LANG>_STANDARD_REQUIRED` is ``OFF``."
msgstr ""
"如果设置了 :prop_tgt:`<LANG>_STANDARD` 并且 :prop_tgt:`<LANG>_STANDARD_REQUIRED` "
"为 ``OFF``，则总是添加一个标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:26
msgid "If :prop_tgt:`<LANG>_STANDARD` is unset:"
msgstr "如果 :prop_tgt:`<LANG>_STANDARD` 未设置："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:28
msgid ""
"Doesn't disable extensions even if :prop_tgt:`<LANG>_EXTENSIONS` is "
"``OFF``."
msgstr "即使 :prop_tgt:`<LANG>_EXTENSIONS` 为 ``OFF`` 也不会禁用扩展。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:31
msgid ""
"Fails to enable extensions if :prop_tgt:`<LANG>_EXTENSIONS` is ``ON`` "
"except for the ``IAR`` compiler."
msgstr "如果 :prop_tgt:`<LANG>_EXTENSIONS` 为 ``ON`` 则无法启用扩展，``IAR`` 编译器除外。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:34
msgid ""
"Code may need to be updated for the ``NEW`` behavior in the following "
"cases:"
msgstr "在以下情况下，可能需要针对 ``NEW`` 行为更新代码："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:36
msgid ""
"If a standard mode flag previously overridden by CMake's and not used "
"during compiler detection now takes effect due to CMake no longer adding "
"one as the default detected is appropriate."
msgstr ""
"如果以前被 CMake 覆盖并且在编译器检测期间未使用的标准模式标志现在生效，因为 CMake 不再添加一个，因为检测到的默认值是合适的。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:40
msgid "Such code should be converted to either:"
msgstr "此类代码应转换为："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:42
msgid ""
"Use :prop_tgt:`<LANG>_STANDARD` and :prop_tgt:`<LANG>_EXTENSIONS` instead "
"of manually adding flags."
msgstr ""
"使用 :prop_tgt:`<LANG>_STANDARD` 和 :prop_tgt:`<LANG>_EXTENSIONS` 而不是手动添加标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:45
msgid ""
"Or ensure the manually-specified flags are used during compiler detection."
msgstr "或者确保在编译器检测期间使用手动指定的标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:47
msgid ""
"If extensions were disabled without :prop_tgt:`<LANG>_STANDARD` being set "
"CMake previously wouldn't actually disable extensions."
msgstr "如果在没有设置 :prop_tgt:`<LANG>_STANDARD` 的情况下禁用扩展，CMake 以前实际上不会禁用扩展。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:50
msgid ""
"Such code should be updated to not disable extensions if they are "
"required."
msgstr "此类代码应更新为在需要时不禁用扩展。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:52
msgid ""
"If extensions were enabled/disabled when :prop_tgt:`<LANG>_STANDARD` was "
"satisfied by the compiler's default CMake previously wouldn't actually "
"enable/disable extensions."
msgstr ""
"如果在编译器的默认 CMake 满足 :prop_tgt:`<LANG>_STANDARD` 时启用/禁用扩展，以前实际上不会启用/禁用扩展。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:56
msgid "Such code should be updated to set the correct extensions mode."
msgstr "应更新此类代码以设置正确的扩展模式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:58
msgid ""
"If compiler flags affecting the standard mode are used during compiler "
"detection (for example in :manual:`a toolchain file <cmake-toolchains(7)>`"
" using :variable:`CMAKE_<LANG>_FLAGS_INIT`) then they will affect the "
"detected default :variable:`standard <CMAKE_<LANG>_STANDARD_DEFAULT>` and "
":variable:`extensions <CMAKE_<LANG>_EXTENSIONS_DEFAULT>`."
msgstr ""
"如果在编译器检测期间使用了影响标准模式的编译器标志（例如在 :manual:`a toolchain file <cmake-"
"toolchains(7)>` using "
":variable:`CMAKE_<LANG>_FLAGS_INIT`）那么它们将影响检测到的默认 :variable:`标准 "
"<CMAKE_<LANG>_STANDARD_DEFAULT>` 和 :variable:`扩展 "
"<CMAKE_<LANG>_EXTENSIONS_DEFAULT>`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0128.rst:64
msgid ""
"Unlike many policies, CMake version |release| does *not* warn when the "
"policy is not set and simply uses the ``OLD`` behavior. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. See documentation of the "
":variable:`CMAKE_POLICY_WARNING_CMP0128 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"variable to control the warning."
msgstr ""
"与许多政策不同，CMake 版本 |release|当政策未设置时 *不* 发出警告，只是使用“旧”行为。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0128 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0129.rst:2
msgid "CMP0129"
msgstr "CMP0129"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0129.rst:6
msgid "Compiler id for MCST LCC compilers is now ``LCC``, not ``GNU``."
msgstr "MCST LCC 编译器的编译器 ID 现在是“LCC”，而不是“GNU”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0129.rst:8
msgid ""
"CMake 3.23 and above recognize MCST LCC compiler as a different from "
"``GNU``, with its own command line and set of capabilities. CMake now "
"prefers to present this to projects by setting the "
":variable:`CMAKE_<LANG>_COMPILER_ID` variable to ``LCC`` instead of "
"``GNU``. However, existing projects may assume the compiler id for LCC is "
"``GNU`` as it was in CMake versions prior to 3.23. Therefore this policy "
"determines for MCST LCC compiler which compiler id to report in the "
":variable:`CMAKE_<LANG>_COMPILER_ID` variable after language ``<LANG>`` is"
" enabled by the :command:`project` or :command:`enable_language` command."
"  The policy must be set prior to the invocation of either command."
msgstr ""
"CMake 3.23 及更高版本将 MCST LCC 编译器识别为不同于“GNU”，具有自己的命令行和功能集。 CMake 现在更喜欢通过将 "
":variable:`CMAKE_<LANG>_COMPILER_ID` 变量设置为 ``LCC`` 而不是 ``GNU`` "
"来将其呈现给项目。然而，现有项目可能假设 LCC 的编译器 ID 是“GNU”，因为它在 3.23 之前的 CMake 版本中。因此，此策略为 "
"MCST LCC 编译器确定在 :command:`project` 或 :command:` 启用语言 ``<LANG>`` 后在 "
"CMAKE_<LANG>_COMPILER_ID 变量中报告哪个编译器 ID enable_language "
"命令。该策略必须在调用任一命令之前设置。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0129.rst:20
msgid ""
"The ``OLD`` behavior for this policy is to use compiler id ``GNU`` (and "
"set :variable:`CMAKE_<LANG>_COMPILER_VERSION` to the supported GNU "
"compiler version.) ``NEW`` behavior for this policy is to use compiler id "
"``LCC``, and set :variable:`CMAKE_<LANG>_SIMULATE_ID` to ``GNU``, and "
":variable:`CMAKE_<LANG>_SIMULATE_VERSION` to the supported GNU compiler "
"version."
msgstr ""
"此策略的“旧”行为是使用编译器 ID“GNU”（并将 CMAKE_<LANG>_COMPILER_VERSION 设置为受支持的 GNU "
"编译器版本。）此策略的“新”行为是使用编译器 ID ``LCC``，并将 :variable:`CMAKE_<LANG>_SIMULATE_ID` "
"设置为 ``GNU``，并将 :variable:`CMAKE_<LANG>_SIMULATE_VERSION` 设置为受支持的 GNU "
"编译器版本。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0129.rst:26
msgid ""
"This policy was introduced in CMake version 3.23.  Use the "
":command:`cmake_policy` command to set this policy to ``OLD`` or ``NEW`` "
"explicitly. Unlike most policies, CMake version |release| does *not* warn "
"by default when this policy is not set and simply uses ``OLD`` behavior. "
"See documentation of the :variable:`CMAKE_POLICY_WARNING_CMP0129 "
"<CMAKE_POLICY_WARNING_CMP<NNNN>>` variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.23 中引入的。使用 :command:`cmake_policy` 命令将此策略显式设置为 ``OLD`` 或 "
"``NEW``。与大多数政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0129 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0130.rst:2
msgid "CMP0130"
msgstr "CMP0130"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0130.rst:6
msgid ":command:`while` diagnoses condition evaluation errors."
msgstr ":command:`while` 诊断条件评估错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0130.rst:8
msgid ""
"CMake 3.23 and below accidentally tolerated errors encountered while "
"evaluating the condition passed to the :command:`while` command (but not "
"the :command:`if` command).  For example, the code"
msgstr ""
"CMake 3.23 及以下版本意外地容忍了在评估传递给 :command:`while` 命令（但不是 :command:`if` "
"命令）的条件时遇到的错误。例如，代码"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0130.rst:18
msgid "creates an unbalanced parenthesis during condition evaluation."
msgstr "在条件评估期间创建不平衡的括号。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0130.rst:20
msgid ""
"CMake 3.24 and above prefer to diagnose such errors.  This policy provides"
" compatibility for projects that have not been updated to fix their "
"condition errors."
msgstr "CMake 3.24 及更高版本更喜欢诊断此类错误。此策略为尚未更新以修复其条件错误的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0130.rst:24
msgid ""
"The ``OLD`` behavior for this policy is to ignore errors in "
":command:`while` conditions.  The ``NEW`` behavior for this policy is to "
"diagnose errors in :command:`while` conditions."
msgstr ""
"此策略的“旧”行为是忽略 :command:`while` 条件中的错误。此策略的“新”行为是诊断 :command:`while` 条件中的错误。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0130.rst:28
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0135.rst:25
msgid ""
"This policy was introduced in CMake version 3.24.  CMake version |release|"
" warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.24 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0131.rst:2
msgid "CMP0131"
msgstr "CMP0131"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0131.rst:6
msgid ""
":prop_tgt:`LINK_LIBRARIES` supports the :genex:`$<LINK_ONLY:...>` "
"generator expression."
msgstr ":prop_tgt:`LINK_LIBRARIES` 支持 :genex:`$<LINK_ONLY:...>` 生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0131.rst:9
msgid ""
"CMake 3.23 and below documented the :genex:`$<LINK_ONLY:...>` generator "
"expression only for use in :prop_tgt:`INTERFACE_LINK_LIBRARIES`. When used"
" in :prop_tgt:`LINK_LIBRARIES`, the content guarded inside "
":genex:`$<LINK_ONLY:...>` was always used, even when collecting non-"
"linking usage requirements such as "
":prop_tgt:`INTERFACE_COMPILE_DEFINITIONS`."
msgstr ""
"CMake 3.23 及以下版本记录了 :genex:`$<LINK_ONLY:...>` 生成器表达式，仅用于 "
":prop_tgt:`INTERFACE_LINK_LIBRARIES`。在 :prop_tgt:`LINK_LIBRARIES` 中使用时，始终使用"
" :genex:`$<LINK_ONLY:...>` 中保护的内容，即使在收集非链接使用要求时，如 "
":prop_tgt:`INTERFACE_COMPILE_DEFINITIONS`。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0131.rst:15
msgid ""
"CMake 3.24 and above prefer to support :genex:`$<LINK_ONLY:...>`, when "
"used in :prop_tgt:`LINK_LIBRARIES`, by using the guarded content only for "
"link dependencies and not other usage requirements.  This policy provides "
"compatibility for projects that have not been updated to account for this "
"change."
msgstr ""
"CMake 3.24 "
"及更高版本更倾向于支持 :genex:`$<LINK_ONLY:...>`，当在 :prop_tgt:`LINK_LIBRARIES` "
"中使用时，通过仅将受保护的内容用于链接依赖项而不是其他使用要求。此策略为尚未更新以说明此更改的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0131.rst:21
msgid ""
"The ``OLD`` behavior for this policy is to use :prop_tgt:`LINK_LIBRARIES` "
"content guarded by :genex:`$<LINK_ONLY:...>` even for non-linking usage "
"requirements.  The ``NEW`` behavior for this policy is to use the guarded "
"content only for link dependencies."
msgstr ""
"此策略的“旧”行为是使用:prop_tgt:`LINK_LIBRARIES` 由:genex:`$<LINK_ONLY:...>` "
"保护的内容，即使是非链接使用要求。此策略的“新”行为是仅将受保护的内容用于链接依赖项。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0131.rst:26
msgid ""
"This policy was introduced in CMake version 3.24.  Use the "
":command:`cmake_policy` command to set this policy to ``OLD`` or ``NEW`` "
"explicitly.  Unlike many policies, CMake version |release| does *not* warn"
" when this policy is not set, and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.24 中引入的。使用 :command:`cmake_policy` 命令将此策略显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置时*不*发出警告，并且仅使用“旧”行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0132.rst:2
msgid "CMP0132"
msgstr "CMP0132"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0132.rst:6
msgid ""
"Apart from when using the Xcode generator and some Visual Studio "
"generators, CMake 3.23 and below will set environment variables like "
":envvar:`CC`, :envvar:`CXX`, etc. when the corresponding language is "
"enabled. This only occurs on the very first time CMake is run in a build "
"directory, and the environment variables are only defined at configure "
"time, not build time. On subsequent CMake runs, these environment "
"variables are not set, opening up the opportunity for different behavior "
"between the first and subsequent CMake runs. CMake 3.24 and above prefer "
"to not set these environment variables when a language is enabled, even on"
" the first run in a build directory."
msgstr ""
"除了使用 Xcode 生成器和一些 Visual Studio 生成器时，CMake 3.23 "
"及以下版本将在启用相应语言时设置环境变量，如 :envvar:`CC`、 :envvar:`CXX` 等。这只发生在 CMake "
"第一次在构建目录中运行时，环境变量只在配置时定义，而不是构建时定义。在随后的 CMake 运行中，这些环境变量未设置，从而为第一次和后续 CMake"
" 运行之间的不同行为提供了机会。 CMake 3.24 及更高版本倾向于在启用语言时不设置这些环境变量，即使是在构建目录中首次运行时也是如此。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0132.rst:17
msgid ""
"The ``OLD`` behavior for this policy sets the relevant environment "
"variable on the first run when a language is enabled. The ``NEW`` behavior"
" for this policy does not set any such environment variables."
msgstr "此策略的 ``OLD`` 行为会在启用语言后的第一次运行时设置相关的环境变量。此策略的“新”行为不会设置任何此类环境变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0132.rst:21
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0138.rst:26
msgid ""
"This policy was introduced in CMake version 3.24. Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.24 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0133.rst:2
msgid "CMP0133"
msgstr "CMP0133"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0133.rst:6
msgid ""
"The :module:`CPack` module disables SLA by default in the "
":cpack_gen:`CPack DragNDrop Generator`."
msgstr ""
":module:`CPack` 模块在 :cpack_gen:`CPack DragNDrop Generator` 中默认禁用 SLA。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0133.rst:9
msgid ""
"The :cpack_gen:`CPack DragNDrop Generator` in CMake 3.22 and below attach "
"a Software License Agreement (SLA) to ``.dmg`` files using the file "
"specified by :variable:`CPACK_RESOURCE_FILE_LICENSE`, if set to a non-"
"default value. macOS 12.0 deprecated the tools used to do this, so CMake "
"3.23 added the :variable:`CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE` option "
"to control the behavior.  CMake 3.23 enables that option by default for "
"compatibility with older versions. CMake 3.24 and above prefer to *not* "
"enable the :variable:`CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE` option by "
"default. This policy provides compatibility with projects that have not "
"been updated to account for the lack of a SLA in their ``.dmg`` packages."
msgstr ""
"CMake 3.22 及以下版本中的 CPack DragNDrop Generator 使用由 "
"CPACK_RESOURCE_FILE_LICENSE 指定的文件（如果设置为非默认值）将软件许可协议 (SLA) 附加到 .dmg 文件. "
"macOS 12.0 弃用了用于执行此操作的工具，因此 CMake 3.23 添加了 "
":variable:`CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE` 选项来控制行为。 CMake 3.23 "
"默认启用该选项以与旧版本兼容。 CMake 3.24 及更高版本倾向于*不*默认启用 "
":variable:`CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE` "
"选项。此政策提供与尚未更新的项目的兼容性，以解决其“.dmg”包中缺少 SLA 的问题。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0133.rst:20
msgid ""
"The ``OLD`` behavior for this policy is to enable "
":variable:`CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE` by default. The "
"``NEW`` behavior for this policy is to not enable it by default."
msgstr ""
"此策略的“旧”行为是默认启用 :variable:`CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE`。此策略的“新”行为是默认不启用它。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0133.rst:24
msgid ""
"This policy was introduced in CMake version 3.24.  Use the "
":command:`cmake_policy` command to set this policy to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"by default when this policy is not set and simply uses ``OLD`` behavior. "
"See documentation of the :variable:`CMAKE_POLICY_WARNING_CMP0133 "
"<CMAKE_POLICY_WARNING_CMP<NNNN>>` variable to control the warning."
msgstr ""
"此策略是在 CMake 版本 3.24 中引入的。使用 :command:`cmake_policy` 命令将此策略显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。请参阅 "
":variable:`CMAKE_POLICY_WARNING_CMP0133 <CMAKE_POLICY_WARNING_CMP<NNNN>>` "
"变量的文档以控制警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:2
msgid "CMP0134"
msgstr "CMP0134"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:6
msgid ""
"The default registry view is ``TARGET`` for the :command:`find_file`, "
":command:`find_path`, :command:`find_library`, and :command:`find_package`"
" commands and ``BOTH`` for the :command:`find_program` command."
msgstr ""
":command:`find_file`、 :command:`find_path`、 :command:`find_library` 和 "
":command:`find_package` 命令的默认注册表视图是 ``TARGET`` 和 ``BOTH`` "
":command:`find_program` 命令。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:10
msgid ""
"The default registry views in CMake 3.23 and below are selected using the "
"following rules:"
msgstr "使用以下规则选择 CMake 3.23 及以下版本中的默认注册表视图："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:13
msgid "if :variable:`CMAKE_SIZEOF_VOID_P` has value ``8``:"
msgstr "如果 :variable:`CMAKE_SIZEOF_VOID_P` 的值为``8``："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:15
msgid ""
"Use view ``64`` for all ``find_*`` commands except :command:`find_program`"
" command."
msgstr "对除 :command:`find_program` 命令之外的所有 ``find_*`` 命令使用视图 ``64``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:17
msgid "Use view ``64_32`` for :command:`find_program` command."
msgstr "对 :command:`find_program` 命令使用视图 ``64_32``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:19
msgid "if :variable:`CMAKE_SIZEOF_VOID_P` has value ``4`` or is undefined:"
msgstr "如果 :variable:`CMAKE_SIZEOF_VOID_P` 的值为 ``4`` 或未定义："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:21
msgid ""
"Use view ``32`` for all ``find_*`` commands except :command:`find_program`"
" command."
msgstr "对除 :command:`find_program` 命令之外的所有 ``find_*`` 命令使用视图 ``32``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:23
msgid "Use view ``32_64`` for :command:`find_program` command."
msgstr "对 :command:`find_program` 命令使用视图 ``32_64``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:25
msgid ""
"The ``OLD`` behavior for this policy is to use registry views ``64`` and "
"``64_32`` or ``32_64`` and ``32`` as default, depending of "
":variable:`CMAKE_SIZEOF_VOID_P` variable value. The ``NEW`` behavior for "
"this policy is to use registry views ``TARGET`` and ``BOTH`` as default."
msgstr ""
"此策略的“旧”行为是使用注册表视图“64”和“64_32”或“32_64”和“32”作为默认值，具体取决于 :variable:“CMAKE_SIZEOF_VOID_P”变量价值。此策略的“新”行为是默认使用注册表视图“TARGET”和“BOTH”。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0134.rst:31
msgid ""
"This policy was introduced in CMake version 3.24.  Use the "
":command:`cmake_policy` command to set this policy to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.24 中引入的。使用 :command:`cmake_policy` 命令将此策略显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0135.rst:2
msgid "CMP0135"
msgstr "CMP0135"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0135.rst:6
msgid ""
"When using the ``URL`` download method with the "
":command:`ExternalProject_Add` command, CMake 3.23 and below sets the "
"timestamps of the extracted contents to the same as the timestamps in the "
"archive. When the ``URL`` changes, the new archive is downloaded and "
"extracted, but the timestamps of the extracted contents might not be newer"
" than the previous contents. Anything that depends on the extracted "
"contents might not be rebuilt, even though the contents may change."
msgstr ""
"当使用 ``URL`` 下载方法和 :command:`ExternalProject_Add` 命令时，CMake 3.23 "
"及以下版本将提取内容的时间戳设置为与存档中的时间戳相同。当 ``URL`` "
"更改时，将下载并提取新存档，但提取内容的时间戳可能不会比以前的内容更新。任何依赖于提取内容的东西都可能不会被重建，即使内容可能会改变。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0135.rst:14
msgid ""
"CMake 3.24 and above prefers to set the timestamps of all extracted "
"contents to the time of the extraction. This ensures that anything that "
"depends on the extracted contents will be rebuilt whenever the ``URL`` "
"changes."
msgstr ""
"CMake 3.24 及以上版本倾向于将所有提取内容的时间戳设置为提取时间。这确保只要“URL”更改，任何依赖于提取内容的内容都会被重建。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0135.rst:18
msgid ""
"The ``DOWNLOAD_EXTRACT_TIMESTAMP`` option to the "
":command:`ExternalProject_Add` command can be used to explicitly specify "
"how timestamps should be handled. When ``DOWNLOAD_EXTRACT_TIMESTAMP`` is "
"not given, this policy controls the default behavior. The ``OLD`` behavior"
" for this policy is to restore the timestamps from the archive. The "
"``NEW`` behavior sets the timestamps of extracted contents to the time of "
"extraction."
msgstr ""
"ExternalProject_Add 命令的 DOWNLOAD_EXTRACT_TIMESTAMP 选项可用于明确指定时间戳的处理方式。当未给出 "
"``DOWNLOAD_EXTRACT_TIMESTAMP`` 时，此策略控制默认行为。此策略的“旧”行为是从存档中恢复时间戳。 ``NEW`` "
"行为将提取内容的时间戳设置为提取时间。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:2
msgid "CMP0136"
msgstr "CMP0136"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:6
msgid "Watcom runtime library flags are selected by an abstraction."
msgstr "Watcom 运行时库标志由抽象选择。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:8
msgid ""
"Compilers targeting the Watcom ABI have flags to select the Watcom runtime"
" library."
msgstr "针对 Watcom ABI 的编译器具有选择 Watcom 运行时库的标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:11
msgid ""
"In CMake 3.23 and below, Watcom runtime library selection flags are added "
"to the default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` cache entries by "
"CMake automatically.  This allows users to edit their cache entries to "
"adjust the flags.  However, the presence of such default flags is "
"problematic for projects that want to choose a different runtime library "
"programmatically. In particular, it requires string editing of the "
":variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` variables with knowledge of the "
"CMake builtin defaults so they can be replaced."
msgstr ""
"在 CMake 3.23 及以下版本中，CMake 会自动将 Watcom 运行时库选择标志添加到默认的 "
"CMAKE_<LANG>_FLAGS_<CONFIG> "
"缓存条目中。这允许用户编辑他们的缓存条目以调整标志。但是，对于想要以编程方式选择不同的运行时库的项目，此类默认标志的存在是有问题的。特别是，它需要在了解"
" CMake 内置默认值的情况下对 CMAKE_<LANG>_FLAGS_<CONFIG> 变量进行字符串编辑，以便替换它们。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:20
msgid ""
"CMake 3.24 and above prefer to leave the Watcom runtime library selection "
"flags out of the default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` values "
"and instead offer a first-class abstraction.  The "
":variable:`CMAKE_WATCOM_RUNTIME_LIBRARY` variable and "
":prop_tgt:`WATCOM_RUNTIME_LIBRARY` target property may be set to select "
"the Watcom runtime library.  If they are not set then CMake uses the "
"default value ``MultiThreadedDLL`` on Windows and ``SingleThreaded`` on "
"other platforms, which is equivalent to the original flags."
msgstr ""
"CMake 3.24 及更高版本倾向于将 Watcom "
"运行时库选择标志保留在默认值之外 :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` 值，而是提供一流的抽象。 "
":variable:`CMAKE_WATCOM_RUNTIME_LIBRARY` "
"变量和 :prop_tgt:`WATCOM_RUNTIME_LIBRARY` 目标属性可以设置为选择 Watcom 运行时库。如果未设置它们，则 "
"CMake 在 Windows "
"上使用默认值“MultiThreadedDLL”，在其他平台上使用“SingleThreaded”，这等同于原始标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:28
msgid ""
"This policy provides compatibility with projects that have not been "
"updated to be aware of the abstraction.  The policy setting takes effect "
"as of the first :command:`project` or :command:`enable_language` command "
"that enables a language whose compiler targets the Watcom ABI."
msgstr ""
"此策略提供与尚未更新以了解抽象的项目的兼容性。该策略设置从第一个 :command:`project` 或 "
":command:`enable_language` 命令开始生效，该命令启用其编译器以 Watcom ABI 为目标的语言。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:39
msgid ""
"The ``OLD`` behavior for this policy is to place Watcom runtime library "
"flags in the default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` cache entries"
" and ignore the :variable:`CMAKE_WATCOM_RUNTIME_LIBRARY` abstraction. The "
"``NEW`` behavior for this policy is to *not* place Watcom runtime library "
"flags in the default cache entries and use the abstraction instead."
msgstr ""
"此策略的“旧”行为是将 Watcom 运行时库标志放置在默认的 CMAKE_<LANG>_FLAGS_<CONFIG> 缓存条目中并忽略 "
"CMAKE_WATCOM_RUNTIME_LIBRARY 抽象。此策略的“新”行为是*不*将 Watcom "
"运行时库标志放在默认缓存条目中，而是使用抽象。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0136.rst:45
msgid ""
"This policy was introduced in CMake version 3.24.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.24 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0137.rst:2
msgid "CMP0137"
msgstr "CMP0137"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0137.rst:6
msgid ":command:`try_compile` passes platform variables in project mode."
msgstr ":command:`try_compile` 在项目模式下传递平台变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0137.rst:8
msgid ""
"The :command:`try_compile` command :ref:`source file <Try Compiling Source"
" Files>` signature propagates CMake variables containing platform "
"settings, and those specified by the "
":variable:`CMAKE_TRY_COMPILE_PLATFORM_VARIABLES` variable, into the "
"generated test project.  This helps the test project drive the toolchain "
"the same way the calling project will.  In CMake 3.23 and below, the "
":ref:`whole-project <Try Compiling Whole Projects>` signature does not "
"propagate platform variables automatically.  CMake 3.24 and above prefer "
"to propagate platform variables in the :ref:`whole-project <Try Compiling "
"Whole Projects>` signature.  This policy provides compatibility with "
"projects that have not been updated to expect the behavior."
msgstr ""
":command:`try_compile` 命令 :ref:`source file <Try Compiling Source Files>` "
"签名将包含平台设置的 CMake 变量以及由 :variable:`CMAKE_TRY_COMPILE_PLATFORM_VARIABLES` "
"变量指定的变量传播到生成的测试项目中。这有助于测试项目以与调用项目相同的方式驱动工具链。在 CMake 3.23 "
"及以下版本中， :ref:`whole-project <Try Compiling Whole Projects>` 签名不会自动传播平台变量。 "
"CMake 3.24 及更高版本更喜欢在 :ref:`whole-project <Try Compiling Whole Projects>` "
"签名中传播平台变量。此策略提供与尚未更新以预期行为的项目的兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0137.rst:19
msgid ""
"The ``OLD`` behavior for this policy is to not pass any additional "
"variables to the :ref:`whole-project <Try Compiling Whole Projects>` "
"signature. The ``NEW`` behavior for this policy is to pass the same "
"variables that the :ref:`source file <Try Compiling Source Files>` "
"signature does."
msgstr ""
"此策略的“旧”行为是不将任何其他变量传递给 :ref:`whole-project <Try Compiling Whole Projects>` "
"签名。此策略的“新”行为是传递与 :ref:`source file <Try Compiling Source Files>` 签名相同的变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0137.rst:24
msgid ""
"Regardless of the policy setting, the "
":variable:`CMAKE_TRY_COMPILE_NO_PLATFORM_VARIABLES` variable may be set to"
" suppress passing the platform variables through either signature."
msgstr ""
"无论策略设置如何，CMAKE_TRY_COMPILE_NO_PLATFORM_VARIABLES 变量都可以设置为禁止通过任一签名传递平台变量。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0137.rst:28
msgid ""
"This policy was introduced in CMake version 3.24.  Use the "
":command:`cmake_policy` command to set this policy to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"by default when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.24 中引入的。使用 :command:`cmake_policy` 命令将此策略显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时，默认情况下*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0138.rst:2
msgid "CMP0138"
msgstr "CMP0138"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0138.rst:6
msgid ":module:`CheckIPOSupported` uses flags from calling project."
msgstr ":module:`CheckIPOsupported` 使用来自调用项目的标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0138.rst:8
msgid ""
"The :module:`CheckIPOSupported` module :command:`check_ipo_supported` "
"command compiles a test project to determine whether the toolchain "
"supports :prop_tgt:`INTERPROCEDURAL_OPTIMIZATION`.  CMake 3.23 and below "
"run the check with the default values of the "
":variable:`CMAKE_<LANG>_FLAGS` and :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>`"
" variables for the current environment and toolchain settings. However, "
"some projects may modify these flag variables to add flags that affect "
"availability of the toolchain's IPO features. CMake 3.24 and above prefer "
"to honor the calling project's values for these variables.  This policy "
"provides compatibility for projects that have not been updated to expect "
"this behavior."
msgstr ""
":module:`CheckIPOsupported` 模块 :command:`check_ipo_supported` "
"命令编译一个测试项目以确定工具链是否支持 :prop_tgt:`INTERPROCEDURAL_OPTIMIZATION`。 CMake 3.23 "
"及更低版本使用当前环境和工具链设置的 CMAKE_<LANG>_FLAGS 和 CMAKE_<LANG>_FLAGS_<CONFIG> "
"变量的默认值运行检查。但是，某些项目可能会修改这些标志变量以添加影响工具链 IPO 功能可用性的标志。 CMake 3.24 "
"及更高版本更愿意为这些变量提供调用项目的值。此策略为尚未更新以期望此行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0138.rst:20
msgid ""
"The ``OLD`` behavior for this policy is to ignore the calling project's "
"values of :variable:`CMAKE_<LANG>_FLAGS` and "
":variable:`CMAKE_<LANG>_FLAGS_<CONFIG>`.  The ``NEW`` behavior for this "
"policy is to use the values of those variables as compiler flags in the "
"test project."
msgstr ""
"此策略的“旧”行为是忽略调用项目的值 :variable:`CMAKE_<LANG>_FLAGS` "
"和 :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>`。此策略的“新”行为是使用这些变量的值作为测试项目中的编译器标志。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0139.rst:2
msgid "CMP0139"
msgstr "CMP0139"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0139.rst:6
msgid ""
"The :command:`if` command supports path comparisons using ``PATH_EQUAL`` "
"operator."
msgstr ":command:`if` 命令支持使用 ``PATH_EQUAL`` 运算符进行路径比较。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0139.rst:9
msgid ""
"The ``OLD`` behavior for this policy is to ignore the ``PATH_EQUAL`` "
"operator. The ``NEW`` behavior is to interpret the ``PATH_EQUAL`` "
"operator."
msgstr "此策略的“旧”行为是忽略“PATH_EQUAL”运算符。 ``NEW`` 行为是解释 ``PATH_EQUAL`` 运算符。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0139.rst:12
msgid ""
"This policy was introduced in CMake version 3.24. CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.24 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0140.rst:2
msgid "CMP0140"
msgstr "CMP0140"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0140.rst:6
msgid "The :command:`return` command checks its parameters."
msgstr ":command:`return` 命令检查它的参数。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0140.rst:8
msgid ""
"The ``OLD`` behavior for this policy is to ignore any parameters given to "
"the command. The ``NEW`` behavior is to check the validity of the "
"parameters."
msgstr "此策略的“旧”行为是忽略提供给命令的任何参数。 ``NEW`` 行为是检查参数的有效性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0140.rst:12
msgid ""
"This policy was introduced in CMake version 3.25. CMake version |release| "
"warns when the policy is not set and uses ``OLD`` behavior.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly."
msgstr ""
"此策略是在 CMake 版本 3.25 中引入的。 CMake 版本 |发布|当未设置策略并使用“旧”行为时发出警告。使用 "
":command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:2
msgid "CMP0141"
msgstr "CMP0141"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:6
msgid "MSVC debug information format flags are selected by an abstraction."
msgstr "MSVC 调试信息格式标志由抽象选择。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:8
msgid ""
"Compilers targeting the MSVC ABI have flags to select the debug "
"information format. Debug information format selection typically varies "
"with build configuration."
msgstr "针对 MSVC ABI 的编译器具有用于选择调试信息格式的标志。调试信息格式选择通常因构建配置而异。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:12
msgid ""
"In CMake 3.24 and below, debug information format flags are added to the "
"default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` cache entries by CMake "
"automatically.  This allows users to edit their cache entries to adjust "
"the flags.  However, the presence of such default flags is problematic for"
" projects that want to choose a different runtime library "
"programmatically. In particular, it requires string editing of the "
":variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` variables with knowledge of the "
"CMake builtin defaults so they can be replaced."
msgstr ""
"在 CMake 3.24 及以下版本中，CMake 会自动将调试信息格式标志添加到默认的 "
":variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` "
"缓存条目中。这允许用户编辑他们的缓存条目以调整标志。但是，对于想要以编程方式选择不同的运行时库的项目，此类默认标志的存在是有问题的。特别是，它需要在了解"
" CMake 内置默认值的情况下对 CMAKE_<LANG>_FLAGS_<CONFIG> 变量进行字符串编辑，以便替换它们。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:21
msgid ""
"CMake 3.25 and above prefer to leave the debug information format flags "
"out of the default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` values and "
"instead offer a first-class abstraction.  The "
":variable:`CMAKE_MSVC_DEBUG_INFORMATION_FORMAT` variable and "
":prop_tgt:`MSVC_DEBUG_INFORMATION_FORMAT` target property may be set to "
"select the MSVC debug information format.  If they are not set, CMake "
"enables debug information in debug configurations using the default value "
"``$<$<CONFIG:Debug,RelWithDebInfo>:ProgramDatabase>``, if supported by the"
" compiler, and otherwise ``$<$<CONFIG:Debug,RelWithDebInfo>:Embedded>``."
msgstr ""
"CMake 3.25 及更高版本更喜欢将调试信息格式标志保留在默认值之外 :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` "
"值，而是提供一流的抽象。 :variable:`CMAKE_MSVC_DEBUG_INFORMATION_FORMAT` 变量和 "
":prop_tgt:`MSVC_DEBUG_INFORMATION_FORMAT` 目标属性可以设置为选择 MSVC "
"调试信息格式。如果未设置它们，CMake "
"使用默认值 ``$<$<CONFIG:Debug,RelWithDebInfo>:ProgramDatabase>`` "
"在调试配置中启用调试信息（如果编译器支持），否则为 ``$<$<CONFIG:Debug,RelWithDebInfo>:Embedded>`` 。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:38
msgid ""
"Once the policy has taken effect at the top of a project, that choice will"
" be used throughout the tree.  In projects that have nested projects in "
"subdirectories, be sure to confirm if everything is working with the "
"selected policy behavior."
msgstr "一旦该策略在项目的顶部生效，该选择将在整个树中使用。在子目录中有嵌套项目的项目中，请务必确认所有内容是否都适用于选定的策略行为。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:43
msgid ""
"The ``OLD`` behavior for this policy is to place MSVC debug information "
"format flags in the default :variable:`CMAKE_<LANG>_FLAGS_<CONFIG>` cache "
"entries and ignore the :variable:`CMAKE_MSVC_DEBUG_INFORMATION_FORMAT` "
"abstraction.  The ``NEW`` behavior for this policy is to *not* place MSVC "
"debug information format flags in the default cache entries and use the "
"abstraction instead."
msgstr ""
"此策略的“旧”行为是将 MSVC 调试信息格式标志放置在默认的 CMAKE_<LANG>_FLAGS_<CONFIG> 缓存条目中，并忽略 "
"CMAKE_MSVC_DEBUG_INFORMATION_FORMAT 抽象。此策略的“新”行为是*不*将 MSVC "
"调试信息格式标志放在默认缓存条目中，而是使用抽象。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0141.rst:50
#: ../../cmake-prefix/src/cmake/Help/policy/CMP0142.rst:22
msgid ""
"This policy was introduced in CMake version 3.25.  Use the "
":command:`cmake_policy` command to set it to ``OLD`` or ``NEW`` "
"explicitly. Unlike many policies, CMake version |release| does *not* warn "
"when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略是在 CMake 版本 3.25 中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 "
"``NEW``。与许多政策不同，CMake 版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0142.rst:2
msgid "CMP0142"
msgstr "CMP0142"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0142.rst:6
msgid ""
"The :generator:`Xcode` generator does not append per-config suffixes to "
"library search paths."
msgstr ":generator:`Xcode` 生成器不会将 per-config 后缀附加到库搜索路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0142.rst:9
msgid ""
"In CMake 3.24 and below, the :generator:`Xcode` generator preceded each "
"entry of a library search path with a copy of itself appended with "
"``$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)``.  This was left from very "
"early versions of CMake in which per-config directories were not well "
"modeled.  Such paths often do not exist, resulting in warnings from the "
"toolchain.  CMake 3.25 and above prefer to not add such library search "
"paths.  This policy provides compatibility for projects that may have been"
" accidentally relying on the old behavior."
msgstr ""
"在 CMake 3.24 及以下版本中， :generator:`Xcode` 生成器在库搜索路径的每个条目之前都有一个自身的副本，并附加了 "
"``$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)``。这是从非常早期的 CMake "
"版本中遗留下来的，其中每个配置目录没有很好地建模。这样的路径通常不存在，导致工具链发出警告。 CMake 3.25 "
"及更高版本倾向于不添加此类库搜索路径。此策略为可能意外依赖旧行为的项目提供兼容性。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0142.rst:18
msgid ""
"The ``OLD`` behavior for this policy is to append "
"``$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)`` to all library search "
"paths. The ``NEW`` behavior is to not modify library search paths."
msgstr ""
"此策略的“旧”行为是将“$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)”附加到所有库搜索路径。 ``NEW``"
" 行为是不修改库搜索路径。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0143.rst:2
msgid "CMP0143"
msgstr "CMP0143"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0143.rst:6
msgid ""
":prop_gbl:`USE_FOLDERS` global property is treated as ``ON`` by default."
msgstr ":prop_gbl:`USE_FOLDERS` 全局属性默认被视为 ``ON``。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0143.rst:8
msgid ""
"When using CMake 3.25 or earlier, :prop_gbl:`USE_FOLDERS` is treated as "
"``OFF`` by default unless projects enable the feature.  For example:"
msgstr "使用 CMake 3.25 或更早版本时，USE_FOLDERS 默认被视为“关闭”，除非项目启用该功能。例如："

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0143.rst:17
msgid "CMake 3.26 and later prefer to enable the feature by default."
msgstr "CMake 3.26 及更高版本更喜欢默认启用该功能。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0143.rst:19
msgid ""
"Note that it is the policy setting at the `end` of the top level "
"``CMakeLists.txt`` file that matters.  The policy setting applies globally"
" to the whole project."
msgstr "请注意，重要的是顶层“CMakeLists.txt”文件末尾的策略设置。策略设置全局适用于整个项目。"

#: ../../cmake-prefix/src/cmake/Help/policy/CMP0143.rst:23
msgid ""
"This policy provides compatibility with projects that have not been "
"updated to expect enabling of folders.  Enabling folders causes projects "
"to appear differently in IDEs.  The policy was introduced in CMake version"
" 3.26.  Use the :command:`cmake_policy` command to set it to ``OLD`` or "
"``NEW`` explicitly. Unlike many policies, CMake version |release| does "
"*not* warn when this policy is not set and simply uses ``OLD`` behavior."
msgstr ""
"此策略提供与尚未更新以期望启用文件夹的项目的兼容性。启用文件夹会导致项目在 IDE 中显示不同。该政策是在 CMake 版本 3.26 "
"中引入的。使用 :command:`cmake_policy` 命令将其显式设置为 ``OLD`` 或 ``NEW``。与许多政策不同，CMake "
"版本 |release|当此策略未设置且仅使用“旧”行为时*不*发出警告。"
