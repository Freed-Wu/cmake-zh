# command
msgid ""
msgstr ""
"Project-Id-Version: CMake 3.26.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-01 00:02+0800\n"
"PO-Revision-Date: 2023-06-01 20:35+0800\n"
"Last-Translator: Wu Zhenyu <wuzhenyu@ustc.edu>\n"
"Language-Team: Wu Zhenyu <wuzhenyu@ustc.edu>\n"
"Language: zh-CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.12.1\n"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_definitions.rst:2
msgid "add_compile_definitions"
msgstr "添加编译定义"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_definitions.rst:6
msgid "Add preprocessor definitions to the compilation of source files."
msgstr "将预处理器定义添加到源文件的编译中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_definitions.rst:12
msgid "Adds preprocessor definitions to the compiler command line."
msgstr "将预处理器定义添加到编译器命令行。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_definitions.rst:14
msgid ""
"The preprocessor definitions are added to the "
":prop_dir:`COMPILE_DEFINITIONS` directory property for the current "
"``CMakeLists`` file. They are also added to the "
":prop_tgt:`COMPILE_DEFINITIONS` target property for each target in the "
"current ``CMakeLists`` file."
msgstr ""
"预处理器定义被添加到当前 CMakeLists 文件的 :prop_dir:`COMPILE_DEFINITIONS` "
"目录属性中。它们也被添加到当前 CMakeLists 文件中每个目标的 COMPILE_DEFINITIONS 目标属性中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_definitions.rst:19
msgid ""
"Definitions are specified using the syntax ``VAR`` or ``VAR=value``. "
"Function-style definitions are not supported. CMake will automatically "
"escape the value correctly for the native build system (note that CMake "
"language syntax may require escapes to specify some values)."
msgstr ""
"使用语法“VAR”或“VAR=value”指定定义。不支持函数样式定义。 CMake 将自动为本机构建系统正确转义该值（请注意，CMake "
"语言语法可能需要转义以指定某些值）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_definitions.rst:24
msgid "Any leading ``-D`` on an item will be removed."
msgstr "项目上任何前导的 ``-D`` 都将被删除。"

#: ../../cmake-prefix/src/cmake/Help/command/GENEX_NOTE.txt:3
#: ../../cmake-prefix/src/cmake/Help/command/GENEX_NOTE.txt:4
msgid ""
"Arguments to |command_name| may use generator expressions with the syntax "
"``$<...>``. See the :manual:`cmake-generator-expressions(7)` manual for "
"available expressions.  |more_see_also|"
msgstr ""
"|command_name| 的参数可以使用语法为“$<...>”的生成器表达式。请参阅 :manual:`cmake-generator-"
"expressions(7)` 手册了解可用的表达式。 |更多_另见|"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_definitions.rst:31
#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:42
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:549
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:190
#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:35
#: ../../cmake-prefix/src/cmake/Help/command/add_dependencies.rst:24
#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:112
#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:266
#: ../../cmake-prefix/src/cmake/Help/command/add_link_options.rst:36
#: ../../cmake-prefix/src/cmake/Help/command/block.rst:72
#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:84
#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:118
#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:155
#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:187
#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:78
#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:133
#: ../../cmake-prefix/src/cmake/Help/command/function.rst:78
#: ../../cmake-prefix/src/cmake/Help/command/get_cmake_property.rst:21
#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:38
#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:74
#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:104
#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:48
#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:26
#: ../../cmake-prefix/src/cmake/Help/command/get_test_property.rst:23
#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:42
#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:58
#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:154
#: ../../cmake-prefix/src/cmake/Help/command/message.rst:248
#: ../../cmake-prefix/src/cmake/Help/command/return.rst:89
#: ../../cmake-prefix/src/cmake/Help/command/set.rst:116
#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:18
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:116
#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:43
#: ../../cmake-prefix/src/cmake/Help/command/set_target_properties.rst:19
#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:18
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:51
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:40
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:42
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:77
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:59
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:412
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:55
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:118
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:207
#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:355
#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:44
#: ../../cmake-prefix/src/cmake/Help/command/while.rst:28
msgid "See Also"
msgstr "也可以看看"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_definitions.rst:33
msgid ""
"The command :command:`target_compile_definitions` adds target-specific "
"definitions."
msgstr "命令 :command:`target_compile_definitions` 添加特定于目标的定义。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:2
msgid "add_compile_options"
msgstr "添加编译选项"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:4
msgid "Add options to the compilation of source files."
msgstr "为源文件的编译添加选项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:10
msgid ""
"Adds options to the :prop_dir:`COMPILE_OPTIONS` directory property. These "
"options are used when compiling targets from the current directory and "
"below."
msgstr "添加选项到 :prop_dir:`COMPILE_OPTIONS` 目录属性。从当前目录及以下目录编译目标时使用这些选项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:15
#: ../../cmake-prefix/src/cmake/Help/command/function.rst:58
#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:56
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:19
msgid "Arguments"
msgstr "参数"

#: ../../cmake-prefix/src/cmake/Help/command/OPTIONS_SHELL.txt:2
msgid "Option De-duplication"
msgstr "选项重复数据删除"

#: ../../cmake-prefix/src/cmake/Help/command/OPTIONS_SHELL.txt:4
msgid ""
"The final set of options used for a target is constructed by accumulating "
"options from the current target and the usage requirements of its "
"dependencies.  The set of options is de-duplicated to avoid repetition."
msgstr "用于目标的最终选项集是通过累积当前目标的选项及其依赖项的使用要求而构建的。对选项集进行去重以避免重复。"

#: ../../cmake-prefix/src/cmake/Help/command/OPTIONS_SHELL.txt:8
msgid ""
"While beneficial for individual options, the de-duplication step can break"
" up option groups.  For example, ``-option A -option B`` becomes ``-option"
" A B``.  One may specify a group of options using shell-like quoting along"
" with a ``SHELL:`` prefix.  The ``SHELL:`` prefix is dropped, and the rest"
" of the option string is parsed using the :command:`separate_arguments` "
"``UNIX_COMMAND`` mode. For example, ``\"SHELL:-option A\" \"SHELL:-option "
"B\"`` becomes ``-option A -option B``."
msgstr ""
"虽然对单个选项有利，但重复数据删除步骤可以分解选项组。例如，“-option A -option B”变为“-option A B”。可以使用类似 "
"shell 的引号和 ``SHELL:`` 前缀来指定一组选项。 ``SHELL:`` 前缀被删除，选项字符串的其余部分使用 "
":command:`separate_arguments` ``UNIX_COMMAND`` 模式进行解析。例如，``\"SHELL:-option"
" A\" \"SHELL:-option B\"`` 变为 ``-option A -option B``。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:23
#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:141
msgid "Example"
msgstr "例子"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:25
msgid ""
"Since different compilers support different options, a typical use of this"
" command is in a compiler-specific conditional clause:"
msgstr "由于不同的编译器支持不同的选项，此命令的典型用法是在特定于编译器的条件子句中："

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:38
msgid ""
"To set per-language options, use the :genex:`$<COMPILE_LANGUAGE>` or "
":genex:`$<COMPILE_LANGUAGE:languages>` generator expressions."
msgstr ""
"要设置每种语言的选项，请使用 :genex:`$<COMPILE_LANGUAGE>` 或 "
":genex:`$<COMPILE_LANGUAGE:languages>` 生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:44
msgid ""
"This command can be used to add any options. However, for adding "
"preprocessor definitions and include directories it is recommended to use "
"the more specific commands :command:`add_compile_definitions` and "
":command:`include_directories`."
msgstr ""
"此命令可用于添加任何选项。但是，为了添加预处理器定义和包含目录，建议使用更具体的命令:command:`add_compile_definitions`"
" 和:command:`include_directories`。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:49
msgid ""
"The command :command:`target_compile_options` adds target-specific "
"options."
msgstr "命令 :command:`target_compile_options` 添加特定于目标的选项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_compile_options.rst:51
msgid ""
"The source file property :prop_sf:`COMPILE_OPTIONS` adds options to one "
"source file."
msgstr "源文件属性 :prop_sf:`COMPILE_OPTIONS` 将选项添加到一个源文件。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:2
msgid "add_custom_command"
msgstr "添加自定义命令"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:4
msgid "Add a custom build rule to the generated build system."
msgstr "将自定义构建规则添加到生成的构建系统。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:6
msgid "There are two main signatures for ``add_custom_command``."
msgstr "``add_custom_command`` 有两个主要签名。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:9
msgid "Generating Files"
msgstr "生成文件"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:11
msgid ""
"The first signature is for adding a custom command to produce an output:"
msgstr "第一个签名用于添加自定义命令以生成输出："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:30
msgid ""
"This defines a command to generate specified ``OUTPUT`` file(s). A target "
"created in the same directory (``CMakeLists.txt`` file) that specifies any"
" output of the custom command as a source file is given a rule to generate"
" the file using the command at build time."
msgstr ""
"这定义了一个命令来生成指定的 ``OUTPUT`` 文件。在同一目录（``CMakeLists.txt`` "
"文件）中创建的将自定义命令的任何输出指定为源文件的目标被赋予规则以在构建时使用命令生成文件。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:35
msgid ""
"Do not list the output in more than one independent target that may build "
"in parallel or the instances of the rule may conflict. Instead, use the "
":command:`add_custom_target` command to drive the command and make the "
"other targets depend on that one.  See the `Example: Generating Files for "
"Multiple Targets`_ below."
msgstr ""
"不要在多个可能并行构建的独立目标中列出输出，否则规则的实例可能会发生冲突。相反，使用 :command:`add_custom_target` "
"命令来驱动命令并使其他目标依赖于该命令。请参阅下面的“示例：为多个目标生成文件”。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:41
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:27
#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:125
#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:27
#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:15
#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:18
#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:22
#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:39
#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:16
#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:10
#: ../../cmake-prefix/src/cmake/Help/command/export.rst:41
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:732
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:762
#: ../../cmake-prefix/src/cmake/Help/command/project.rst:43
#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:17
#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:146
msgid "The options are:"
msgstr "选项是："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:55
#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:38
#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:30
#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:29
#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:59
#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:50
#: ../../cmake-prefix/src/cmake/Help/command/export.rst:48
msgid "``APPEND``"
msgstr "``追加``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:44
msgid ""
"Append the ``COMMAND`` and ``DEPENDS`` option values to the custom command"
" for the first output specified.  There must have already been a previous "
"call to this command with the same output."
msgstr ""
"将 ``COMMAND`` 和 ``DEPENDS`` 选项值附加到指定第一个输出的自定义命令。之前必须已经调用过具有相同输出的此命令。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:48
msgid ""
"If the previous call specified the output via a generator expression, the "
"output specified by the current call must match in at least one "
"configuration after evaluating generator expressions.  In this case, the "
"appended commands and dependencies apply to all configurations."
msgstr ""
"如果前一个调用通过生成器表达式指定了输出，则当前调用指定的输出必须在评估生成器表达式后至少在一个配置中匹配。在这种情况下，附加的命令和依赖项适用于所有配置。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:53
msgid ""
"The ``COMMENT``, ``MAIN_DEPENDENCY``, and ``WORKING_DIRECTORY`` options "
"are currently ignored when APPEND is given, but may be used in the future."
msgstr ""
"``COMMENT``、``MAIN_DEPENDENCY`` 和 ``WORKING_DIRECTORY`` 选项当前在给出 APPEND "
"时被忽略，但将来可能会被使用。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:86
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:63
msgid "``BYPRODUCTS``"
msgstr "``副产品``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:60
msgid ""
"Specify the files the command is expected to produce but whose "
"modification time may or may not be newer than the dependencies. If a "
"byproduct name is a relative path it will be interpreted relative to the "
"build tree directory corresponding to the current source directory. Each "
"byproduct file will be marked with the :prop_sf:`GENERATED` source file "
"property automatically."
msgstr ""
"指定命令预期生成的文件，但其修改时间可能比依赖项更新，也可能不更新。如果副产品名称是相对路径，它将相对于与当前源目录相对应的构建树目录进行解释。每个副产品文件将自动标有"
" :prop_sf:`GENERATED` 源文件属性。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:68
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:45
msgid ""
"*See policy* :policy:`CMP0058` *for the motivation behind this feature.*"
msgstr "*查看政策* :policy:`CMP0058` *了解此功能背后的动机。*"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:70
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:47
msgid ""
"Explicit specification of byproducts is supported by the "
":generator:`Ninja` generator to tell the ``ninja`` build tool how to "
"regenerate byproducts when they are missing.  It is also useful when other"
" build rules (e.g. custom commands) depend on the byproducts.  Ninja "
"requires a build rule for any generated file on which another rule depends"
" even if there are order-only dependencies to ensure the byproducts will "
"be available before their dependents build."
msgstr ""
":generator:`Ninja` 生成器支持副产品的显式规范，以告诉 ``ninja`` "
"构建工具如何在副产品丢失时重新生成它们。当其他构建规则（例如自定义命令）依赖于副产品时，它也很有用。 Ninja "
"需要为任何生成的文件建立规则，而另一个规则所依赖的文件即使存在仅顺序依赖项，以确保副产品在其依赖项构建之前可用。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:79
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:56
msgid ""
"The :ref:`Makefile Generators` will remove ``BYPRODUCTS`` and other "
":prop_sf:`GENERATED` files during ``make clean``."
msgstr ""
":ref:`Makefile Generators` 将在 ``make clean`` 期间删除 ``BYPRODUCTS`` 和其他 "
":prop_sf:`GENERATED` 文件。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:82
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:59
msgid ""
"Arguments to ``BYPRODUCTS`` may use a restricted set of :manual:`generator"
" expressions <cmake-generator-expressions(7)>`. :ref:`Target-dependent "
"expressions <Target-Dependent Queries>` are not permitted."
msgstr ""
"``BYPRODUCTS`` 的参数可以使用一组受限的 :manual:`generator expressions <cmake-"
"generator-expressions(7)>`。 :ref:`Target-dependent expressions <Target-"
"Dependent Queries>` 是不允许的。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:135
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:106
#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:24
#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:60
msgid "``COMMAND``"
msgstr "``命令``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:89
msgid ""
"Specify the command-line(s) to execute at build time. If more than one "
"``COMMAND`` is specified they will be executed in order, but *not* "
"necessarily composed into a stateful shell or batch script. (To run a full"
" script, use the :command:`configure_file` command or the "
":command:`file(GENERATE)` command to create it, and then specify a "
"``COMMAND`` to launch it.) The optional ``ARGS`` argument is for backward "
"compatibility and will be ignored."
msgstr ""
"指定要在构建时执行的命令行。如果指定了多个 ``COMMAND``，它们将按顺序执行，但 *不一定* 必须组合成有状态的 shell 或批处理脚本。"
" （要运行完整脚本，请使用 :command:`configure_file` 命令或 :command:`file(GENERATE)` "
"命令创建它，然后指定一个 ``COMMAND`` 来启动它。）可选的 `` ARGS`` 参数是为了向后兼容，将被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:98
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:73
msgid ""
"If ``COMMAND`` specifies an executable target name (created by the "
":command:`add_executable` command), it will automatically be replaced by "
"the location of the executable created at build time if either of the "
"following is true:"
msgstr ""
"如果 ``COMMAND`` 指定了可执行目标名称（由 :command:`add_executable` "
"命令创建），如果满足以下任一条件，它将自动替换为构建时创建的可执行文件的位置："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:103
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:78
msgid ""
"The target is not being cross-compiled (i.e. the "
":variable:`CMAKE_CROSSCOMPILING` variable is not set to true)."
msgstr "目标未被交叉编译（即 :variable:`CMAKE_CROSSCOMPILING` 变量未设置为 true）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:105
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:80
msgid ""
"The target is being cross-compiled and an emulator is provided (i.e. its "
":prop_tgt:`CROSSCOMPILING_EMULATOR` target property is set). In this case,"
" the contents of :prop_tgt:`CROSSCOMPILING_EMULATOR` will be prepended to "
"the command before the location of the target executable."
msgstr ""
"正在交叉编译目标并提供模拟器（即设置其 :prop_tgt:`CROSSCOMPILING_EMULATOR` "
"目标属性）。在这种情况下，CROSSCOMPILING_EMULATOR 的内容将添加到目标可执行文件位置之前的命令中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:111
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:86
msgid ""
"If neither of the above conditions are met, it is assumed that the command"
" name is a program to be found on the ``PATH`` at build time."
msgstr "如果以上条件都不满足，则假定命令名称是在构建时在 ``PATH`` 上找到的程序。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:114
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:89
msgid ""
"Arguments to ``COMMAND`` may use :manual:`generator expressions <cmake-"
"generator-expressions(7)>`. Use the :genex:`TARGET_FILE` generator "
"expression to refer to the location of a target later in the command line "
"(i.e. as a command argument rather than as the command to execute)."
msgstr ""
"``COMMAND`` 的参数可以使用 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`。使用 :genex:`TARGET_FILE` "
"生成器表达式稍后在命令行中引用目标的位置（即作为命令参数而不是作为要执行的命令）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:120
msgid ""
"Whenever one of the following target based generator expressions are used "
"as a command to execute or is mentioned in a command argument, a target-"
"level dependency will be added automatically so that the mentioned target "
"will be built before any target using this custom command (see policy "
":policy:`CMP0112`)."
msgstr ""
"每当以下基于目标的生成器表达式之一用作要执行的命令或在命令参数中提及时，将自动添加目标级依赖项，以便在使用此自定义命令的任何目标之前构建提及的目标（请参阅政策:policy:`CMP0112`）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:126
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:100
msgid "``TARGET_FILE``"
msgstr "``TARGET_FILE``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:127
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:101
msgid "``TARGET_LINKER_FILE``"
msgstr "``TARGET_LINKER_FILE``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:128
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:102
msgid "``TARGET_SONAME_FILE``"
msgstr "``TARGET_SONAME_FILE``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:129
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:103
msgid "``TARGET_PDB_FILE``"
msgstr "``TARGET_PDB_FILE``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:131
msgid ""
"This target-level dependency does NOT add a file-level dependency that "
"would cause the custom command to re-run whenever the executable is "
"recompiled. List target names with the ``DEPENDS`` option to add such "
"file-level dependencies."
msgstr ""
"此目标级依赖性不会添加文件级依赖性，该文件级依赖性会导致自定义命令在可执行文件重新编译时重新运行。使用 ``DEPENDS`` "
"选项列出目标名称以添加此类文件级依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:143
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:114
msgid "``COMMENT``"
msgstr "``评论``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:138
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:109
msgid ""
"Display the given message before the commands are executed at build time."
msgstr "在构建时执行命令之前显示给定的消息。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:141
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:112
msgid ""
"Arguments to ``COMMENT`` may use :manual:`generator expressions <cmake-"
"generator-expressions(7)>`."
msgstr ""
"``COMMENT`` 的参数可以使用 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:187
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:128
msgid "``DEPENDS``"
msgstr "``取决于``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:146
msgid ""
"Specify files on which the command depends.  Each argument is converted to"
" a dependency as follows:"
msgstr "指定命令所依赖的文件。每个参数都转换为依赖项，如下所示："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:149
msgid ""
"If the argument is the name of a target (created by the "
":command:`add_custom_target`, :command:`add_executable`, or "
":command:`add_library` command) a target-level dependency is created to "
"make sure the target is built before any target using this custom command."
"  Additionally, if the target is an executable or library, a file-level "
"dependency is created to cause the custom command to re-run whenever the "
"target is recompiled."
msgstr ""
"如果参数是目标的名称（由 :command:`add_custom_target`、 :command:`add_executable` 或 "
":command:`add_library` "
"命令创建），则创建目标级依赖项以确保构建目标在使用此自定义命令的任何目标之前。此外，如果目标是可执行文件或库，则会创建文件级依赖性，以便在重新编译目标时重新运行自定义命令。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:158
msgid ""
"If the argument is an absolute path, a file-level dependency is created on"
" that path."
msgstr "如果参数是绝对路径，则会在该路径上创建文件级依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:161
msgid ""
"If the argument is the name of a source file that has been added to a "
"target or on which a source file property has been set, a file-level "
"dependency is created on that source file."
msgstr "如果参数是已添加到目标或已设置源文件属性的源文件的名称，则会在该源文件上创建文件级依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:165
msgid ""
"If the argument is a relative path and it exists in the current source "
"directory, a file-level dependency is created on that file in the current "
"source directory."
msgstr "如果参数是相对路径并且它存在于当前源目录中，则会在当前源目录中的该文件上创建文件级依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:169
msgid ""
"Otherwise, a file-level dependency is created on that path relative to the"
" current binary directory."
msgstr "否则，将在相对于当前二进制目录的该路径上创建文件级依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:172
msgid ""
"If any dependency is an ``OUTPUT`` of another custom command in the same "
"directory (``CMakeLists.txt`` file), CMake automatically brings the other "
"custom command into the target in which this command is built."
msgstr ""
"如果任何依赖项是同一目录中另一个自定义命令的“输出”（“CMakeLists.txt”文件），CMake "
"会自动将其他自定义命令引入构建此命令的目标中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:176
msgid ""
"A target-level dependency is added if any dependency is listed as "
"``BYPRODUCTS`` of a target or any of its build events in the same "
"directory to ensure the byproducts will be available."
msgstr "如果任何依赖项被列为目标的“BYPRODUCTS”或其在同一目录中的任何构建事件，则会添加目标级依赖项，以确保副产品可用。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:181
msgid ""
"If ``DEPENDS`` is not specified, the command will run whenever the "
"``OUTPUT`` is missing; if the command does not actually create the "
"``OUTPUT``, the rule will always run."
msgstr ""
"如果未指定“DEPENDS”，则只要缺少“OUTPUT”，该命令就会运行；如果该命令实际上并未创建 ``OUTPUT``，则该规则将始终运行。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:185
msgid ""
"Arguments to ``DEPENDS`` may use :manual:`generator expressions <cmake-"
"generator-expressions(7)>`."
msgstr ""
"``DEPENDS`` 的参数可以使用 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:197
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:138
#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:44
msgid "``COMMAND_EXPAND_LISTS``"
msgstr "``COMMAND_EXPAND_LISTS``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:192
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:133
msgid ""
"Lists in ``COMMAND`` arguments will be expanded, including those created "
"with :manual:`generator expressions <cmake-generator-expressions(7)>`, "
"allowing ``COMMAND`` arguments such as ``${CC} "
"\"-I$<JOIN:$<TARGET_PROPERTY:foo,INCLUDE_DIRECTORIES>,;-I>\" foo.cc`` to "
"be properly expanded."
msgstr ""
"``COMMAND`` 参数中的列表将被扩展，包括使用 :manual:`generator expressions <cmake-"
"generator-expressions(7)>` 创建的列表，允许 ``COMMAND`` 参数，例如 ``${CC} ” "
"-I$<JOIN:$<TARGET_PROPERTY:foo,INCLUDE_DIRECTORIES>,;-I>\" foo.cc`` 被正确扩展。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:212
msgid "``IMPLICIT_DEPENDS``"
msgstr "``IMPLICIT_DEPENDS``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:200
msgid ""
"Request scanning of implicit dependencies of an input file. The language "
"given specifies the programming language whose corresponding dependency "
"scanner should be used. Currently only ``C`` and ``CXX`` language scanners"
" are supported. The language has to be specified for every file in the "
"``IMPLICIT_DEPENDS`` list.  Dependencies discovered from the scanning are "
"added to those of the custom command at build time. Note that the "
"``IMPLICIT_DEPENDS`` option is currently supported only for Makefile "
"generators and will be ignored by other generators."
msgstr ""
"请求扫描输入文件的隐式依赖项。给定的语言指定应使用其相应依赖扫描器的编程语言。目前仅支持``C`` 和``CXX`` "
"语言扫描器。必须为“IMPLICIT_DEPENDS”列表中的每个文件指定语言。从扫描中发现的依赖项会在构建时添加到自定义命令的依赖项中。请注意，``IMPLICIT_DEPENDS``"
" 选项目前仅支持 Makefile 生成器，其他生成器将忽略该选项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:212
msgid ""
"This option cannot be specified at the same time as ``DEPFILE`` option."
msgstr "此选项不能与 ``DEPFILE`` 选项同时指定。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:221
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:147
msgid "``JOB_POOL``"
msgstr "``作业池``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:217
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:143
msgid ""
"Specify a :prop_gbl:`pool <JOB_POOLS>` for the :generator:`Ninja` "
"generator. Incompatible with ``USES_TERMINAL``, which implies the "
"``console`` pool. Using a pool that is not defined by "
":prop_gbl:`JOB_POOLS` causes an error by ninja at build time."
msgstr ""
"为 :generator:`Ninja` 生成器指定一个 :prop_gbl:`pool <JOB_POOLS>`。与 "
"``USES_TERMINAL`` 不兼容，这意味着 ``console`` 池。使用 JOB_POOLS 未定义的池会导致 ninja "
"在构建时出错。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:230
msgid "``MAIN_DEPENDENCY``"
msgstr "``MAIN_DEPENDENCY``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:224
msgid ""
"Specify the primary input source file to the command.  This is treated "
"just like any value given to the ``DEPENDS`` option but also suggests to "
"Visual Studio generators where to hang the custom command. Each source "
"file may have at most one command specifying it as its main dependency. A "
"compile command (i.e. for a library or an executable) counts as an "
"implicit main dependency which gets silently overwritten by a custom "
"command specification."
msgstr ""
"指定命令的主要输入源文件。这就像赋予“DEPENDS”选项的任何值一样对待，但也会向 Visual Studio "
"生成器建议将自定义命令挂在何处。每个源文件最多可以有一个命令将其指定为其主要依赖项。编译命令（即用于库或可执行文件）算作隐式主要依赖项，它会被自定义命令规范悄悄覆盖。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:256
msgid "``OUTPUT``"
msgstr "``输出``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:233
msgid ""
"Specify the output files the command is expected to produce. Each output "
"file will be marked with the :prop_sf:`GENERATED` source file property "
"automatically. If the output of the custom command is not actually created"
" as a file on disk it should be marked with the :prop_sf:`SYMBOLIC` source"
" file property."
msgstr ""
"指定命令预期生成的输出文件。每个输出文件将自动标有 :prop_sf:`GENERATED` "
"源文件属性。如果自定义命令的输出实际上并未创建为磁盘上的文件，则应使用 :prop_sf:`SYMBOLIC` 源文件属性进行标记。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:240
msgid ""
"If an output file name is a relative path, its absolute path is determined"
" by interpreting it relative to:"
msgstr "如果输出文件名是相对路径，则其绝对路径是通过相对于以下各项解释它来确定的："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:243
msgid ""
"the build directory corresponding to the current source directory "
"(:variable:`CMAKE_CURRENT_BINARY_DIR`), or"
msgstr "与当前源目录对应的构建目录（ :variable:`CMAKE_CURRENT_BINARY_DIR`），或"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:246
msgid "the current source directory (:variable:`CMAKE_CURRENT_SOURCE_DIR`)."
msgstr "当前源目录（ :variable:`CMAKE_CURRENT_SOURCE_DIR`）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:248
msgid ""
"The path in the build directory is preferred unless the path in the source"
" tree is mentioned as an absolute source file path elsewhere in the "
"current directory."
msgstr "构建目录中的路径是首选，除非源树中的路径被提及为当前目录中其他地方的绝对源文件路径。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:252
msgid ""
"Arguments to ``OUTPUT`` may use a restricted set of :manual:`generator "
"expressions <cmake-generator-expressions(7)>`. :ref:`Target-dependent "
"expressions <Target-Dependent Queries>` are not permitted."
msgstr ""
"``OUTPUT`` 的参数可以使用一组受限的 :manual:`generator expressions <cmake-generator-"
"expressions(7)>`。 :ref:`Target-dependent expressions <Target-Dependent "
"Queries>` 是不允许的。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:263
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:169
msgid "``USES_TERMINAL``"
msgstr "``USES_TERMINAL``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:261
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:167
msgid ""
"The command will be given direct access to the terminal if possible. With "
"the :generator:`Ninja` generator, this places the command in the "
"``console`` :prop_gbl:`pool <JOB_POOLS>`."
msgstr ""
"如果可能，该命令将被授予直接访问终端的权限。使用 :generator:`Ninja` 生成器，这会将命令放在 ``console`` "
":prop_gbl:`pool <JOB_POOLS>` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:273
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:162
msgid "``VERBATIM``"
msgstr "``逐字``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:266
msgid ""
"All arguments to the commands will be escaped properly for the build tool "
"so that the invoked command receives each argument unchanged.  Note that "
"one level of escapes is still used by the CMake language processor before "
"add_custom_command even sees the arguments.  Use of ``VERBATIM`` is "
"recommended as it enables correct behavior.  When ``VERBATIM`` is not "
"given the behavior is platform specific because there is no protection of "
"tool-specific special characters."
msgstr ""
"命令的所有参数都将为构建工具正确转义，以便调用的命令接收每个参数不变。请注意，在 add_custom_command 甚至看到参数之前，CMake"
" 语言处理器仍然使用一级转义。建议使用“VERBATIM”，因为它可以实现正确的行为。当未给出 VERBATIM "
"时，行为是特定于平台的，因为没有对特定于工具的特殊字符的保护。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:282
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:178
#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:37
#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:64
msgid "``WORKING_DIRECTORY``"
msgstr "``工作目录``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:276
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:172
msgid ""
"Execute the command with the given current working directory. If it is a "
"relative path it will be interpreted relative to the build tree directory "
"corresponding to the current source directory."
msgstr "使用给定的当前工作目录执行命令。如果它是相对路径，它将被解释为相对于当前源目录对应的构建树目录。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:280
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:176
msgid ""
"Arguments to ``WORKING_DIRECTORY`` may use :manual:`generator expressions "
"<cmake-generator-expressions(7)>`."
msgstr ""
"``WORKING_DIRECTORY`` 的参数可以使用 :manual:`generator expressions <cmake-"
"generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:358
msgid "``DEPFILE``"
msgstr "``DEPFILE``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:287
msgid ""
"Specify a depfile which holds dependencies for the custom command. It is "
"usually emitted by the custom command itself.  This keyword may only be "
"used if the generator supports it, as detailed below."
msgstr "指定一个包含自定义命令依赖项的 depfile。它通常由自定义命令本身发出。这个关键字只能在生成器支持的情况下使用，如下所述。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:291
msgid ""
"The expected format, compatible with what is generated by ``gcc`` with the"
" option ``-M``, is independent of the generator or platform."
msgstr "预期格式与带有选项“-M”的“gcc”生成的内容兼容，与生成器或平台无关。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:294
#, python-format
msgid ""
"The formal syntax, as specified using `BNF "
"<https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form>`_ notation with "
"the regular extensions, is the following:"
msgstr ""
"使用带有常规扩展名的`BNF <https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form>`_ "
"符号指定的正式语法如下："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:326
msgid ""
"As part of ``pathname``, any slash and backslash is interpreted as a "
"directory separator."
msgstr "作为“路径名”的一部分，任何斜杠和反斜杠都被解释为目录分隔符。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:329
msgid ""
"The :generator:`Ninja` generator supports ``DEPFILE`` since the keyword "
"was first added."
msgstr ":generator:`Ninja` 生成器支持 ``DEPFILE`` 因为关键字是第一次添加的。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:333
msgid ""
"Added the :generator:`Ninja Multi-Config` generator, which included "
"support for the ``DEPFILE`` keyword."
msgstr "添加了 :generator:`Ninja Multi-Config` 生成器，其中包括对 ``DEPFILE`` 关键字的支持。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:337
msgid "Added support for :ref:`Makefile Generators`."
msgstr "添加了对 :ref:`Makefile Generators` 的支持。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:342
msgid ""
"``DEPFILE`` cannot be specified at the same time as the "
"``IMPLICIT_DEPENDS`` option for :ref:`Makefile Generators`."
msgstr ""
"``DEPFILE`` 不能与 :ref:`Makefile Generators` 的 ``IMPLICIT_DEPENDS`` 选项同时指定。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:345
msgid ""
"Added support for :ref:`Visual Studio Generators` with VS 2012 and above, "
"and for the :generator:`Xcode` generator.  Support for :manual:`generator "
"expressions <cmake-generator-expressions(7)>` was also added."
msgstr ""
"添加了对 VS 2012 及更高版本的 Visual Studio Generators 和 Xcode 生成器的支持。还添加了对 "
":manual:`generator expressions <cmake-generator-expressions(7)>` 的支持。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:351
msgid ""
"Using ``DEPFILE`` with generators other than those listed above is an "
"error."
msgstr "将 ``DEPFILE`` 与上面列出的生成器以外的生成器一起使用是错误的。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:353
msgid ""
"If the ``DEPFILE`` argument is relative, it should be relative to "
":variable:`CMAKE_CURRENT_BINARY_DIR`, and any relative paths inside the "
"``DEPFILE`` should also be relative to "
":variable:`CMAKE_CURRENT_BINARY_DIR`. See policy :policy:`CMP0116`, which "
"is always ``NEW`` for :ref:`Makefile Generators`, :ref:`Visual Studio "
"Generators`, and the :generator:`Xcode` generator."
msgstr ""
"如果``DEPFILE`` 参数是相对的，它应该是相对于 :variable:`CMAKE_CURRENT_BINARY_DIR`，并且``DEPFILE`` "
"中的任何相对路径也应该是相对于 :variable:`CMAKE_CURRENT_BINARY_DIR`。请参阅策略:policy:`CMP0116`，对于:ref:`Makefile"
" Generators`、:ref:`Visual Studio Generators` 和:generator:`Xcode` 生成器，它始终是 "
"``NEW``。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:361
msgid "Examples: Generating Files"
msgstr "示例：生成文件"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:363
msgid ""
"Custom commands may be used to generate source files. For example, the "
"code:"
msgstr "自定义命令可用于生成源文件。例如，代码："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:376
msgid ""
"adds a custom command to run ``someTool`` to generate ``out.c`` and then "
"compile the generated source as part of a library.  The generation rule "
"will re-run whenever ``in.txt`` changes."
msgstr ""
"添加自定义命令以运行“someTool”以生成“out.c”，然后将生成的源代码编译为库的一部分。只要 ``in.txt`` "
"发生变化，生成规则就会重新运行。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:380
msgid ""
"One may use generator expressions to specify per-configuration outputs. "
"For example, the code:"
msgstr "可以使用生成器表达式来指定每个配置的输出。例如，代码："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:395
msgid ""
"adds a custom command to run ``someTool`` to generate ``out-<config>.c``, "
"where ``<config>`` is the build configuration, and then compile the "
"generated source as part of a library."
msgstr ""
"添加一个自定义命令来运行 ``someTool`` 以生成 ``out-<config>.c``，其中 ``<config>`` "
"是构建配置，然后将生成的源代码编译为库的一部分。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:400
msgid "Example: Generating Files for Multiple Targets"
msgstr "示例：为多个目标生成文件"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:402
msgid ""
"If multiple independent targets need the same custom command output, it "
"must be attached to a single custom target on which they all depend. "
"Consider the following example:"
msgstr "如果多个独立目标需要相同的自定义命令输出，则它必须附加到它们都依赖的单个自定义目标。考虑以下示例："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:432
msgid ""
"Output ``foo.cxx`` is needed only by target ``foo`` and output ``bar.cxx``"
" is needed only by target ``bar``, but *both* targets need ``table.csv``, "
"transitively.  Since ``foo`` and ``bar`` are independent targets that may "
"build concurrently, we prevent them from racing to generate ``table.csv`` "
"by placing its custom command in a separate target, "
"``generate_table_csv``. The custom commands generating ``foo.cxx`` and "
"``bar.cxx`` each specify a target-level dependency on "
"``generate_table_csv``, so the targets using them, ``foo`` and ``bar``, "
"will not build until after target ``generate_table_csv`` is built."
msgstr ""
"只有目标“foo”需要输出“foo.cxx”，只有目标“bar”需要输出“bar.cxx”，但是*两个*目标都需要“table.csv” "
"`，传递性。由于“foo”和“bar”是可以同时构建的独立目标，我们通过将其自定义命令放在单独的目标“generate_table_csv”中来防止它们竞相生成“table.csv”。生成"
" ``foo.cxx`` 和 ``bar.cxx`` 的自定义命令各自指定了对 ``generate_table_csv`` "
"的目标级依赖，因此使用它们的目标，``foo`` 和 ``bar`` , 在构建目标 ``generate_table_csv`` 之前不会构建。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:445
msgid "Build Events"
msgstr "建立事件"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:447
msgid ""
"The second signature adds a custom command to a target such as a library "
"or executable.  This is useful for performing an operation before or after"
" building the target.  The command becomes part of the target and will "
"only execute when the target itself is built.  If the target is already "
"built, the command will not execute."
msgstr ""
"第二个签名将自定义命令添加到目标，例如库或可执行文件。这对于在构建目标之前或之后执行操作很有用。该命令成为目标的一部分，并且只会在构建目标本身时执行。如果目标已经构建，命令将不会执行。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:465
msgid ""
"This defines a new command that will be associated with building the "
"specified ``<target>``.  The ``<target>`` must be defined in the current "
"directory; targets defined in other directories may not be specified."
msgstr ""
"这定义了一个新命令，该命令将与构建指定的 ``<target>`` 相关联。 ``<target>`` "
"必须在当前目录中定义；可能未指定在其他目录中定义的目标。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:469
msgid ""
"When the command will happen is determined by which of the following is "
"specified:"
msgstr "该命令何时执行取决于指定了以下哪一项："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:474
msgid "``PRE_BUILD``"
msgstr "``PRE_BUILD``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:473
msgid ""
"On :ref:`Visual Studio Generators`, run before any other rules are "
"executed within the target. On other generators, run just before "
"``PRE_LINK`` commands."
msgstr ""
"在 :ref:`Visual Studio Generators` "
"上，在目标内执行任何其他规则之前运行。在其他生成器上，在“PRE_LINK”命令之前运行。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:479
msgid "``PRE_LINK``"
msgstr "``PRE_LINK``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:477
msgid ""
"Run after sources have been compiled but before linking the binary or "
"running the librarian or archiver tool of a static library. This is not "
"defined for targets created by the :command:`add_custom_target` command."
msgstr ""
"在编译源之后但在链接二进制文件或运行静态库的库管理器或归档器工具之前运行。这不是为 add_custom_target 命令创建的目标定义的。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:482
msgid "``POST_BUILD``"
msgstr "``POST_BUILD``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:482
msgid "Run after all other rules within the target have been executed."
msgstr "在执行完目标中的所有其他规则后运​​行。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:484
msgid ""
"Projects should always specify one of the above three keywords when using "
"the ``TARGET`` form.  For backward compatibility reasons, ``POST_BUILD`` "
"is assumed if no such keyword is given, but projects should explicitly "
"provide one of the keywords to make clear the behavior they expect."
msgstr ""
"使用“TARGET”形式时，项目应始终指定上述三个关键字之一。出于向后兼容性的原因，如果没有给出这样的关键字，则假定为“POST_BUILD”，但项目应明确提供关键字之一以明确他们期望的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:490
msgid ""
"Because generator expressions can be used in custom commands, it is "
"possible to define ``COMMAND`` lines or whole custom commands which "
"evaluate to empty strings for certain configurations. For **Visual Studio "
"11 2012 (and newer)** generators these command lines or custom commands "
"will be omitted for the specific configuration and no \"empty-string-"
"command\" will be added."
msgstr ""
"因为生成器表达式可以在自定义命令中使用，所以可以定义 ``COMMAND`` 行或整个自定义命令，这些命令对某些配置求值为空字符串。对于 "
"**Visual Studio 11 2012（及更新版本）** 生成器，这些命令行或自定义命令将针对特定配置省略，并且不会添加“空字符串命令”。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:497
msgid "This allows to add individual build events for every configuration."
msgstr "这允许为每个配置添加单独的构建事件。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:499
msgid "Support for target-dependent generator expressions."
msgstr "支持目标相关的生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:503
msgid "Examples: Build Events"
msgstr "示例：构建事件"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:505
msgid ""
"A ``POST_BUILD`` event may be used to post-process a binary after linking."
" For example, the code:"
msgstr "``POST_BUILD`` 事件可用于在链接后对二进制文件进行后处理。例如，代码："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:517
msgid ""
"will run ``someHasher`` to produce a ``.hash`` file next to the executable"
" after linking."
msgstr "将在链接后运行 ``someHasher`` 以在可执行文件旁边生成一个 ``.hash`` 文件。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:520
msgid ""
"One may use generator expressions to specify per-configuration byproducts."
" For example, the code:"
msgstr "可以使用生成器表达式来指定每个配置的副产品。例如，代码："

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:535
msgid ""
"will run ``someHasher`` after linking ``myPlugin``, e.g. to produce a "
"``.c`` file containing code to check the hash of ``myPlugin`` that the "
"``myExe`` executable can use to verify it before loading."
msgstr ""
"将在链接 ``myPlugin`` 后运行 ``someHasher``，例如生成一个 ``.c`` 文件，其中包含用于检查 ``myExe`` "
"可执行文件可以在加载之前验证它的 ``myPlugin`` 散列的代码。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:540
#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:181
msgid "Ninja Multi-Config"
msgstr "忍者多配置"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:544
msgid ""
"``add_custom_command`` supports the :generator:`Ninja Multi-Config` "
"generator's cross-config capabilities. See the generator documentation for"
" more information."
msgstr ""
"``add_custom_command`` 支持 :generator:`Ninja Multi-Config` "
"生成器的交叉配置功能。有关详细信息，请参阅生成器文档。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_command.rst:551
msgid ":command:`add_custom_target`"
msgstr ":command:`add_custom_target`"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:2
msgid "add_custom_target"
msgstr "添加自定义目标"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:4
msgid "Add a target with no output so it will always be built."
msgstr "添加一个没有输出的目标，以便始终构建它。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:19
msgid ""
"Adds a target with the given name that executes the given commands. The "
"target has no output file and is *always considered out of date* even if "
"the commands try to create a file with the name of the target. Use the "
":command:`add_custom_command` command to generate a file with "
"dependencies.  By default nothing depends on the custom target.  Use the "
":command:`add_dependencies` command to add dependencies to or from other "
"targets."
msgstr ""
"添加具有执行给定命令的给定名称的目标。目标没有输出文件，并且*总是被认为是过时的*，即使命令试图创建一个具有目标名称的文件。使用 "
":command:`add_custom_command` 命令生成具有依赖项的文件。默认情况下，没有什么依赖于自定义目标。使用 "
":command:`add_dependencies` 命令向其他目标添加依赖项或从其他目标添加依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:32
msgid "``ALL``"
msgstr "``全部``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:30
msgid ""
"Indicate that this target should be added to the default build target so "
"that it will be run every time (the command cannot be called ``ALL``)."
msgstr "指明这个目标应该被添加到默认的构建目标中，以便它每次都会运行（该命令不能称为 ``ALL``）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:37
msgid ""
"Specify the files the command is expected to produce but whose "
"modification time may or may not be updated on subsequent builds. If a "
"byproduct name is a relative path it will be interpreted relative to the "
"build tree directory corresponding to the current source directory. Each "
"byproduct file will be marked with the :prop_sf:`GENERATED` source file "
"property automatically."
msgstr ""
"指定命令预期生成的文件，但其修改时间可能会或可能不会在后续构建中更新。如果副产品名称是相对路径，它将相对于与当前源目录相对应的构建树目录进行解释。每个副产品文件将自动标有"
" :prop_sf:`GENERATED` 源文件属性。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:66
msgid ""
"Specify the command-line(s) to execute at build time. If more than one "
"``COMMAND`` is specified they will be executed in order, but *not* "
"necessarily composed into a stateful shell or batch script. (To run a full"
" script, use the :command:`configure_file` command or the "
":command:`file(GENERATE)` command to create it, and then specify a "
"``COMMAND`` to launch it.)"
msgstr ""
"指定要在构建时执行的命令行。如果指定了多个 ``COMMAND``，它们将按顺序执行，但 *不一定* 必须组合成有状态的 shell 或批处理脚本。"
" （要运行完整脚本，请使用 :command:`configure_file` 命令或 :command:`file(GENERATE)` "
"命令创建它，然后指定一个 ``COMMAND`` 来启动它。）"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:95
msgid ""
"Whenever one of the following target based generator expressions are used "
"as a command to execute or is mentioned in a command argument, a target-"
"level dependency will be added automatically so that the mentioned target "
"will be built before this custom target (see policy :policy:`CMP0112`)."
msgstr ""
"每当以下基于目标的生成器表达式之一用作要执行的命令或在命令参数中提及时，将自动添加目标级依赖项，以便在该自定义目标之前构建提及的目标（请参阅策略 "
":policy :`CMP0112`)。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:105
msgid ""
"The command and arguments are optional and if not specified an empty "
"target will be created."
msgstr "命令和参数是可选的，如果未指定，将创建一个空目标。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:117
msgid ""
"Reference files and outputs of custom commands created with "
":command:`add_custom_command` command calls in the same directory "
"(``CMakeLists.txt`` file).  They will be brought up to date when the "
"target is built."
msgstr ""
"在同一目录（``CMakeLists.txt`` 文件）中使用 add_custom_command "
"命令调用创建的自定义命令的参考文件和输出。当构建目标时，它们将被更新。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:122
msgid ""
"A target-level dependency is added if any dependency is a byproduct of a "
"target or any of its build events in the same directory to ensure the "
"byproducts will be available before this target is built."
msgstr "如果任何依赖项是目标或其在同一目录中的任何构建事件的副产品，则会添加目标级依赖项，以确保在构建此目标之前副产品可用。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:127
msgid ""
"Use the :command:`add_dependencies` command to add dependencies on other "
"targets."
msgstr "使用 :command:`add_dependencies` 命令添加对其他目标的依赖。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:152
msgid "``SOURCES``"
msgstr "``来源``"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:150
msgid ""
"Specify additional source files to be included in the custom target. "
"Specified source files will be added to IDE project files for convenience "
"in editing even if they have no build rules."
msgstr "指定要包含在自定义目标中的其他源文件。指定的源文件将被添加到 IDE 项目文件中，以方便编辑，即使它们没有构建规则。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:155
msgid ""
"All arguments to the commands will be escaped properly for the build tool "
"so that the invoked command receives each argument unchanged.  Note that "
"one level of escapes is still used by the CMake language processor before "
"``add_custom_target`` even sees the arguments.  Use of ``VERBATIM`` is "
"recommended as it enables correct behavior.  When ``VERBATIM`` is not "
"given the behavior is platform specific because there is no protection of "
"tool-specific special characters."
msgstr ""
"命令的所有参数都将为构建工具正确转义，以便调用的命令接收每个参数不变。请注意，在 add_custom_target 甚至看到参数之前，CMake "
"语言处理器仍然使用一级转义。建议使用“VERBATIM”，因为它可以实现正确的行为。当未给出 VERBATIM "
"时，行为是特定于平台的，因为没有对特定于工具的特殊字符的保护。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:185
msgid ""
"``add_custom_target`` supports the :generator:`Ninja Multi-Config` "
"generator's cross-config capabilities. See the generator documentation for"
" more information."
msgstr ""
"``add_custom_target`` 支持 :generator:`Ninja Multi-Config` "
"生成器的交叉配置功能。有关详细信息，请参阅生成器文档。"

#: ../../cmake-prefix/src/cmake/Help/command/add_custom_target.rst:192
msgid ":command:`add_custom_command`"
msgstr ":command:`add_custom_command`"

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:2
msgid "add_definitions"
msgstr "添加定义"

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:4
msgid "Add ``-D`` define flags to the compilation of source files."
msgstr "将“-D”定义标志添加到源文件的编译中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:10
msgid ""
"Adds definitions to the compiler command line for targets in the current "
"directory, whether added before or after this command is invoked, and for "
"the ones in sub-directories added after. This command can be used to add "
"any flags, but it is intended to add preprocessor definitions."
msgstr ""
"将定义添加到当前目录中目标的编译器命令行，无论是在调用此命令之前还是之后添加，以及之后添加的子目录中的定义。此命令可用于添加任何标志，但它旨在添加预处理器定义。"

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:17
msgid "This command has been superseded by alternatives:"
msgstr "此命令已被替代项取代："

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:19
msgid ""
"Use :command:`add_compile_definitions` to add preprocessor definitions."
msgstr "使用 :command:`add_compile_definitions` 添加预处理器定义。"

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:20
msgid "Use :command:`include_directories` to add include directories."
msgstr "使用 :command:`include_directories` 添加包含目录。"

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:21
msgid "Use :command:`add_compile_options` to add other options."
msgstr "使用 :command:`add_compile_options` 添加其他选项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:23
msgid ""
"Flags beginning in ``-D`` or ``/D`` that look like preprocessor "
"definitions are automatically added to the :prop_dir:`COMPILE_DEFINITIONS`"
" directory property for the current directory.  Definitions with non-"
"trivial values may be left in the set of flags instead of being converted "
"for reasons of backwards compatibility.  See documentation of the "
":prop_dir:`directory <COMPILE_DEFINITIONS>`, :prop_tgt:`target "
"<COMPILE_DEFINITIONS>`, :prop_sf:`source file <COMPILE_DEFINITIONS>` "
"``COMPILE_DEFINITIONS`` properties for details on adding preprocessor "
"definitions to specific scopes and configurations."
msgstr ""
"以“-D”或“/D”开头的看起来像预处理器定义的标志会自动添加到当前目录的 COMPILE_DEFINITIONS "
"目录属性中。出于向后兼容性的原因，具有重要值的定义可能会留在标志集中而不是被转换。有关将预处理器定义添加到特定范围和配置。"

#: ../../cmake-prefix/src/cmake/Help/command/add_definitions.rst:37
msgid ""
"The :manual:`cmake-buildsystem(7)` manual for more on defining buildsystem"
" properties."
msgstr ":manual:`cmake-buildsystem(7)` 手册，了解更多关于定义构建系统属性的信息。"

#: ../../cmake-prefix/src/cmake/Help/command/add_dependencies.rst:2
msgid "add_dependencies"
msgstr "添加依赖项"

#: ../../cmake-prefix/src/cmake/Help/command/add_dependencies.rst:4
msgid "Add a dependency between top-level targets."
msgstr "在顶级目标之间添加依赖关系。"

#: ../../cmake-prefix/src/cmake/Help/command/add_dependencies.rst:10
msgid ""
"Makes a top-level ``<target>`` depend on other top-level targets to ensure"
" that they build before ``<target>`` does.  A top-level target is one "
"created by one of the :command:`add_executable`, :command:`add_library`, "
"or :command:`add_custom_target` commands (but not targets generated by "
"CMake like ``install``)."
msgstr ""
"使顶级 ``<target>`` 依赖于其他顶级目标，以确保它们在 ``<target>`` 之前构建。顶级目标是由 "
":command:`add_executable`、 :command:`add_library` 或 "
":command:`add_custom_target` 命令之一创建的目标（但不是由 CMake 生成的目标，如 ``install``）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_dependencies.rst:16
msgid ""
"Dependencies added to an :ref:`imported target <Imported Targets>` or an "
":ref:`interface library <Interface Libraries>` are followed transitively "
"in its place since the target itself does not build."
msgstr ""
"添加到 :ref:`imported target <Imported Targets>` 或 :ref:`interface library "
"<Interface Libraries>` 的依赖项会在其位置上传递，因为目标本身不会构建。"

#: ../../cmake-prefix/src/cmake/Help/command/add_dependencies.rst:20
msgid "Allow adding dependencies to interface libraries."
msgstr "允许向接口库添加依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_dependencies.rst:26
msgid ""
"The ``DEPENDS`` option of :command:`add_custom_target` and "
":command:`add_custom_command` commands for adding file-level dependencies "
"in custom rules."
msgstr ""
":command:`add_custom_target` 和 :command:`add_custom_command` 命令的 "
"``DEPENDS`` 选项用于在自定义规则中添加文件级依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/add_dependencies.rst:30
msgid ""
"The :prop_sf:`OBJECT_DEPENDS` source file property to add file-level "
"dependencies to object files."
msgstr ":prop_sf:`OBJECT_DEPENDS` 源文件属性，用于将文件级依赖项添加到目标文件。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:2
msgid "add_executable"
msgstr "添加_可执行文件"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:5
#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:5
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:11
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:5
#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:5
#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:5
msgid "Contents"
msgstr "内容"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:8
msgid "Add an executable to the project using the specified source files."
msgstr "使用指定的源文件向项目添加可执行文件。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:11
msgid "Normal Executables"
msgstr "普通可执行文件"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:19
msgid ""
"Adds an executable target called ``<name>`` to be built from the source "
"files listed in the command invocation.  The ``<name>`` corresponds to the"
" logical target name and must be globally unique within a project.  The "
"actual file name of the executable built is constructed based on "
"conventions of the native platform (such as ``<name>.exe`` or just "
"``<name>``)."
msgstr ""
"添加一个名为 ``<name>`` 的可执行目标，以从命令调用中列出的源文件构建。 ``<name>`` "
"对应于逻辑目标名称，并且在项目中必须是全局唯一的。构建的可执行文件的实际文件名是根据本机平台的约定构建的（例如 ``<name>.exe`` 或只是"
" ``<name>``）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:26
msgid ""
"Source arguments to ``add_executable`` may use \"generator expressions\" "
"with the syntax ``$<...>``.  See the :manual:`cmake-generator-"
"expressions(7)` manual for available expressions."
msgstr ""
"``add_executable`` 的源参数可以使用语法为``$<...>`` 的“生成器表达式”。请参阅 :manual:`cmake-"
"generator-expressions(7)` 手册了解可用的表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:31
#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:31
msgid ""
"The source files can be omitted if they are added later using "
":command:`target_sources`."
msgstr "如果稍后使用 :command:`target_sources` 添加源文件，则可以省略它们。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:35
msgid ""
"By default the executable file will be created in the build tree directory"
" corresponding to the source tree directory in which the command was "
"invoked.  See documentation of the :prop_tgt:`RUNTIME_OUTPUT_DIRECTORY` "
"target property to change this location.  See documentation of the "
":prop_tgt:`OUTPUT_NAME` target property to change the ``<name>`` part of "
"the final file name."
msgstr ""
"默认情况下，可执行文件将在与调用命令的源树目录相对应的构建树目录中创建。请参阅 "
":prop_tgt:`RUNTIME_OUTPUT_DIRECTORY` 目标属性的文档以更改此位置。请参阅 "
":prop_tgt:`OUTPUT_NAME` 目标属性的文档以更改最终文件名的 ``<name>`` 部分。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:42
msgid ""
"If ``WIN32`` is given the property :prop_tgt:`WIN32_EXECUTABLE` will be "
"set on the target created.  See documentation of that target property for "
"details."
msgstr ""
"如果给定 ``WIN32`` 属性 :prop_tgt:`WIN32_EXECUTABLE` "
"将在创建的目标上设置。有关详细信息，请参阅该目标属性的文档。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:46
msgid ""
"If ``MACOSX_BUNDLE`` is given the corresponding property will be set on "
"the created target.  See documentation of the :prop_tgt:`MACOSX_BUNDLE` "
"target property for details."
msgstr ""
"如果给出``MACOSX_BUNDLE``，相应的属性将被设置在创建的目标上。有关详细信息，请参阅 "
":prop_tgt:`MACOSX_BUNDLE` 目标属性的文档。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:50
#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:66
msgid ""
"If ``EXCLUDE_FROM_ALL`` is given the corresponding property will be set on"
" the created target.  See documentation of the "
":prop_tgt:`EXCLUDE_FROM_ALL` target property for details."
msgstr ""
"如果给出 ``EXCLUDE_FROM_ALL``，则将在创建的目标上设置相应的属性。有关详细信息，请参阅 "
":prop_tgt:`EXCLUDE_FROM_ALL` 目标属性的文档。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:54
#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:70
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:137
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:60
msgid ""
"See the :manual:`cmake-buildsystem(7)` manual for more on defining "
"buildsystem properties."
msgstr "有关定义构建系统属性的更多信息，请参阅 :manual:`cmake-buildsystem(7)` 手册。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:57
#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:73
msgid ""
"See also :prop_sf:`HEADER_FILE_ONLY` on what to do if some sources are "
"pre-processed, and you want to have the original sources reachable from "
"within IDE."
msgstr ""
"另请参阅 :prop_sf:`HEADER_FILE_ONLY` 了解如果对某些源进行了预处理，并且您希望可以从 IDE 中访问原始源，该怎么做。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:62
msgid "Imported Executables"
msgstr "导入的可执行文件"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:68
msgid ""
"An :ref:`IMPORTED executable target <Imported Targets>` references an "
"executable file located outside the project.  No rules are generated to "
"build it, and the :prop_tgt:`IMPORTED` target property is ``True``.  The "
"target name has scope in the directory in which it is created and below, "
"but the ``GLOBAL`` option extends visibility.  It may be referenced like "
"any target built within the project.  ``IMPORTED`` executables are useful "
"for convenient reference from commands like :command:`add_custom_command`."
" Details about the imported executable are specified by setting properties"
" whose names begin in ``IMPORTED_``.  The most important such property is "
":prop_tgt:`IMPORTED_LOCATION` (and its per-configuration version "
":prop_tgt:`IMPORTED_LOCATION_<CONFIG>`) which specifies the location of "
"the main executable file on disk.  See documentation of the ``IMPORTED_*``"
" properties for more information."
msgstr ""
":ref:`IMPORTED 可执行目标 <Imported Targets>` 引用位于项目外部的可执行文件。没有生成规则来构建它，并且 "
":prop_tgt:`IMPORTED` 目标属性是 ``True``。目标名称在其创建目录及以下目录中具有范围，但 ``GLOBAL`` "
"选项扩展了可见性。它可以像项目中构建的任何目标一样被引用。 ``IMPORTED`` 可执行文件可用于方便地从 "
":command:`add_custom_command` "
"等命令中引用。有关导入的可执行文件的详细信息是通过设置名称以“IMPORTED_”开头的属性来指定的。最重要的此类属性是:prop_tgt:`IMPORTED_LOCATION`（及其每个配置版本:prop_tgt:`IMPORTED_LOCATION_<CONFIG>`），它指定了磁盘上主要可执行文件的位置。有关更多信息，请参阅"
" ``IMPORTED_*`` 属性的文档。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:83
msgid "Alias Executables"
msgstr "别名可执行文件"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:89
#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:243
msgid ""
"Creates an :ref:`Alias Target <Alias Targets>`, such that ``<name>`` can "
"be used to refer to ``<target>`` in subsequent commands.  The ``<name>`` "
"does not appear in the generated buildsystem as a make target.  The "
"``<target>`` may not be an ``ALIAS``."
msgstr ""
"创建一个 :ref:`Alias Target <Alias Targets>`，这样 ``<name>`` 可用于在后续命令中引用 "
"``<target>``。 ``<name>`` 不会作为生成目标出现在生成的构建系统中。 ``<target>`` 可能不是 ``ALIAS``。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:94
#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:248
msgid ""
"An ``ALIAS`` can target a ``GLOBAL`` :ref:`Imported Target <Imported "
"Targets>`"
msgstr "``ALIAS`` 可以针对 ``GLOBAL`` :ref:`Imported Target <Imported Targets>`"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:97
msgid ""
"An ``ALIAS`` can target a non-``GLOBAL`` Imported Target. Such alias is "
"scoped to the directory in which it is created and subdirectories. The "
":prop_tgt:`ALIAS_GLOBAL` target property can be used to check if the alias"
" is global or not."
msgstr ""
"``ALIAS`` 可以针对非``GLOBAL`` 导入目标。这种别名的范围是创建它的目录和子目录。 "
":prop_tgt:`ALIAS_GLOBAL` 目标属性可用于检查别名是否为全局别名。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:103
msgid ""
"``ALIAS`` targets can be used as targets to read properties from, "
"executables for custom commands and custom targets.  They can also be "
"tested for existence with the regular :command:`if(TARGET)` subcommand. "
"The ``<name>`` may not be used to modify properties of ``<target>``, that "
"is, it may not be used as the operand of :command:`set_property`, "
":command:`set_target_properties`, :command:`target_link_libraries` etc. An"
" ``ALIAS`` target may not be installed or exported."
msgstr ""
"``ALIAS`` 目标可以用作从自定义命令和自定义目标的可执行文件中读取属性的目标。也可以使用常规的 if(TARGET) "
"子命令来测试它们是否存在。 ``<name>`` 不得用于修改 ``<target>`` 的属性，也就是说，它不得用作 "
":command:`set_property`、 :command:`set_target_properties` 的操作数， "
":command:`target_link_libraries` 等 ``ALIAS`` 目标可能无法安装或导出。"

#: ../../cmake-prefix/src/cmake/Help/command/add_executable.rst:114
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:210
msgid ":command:`add_library`"
msgstr ":command:`add_library`"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:2
msgid "add_library"
msgstr "添加_库"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:8
msgid "Add a library to the project using the specified source files."
msgstr "使用指定的源文件将库添加到项目中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:11
msgid "Normal Libraries"
msgstr "普通图书馆"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:19
msgid ""
"Adds a library target called ``<name>`` to be built from the source files "
"listed in the command invocation.  The ``<name>`` corresponds to the "
"logical target name and must be globally unique within a project.  The "
"actual file name of the library built is constructed based on conventions "
"of the native platform (such as ``lib<name>.a`` or ``<name>.lib``)."
msgstr ""
"添加一个名为 ``<name>`` 的库目标，以从命令调用中列出的源文件构建。 ``<name>`` "
"对应于逻辑目标名称，并且在项目中必须是全局唯一的。构建的库的实际文件名是根据本机平台的约定构建的（例如 ``lib<name>.a`` 或 "
"``<name>.lib``）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:26
msgid ""
"Source arguments to ``add_library`` may use \"generator expressions\" with"
" the syntax ``$<...>``.  See the :manual:`cmake-generator-expressions(7)` "
"manual for available expressions."
msgstr ""
"``add_library`` 的源参数可以使用语法为``$<...>`` 的“生成器表达式”。请参阅 :manual:`cmake-"
"generator-expressions(7)` 手册了解可用的表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:35
msgid ""
"``STATIC``, ``SHARED``, or ``MODULE`` may be given to specify the type of "
"library to be created.  ``STATIC`` libraries are archives of object files "
"for use when linking other targets.  ``SHARED`` libraries are linked "
"dynamically and loaded at runtime.  ``MODULE`` libraries are plugins that "
"are not linked into other targets but may be loaded dynamically at runtime"
" using dlopen-like functionality.  If no type is given explicitly the type"
" is ``STATIC`` or ``SHARED`` based on whether the current value of the "
"variable :variable:`BUILD_SHARED_LIBS` is ``ON``.  For ``SHARED`` and "
"``MODULE`` libraries the :prop_tgt:`POSITION_INDEPENDENT_CODE` target "
"property is set to ``ON`` automatically. A ``SHARED`` library may be "
"marked with the :prop_tgt:`FRAMEWORK` target property to create an macOS "
"Framework."
msgstr ""
"可以给出 ``STATIC``、``SHARED`` 或 ``MODULE`` 来指定要创建的库的类型。 ``STATIC`` "
"库是目标文件的存档，供链接其他目标时使用。 ``SHARED`` 库动态链接并在运行时加载。 ``MODULE`` "
"库是不链接到其他目标但可以在运行时使用类似 dlopen 的功能动态加载的插件。如果没有明确给出类型，则类型是 ``STATIC`` 或 "
"``SHARED`` 取决于变量的当前值 :variable:`BUILD_SHARED_LIBS` 是否为 ``ON``。对于 ``SHARED`` 和 "
"``MODULE`` 库， :prop_tgt:`POSITION_INDEPENDENT_CODE` 目标属性自动设置为 ``ON``。 "
"``SHARED`` 库可以用 :prop_tgt:`FRAMEWORK` 目标属性标记以创建 macOS 框架。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:48
msgid ""
"A ``STATIC`` library may be marked with the :prop_tgt:`FRAMEWORK` target "
"property to create a static Framework."
msgstr "``STATIC`` 库可以用 :prop_tgt:`FRAMEWORK` 目标属性标记以创建静态框架。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:52
msgid ""
"If a library does not export any symbols, it must not be declared as a "
"``SHARED`` library.  For example, a Windows resource DLL or a managed "
"C++/CLI DLL that exports no unmanaged symbols would need to be a "
"``MODULE`` library. This is because CMake expects a ``SHARED`` library to "
"always have an associated import library on Windows."
msgstr ""
"如果库不导出任何符号，则不得将其声明为“共享”库。例如，Windows 资源 DLL 或不导出非托管符号的托管 C++/CLI DLL "
"需要是一个“MODULE”库。这是因为 CMake 期望 ``SHARED`` 库在 Windows 上始终具有关联的导入库。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:58
msgid ""
"By default the library file will be created in the build tree directory "
"corresponding to the source tree directory in which the command was "
"invoked.  See documentation of the :prop_tgt:`ARCHIVE_OUTPUT_DIRECTORY`, "
":prop_tgt:`LIBRARY_OUTPUT_DIRECTORY`, and "
":prop_tgt:`RUNTIME_OUTPUT_DIRECTORY` target properties to change this "
"location.  See documentation of the :prop_tgt:`OUTPUT_NAME` target "
"property to change the ``<name>`` part of the final file name."
msgstr ""
"默认情况下，库文件将在与调用命令的源树目录相对应的构建树目录中创建。请参阅 "
":prop_tgt:`ARCHIVE_OUTPUT_DIRECTORY`、 :prop_tgt:`LIBRARY_OUTPUT_DIRECTORY` "
"和 :prop_tgt:`RUNTIME_OUTPUT_DIRECTORY` 目标属性的文档以更改此位置。请参阅 "
":prop_tgt:`OUTPUT_NAME` 目标属性的文档以更改最终文件名的 ``<name>`` 部分。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:78
msgid "Object Libraries"
msgstr "对象库"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:84
msgid ""
"Creates an :ref:`Object Library <Object Libraries>`.  An object library "
"compiles source files but does not archive or link their object files into"
" a library.  Instead other targets created by ``add_library`` or "
":command:`add_executable` may reference the objects using an expression of"
" the form :genex:`$\\<TARGET_OBJECTS:objlib\\> <TARGET_OBJECTS>` as a "
"source, where ``objlib`` is the object library name.  For example:"
msgstr ""
"创建一个 :ref:`Object Library <Object "
"Libraries>`。目标库编译源文件但不将它们的目标文件存档或链接到库中。相反，由 ``add_library`` 或 "
":command:`add_executable` 创建的其他目标可以使用 :genex:`$\\<TARGET_OBJECTS:objlib\\>"
" <TARGET_OBJECTS>` 形式的表达式作为源引用对象，其中 `` objlib`` 是对象库名称。例如："

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:96
msgid ""
"will include objlib's object files in a library and an executable along "
"with those compiled from their own sources.  Object libraries may contain "
"only sources that compile, header files, and other files that would not "
"affect linking of a normal library (e.g. ``.txt``). They may contain "
"custom commands generating such sources, but not ``PRE_BUILD``, "
"``PRE_LINK``, or ``POST_BUILD`` commands.  Some native build systems (such"
" as Xcode) may not like targets that have only object files, so consider "
"adding at least one real source file to any target that references "
":genex:`$\\<TARGET_OBJECTS:objlib\\> <TARGET_OBJECTS>`."
msgstr ""
"将 objlib "
"的目标文件包含在一个库和一个可执行文件中，以及那些从他们自己的源代码编译的文件。对象库可能只包含编译源、头文件和其他不会影响普通库链接的文件（例如 "
"``.txt``）。它们可能包含生成此类源的自定义命令，但不包含“PRE_BUILD”、“PRE_LINK”或“POST_BUILD”命令。某些本机构建系统（例如"
" Xcode）可能不喜欢只有目标文件的目标，因此请考虑向任何引用 :genex:`$\\<TARGET_OBJECTS:objlib\\> "
"<TARGET_OBJECTS>` 的目标添加至少一个真实的源文件。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:106
msgid ""
"Object libraries can be linked to with :command:`target_link_libraries`."
msgstr "对象库可以链接到:command:`target_link_libraries`。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:110
msgid "Interface Libraries"
msgstr "接口库"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:116
msgid ""
"Creates an :ref:`Interface Library <Interface Libraries>`. An "
"``INTERFACE`` library target does not compile sources and does not produce"
" a library artifact on disk.  However, it may have properties set on it "
"and it may be installed and exported. Typically, ``INTERFACE_*`` "
"properties are populated on an interface target using the commands:"
msgstr ""
"创建一个 :ref:`Interface Library <Interface Libraries>`。 ``INTERFACE`` "
"库目标不会编译源代码，也不会在磁盘上生成库工件。但是，它可能设置了属性，并且可以安装和导出。通常，使用以下命令在接口目标上填充 "
"``INTERFACE_*`` 属性："

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:123
msgid ":command:`set_property`,"
msgstr ":command:`set_property`，"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:124
msgid ":command:`target_link_libraries(INTERFACE)`,"
msgstr ":command:`target_link_libraries（接口）`，"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:125
msgid ":command:`target_link_options(INTERFACE)`,"
msgstr ":command:`target_link_options（接口）`，"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:126
msgid ":command:`target_include_directories(INTERFACE)`,"
msgstr ":command:`target_include_directories（接口）`，"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:127
msgid ":command:`target_compile_options(INTERFACE)`,"
msgstr ":command:`target_compile_options（接口）`，"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:128
msgid ":command:`target_compile_definitions(INTERFACE)`, and"
msgstr ":command:`target_compile_definitions(INTERFACE)`，和"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:129
msgid ":command:`target_sources(INTERFACE)`,"
msgstr ":command:`target_sources（接口）`，"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:131
msgid ""
"and then it is used as an argument to :command:`target_link_libraries` "
"like any other target."
msgstr "然后它像任何其他目标一样用作 :command:`target_link_libraries` 的参数。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:134
msgid ""
"An interface library created with the above signature has no source files "
"itself and is not included as a target in the generated buildsystem."
msgstr "使用上述签名创建的接口库本身没有源文件，也不会作为目标包含在生成的构建系统中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:137
msgid ""
"An interface library can have :prop_tgt:`PUBLIC_HEADER` and "
":prop_tgt:`PRIVATE_HEADER` properties.  The headers specified by those "
"properties can be installed using the :command:`install(TARGETS)` command."
msgstr ""
"接口库可以具有 :prop_tgt:`PUBLIC_HEADER` 和 :prop_tgt:`PRIVATE_HEADER` 属性。可以使用 "
":command:`install(TARGETS)` 命令安装由这些属性指定的标头。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:142
msgid "An interface library target may be created with source files:"
msgstr "可以使用源文件创建接口库目标："

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:149
msgid ""
"Source files may be listed directly in the ``add_library`` call or added "
"later by calls to :command:`target_sources` with the ``PRIVATE`` or "
"``PUBLIC`` keywords."
msgstr ""
"源文件可以直接在 ``add_library`` 调用中列出，或者稍后通过使用 ``PRIVATE`` 或 ``PUBLIC`` "
"关键字调用:command:`target_sources` 添加。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:153
msgid ""
"If an interface library has source files (i.e. the :prop_tgt:`SOURCES` "
"target property is set), or header sets (i.e. the :prop_tgt:`HEADER_SETS` "
"target property is set), it will appear in the generated buildsystem as a "
"build target much like a target defined by the "
":command:`add_custom_target` command.  It does not compile any sources, "
"but does contain build rules for custom commands created by the "
":command:`add_custom_command` command."
msgstr ""
"如果接口库有源文件（即设置了 :prop_tgt:`SOURCES` 目标属性），或设置了头文件（即设置了 "
":prop_tgt:`HEADER_SETS` 目标属性），它将作为构建出现在生成的构建系统中target 很像 "
":command:`add_custom_target` 命令定义的目标。它不编译任何源代码，但包含由 "
":command:`add_custom_command` 命令创建的自定义命令的构建规则。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:162
msgid ""
"In most command signatures where the ``INTERFACE`` keyword appears, the "
"items listed after it only become part of that target's usage requirements"
" and are not part of the target's own settings.  However, in this "
"signature of ``add_library``, the ``INTERFACE`` keyword refers to the "
"library type only.  Sources listed after it in the ``add_library`` call "
"are ``PRIVATE`` to the interface library and do not appear in its "
":prop_tgt:`INTERFACE_SOURCES` target property."
msgstr ""
"在大多数出现 ``INTERFACE`` 关键字的命令签名中，其后列出的项目仅成为该目标使用要求的一部分，而不是目标自身设置的一部分。然而，在 "
"``add_library`` 的签名中，``INTERFACE`` 关键字仅指库类型。在 ``add_library`` "
"调用中它后面列出的源是接口库的 ``PRIVATE`` 并且不会出现在它的 INTERFACE_SOURCES 目标属性中。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:173
msgid "Imported Libraries"
msgstr "导入库"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:179
msgid ""
"Creates an :ref:`IMPORTED library target <Imported Targets>` called "
"``<name>``. No rules are generated to build it, and the "
":prop_tgt:`IMPORTED` target property is ``True``.  The target name has "
"scope in the directory in which it is created and below, but the "
"``GLOBAL`` option extends visibility. It may be referenced like any target"
" built within the project. ``IMPORTED`` libraries are useful for "
"convenient reference from commands like :command:`target_link_libraries`."
"  Details about the imported library are specified by setting properties "
"whose names begin in ``IMPORTED_`` and ``INTERFACE_``."
msgstr ""
"创建一个名为 ``<name>`` 的 :ref:`IMPORTED 库目标 <Imported Targets>`。没有生成规则来构建它，并且 "
":prop_tgt:`IMPORTED` 目标属性是 ``True``。目标名称在其创建目录及以下目录中具有范围，但 ``GLOBAL`` "
"选项扩展了可见性。它可以像项目中构建的任何目标一样被引用。 ``IMPORTED`` 库可用于方便地从 "
":command:`target_link_libraries` "
"等命令中引用。有关导入库的详细信息通过设置名称以“IMPORTED_”和“INTERFACE_”开头的属性来指定。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:189
msgid "The ``<type>`` must be one of:"
msgstr "``<type>`` 必须是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:220
msgid "``STATIC``, ``SHARED``, ``MODULE``, ``UNKNOWN``"
msgstr "``静态``，``共享``，``模块``，``未知``"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:192
msgid ""
"References a library file located outside the project.  The "
":prop_tgt:`IMPORTED_LOCATION` target property (or its per-configuration "
"variant :prop_tgt:`IMPORTED_LOCATION_<CONFIG>`) specifies the location of "
"the main library file on disk:"
msgstr ""
"引用位于项目外部的库文件。 :prop_tgt:`IMPORTED_LOCATION` 目标属性（或其每个配置变体 "
":prop_tgt:`IMPORTED_LOCATION_<CONFIG>`）指定主库文件在磁盘上的位置："

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:197
msgid ""
"For a ``SHARED`` library on most non-Windows platforms, the main library "
"file is the ``.so`` or ``.dylib`` file used by both linkers and dynamic "
"loaders.  If the referenced library file has a ``SONAME`` (or on macOS, "
"has a ``LC_ID_DYLIB`` starting in ``@rpath/``), the value of that field "
"should be set in the :prop_tgt:`IMPORTED_SONAME` target property. If the "
"referenced library file does not have a ``SONAME``, but the platform "
"supports it, then  the :prop_tgt:`IMPORTED_NO_SONAME` target property "
"should be set."
msgstr ""
"对于大多数非 Windows 平台上的“共享”库，主库文件是链接器和动态加载器使用的“.so”或“.dylib”文件。如果引用的库文件有一个 "
"``SONAME``（或者在 macOS 上，有一个 ``LC_ID_DYLIB`` 从 ``@rpath/`` 开始），该字段的值应该在 "
":prop_tgt:`IMPORTED_SONAME 中设置` 目标属性。如果引用的库文件没有 ``SONAME``，但平台支持它，则应设置 "
":prop_tgt:`IMPORTED_NO_SONAME` 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:206
msgid ""
"For a ``SHARED`` library on Windows, the :prop_tgt:`IMPORTED_IMPLIB` "
"target property (or its per-configuration variant "
":prop_tgt:`IMPORTED_IMPLIB_<CONFIG>`) specifies the location of the DLL "
"import library file (``.lib`` or ``.dll.a``) on disk, and the "
"``IMPORTED_LOCATION`` is the location of the ``.dll`` runtime library (and"
" is optional, but needed by the :genex:`TARGET_RUNTIME_DLLS` generator "
"expression)."
msgstr ""
"对于 Windows 上的 ``SHARED`` 库， :prop_tgt:`IMPORTED_IMPLIB` "
"目标属性（或其每个配置变体:prop_tgt:`IMPORTED_IMPLIB_<CONFIG>`）指定 DLL 导入库文件 (``. lib`` "
"或 ``.dll.a``) 在磁盘上，而 ``IMPORTED_LOCATION`` 是 ``.dll`` 运行时库的位置（并且是可选的，但 "
":genex:`TARGET_RUNTIME_DLLS 需要` 生成器表达式）。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:214
msgid ""
"Additional usage requirements may be specified in ``INTERFACE_*`` "
"properties."
msgstr "额外的使用要求可以在 ``INTERFACE_*`` 属性中指定。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:216
msgid ""
"An ``UNKNOWN`` library type is typically only used in the implementation "
"of :ref:`Find Modules`.  It allows the path to an imported library (often "
"found using the :command:`find_library` command) to be used without having"
" to know what type of library it is.  This is especially useful on Windows"
" where a static library and a DLL's import library both have the same file"
" extension."
msgstr ""
"``UNKNOWN`` 库类型通常仅用于 :ref:`Find Modules` 的实现。它允许使用导入库的路径（通常使用 "
":command:`find_library` 命令找到），而不必知道它是什么类型的库。这在 Windows 上特别有用，其中静态库和 DLL "
"的导入库都具有相同的文件扩展名。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:227
msgid "``OBJECT``"
msgstr "``对象``"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:223
msgid ""
"References a set of object files located outside the project. The "
":prop_tgt:`IMPORTED_OBJECTS` target property (or its per-configuration "
"variant :prop_tgt:`IMPORTED_OBJECTS_<CONFIG>`) specifies the locations of "
"object files on disk. Additional usage requirements may be specified in "
"``INTERFACE_*`` properties."
msgstr ""
"引用位于项目外部的一组目标文件。 :prop_tgt:`IMPORTED_OBJECTS` 目标属性（或其每个配置变体 "
":prop_tgt:`IMPORTED_OBJECTS_<CONFIG>`）指定目标文件在磁盘上的位置。额外的使用要求可以在 "
"``INTERFACE_*`` 属性中指定。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:231
msgid "``INTERFACE``"
msgstr "``界面``"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:230
msgid ""
"Does not reference any library or object files on disk, but may specify "
"usage requirements in ``INTERFACE_*`` properties."
msgstr "不引用磁盘上的任何库或对象文件，但可以在 ``INTERFACE_*`` 属性中指定使用要求。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:233
msgid ""
"See documentation of the ``IMPORTED_*`` and ``INTERFACE_*`` properties for"
" more information."
msgstr "有关更多信息，请参阅 ``IMPORTED_*`` 和 ``INTERFACE_*`` 属性的文档。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:237
msgid "Alias Libraries"
msgstr "别名库"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:251
msgid ""
"An ``ALIAS`` can target a non-``GLOBAL`` Imported Target. Such alias is "
"scoped to the directory in which it is created and below. The "
":prop_tgt:`ALIAS_GLOBAL` target property can be used to check if the alias"
" is global or not."
msgstr ""
"``ALIAS`` 可以针对非``GLOBAL`` 导入目标。此类别名的范围限于创建它的目录及以下目录。 "
":prop_tgt:`ALIAS_GLOBAL` 目标属性可用于检查别名是否为全局别名。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:257
msgid ""
"``ALIAS`` targets can be used as linkable targets and as targets to read "
"properties from.  They can also be tested for existence with the regular "
":command:`if(TARGET)` subcommand.  The ``<name>`` may not be used to "
"modify properties of ``<target>``, that is, it may not be used as the "
"operand of :command:`set_property`, :command:`set_target_properties`, "
":command:`target_link_libraries` etc.  An ``ALIAS`` target may not be "
"installed or exported."
msgstr ""
"``ALIAS`` 目标可以用作可链接的目标和从中读取属性的目标。也可以使用常规的 if(TARGET) 子命令来测试它们是否存在。 "
"``<name>`` 不得用于修改 ``<target>`` 的属性，也就是说，它不得用作 "
":command:`set_property`、 :command:`set_target_properties` 的操作数， "
":command:`target_link_libraries` 等 ``ALIAS`` 目标可能无法安装或导出。"

#: ../../cmake-prefix/src/cmake/Help/command/add_library.rst:268
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:209
msgid ":command:`add_executable`"
msgstr ":command:`add_executable`"

#: ../../cmake-prefix/src/cmake/Help/command/add_link_options.rst:2
msgid "add_link_options"
msgstr "添加链接选项"

#: ../../cmake-prefix/src/cmake/Help/command/add_link_options.rst:6
msgid ""
"Add options to the link step for executable, shared library or module "
"library targets in the current directory and below that are added after "
"this command is invoked."
msgstr "将选项添加到当前目录和调用此命令后添加的以下目录中的可执行文件、共享库或模块库目标的链接步骤。"

#: ../../cmake-prefix/src/cmake/Help/command/add_link_options.rst:14
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:19
msgid ""
"This command can be used to add any link options, but alternative commands"
" exist to add libraries (:command:`target_link_libraries` or "
":command:`link_libraries`).  See documentation of the :prop_dir:`directory"
" <LINK_OPTIONS>` and :prop_tgt:`target <LINK_OPTIONS>` ``LINK_OPTIONS`` "
"properties."
msgstr ""
"此命令可用于添加任何链接选项，但存在用于添加库的替代命令（ :command:`target_link_libraries` "
"或 :command:`link_libraries`）。请参阅 :prop_dir:`directory <LINK_OPTIONS>` 和 "
":prop_tgt:`target <LINK_OPTIONS>` ``LINK_OPTIONS`` 属性的文档。"

#: ../../cmake-prefix/src/cmake/Help/command/add_link_options.rst:22
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:27
msgid ""
"This command cannot be used to add options for static library targets, "
"since they do not use a linker.  To add archiver or MSVC librarian flags, "
"see the :prop_tgt:`STATIC_LIBRARY_OPTIONS` target property."
msgstr ""
"此命令不能用于为静态库目标添加选项，因为它们不使用链接器。要添加存档器或 MSVC 库管理器标志，请参阅 "
":prop_tgt:`STATIC_LIBRARY_OPTIONS` 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/command/DEVICE_LINK_OPTIONS.txt:2
msgid "Host And Device Specific Link Options"
msgstr "主机和设备特定链接选项"

#: ../../cmake-prefix/src/cmake/Help/command/DEVICE_LINK_OPTIONS.txt:4
msgid ""
"When a device link step is involved, which is controlled by "
":prop_tgt:`CUDA_SEPARABLE_COMPILATION` and "
":prop_tgt:`CUDA_RESOLVE_DEVICE_SYMBOLS` properties and policy "
":policy:`CMP0105`, the raw options will be delivered to the host and "
"device link steps (wrapped in ``-Xcompiler`` or equivalent for device "
"link). Options wrapped with :genex:`$<DEVICE_LINK:...>` generator "
"expression will be used only for the device link step. Options wrapped "
"with :genex:`$<HOST_LINK:...>` generator expression will be used only for "
"the host link step."
msgstr ""
"当涉及设备链接步骤时，它由 CUDA_SEPARABLE_COMPILATION 和 CUDA_RESOLVE_DEVICE_SYMBOLS "
"属性和策略 CMP0105 控制，原始选项将被传递到主机和设备链接步骤（包装在“-Xcompiler”或设备链接的等效项中）。用 "
":genex:`$<DEVICE_LINK:...>` 生成器表达式包装的选项将仅用于设备链接步骤。用 "
":genex:`$<HOST_LINK:...>` 生成器表达式包装的选项将仅用于主机链接步骤。"

#: ../../cmake-prefix/src/cmake/Help/command/LINK_OPTIONS_LINKER.txt:2
msgid "Handling Compiler Driver Differences"
msgstr "处理编译器驱动程序差异"

#: ../../cmake-prefix/src/cmake/Help/command/LINK_OPTIONS_LINKER.txt:4
msgid ""
"To pass options to the linker tool, each compiler driver has its own "
"syntax. The ``LINKER:`` prefix and ``,`` separator can be used to specify,"
" in a portable way, options to pass to the linker tool. ``LINKER:`` is "
"replaced by the appropriate driver option and ``,`` by the appropriate "
"driver separator. The driver prefix and driver separator are given by the "
"values of the :variable:`CMAKE_<LANG>_LINKER_WRAPPER_FLAG` and "
":variable:`CMAKE_<LANG>_LINKER_WRAPPER_FLAG_SEP` variables."
msgstr ""
"为了将选项传递给链接器工具，每个编译器驱动程序都有自己的语法。 ``LINKER:`` 前缀和 ``,`` "
"分隔符可用于以可移植的方式指定要传递给链接器工具的选项。 ``LINKER:`` 被适当的驱动程序选项和 ``,`` "
"替换为适当的驱动程序分隔符。驱动程序前缀和驱动程序分隔符由 :variable:`CMAKE_<LANG>_LINKER_WRAPPER_FLAG`"
" 和 :variable:`CMAKE_<LANG>_LINKER_WRAPPER_FLAG_SEP` 变量的值给出。"

#: ../../cmake-prefix/src/cmake/Help/command/LINK_OPTIONS_LINKER.txt:12
msgid ""
"For example, ``\"LINKER:-z,defs\"`` becomes ``-Xlinker -z -Xlinker defs`` "
"for ``Clang`` and ``-Wl,-z,defs`` for ``GNU GCC``."
msgstr ""
"例如，``\"LINKER:-z,defs\"`` 变成``-Xlinker -z -Xlinker defs`` 对于``Clang`` "
"和``-Wl,-z,defs`` 对于``GNU GCC ``。"

#: ../../cmake-prefix/src/cmake/Help/command/LINK_OPTIONS_LINKER.txt:15
msgid ""
"The ``LINKER:`` prefix can be specified as part of a ``SHELL:`` prefix "
"expression."
msgstr "``LINKER:`` 前缀可以指定为 ``SHELL:`` 前缀表达式的一部分。"

#: ../../cmake-prefix/src/cmake/Help/command/LINK_OPTIONS_LINKER.txt:18
msgid ""
"The ``LINKER:`` prefix supports, as an alternative syntax, specification "
"of arguments using the ``SHELL:`` prefix and space as separator. The "
"previous example then becomes ``\"LINKER:SHELL:-z defs\"``."
msgstr ""
"作为一种替代语法，``LINKER:`` 前缀支持使用``SHELL:`` "
"前缀和空格作为分隔符的参数规范。前面的例子变成了``\"LINKER:SHELL:-z defs\"``。"

#: ../../cmake-prefix/src/cmake/Help/command/LINK_OPTIONS_LINKER.txt:24
msgid ""
"Specifying the ``SHELL:`` prefix anywhere other than at the beginning of "
"the ``LINKER:`` prefix is not supported."
msgstr "不支持在 ``LINKER:`` 前缀以外的任何地方指定 ``SHELL:`` 前缀。"

#: ../../cmake-prefix/src/cmake/Help/command/add_link_options.rst:38
msgid ":command:`link_libraries`"
msgstr ":command:`link_libraries`"

#: ../../cmake-prefix/src/cmake/Help/command/add_link_options.rst:39
#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:61
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:57
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:45
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:54
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:83
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:66
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:61
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:130
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:215
msgid ":command:`target_link_libraries`"
msgstr ":command:`target_link_libraries`"

#: ../../cmake-prefix/src/cmake/Help/command/add_link_options.rst:40
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:59
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:47
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:56
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:85
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:67
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:419
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:132
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:217
msgid ":command:`target_link_options`"
msgstr ":command:`target_link_options`"

#: ../../cmake-prefix/src/cmake/Help/command/add_subdirectory.rst:2
msgid "add_subdirectory"
msgstr "添加子目录"

#: ../../cmake-prefix/src/cmake/Help/command/add_subdirectory.rst:4
msgid "Add a subdirectory to the build."
msgstr "在构建中添加一个子目录。"

#: ../../cmake-prefix/src/cmake/Help/command/add_subdirectory.rst:10
msgid ""
"Adds a subdirectory to the build.  The ``source_dir`` specifies the "
"directory in which the source ``CMakeLists.txt`` and code files are "
"located.  If it is a relative path, it will be evaluated with respect to "
"the current directory (the typical usage), but it may also be an absolute "
"path.  The ``binary_dir`` specifies the directory in which to place the "
"output files.  If it is a relative path, it will be evaluated with respect"
" to the current output directory, but it may also be an absolute path.  If"
" ``binary_dir`` is not specified, the value of ``source_dir``, before "
"expanding any relative path, will be used (the typical usage).  The "
"``CMakeLists.txt`` file in the specified source directory will be "
"processed immediately by CMake before processing in the current input file"
" continues beyond this command."
msgstr ""
"将子目录添加到构建中。 ``source_dir`` 指定源``CMakeLists.txt`` "
"和代码文件所在的目录。如果它是一个相对路径，它将相对于当前目录进行评估（典型用法），但它也可能是一个绝对路径。 ``binary_dir`` "
"指定放置输出文件的目录。如果它是相对路径，则会根据当前输出目录进行评估，但它也可能是绝对路径。如果未指定 "
"``binary_dir``，则在扩展任何相对路径之前使用 ``source_dir`` 的值（典型用法）。指定源目录中的 "
"``CMakeLists.txt`` 文件将由 CMake 立即处理，然后在当前输入文件中的处理继续超出此命令。"

#: ../../cmake-prefix/src/cmake/Help/command/add_subdirectory.rst:23
msgid ""
"If the ``EXCLUDE_FROM_ALL`` argument is provided then targets in the "
"subdirectory will not be included in the ``ALL`` target of the parent "
"directory by default, and will be excluded from IDE project files. Users "
"must explicitly build targets in the subdirectory.  This is meant for use "
"when the subdirectory contains a separate part of the project that is "
"useful but not necessary, such as a set of examples. Typically the "
"subdirectory should contain its own :command:`project` command invocation "
"so that a full build system will be generated in the subdirectory (such as"
" a Visual Studio IDE solution file).  Note that inter-target dependencies "
"supersede this exclusion.  If a target built by the parent project depends"
" on a target in the subdirectory, the dependee target will be included in "
"the parent project build system to satisfy the dependency."
msgstr ""
"如果提供了 ``EXCLUDE_FROM_ALL`` 参数，则默认情况下子目录中的目标将不会包含在父目录的 ``ALL`` 目标中，并且将从 IDE"
" "
"项目文件中排除。用户必须在子目录中显式构建目标。这意味着当子目录包含有用但不是必需的项目的单独部分（例如一组示例）时使用。通常，子目录应包含其自己的"
" :command:`project` 命令调用，以便在子目录中生成完整的构建系统（例如 Visual Studio IDE "
"解决方案文件）。请注意，目标间依赖性会取代此排除。如果父项目构建的目标依赖于子目录中的目标，则依赖目标将包含在父项目构建系统中以满足依赖性。"

#: ../../cmake-prefix/src/cmake/Help/command/add_subdirectory.rst:37
msgid ""
"If the ``SYSTEM`` argument is provided, the :prop_dir:`SYSTEM` directory "
"property of the subdirectory will be set to true.  This property is used "
"to initialize the :prop_tgt:`SYSTEM` property of each non-imported target "
"created in that subdirectory."
msgstr ""
"如果提供了 ``SYSTEM`` 参数，则子目录的 :prop_dir:`SYSTEM` 目录属性将设置为 "
"true。此属性用于初始化在该子目录中创建的每个非导入目标的 :prop_tgt:`SYSTEM` 属性。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:2
msgid "add_test"
msgstr "添加测试"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:4
msgid "Add a test to the project to be run by :manual:`ctest(1)`."
msgstr "向要由 ctest(1) 运行的项目添加测试。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:13
msgid ""
"Adds a test called ``<name>``.  The test name may contain arbitrary "
"characters, expressed as a :ref:`Quoted Argument` or :ref:`Bracket "
"Argument` if necessary.  See policy :policy:`CMP0110`.  The options are:"
msgstr ""
"添加一个名为 ``<name>`` 的测试。测试名称可以包含任意字符，如有必要，表示为 :ref:`Quoted Argument` 或 "
":ref:`Bracket Argument`。请参阅政策:policy:`CMP0110`。选项是："

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:18
msgid ""
"Specify the test command-line.  If ``<command>`` specifies an executable "
"target (created by :command:`add_executable`) it will automatically be "
"replaced by the location of the executable created at build time."
msgstr ""
"指定测试命令行。如果 ``<command>`` 指定了一个可执行目标（由 :command:`add_executable` "
"创建），它将自动替换为在构建时创建的可执行文件的位置。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:23
msgid ""
"The command may be specified using :manual:`generator expressions <cmake-"
"generator-expressions(7)>`."
msgstr ""
"该命令可以使用 :manual:`generator expressions <cmake-generator-expressions(7)>` "
"指定。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:27
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:84
msgid "``CONFIGURATIONS``"
msgstr "``配置``"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:27
msgid "Restrict execution of the test only to the named configurations."
msgstr "将测试的执行限制在指定的配置上。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:30
msgid ""
"Set the :prop_test:`WORKING_DIRECTORY` test property to specify the "
"working directory in which to execute the test. If not specified the test "
"will be run with the current working directory set to the build directory "
"corresponding to the current source directory."
msgstr ""
"设置 :prop_test:`WORKING_DIRECTORY` "
"测试属性以指定执行测试的工作目录。如果未指定，则测试将在当前工作目录设置为与当前源目录对应的构建目录的情况下运行。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:36
msgid ""
"The working directory may be specified using :manual:`generator "
"expressions <cmake-generator-expressions(7)>`."
msgstr ""
"工作目录可以使用 :manual:`generator expressions <cmake-generator-expressions(7)>` "
"指定。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:42
msgid ""
"Lists in ``COMMAND`` arguments will be expanded, including those created "
"with :manual:`generator expressions <cmake-generator-expressions(7)>`."
msgstr ""
"``COMMAND`` 参数中的列表将被扩展，包括使用 :manual:`generator expressions <cmake-"
"generator-expressions(7)>` 创建的列表。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:46
msgid ""
"The given test command is expected to exit with code ``0`` to pass and "
"non-zero to fail, or vice-versa if the :prop_test:`WILL_FAIL` test "
"property is set.  Any output written to stdout or stderr will be captured "
"by :manual:`ctest(1)` but does not affect the pass/fail status unless the "
":prop_test:`PASS_REGULAR_EXPRESSION`, :prop_test:`FAIL_REGULAR_EXPRESSION`"
" or :prop_test:`SKIP_REGULAR_EXPRESSION` test property is used."
msgstr ""
"如果设置了 WILL_FAIL 测试属性，给定的测试命令预计会以代码“0”退出，非零表示失败，反之亦然。任何写入 stdout 或 stderr "
"的输出都将被 ctest(1) "
"捕获，但不会影响通过/失败状态，除非:prop_test:`PASS_REGULAR_EXPRESSION`、 :prop_test:`FAIL_REGULAR_EXPRESSION`"
" 或 :prop_test:`SKIP_REGULAR_EXPRESSION ` 使用测试属性。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:54
msgid "Added :prop_test:`SKIP_REGULAR_EXPRESSION` property."
msgstr "添加了 :prop_test:`SKIP_REGULAR_EXPRESSION` 属性。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:57
msgid ""
"Tests added with the ``add_test(NAME)`` signature support using "
":manual:`generator expressions <cmake-generator-expressions(7)>` in test "
"properties set by :command:`set_property(TEST)` or "
":command:`set_tests_properties`."
msgstr ""
"使用 ``add_test(NAME)`` 签名支持添加的测试使用 :manual:`generator expressions <cmake-"
"generator-expressions(7)>` 在由 :command:`set_property(TEST)` 或 :command "
"设置的测试属性中： `set_tests_properties`。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:62
msgid "Example usage:"
msgstr "用法示例："

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:70
msgid ""
"This creates a test ``mytest`` whose command runs a ``testDriver`` tool "
"passing the configuration name and the full path to the executable file "
"produced by target ``myexe``."
msgstr ""
"这将创建一个测试“mytest”，其命令运行一个“testDriver”工具，传递配置名称和目标“myexe”生成的可执行文件的完整路径。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:76
msgid ""
"CMake will generate tests only if the :command:`enable_testing` command "
"has been invoked.  The :module:`CTest` module invokes the command "
"automatically unless the ``BUILD_TESTING`` option is turned ``OFF``."
msgstr ""
"仅当调用 enable_testing 命令时，CMake 才会生成测试。 :module:`CTest` "
"模块会自动调用命令，除非``BUILD_TESTING`` 选项被关闭。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:83
msgid "This command also supports a simpler, but less flexible, signature:"
msgstr "此命令还支持更简单但不太灵活的签名："

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:89
msgid "Add a test called ``<name>`` with the given command-line."
msgstr "使用给定的命令行添加名为 ``<name>`` 的测试。"

#: ../../cmake-prefix/src/cmake/Help/command/add_test.rst:91
msgid ""
"Unlike the above ``NAME`` signature, target names are not supported in the"
" command-line.  Furthermore, tests added with this signature do not "
"support :manual:`generator expressions <cmake-generator-expressions(7)>` "
"in the command-line or test properties."
msgstr ""
"与上面的 ``NAME`` 签名不同，命令行不支持目标名称。此外，使用此签名添加的测试不支持命令行或测试属性中的 "
":manual:`generator expressions <cmake-generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/aux_source_directory.rst:2
msgid "aux_source_directory"
msgstr "aux_source_directory"

#: ../../cmake-prefix/src/cmake/Help/command/aux_source_directory.rst:4
msgid "Find all source files in a directory."
msgstr "查找目录中的所有源文件。"

#: ../../cmake-prefix/src/cmake/Help/command/aux_source_directory.rst:10
msgid ""
"Collects the names of all the source files in the specified directory and "
"stores the list in the ``<variable>`` provided.  This command is intended "
"to be used by projects that use explicit template instantiation.  Template"
" instantiation files can be stored in a ``Templates`` subdirectory and "
"collected automatically using this command to avoid manually listing all "
"instantiations."
msgstr ""
"收集指定目录中所有源文件的名称，并将列表存储在提供的``<variable>``中。此命令旨在供使用显式模板实例化的项目使用。模板实例化文件可以存储在"
" ``Templates`` 子目录中，并使用此命令自动收集，以避免手动列出所有实例化。"

#: ../../cmake-prefix/src/cmake/Help/command/aux_source_directory.rst:17
msgid ""
"It is tempting to use this command to avoid writing the list of source "
"files for a library or executable target.  While this seems to work, there"
" is no way for CMake to generate a build system that knows when a new "
"source file has been added.  Normally the generated build system knows "
"when it needs to rerun CMake because the ``CMakeLists.txt`` file is "
"modified to add a new source.  When the source is just added to the "
"directory without modifying this file, one would have to manually rerun "
"CMake to generate a build system incorporating the new file."
msgstr ""
"很容易使用此命令来避免为库或可执行目标编写源文件列表。虽然这似乎可行，但 CMake "
"无法生成知道何时添加了新源文件的构建系统。通常，生成的构建系统知道何时需要重新运行 CMake，因为修改了 CMakeLists.txt "
"文件以添加新源。如果只是将源代码添加到目录而不修改此文件，则必须手动重新运行 CMake 以生成包含新文件的构建系统。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:2
msgid "block"
msgstr "堵塞"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:6
msgid ""
"Evaluate a group of commands with a dedicated variable and/or policy "
"scope."
msgstr "使用专用变量和/或策略范围评估一组命令。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:14
msgid ""
"All commands between ``block()`` and the matching :command:`endblock` are "
"recorded without being invoked.  Once the :command:`endblock` is "
"evaluated, the recorded list of commands is invoked inside the requested "
"scopes, then the scopes created by the ``block()`` command are removed."
msgstr ""
"``block()`` 和匹配的 :command:`endblock` 之间的所有命令都被记录下来而不被调用。一旦 "
":command:`endblock` 被评估，记录的命令列表在请求的范围内被调用，然后由 ``block()`` 命令创建的范围被删除。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:33
msgid "``SCOPE_FOR``"
msgstr "``SCOPE_FOR``"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:20
msgid "Specify which scopes must be created."
msgstr "指定必须创建的范围。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:24
msgid "``POLICIES``"
msgstr "``政策``"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:23
msgid ""
"Create a new policy scope. This is equivalent to "
":command:`cmake_policy(PUSH)`."
msgstr "创建新的策略范围。这相当于 :command:`cmake_policy(PUSH)`。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:27
msgid "``VARIABLES``"
msgstr "``变量``"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:27
msgid "Create a new variable scope."
msgstr "创建一个新的变量作用域。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:29
msgid "If ``SCOPE_FOR`` is not specified, this is equivalent to:"
msgstr "如果未指定``SCOPE_FOR``，这相当于："

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:54
#: ../../cmake-prefix/src/cmake/Help/command/return.rst:86
msgid "``PROPAGATE``"
msgstr "``传播``"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:36
msgid ""
"When a variable scope is created by the :command:`block` command, this "
"option sets or unsets the specified variables in the parent scope. This is"
" equivalent to :command:`set(PARENT_SCOPE)` or "
":command:`unset(PARENT_SCOPE)` commands."
msgstr ""
"当通过 :command:`block` 命令创建变量作用域时，此选项设置或取消设置父作用域中的指定变量。这相当于 "
":command:`set(PARENT_SCOPE)` 或 :command:`unset(PARENT_SCOPE)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:53
msgid ""
"This option is only allowed when a variable scope is created. An error "
"will be raised in the other cases."
msgstr "只有在创建变量作用域时才允许使用此选项。在其他情况下将引发错误。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:56
msgid ""
"When the ``block()`` is inside a :command:`foreach` or :command:`while` "
"command, the :command:`break` and :command:`continue` commands can be used"
" inside the block."
msgstr ""
"当``block()`` 位于 :command:`foreach` 或 :command:`while` 命令内时， :command:`break` "
"和 :command:`continue` 命令可以在块内使用。"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:74
msgid ":command:`endblock`"
msgstr ":command:`endblock`"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:75
#: ../../cmake-prefix/src/cmake/Help/command/function.rst:82
msgid ":command:`return`"
msgstr ":command:`返回`"

#: ../../cmake-prefix/src/cmake/Help/command/block.rst:76
#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:86
msgid ":command:`cmake_policy`"
msgstr ":command:`cmake_policy`"

#: ../../cmake-prefix/src/cmake/Help/command/break.rst:2
msgid "break"
msgstr "休息"

#: ../../cmake-prefix/src/cmake/Help/command/break.rst:4
msgid "Break from an enclosing foreach or while loop."
msgstr "从封闭的 foreach 或 while 循环中断。"

#: ../../cmake-prefix/src/cmake/Help/command/break.rst:10
msgid ""
"Breaks from an enclosing :command:`foreach` or :command:`while` loop."
msgstr "从封闭的 :command:`foreach` 或 :command:`while` 循环中断。"

#: ../../cmake-prefix/src/cmake/Help/command/break.rst:12
msgid "See also the :command:`continue` command."
msgstr "另请参阅 :command:`continue` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:2
msgid "build_command"
msgstr "构建命令"

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:4
msgid ""
"Get a command line to build the current project. This is mainly intended "
"for internal use by the :module:`CTest` module."
msgstr "获取命令行以构建当前项目。这主要供 :module:`CTest` 模块内部使用。"

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:16
msgid "Sets the given ``<variable>`` to a command-line string of the form::"
msgstr "将给定的 ``<variable>`` 设置为以下形式的命令行字符串："

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:20
msgid ""
"where ``<cmake>`` is the location of the :manual:`cmake(1)` command-line "
"tool, and ``<config>``, ``<parallel>`` and ``<target>`` are the values "
"provided to the ``CONFIGURATION``, ``PARALLEL_LEVEL`` and ``TARGET`` "
"options, if any.  The trailing ``-- -i`` option is added for "
":ref:`Makefile Generators` if policy :policy:`CMP0061` is not set to "
"``NEW``."
msgstr ""
"其中 ``<cmake>`` 是 :manual:`cmake(1)` 命令行工具的位置，``<config>``、``<parallel>`` 和"
" ``<target>` ` 是提供给 ``CONFIGURATION``、``PARALLEL_LEVEL`` 和 ``TARGET`` "
"选项的值（如果有的话）。如果策略:policy:`CMP0061` 未设置为 ``NEW``，则为 Makefile Generators "
"添加尾随的 ``-- -i`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:27
msgid ""
"When invoked, this :option:`cmake --build` command line will launch the "
"underlying build system tool."
msgstr "调用时，此 :option:`cmake --build` 命令行将启动底层构建系统工具。"

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:30
msgid ""
"The ``PARALLEL_LEVEL`` argument can be used to set the :option:`--parallel"
" <cmake--build --parallel>` flag."
msgstr ""
"``PARALLEL_LEVEL`` 参数可用于设置:option:`--parallel <cmake--build --parallel>` 标志。"

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:38
msgid ""
"This second signature is deprecated, but still available for backwards "
"compatibility.  Use the first signature instead."
msgstr "第二个签名已弃用，但仍可用于向后兼容。请改用第一个签名。"

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:41
msgid ""
"It sets the given ``<cachevariable>`` to a command-line string as above "
"but without the :option:`--target <cmake--build --target>` option. The "
"``<makecommand>`` is ignored but should be the full path to devenv, nmake,"
" make or one of the end user build tools for legacy invocations."
msgstr ""
"它将给定的 ``<cachevariable>`` 设置为上面的命令行字符串，但没有 :option:`--target <cmake--build"
" --target>` 选项。 ``<makecommand>`` 被忽略但应该是 devenv、nmake、make "
"或用于遗留调用的最终用户构建工具之一的完整路径。"

#: ../../cmake-prefix/src/cmake/Help/command/build_command.rst:48
msgid ""
"In CMake versions prior to 3.0 this command returned a command line that "
"directly invokes the native build tool for the current generator.  Their "
"implementation of the ``PROJECT_NAME`` option had no useful effects, so "
"CMake now warns on use of the option."
msgstr ""
"在 3.0 之前的 CMake 版本中，此命令返回一个命令行，该命令行直接调用当前生成器的本机构建工具。他们对 ``PROJECT_NAME`` "
"选项的实现没有任何有用的效果，因此 CMake 现在会在使用该选项时发出警告。"

#: ../../cmake-prefix/src/cmake/Help/command/build_name.rst:2
msgid "build_name"
msgstr "构建名称"

#: ../../cmake-prefix/src/cmake/Help/command/build_name.rst:4
msgid "Disallowed since version 3.0.  See CMake Policy :policy:`CMP0036`."
msgstr "3.0 版后不允许。请参阅 CMake 政策:policy:`CMP0036`。"

#: ../../cmake-prefix/src/cmake/Help/command/build_name.rst:6
msgid "Use ``${CMAKE_SYSTEM}`` and ``${CMAKE_CXX_COMPILER}`` instead."
msgstr "使用 ``${CMAKE_SYSTEM}`` 和 ``${CMAKE_CXX_COMPILER}`` 代替。"

#: ../../cmake-prefix/src/cmake/Help/command/build_name.rst:12
msgid ""
"Sets the specified variable to a string representing the platform and "
"compiler settings.  These values are now available through the "
":variable:`CMAKE_SYSTEM` and :variable:`CMAKE_CXX_COMPILER "
"<CMAKE_<LANG>_COMPILER>` variables."
msgstr ""
"将指定变量设置为表示平台和编译器设置的字符串。这些值现在可通过 :variable:`CMAKE_SYSTEM` 和 "
":variable:`CMAKE_CXX_COMPILER <CMAKE_<LANG>_COMPILER>` 变量获得。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:2
msgid "cmake_host_system_information"
msgstr "cmake_host_system_information"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:4
msgid "Query various host system information."
msgstr "查询各种主机系统信息。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:7
#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:9
#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:22
#: ../../cmake-prefix/src/cmake/Help/command/export.rst:11
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:22
#: ../../cmake-prefix/src/cmake/Help/command/if.rst:7
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:7
#: ../../cmake-prefix/src/cmake/Help/command/list.rst:7
#: ../../cmake-prefix/src/cmake/Help/command/message.rst:7
#: ../../cmake-prefix/src/cmake/Help/command/project.rst:7
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:7
msgid "Synopsis"
msgstr "概要"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:18
msgid "Query host system specific information"
msgstr "查询主机系统特定信息"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:24
msgid ""
"Queries system information of the host system on which cmake runs. One or "
"more ``<key>`` can be provided to select the information to be queried.  "
"The list of queried values is stored in ``<variable>``."
msgstr ""
"查询运行cmake的宿主系统的系统信息。可以提供一个或多个``<key>``来选择要查询的信息。查询值列表存储在“<variable>”中。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:28
msgid "``<key>`` can be one of the following values:"
msgstr "``<key>`` 可以是以下值之一："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:31
msgid "``NUMBER_OF_LOGICAL_CORES``"
msgstr "``NUMBER_OF_LOGICAL_CORES``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:31
msgid "Number of logical cores"
msgstr "逻辑核心数"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:34
msgid "``NUMBER_OF_PHYSICAL_CORES``"
msgstr "``NUMBER_OF_PHYSICAL_CORES``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:34
msgid "Number of physical cores"
msgstr "物理核心数"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:37
msgid "``HOSTNAME``"
msgstr "``主机名``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:37
msgid "Hostname"
msgstr "主机名"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:40
msgid "``FQDN``"
msgstr "``FQDN``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:40
msgid "Fully qualified domain name"
msgstr "完全合格的域名"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:43
msgid "``TOTAL_VIRTUAL_MEMORY``"
msgstr "``TOTAL_VIRTUAL_MEMORY``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:43
msgid "Total virtual memory in MiB [#mebibytes]_"
msgstr "MiB 中的总虚拟内存 [#mebibytes]_"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:46
msgid "``AVAILABLE_VIRTUAL_MEMORY``"
msgstr "``AVAILABLE_VIRTUAL_MEMORY``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:46
msgid "Available virtual memory in MiB [#mebibytes]_"
msgstr "MiB 中的可用虚拟内存 [#mebibytes]_"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:49
msgid "``TOTAL_PHYSICAL_MEMORY``"
msgstr "``TOTAL_PHYSICAL_MEMORY``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:49
msgid "Total physical memory in MiB [#mebibytes]_"
msgstr "以 MiB 为单位的总物理内存 [#mebibytes]_"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:52
msgid "``AVAILABLE_PHYSICAL_MEMORY``"
msgstr "``AVAILABLE_PHYSICAL_MEMORY``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:52
msgid "Available physical memory in MiB [#mebibytes]_"
msgstr "以 MiB 为单位的可用物理内存 [#mebibytes]_"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:57
msgid "``IS_64BIT``"
msgstr "``IS_64BIT``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:57
msgid "One if processor is 64Bit"
msgstr "一个如果处理器是 64 位"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:62
msgid "``HAS_FPU``"
msgstr "``HAS_FPU``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:62
msgid "One if processor has floating point unit"
msgstr "一个如果处理器有浮点单元"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:67
msgid "``HAS_MMX``"
msgstr "``有_MMX``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:67
msgid "One if processor supports MMX instructions"
msgstr "一个如果处理器支持 MMX 指令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:72
msgid "``HAS_MMX_PLUS``"
msgstr "``HAS_MMX_PLUS``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:72
msgid "One if processor supports Ext. MMX instructions"
msgstr "如果处理器支持 Ext。 MMX指令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:77
msgid "``HAS_SSE``"
msgstr "``HAS_SSE``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:77
msgid "One if processor supports SSE instructions"
msgstr "一个如果处理器支持 SSE 指令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:82
msgid "``HAS_SSE2``"
msgstr "``HAS_SSE2``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:82
msgid "One if processor supports SSE2 instructions"
msgstr "一个如果处理器支持 SSE2 指令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:87
msgid "``HAS_SSE_FP``"
msgstr "``HAS_SSE_FP``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:87
msgid "One if processor supports SSE FP instructions"
msgstr "一个如果处理器支持 SSE FP 指令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:92
msgid "``HAS_SSE_MMX``"
msgstr "``HAS_SSE_MMX``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:92
msgid "One if processor supports SSE MMX instructions"
msgstr "一个如果处理器支持 SSE MMX 指令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:97
msgid "``HAS_AMD_3DNOW``"
msgstr "``HAS_AMD_3DNOW``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:97
msgid "One if processor supports 3DNow instructions"
msgstr "一个如果处理器支持 3DNow 指令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:102
msgid "``HAS_AMD_3DNOW_PLUS``"
msgstr "``HAS_AMD_3DNOW_PLUS``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:102
msgid "One if processor supports 3DNow+ instructions"
msgstr "一个如果处理器支持 3DNow+ 指令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:107
msgid "``HAS_IA64``"
msgstr "``HAS_IA64``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:107
msgid "One if IA64 processor emulating x86"
msgstr "一个是 IA64 处理器模拟 x86"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:112
msgid "``HAS_SERIAL_NUMBER``"
msgstr "``HAS_SERIAL_NUMBER``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:112
msgid "One if processor has serial number"
msgstr "一个，如果处理器有序列号"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:117
msgid "``PROCESSOR_SERIAL_NUMBER``"
msgstr "``PROCESSOR_SERIAL_NUMBER``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:117
msgid "Processor serial number"
msgstr "处理器序列号"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:122
msgid "``PROCESSOR_NAME``"
msgstr "``PROCESSOR_NAME``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:122
msgid "Human readable processor name"
msgstr "人类可读的处理器名称"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:127
msgid "``PROCESSOR_DESCRIPTION``"
msgstr "``PROCESSOR_DESCRIPTION``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:127
msgid "Human readable full processor description"
msgstr "人类可读的完整处理器描述"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:132
msgid "``OS_NAME``"
msgstr "``OS_NAME``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:132
msgid "See :variable:`CMAKE_HOST_SYSTEM_NAME`"
msgstr "请参阅 :variable:`CMAKE_HOST_SYSTEM_NAME`"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:137
msgid "``OS_RELEASE``"
msgstr "``OS_RELEASE``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:137
msgid "The OS sub-type e.g. on Windows ``Professional``"
msgstr "操作系统子类型，例如在 Windows ``Professional``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:142
msgid "``OS_VERSION``"
msgstr "``OS_VERSION``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:142
msgid "The OS build ID"
msgstr "操作系统构建 ID"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:147
msgid "``OS_PLATFORM``"
msgstr "``OS_PLATFORM``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:147
msgid "See :variable:`CMAKE_HOST_SYSTEM_PROCESSOR`"
msgstr "请参阅 :variable:`CMAKE_HOST_SYSTEM_PROCESSOR`"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:153
msgid "``DISTRIB_INFO``"
msgstr "``DISTRIB_INFO``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:152
msgid ""
"Read :file:`/etc/os-release` file and define the given ``<variable>`` into"
" a list of read variables"
msgstr "读取 :file:`/etc/os-release` 文件并将给定的 ``<variable>`` 定义到读取变量列表中"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:189
msgid "``DISTRIB_<name>``"
msgstr "``DISTRIB_<名称>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:158
msgid ""
"Get the ``<name>`` variable (see `man 5 os-release`_) if it exists in the "
":file:`/etc/os-release` file"
msgstr ""
"获取 ``<name>`` 变量（参见 `man 5 os-release`_）如果它存在于 :file:`/etc/os-release` 文件中"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:161
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:218
msgid "Example:"
msgstr "例子："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:175
#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:535
#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:605
msgid "Output::"
msgstr "输出：："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:191
msgid ""
"If :file:`/etc/os-release` file is not found, the command tries to gather "
"OS identification via fallback scripts.  The fallback script can use "
"`various distribution-specific files`_ to collect OS identification data "
"and map it into `man 5 os-release`_ variables."
msgstr ""
"如果未找到:file:`/etc/os-release` "
"文件，该命令会尝试通过回退脚本收集操作系统标识。回退脚本可以使用“各种特定于发行版的文件”来收集操作系统标识数据并将其映射到“man 5 os-"
"release”变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:197
msgid "Fallback Interface Variables"
msgstr "后备接口变量"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:201
msgid ""
"In addition to the scripts shipped with CMake, a user may append full "
"paths to his script(s) to the this list.  The script filename has the "
"following format: ``NNN-<name>.cmake``, where ``NNN`` is three digits used"
" to apply collected scripts in a specific order."
msgstr ""
"除了 CMake "
"附带的脚本之外，用户还可以将其脚本的完整路径附加到此列表中。脚本文件名具有以下格式：``NNN-<name>.cmake``，其中``NNN`` "
"是三位数字，用于按特定顺序应用收集的脚本。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:208
msgid ""
"Variables collected by the user provided fallback script ought to be "
"assigned to CMake variables using this naming convention.  Example, the "
"``ID`` variable from the manual becomes "
"``CMAKE_GET_OS_RELEASE_FALLBACK_RESULT_ID``."
msgstr ""
"用户提供的后备脚本收集的变量应该使用此命名约定分配给 CMake "
"变量。例如，手册中的“ID”变量变为“CMAKE_GET_OS_RELEASE_FALLBACK_RESULT_ID”。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:215
msgid ""
"The fallback script ought to store names of all assigned "
"``CMAKE_GET_OS_RELEASE_FALLBACK_RESULT_<varname>`` variables in this list."
msgstr ""
"回退脚本应该在此列表中存储所有分配的“CMAKE_GET_OS_RELEASE_FALLBACK_RESULT_<varname>”变量的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:258
msgid "Footnotes"
msgstr "脚注"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:259
msgid "One MiB (mebibyte) is equal to 1024x1024 bytes."
msgstr "1 MiB（兆字节）等于 1024x1024 字节。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:267
msgid "Query Windows registry"
msgstr "查询 Windows 注册表"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:279
msgid ""
"Performs query operations on local computer registry subkey. Returns a "
"list of subkeys or value names that are located under the specified subkey"
" in the registry or the data of the specified value name. The result of "
"the queried entity is stored in ``<variable>``."
msgstr ""
"对本地计算机注册表子项执行查询操作。返回位于注册表中指定子项下的子项或值名称列表或指定值名称的数据。查询实体的结果存储在``<variable>``中。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:286
msgid ""
"Querying registry for any other platforms than ``Windows``, including "
"``CYGWIN``, will always returns an empty string and sets an error message "
"in the variable specified with sub-option ``ERROR_VARIABLE``."
msgstr ""
"查询除“Windows”以外的任何其他平台的注册表，包括“CYGWIN”，将始终返回空字符串并在子选项“ERROR_VARIABLE”指定的变量中设置错误消息。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:290
msgid ""
"``<key>`` specify the full path of a subkey on the local computer. The "
"``<key>`` must include a valid root key. Valid root keys for the local "
"computer are:"
msgstr "``<key>`` 指定本地计算机上子项的完整路径。 ``<key>`` 必须包含一个有效的根密钥。本地计算机的有效根密钥是："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:294
msgid "``HKLM`` or ``HKEY_LOCAL_MACHINE``"
msgstr "``HKLM`` 或 ``HKEY_LOCAL_MACHINE``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:295
msgid "``HKCU`` or ``HKEY_CURRENT_USER``"
msgstr "``HKCU`` 或 ``HKEY_CURRENT_USER``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:296
msgid "``HKCR`` or ``HKEY_CLASSES_ROOT``"
msgstr "``HKCR`` 或 ``HKEY_CLASSES_ROOT``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:297
msgid "``HKU`` or ``HKEY_USERS``"
msgstr "``HKU`` 或 ``HKEY_USERS``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:298
msgid "``HKCC`` or ``HKEY_CURRENT_CONFIG``"
msgstr "``HKCC`` 或 ``HKEY_CURRENT_CONFIG``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:300
msgid ""
"And, optionally, the path to a subkey under the specified root key. The "
"path separator can be the slash or the backslash. ``<key>`` is not case "
"sensitive. For example:"
msgstr "并且，可选地，指定根键下子键的路径。路径分隔符可以是斜杠或反斜杠。 ``<key>`` 不区分大小写。例如："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:312
msgid "``VALUE_NAMES``"
msgstr "``VALUE_NAMES``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:311
msgid ""
"Request the list of value names defined under ``<key>``. If a default "
"value is defined, it will be identified with the special name "
"``(default)``."
msgstr "请求在 ``<key>`` 下定义的值名称列表。如果定义了默认值，它将用特殊名称“(default)”来标识。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:315
msgid "``SUBKEYS``"
msgstr "``子键``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:315
msgid "Request the list of subkeys defined under ``<key>``."
msgstr "请求在 ``<key>`` 下定义的子键列表。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:342
msgid "``VALUE <name>``"
msgstr "``值 <名称>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:318
msgid ""
"Request the data stored in value named ``<name>``. If ``VALUE`` is not "
"specified or argument is the special name ``(default)``, the content of "
"the default value, if any, will be returned."
msgstr ""
"请求存储在名为“<name>”的值中的数据。如果未指定 ``VALUE`` 或参数是特殊名称 "
"``(default)``，则返回默认值的内容（如果有）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:333
msgid "Supported types are:"
msgstr "支持的类型有："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:335
msgid "``REG_SZ``."
msgstr "``REG_SZ``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:336
msgid "``REG_EXPAND_SZ``. The returned data is expanded."
msgstr "``REG_EXPAND_SZ``。返回的数据被展开。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:337
msgid ""
"``REG_MULTI_SZ``. The returned is expressed as a CMake list. See also "
"``SEPARATOR`` sub-option."
msgstr "``REG_MULTI_SZ``。返回的表示为 CMake 列表。另见 ``SEPARATOR`` 子选项。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:339
msgid "``REG_DWORD``."
msgstr "``REG_DWORD``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:340
msgid "``REG_QWORD``."
msgstr "``REG_QWORD``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:342
msgid "For all other types, an empty string is returned."
msgstr "对于所有其他类型，返回一个空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:388
msgid "``VIEW``"
msgstr "``查看``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:345
msgid ""
"Specify which registry views must be queried. When not specified, ``BOTH``"
" view is used."
msgstr "指定必须查询哪些注册表视图。如果未指定，则使用 ``BOTH`` 视图。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:9
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:350
msgid "``64``"
msgstr "``64``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:349
msgid ""
"Query the 64bit registry. On ``32bit Windows``, returns always an empty "
"string."
msgstr "查询 64 位注册表。在“32 位 Windows”上，始终返回一个空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:12
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:353
msgid "``32``"
msgstr "``32``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:353
msgid "Query the 32bit registry."
msgstr "查询 32 位注册表。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:15
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:359
msgid "``64_32``"
msgstr "``64_32``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:356
msgid ""
"For ``VALUE`` sub-option or default value, query the registry using view "
"``64``, and if the request failed, query the registry using view ``32``. "
"For ``VALUE_NAMES`` and ``SUBKEYS`` sub-options, query both views (``64`` "
"and ``32``) and merge the results (sorted and duplicates removed)."
msgstr ""
"对于 ``VALUE`` 子选项或默认值，使用视图 ``64`` 查询注册表，如果请求失败，则使用视图 ``32`` "
"查询注册表。对于“VALUE_NAMES”和“SUBKEYS”子选项，查询两个视图（“64”和“32”）并合并结果（排序并删除重复项）。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:18
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:365
msgid "``32_64``"
msgstr "``32_64``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:362
msgid ""
"For ``VALUE`` sub-option or default value, query the registry using view "
"``32``, and if the request failed, query the registry using view ``64``. "
"For ``VALUE_NAMES`` and ``SUBKEYS`` sub-options, query both views (``32`` "
"and ``64``) and merge the results (sorted and duplicates removed)."
msgstr ""
"对于 ``VALUE`` 子选项或默认值，使用视图 ``32`` 查询注册表，如果请求失败，则使用视图 ``64`` "
"查询注册表。对于“VALUE_NAMES”和“SUBKEYS”子选项，查询两个视图（“32”和“64”）并合并结果（排序并删除重复项）。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:22
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:369
msgid "``HOST``"
msgstr "``主机``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:368
msgid ""
"Query the registry matching the architecture of the host: ``64`` on "
"``64bit Windows`` and ``32`` on ``32bit Windows``."
msgstr ""
"查询与主机架构匹配的注册表：``64 位 Windows`` 上的 ``64`` 和 ``32 位 Windows`` 上的 ``32``。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:27
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:374
#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:42
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:39
msgid "``TARGET``"
msgstr "``目标``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:372
msgid ""
"Query the registry matching the architecture specified by "
":variable:`CMAKE_SIZEOF_VOID_P` variable. If not defined, fallback to "
"``HOST`` view."
msgstr "查询与 CMAKE_SIZEOF_VOID_P 变量指定的体系结构相匹配的注册表。如果未定义，则回退到 ``HOST`` 视图。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:41
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:388
msgid "``BOTH``"
msgstr "``两者``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:377
msgid ""
"Query both views (``32`` and ``64``). The order depends of the following "
"rules: If :variable:`CMAKE_SIZEOF_VOID_P` variable is defined. Use the "
"following view depending of the content of this variable:"
msgstr ""
"查询两个视图（``32`` 和 ``64``）。顺序取决于以下规则：如果定义了 CMAKE_SIZEOF_VOID_P "
"变量。根据此变量的内容使用以下视图："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:34
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:381
msgid "``8``: ``64_32``"
msgstr "``8``：``64_32``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:35
#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:382
msgid "``4``: ``32_64``"
msgstr "``4``：``32_64``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:384
msgid ""
"If :variable:`CMAKE_SIZEOF_VOID_P` variable is not defined, rely on "
"architecture of the host:"
msgstr "如果未定义 :variable:`CMAKE_SIZEOF_VOID_P` 变量，则取决于主机的体系结构："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:387
msgid "``64bit``: ``64_32``"
msgstr "``64位``：``64_32``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:388
msgid "``32bit``: ``32``"
msgstr "``32位``：``32``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:392
msgid "``SEPARATOR``"
msgstr "``分隔符``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:391
msgid ""
"Specify the separator character for ``REG_MULTI_SZ`` type. When not "
"specified, the character ``\\0`` is used."
msgstr "为 ``REG_MULTI_SZ`` 类型指定分隔符。如果未指定，则使用字符“\\0”。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:395
msgid "``ERROR_VARIABLE <result>``"
msgstr "``ERROR_VARIABLE <结果>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_host_system_information.rst:395
msgid ""
"Returns any error raised during query operation. In case of success, the "
"variable holds an empty string."
msgstr "返回查询操作期间引发的任何错误。如果成功，该变量将保存一个空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:2
msgid "cmake_language"
msgstr "cmake_语言"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:6
msgid "Call meta-operations on CMake commands."
msgstr "在 CMake 命令上调用元操作。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:20
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:21
#: ../../cmake-prefix/src/cmake/Help/command/list.rst:37
msgid "Introduction"
msgstr "介绍"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:22
msgid ""
"This command will call meta-operations on built-in CMake commands or those"
" created via the :command:`macro` or :command:`function` commands."
msgstr ""
"此命令将调用内置 CMake 命令或通过 :command:`macro` 或 :command:`function` 命令创建的元操作。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:25
msgid ""
"``cmake_language`` does not introduce a new variable or policy scope."
msgstr "``cmake_language`` 不引入新的变量或策略范围。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:28
msgid "Calling Commands"
msgstr "调用命令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:36
msgid ""
"Calls the named ``<command>`` with the given arguments (if any). For "
"example, the code:"
msgstr "使用给定的参数（如果有的话）调用命名的``<command>``。例如，代码："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:44
#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:88
#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:67
msgid "is equivalent to"
msgstr "相当于"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:51
msgid ""
"To ensure consistency of the code, the following commands are not allowed:"
msgstr "为了保证代码的一致性，不允许使用以下命令："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:53
msgid "``if`` / ``elseif`` / ``else`` / ``endif``"
msgstr "``if`` / ``elseif`` / ``else`` / ``endif``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:54
msgid "``block`` / ``endblock``"
msgstr "``block`` / ``endblock``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:55
msgid "``while`` / ``endwhile``"
msgstr "``while`` / ``endwhile``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:56
msgid "``foreach`` / ``endforeach``"
msgstr "``foreach`` / ``endforeach``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:57
msgid "``function`` / ``endfunction``"
msgstr "``函数``/``结束函数``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:58
msgid "``macro`` / ``endmacro``"
msgstr "``macro`` / ``endmacro``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:61
msgid "Evaluating Code"
msgstr "评估代码"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:69
msgid "Evaluates the ``<code>...`` as CMake code."
msgstr "评估 ``<code>...`` 作为 CMake 代码。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:71
#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:191
msgid "For example, the code:"
msgstr "例如，代码："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:108
msgid "Deferring Calls"
msgstr "推迟通话"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:118
msgid ""
"Schedules a call to the named ``<command>`` with the given arguments (if "
"any) to occur at a later time.  By default, deferred calls are executed as"
" if written at the end of the current directory's ``CMakeLists.txt`` file,"
" except that they run even after a :command:`return` call.  Variable "
"references in arguments are evaluated at the time the deferred call is "
"executed."
msgstr ""
"使用给定的参数（如果有的话）安排对命名的 ``<command>`` 的调用在以后发生。默认情况下，延迟调用的执行就像写在当前目录的 "
"CMakeLists.txt 文件的末尾一样，除了它们甚至在 :command:`return` "
"调用之后运行。在执行延迟调用时评估参数中的变量引用。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:136
#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:59
#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:32
msgid "``DIRECTORY <dir>``"
msgstr "``目录<目录>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:128
msgid ""
"Schedule the call for the end of the given directory instead of the "
"current directory.  The ``<dir>`` may reference either a source directory "
"or its corresponding binary directory.  Relative paths are treated as "
"relative to the current source directory."
msgstr "为给定目录而不是当前目录的末尾安排调用。 ``<dir>`` 可以引用源目录或其对应的二进制目录。相对路径被视为相对于当前源目录。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:133
msgid ""
"The given directory must be known to CMake, being either the top-level "
"directory or one added by :command:`add_subdirectory`.  Furthermore, the "
"given directory must not yet be finished processing.  This means it can be"
" the current directory or one of its ancestors."
msgstr ""
"CMake 必须知道给定的目录，它可以是顶级目录，也可以是通过 add_subdirectory "
"添加的目录。此外，给定目录必须尚未完成处理。这意味着它可以是当前目录或其祖先目录之一。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:142
msgid "``ID <id>``"
msgstr "``ID <id>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:139
msgid ""
"Specify an identification for the deferred call. The ``<id>`` may not be "
"empty and may not begin with a capital letter ``A-Z``. The ``<id>`` may "
"begin with an underscore (``_``) only if it was generated automatically by"
" an earlier call that used ``ID_VAR`` to get the id."
msgstr ""
"指定延迟调用的标识。 ``<id>`` 不能为空并且不能以大写字母 ``A-Z`` 开头。 ``<id>`` 可以以下划线 (``_``) "
"开头，前提是它是由先前使用 ``ID_VAR`` 获取 id 的调用自动生成的。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:147
msgid "``ID_VAR <var>``"
msgstr "``ID_VAR <var>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:145
msgid ""
"Specify a variable in which to store the identification for the deferred "
"call.  If ``ID <id>`` is not given, a new identification will be generated"
" and the generated id will start with an underscore (``_``)."
msgstr ""
"指定一个变量，用于存储延迟调用的标识。如果未给出 ``ID <id>``，将生成一个新的标识，生成的 id 将以下划线 (``_``) 开头。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:149
msgid "The currently scheduled list of deferred calls may be retrieved:"
msgstr "可以检索当前安排的延迟调用列表："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:155
msgid ""
"This will store in ``<var>`` a :ref:`semicolon-separated list <CMake "
"Language Lists>` of deferred call ids.  The ids are for the directory "
"scope in which the calls have been deferred to (i.e. where they will be "
"executed), which can be different to the scope in which they were created."
"  The ``DIRECTORY`` option can be used to specify the scope for which to "
"retrieve the call ids. If that option is not given, the call ids for the "
"current directory scope will be returned."
msgstr ""
"这将在 ``<var>`` 中存储延迟调用 ID 的 :ref:`分号分隔列表 <CMake Language Lists>`。 ids "
"用于调用被推迟到的目录范围（即它们将被执行的位置），这可能与创建它们的范围不同。 ``DIRECTORY`` 选项可用于指定检索呼叫 ID "
"的范围。如果未给出该选项，则将返回当前目录范围的调用 ID。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:163
msgid "Details of a specific call may be retrieved from its id:"
msgstr "可以从其 id 中检索特定调用的详细信息："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:169
msgid ""
"This will store in ``<var>`` a :ref:`semicolon-separated list <CMake "
"Language Lists>` in which the first element is the name of the command to "
"be called, and the remaining elements are its unevaluated arguments (any "
"contained ``;`` characters are included literally and cannot be "
"distinguished from multiple arguments).  If multiple calls are scheduled "
"with the same id, this retrieves the first one.  If no call is scheduled "
"with the given id in the specified ``DIRECTORY`` scope (or the current "
"directory scope if no ``DIRECTORY`` option is given), this stores an empty"
" string in the variable."
msgstr ""
"这将在 ``<var>`` 中存储一个分号分隔的列表 <CMake Language Lists>` "
"其中第一个元素是要调用的命令的名称，其余元素是其未评估的参数（任何包含的``;``字符都是按字面意思包含的，无法与多个参数区分开来）。如果使用相同的"
" ID 安排了多个呼叫，这将检索第一个。如果在指定的 ``DIRECTORY`` 范围内没有使用给定的 id 安排调用（如果没有给出 "
"``DIRECTORY`` 选项则为当前目录范围），这将在变量中存储一个空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:178
msgid "Deferred calls may be canceled by their id:"
msgstr "延迟调用可能会被他们的 id 取消："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:184
msgid ""
"This cancels all deferred calls matching any of the given ids in the "
"specified ``DIRECTORY`` scope (or the current directory scope if no "
"``DIRECTORY`` option is given).  Unknown ids are silently ignored."
msgstr ""
"这将取消在指定的 ``DIRECTORY`` 范围内（如果没有给出 ``DIRECTORY`` 选项则为当前目录范围内匹配任何给定 id "
"的所有延迟调用）。未知的 ID 会被默默地忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:189
msgid "Deferred Call Examples"
msgstr "延迟调用示例"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:201
msgid "prints::"
msgstr "印刷：："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:206
msgid ""
"The ``Cancelled Message`` is never printed because its command is "
"canceled.  The ``deferred_message`` variable reference is not evaluated "
"until the call site, so it can be set after the deferred call is "
"scheduled."
msgstr ""
"``Cancelled Message`` 永远不会被打印出来，因为它的命令被取消了。 ``deferred_message`` "
"变量引用直到调用站点才会被评估，所以它可以在延迟调用被安排后设置。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:210
msgid ""
"In order to evaluate variable references immediately when scheduling a "
"deferred call, wrap it using ``cmake_language(EVAL)``.  However, note that"
" arguments will be re-evaluated in the deferred call, though that can be "
"avoided by using bracket arguments.  For example:"
msgstr ""
"为了在安排延迟调用时立即评估变量引用，请使用 cmake_language(EVAL) "
"将其包装。但是，请注意参数将在延迟调用中重新计算，尽管可以通过使用括号参数来避免这种情况。例如："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:226
msgid "also prints::"
msgstr "还打印 ::"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:237
msgid "Dependency Providers"
msgstr "依赖提供者"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:241
msgid ""
"A high-level introduction to this feature can be found in the :ref:`Using "
"Dependencies Guide <dependency_providers_overview>`."
msgstr "可以在 :ref:`使用依赖项指南 <dependency_providers_overview>` 中找到对此功能的高级介绍。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:249
msgid ""
"When a call is made to :command:`find_package` or "
":command:`FetchContent_MakeAvailable`, the call may be forwarded to a "
"dependency provider which then has the opportunity to fulfill the request."
" If the request is for one of the ``<methods>`` specified when the "
"provider was set, CMake calls the provider's ``<command>`` with a set of "
"method-specific arguments.  If the provider does not fulfill the request, "
"or if the provider doesn't support the request's method, or no provider is"
" set, the built-in :command:`find_package` or "
":command:`FetchContent_MakeAvailable` implementation is used to fulfill "
"the request in the usual way."
msgstr ""
"当调用 :command:`find_package` 或 :command:`FetchContent_MakeAvailable` "
"时，调用可能会被转发到依赖项提供程序，然后有机会完成请求。如果请求是针对设置提供者时指定的``<methods>`` 之一，CMake "
"会使用一组特定于方法的参数调用提供者的``<command>``。如果提供者不满足请求，或者提供者不支持请求的方法，或者没有设置提供者，则使用内置的"
" find_package 或 FetchContent_MakeAvailable 实现来完成以通常的方式请求。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:260
msgid ""
"One or more of the following values can be specified for the ``<methods>``"
" when setting the provider:"
msgstr "设置提供程序时，可以为 ``<methods>`` 指定以下一个或多个值："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:264
#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:329
msgid "``FIND_PACKAGE``"
msgstr "``FIND_PACKAGE``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:264
msgid "The provider command accepts :command:`find_package` requests."
msgstr "provider 命令接受 :command:`find_package` 请求。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:269
msgid "``FETCHCONTENT_MAKEAVAILABLE_SERIAL``"
msgstr "``FETCHCONTENT_MAKEAVAILABLE_SERIAL``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:267
msgid ""
"The provider command accepts :command:`FetchContent_MakeAvailable` "
"requests.  It expects each dependency to be fed to the provider command "
"one at a time, not the whole list in one go."
msgstr ""
"provider 命令接受 FetchContent_MakeAvailable "
"请求。它期望每个依赖项一次一个地被提供给提供者命令，而不是一次将整个列表提供给提供者命令。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:271
msgid ""
"Only one provider can be set at any point in time.  If a provider is "
"already set when ``cmake_language(SET_DEPENDENCY_PROVIDER)`` is called, "
"the new provider replaces the previously set one.  The specified "
"``<command>`` must already exist when "
"``cmake_language(SET_DEPENDENCY_PROVIDER)`` is called. As a special case, "
"providing an empty string for the ``<command>`` and no ``<methods>`` will "
"discard any previously set provider."
msgstr ""
"在任何时间点只能设置一个提供者。如果在调用 cmake_language(SET_DEPENDENCY_PROVIDER) "
"时已经设置了提供程序，则新的提供程序将替换之前设置的提供程序。当调用 cmake_language(SET_DEPENDENCY_PROVIDER)"
" 时，指定的 <command> 必须已经存在。作为一种特殊情况，为 ``<command>`` 提供空字符串而不提供 ``<methods>`` "
"将丢弃任何先前设置的提供程序。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:278
msgid ""
"The dependency provider can only be set while processing one of the files "
"specified by the :variable:`CMAKE_PROJECT_TOP_LEVEL_INCLUDES` variable. "
"Thus, dependency providers can only be set as part of the first call to "
":command:`project`.  Calling ``cmake_language(SET_DEPENDENCY_PROVIDER)`` "
"outside of that context will result in an error."
msgstr ""
"只能在处理 CMAKE_PROJECT_TOP_LEVEL_INCLUDES "
"变量指定的文件之一时设置依赖项提供程序。因此，依赖提供者只能设置为第一次调用 :command:`project` 的一部分。在该上下文之外调用 "
"cmake_language(SET_DEPENDENCY_PROVIDER) 将导致错误。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:285
msgid ""
"The choice of dependency provider should always be under the user's "
"control. As a convenience, a project may choose to provide a file that "
"users can list in their :variable:`CMAKE_PROJECT_TOP_LEVEL_INCLUDES` "
"variable, but the use of such a file should always be the user's choice."
msgstr ""
"依赖提供者的选择应该始终在用户的控制之下。为方便起见，项目可以选择提供用户可以在其 "
":variable:`CMAKE_PROJECT_TOP_LEVEL_INCLUDES` 变量中列出的文件，但使用此类文件应始终由用户选择。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:291
msgid "Provider commands"
msgstr "供应商命令"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:293
msgid ""
"Providers define a single ``<command>`` to accept requests.  The name of "
"the command should be specific to that provider, not something overly "
"generic that another provider might also use.  This enables users to "
"compose different providers in their own custom provider.  The recommended"
" form is ``xxx_provide_dependency()``, where ``xxx`` is the provider-"
"specific part (e.g. ``vcpkg_provide_dependency()``, "
"``conan_provide_dependency()``, ``ourcompany_provide_dependency()``, and "
"so on)."
msgstr ""
"提供者定义一个单一的``<command>``来接受请求。命令的名称应该特定于该提供者，而不是其他提供者也可能使用的过于通用的名称。这使用户能够在他们自己的自定义提供程序中组合不同的提供程序。推荐的形式是"
" ``xxx_provide_dependency()``，其中 ``xxx`` 是提供商特定的部分（例如 "
"``vcpkg_provide_dependency()``、``conan_provide_dependency()``、``ourcompany_provide_dependency()``、等等）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:305
msgid ""
"Because some methods expect certain variables to be set in the calling "
"scope, the provider command should typically be implemented as a macro "
"rather than a function.  This ensures it does not introduce a new variable"
" scope."
msgstr "因为某些方法期望在调用范围内设置某些变量，所以提供程序命令通常应作为宏而不是函数来实现。这确保它不会引入新的变量范围。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:309
msgid ""
"The arguments CMake passes to the dependency provider depend on the type "
"of request.  The first argument is always the method, and it will only "
"ever be one of the ``<methods>`` that was specified when setting the "
"provider."
msgstr "CMake 传递给依赖提供者的参数取决于请求的类型。第一个参数始终是方法，它只会是设置提供者时指定的“<methods>”之一。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:314
msgid ""
"The ``<method-specific-args>`` will be everything passed to the "
":command:`find_package` call that requested the dependency.  The first of "
"these ``<method-specific-args>`` will therefore always be the name of the "
"dependency.  Dependency names are case-sensitive for this method because "
":command:`find_package` treats them case-sensitively too."
msgstr ""
"``<method-specific-args>`` 将是传递给请求依赖项的 find_package 调用的所有内容。因此，这些“<method-"
"specific-args>”中的第一个将始终是依赖项的名称。此方法的依赖项名称区分大小写，因为 :command:`find_package` "
"也区分大小写。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:320
msgid ""
"If the provider command fulfills the request, it must set the same "
"variable that :command:`find_package` expects to be set.  For a dependency"
" named ``depName``, the provider must set ``depName_FOUND`` to true if it "
"fulfilled the request.  If the provider returns without setting this "
"variable, CMake will assume the request was not fulfilled and will fall "
"back to the built-in implementation."
msgstr ""
"如果 provider 命令满足请求，它必须设置 find_package "
"期望设置的相同变量。对于名为“depName”的依赖项，提供者必须在满足请求时将“depName_FOUND”设置为 "
"true。如果提供者返回时没有设置此变量，CMake 将假定请求未完成并将回退到内置实现。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:327
msgid ""
"If the provider needs to call the built-in :command:`find_package` "
"implementation as part of its processing, it can do so by including the "
"``BYPASS_PROVIDER`` keyword as one of the arguments."
msgstr ""
"如果提供者需要调用内置的 find_package 实现作为其处理的一部分，它可以通过将 ``BYPASS_PROVIDER`` "
"关键字作为参数之一来实现。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:373
msgid "``FETCHCONTENT_MAKEAVAILABE_SERIAL``"
msgstr "``FETCHCONTENT_MAKEAVAILABE_SERIAL``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:332
msgid ""
"The ``<method-specific-args>`` will be everything passed to the "
":command:`FetchContent_Declare` call that corresponds to the requested "
"dependency, with the following exceptions:"
msgstr ""
"``<method-specific-args>`` 将是传递给与请求的依赖项相对应的 FetchContent_Declare "
"调用的所有内容，但以下情况除外："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:336
msgid ""
"If ``SOURCE_DIR`` or ``BINARY_DIR`` were not part of the original declared"
" arguments, they will be added with their default values."
msgstr "如果 ``SOURCE_DIR`` 或 ``BINARY_DIR`` 不是原始声明参数的一部分，它们将被添加为默认值。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:338
msgid ""
"If :variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` is set to ``NEVER``, any"
" ``FIND_PACKAGE_ARGS`` will be omitted."
msgstr ""
"如果 :variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` 设置为 ``NEVER``，任何 "
"``FIND_PACKAGE_ARGS`` 都将被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:340
msgid "The ``OVERRIDE_FIND_PACKAGE`` keyword is always omitted."
msgstr "``OVERRIDE_FIND_PACKAGE`` 关键字总是被省略。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:342
msgid ""
"The first of the ``<method-specific-args>`` will always be the name of the"
" dependency.  Dependency names are case-insensitive for this method "
"because :module:`FetchContent` also treats them case-insensitively."
msgstr ""
"``<method-specific-args>`` 的第一个将始终是依赖项的名称。此方法的依赖项名称不区分大小写，因为 FetchContent "
"也对它们不区分大小写。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:346
msgid ""
"If the provider fulfills the request, it should call "
":command:`FetchContent_SetPopulated`, passing the name of the dependency "
"as the first argument.  The ``SOURCE_DIR`` and ``BINARY_DIR`` arguments to"
" that command should only be given if the provider makes the dependency's "
"source and build directories available in exactly the same way as the "
"built-in :command:`FetchContent_MakeAvailable` command."
msgstr ""
"如果提供者满足请求，它应该调用 FetchContent_SetPopulated ，将依赖项的名称作为第一个参数传递。该命令的 "
"``SOURCE_DIR`` 和 ``BINARY_DIR`` 参数只有在提供商以与内置 FetchContent_MakeAvailable "
"命令完全相同的方式提供依赖项的源和构建目录时才应给出。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:353
msgid ""
"If the provider returns without calling "
":command:`FetchContent_SetPopulated` for the named dependency, CMake will "
"assume the request was not fulfilled and will fall back to the built-in "
"implementation."
msgstr ""
"如果提供者返回时没有为指定的依赖项调用 FetchContent_SetPopulated ，CMake 将假定请求未完成并将回退到内置实现。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:357
msgid ""
"Note that empty arguments may be significant for this method (e.g. an "
"empty string following a ``GIT_SUBMODULES`` keyword).  Therefore, if "
"forwarding these arguments on to another command, extra care must be taken"
" to avoid such arguments being silently dropped."
msgstr ""
"请注意，空参数对于此方法可能很重要（例如，``GIT_SUBMODULES`` "
"关键字后的空字符串）。因此，如果将这些参数转发给另一个命令，则必须格外小心，以免这些参数被悄无声息地丢弃。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:362
msgid ""
"If ``FETCHCONTENT_SOURCE_DIR_<uppercaseDepName>`` is set, then the "
"dependency provider will never see requests for the ``<depName>`` "
"dependency for this method. When the user sets such a variable, they are "
"explicitly overriding where to get that dependency from and are taking on "
"the responsibility that their overriding version meets any requirements "
"for that dependency and is compatible with whatever else in the project "
"uses it. Depending on the value of "
":variable:`FETCHCONTENT_TRY_FIND_PACKAGE_MODE` and whether the "
"``OVERRIDE_FIND_PACKAGE`` option was given to "
":command:`FetchContent_Declare`, having "
"``FETCHCONTENT_SOURCE_DIR_<uppercaseDepName>`` set may also prevent the "
"dependency provider from seeing requests for a ``find_package(depName)`` "
"call too."
msgstr ""
"如果设置了``FETCHCONTENT_SOURCE_DIR_<uppercaseDepName>``，那么依赖项提供者将永远不会看到对此方法的``<depName>``"
" "
"依赖项的请求。当用户设置这样一个变量时，他们明确地覆盖了从哪里获取该依赖项，并承担了他们的覆盖版本满足该依赖项的任何要求并且与项目中使用它的任何其他内容兼容的责任。根据"
" FETCHCONTENT_TRY_FIND_PACKAGE_MODE 的值以及是否为 FetchContent_Declare 提供了 "
"OVERRIDE_FIND_PACKAGE 选项，设置 FETCHCONTENT_SOURCE_DIR_<uppercaseDepName> "
"也可能会阻止依赖提供者看到请求``find_package(depName)`` 调用。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:376
msgid "Provider Examples"
msgstr "提供商示例"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:378
msgid ""
"This first example only intercepts :command:`find_package` calls.  The "
"provider command runs an external tool which copies the relevant artifacts"
" into a provider-specific directory, if that tool knows about the "
"dependency. It then relies on the built-in implementation to then find "
"those artifacts. :command:`FetchContent_MakeAvailable` calls would not go "
"through the provider."
msgstr ""
"第一个示例仅拦截 :command:`find_package` 调用。 provider "
"命令运行一个外部工具，该工具将相关工件复制到特定于提供者的目录中（如果该工具知道依赖项）。然后它依赖于内置的实现来找到那些工件。 "
":command:`FetchContent_MakeAvailable` 调用不会通过提供商。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:384
#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:424
#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:483
msgid "mycomp_provider.cmake"
msgstr "mycomp_provider.cmake"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:410
msgid "The user would then typically use the above file like so::"
msgstr "然后用户通常会像这样使用上面的文件 ::"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:414
msgid ""
"The next example demonstrates a provider that accepts both methods, but "
"only handles one specific dependency.  It enforces providing Google Test "
"using :module:`FetchContent`, but leaves all other dependencies to be "
"fulfilled by CMake's built-in implementation.  It accepts a few different "
"names, which demonstrates one way of working around projects that hard-"
"code an unusual or undesirable way of adding this particular dependency to"
" the build.  The example also demonstrates how to use the :command:`list` "
"command to preserve variables that may be overwritten by a call to "
":command:`FetchContent_MakeAvailable`."
msgstr ""
"下一个示例演示了一个接受这两种方法但只处理一个特定依赖项的提供程序。它强制使用 :module:`FetchContent` 提供 Google "
"Test，但将所有其他依赖项留给 CMake "
"的内置实现来完成。它接受一些不同的名称，这展示了一种解决项目的方法，这些项目通过硬编码将这种特定依赖项添加到构建中的不寻常或不受欢迎的方式。该示例还演示了如何使用"
" :command:`list` 命令来保留可能被调用 :command:`FetchContent_MakeAvailable` 覆盖的变量。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:478
msgid ""
"The final example demonstrates how to modify arguments to a "
":command:`find_package` call.  It forces all such calls to have the "
"``QUIET`` keyword.  It uses the ``BYPASS_PROVIDER`` keyword to prevent "
"calling the provider command recursively for the same dependency."
msgstr ""
"最后一个示例演示了如何修改 :command:`find_package` "
"调用的参数。它强制所有此类调用都具有“QUIET”关键字。它使用“BYPASS_PROVIDER”关键字来防止为相同的依赖项递归调用提供程序命令。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:498
msgid "Getting current message log level"
msgstr "获取当前消息日志级别"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:509
msgid ""
"Writes the current :command:`message` logging level into the given "
"``<output_variable>``."
msgstr "将当前的 :command:`message` 日志记录级别写入给定的 ``<output_variable>``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:512
msgid "See :command:`message` for the possible logging levels."
msgstr "有关可能的日志记录级别，请参阅:command:`message`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:514
msgid ""
"The current message logging level can be set either using the "
":option:`--log-level <cmake --log-level>` command line option of the "
":manual:`cmake(1)` program or using the "
":variable:`CMAKE_MESSAGE_LOG_LEVEL` variable."
msgstr ""
"当前消息日志记录级别可以使用 :option:`--log-level <cmake --log-level>` cmake(1)` "
"程序的命令行选项或使用 :variable: `CMAKE_MESSAGE_LOG_LEVEL` 变量。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_language.rst:519
msgid ""
"If both the command line option and the variable are set, the command line"
" option takes precedence. If neither are set, the default logging level is"
" returned."
msgstr "如果同时设置了命令行选项和变量，则命令行选项优先。如果两者均未设置，则返回默认日志记录级别。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:2
msgid "cmake_minimum_required"
msgstr "cmake_minimum_required"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:4
msgid "Require a minimum version of cmake."
msgstr "需要最低版本的 cmake。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:10
msgid "The optional ``<policy_max>`` version."
msgstr "可选的``<policy_max>`` 版本。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:13
msgid ""
"Sets the minimum required version of cmake for a project. Also updates the"
" policy settings as explained below."
msgstr "设置项目所需的最低 cmake 版本。还更新策略设置，如下所述。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:16
msgid ""
"``<min>`` and the optional ``<policy_max>`` are each CMake versions of the"
" form ``major.minor[.patch[.tweak]]``, and the ``...`` is literal."
msgstr ""
"``<min>`` 和可选的 ``<policy_max>`` 都是 ``major.minor[.patch[.tweak]]`` 形式的每个 "
"CMake 版本，而 ``...`` 是文字。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:19
msgid ""
"If the running version of CMake is lower than the ``<min>`` required "
"version it will stop processing the project and report an error. The "
"optional ``<policy_max>`` version, if specified, must be at least the "
"``<min>`` version and affects policy settings as described in `Policy "
"Settings`_. If the running version of CMake is older than 3.12, the extra "
"``...`` dots will be seen as version component separators, resulting in "
"the ``...<max>`` part being ignored and preserving the pre-3.12 behavior "
"of basing policies on ``<min>``."
msgstr ""
"如果 CMake 的运行版本低于所需的 ``<min>`` 版本，它将停止处理项目并报告错误。可选的 ``<policy_max>`` "
"版本（如果指定）必须至少为 ``<min>`` 版本并影响策略设置，如 `Policy Settings`_ 中所述。如果 CMake "
"的运行版本早于 3.12，额外的 ``...`` 点将被视为版本组件分隔符，导致 ``...<max>`` 部分被忽略并保留前- 3.12 基于 "
"``<min>`` 策略的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:28
msgid ""
"This command will set the value of the "
":variable:`CMAKE_MINIMUM_REQUIRED_VERSION` variable to ``<min>``."
msgstr "此命令会将 :variable:`CMAKE_MINIMUM_REQUIRED_VERSION` 变量的值设置为 ``<min>``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:31
msgid ""
"The ``FATAL_ERROR`` option is accepted but ignored by CMake 2.6 and "
"higher.  It should be specified so CMake versions 2.4 and lower fail with "
"an error instead of just a warning."
msgstr ""
"``FATAL_ERROR`` 选项被 CMake 2.6 及更高版本接受但被忽略。应该指定它，以便 CMake 版本 2.4 "
"和更低版本失败并出现错误，而不仅仅是警告。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:36
msgid ""
"Call the ``cmake_minimum_required()`` command at the beginning of the top-"
"level ``CMakeLists.txt`` file even before calling the :command:`project` "
"command.  It is important to establish version and policy settings before "
"invoking other commands whose behavior they may affect.  See also policy "
":policy:`CMP0000`."
msgstr ""
"在调用 :command:`project` 命令之前，在顶级 ``CMakeLists.txt`` 文件的开头调用 "
"``cmake_minimum_required()`` "
"命令。在调用可能影响其行为的其他命令之前建立版本和策略设置很重要。另请参阅政策:policy:`CMP0000`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:42
msgid ""
"Calling ``cmake_minimum_required()`` inside a :command:`function` limits "
"some effects to the function scope when invoked.  For example, the "
":variable:`CMAKE_MINIMUM_REQUIRED_VERSION` variable won't be set in the "
"calling scope.  Functions do not introduce their own policy scope though, "
"so policy settings of the caller *will* be affected (see below).  Due to "
"this mix of things that do and do not affect the calling scope, calling "
"``cmake_minimum_required()`` inside a function is generally discouraged."
msgstr ""
"在 :command:`function` 中调用 ``cmake_minimum_required()`` "
"会在调用时限制对函数作用域的一些影响。例如，CMAKE_MINIMUM_REQUIRED_VERSION "
"变量不会在调用范围内设置。但是，函数不会引入自己的策略范围，因此调用者的策略设置*将*受到影响（见下文）。由于这种影响调用范围和不影响调用范围的事情的混合，通常不鼓励在函数内部调用"
" cmake_minimum_required() 。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:54
msgid "Policy Settings"
msgstr "策略设置"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:56
msgid ""
"The ``cmake_minimum_required(VERSION)`` command implicitly invokes the "
":command:`cmake_policy(VERSION)` command to specify that the current "
"project code is written for the given range of CMake versions. All "
"policies known to the running version of CMake and introduced in the "
"``<min>`` (or ``<max>``, if specified) version or earlier will be set to "
"use ``NEW`` behavior.  All policies introduced in later versions will be "
"unset.  This effectively requests behavior preferred as of a given CMake "
"version and tells newer CMake versions to warn about their new policies."
msgstr ""
"``cmake_minimum_required(VERSION)`` 命令隐式调用 "
":command:`cmake_policy(VERSION)` 命令来指定当前项目代码是为给定的 CMake 版本范围编写的。 CMake "
"的运行版本已知并在“<min>”（或“<max>”，如果指定）版本或更早版本中引入的所有策略都将设置为使用“NEW”行为。以后版本中引入的所有策略都将取消设置。这有效地请求了给定"
" CMake 版本的首选行为，并告诉较新的 CMake 版本警告他们的新政策。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:66
msgid ""
"When a ``<min>`` version higher than 2.4 is specified the command "
"implicitly invokes"
msgstr "当指定高于 2.4 的 ``<min>`` 版本时，命令隐式调用"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:73
msgid ""
"which sets CMake policies based on the range of versions specified. When a"
" ``<min>`` version 2.4 or lower is given the command implicitly invokes"
msgstr "它根据指定的版本范围设置 CMake 策略。当给出 ``<min>`` 2.4 或更低版本时，命令隐式调用"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_minimum_required.rst:81
msgid "which enables compatibility features for CMake 2.4 and lower."
msgstr "这为 CMake 2.4 及更低版本启用了兼容性功能。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:2
msgid "cmake_parse_arguments"
msgstr "cmake_parse_arguments"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:4
msgid "Parse function or macro arguments."
msgstr "解析函数或宏参数。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:14
msgid ""
"This command is implemented natively.  Previously, it has been defined in "
"the module :module:`CMakeParseArguments`."
msgstr "此命令是本机实现的。以前，它已在模块 :module:`CMakeParseArguments` 中定义。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:18
msgid ""
"This command is for use in macros or functions. It processes the arguments"
" given to that macro or function, and defines a set of variables which "
"hold the values of the respective options."
msgstr "此命令用于宏或函数中。它处理提供给该宏或函数的参数，并定义一组变量来保存各个选项的值。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:23
msgid ""
"The first signature reads processes arguments passed in the ``<args>...``."
" This may be used in either a :command:`macro` or a :command:`function`."
msgstr ""
"第一个签名读取在 ``<args>...`` 中传递的进程参数。这可以在 :command:`macro` 或 "
":command:`function` 中使用。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:26
msgid ""
"The ``PARSE_ARGV`` signature is only for use in a :command:`function` "
"body.  In this case the arguments that are parsed come from the ``ARGV#`` "
"variables of the calling function.  The parsing starts with the ``<N>``-th"
" argument, where ``<N>`` is an unsigned integer. This allows for the "
"values to have special characters like ``;`` in them."
msgstr ""
"``PARSE_ARGV`` 签名仅用于 :command:`function` 主体。在这种情况下，解析的参数来自调用函数的 ``ARGV#`` "
"变量。解析从第一个参数“<N>”开始，其中“<N>”是一个无符号整数。这允许值中包含特殊字符，如 ``;``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:33
msgid ""
"The ``<options>`` argument contains all options for the respective macro, "
"i.e.  keywords which can be used when calling the macro without any value "
"following, like e.g.  the ``OPTIONAL`` keyword of the :command:`install` "
"command."
msgstr ""
"``<options>`` 参数包含相应宏的所有选项，即在调用宏时可以使用的关键字，后面没有任何值，例如 :command:`install` 命令的"
" ``OPTIONAL`` 关键字。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:38
msgid ""
"The ``<one_value_keywords>`` argument contains all keywords for this macro"
" which are followed by one value, like e.g. ``DESTINATION`` keyword of the"
" :command:`install` command."
msgstr ""
"``<one_value_keywords>`` 参数包含此宏的所有关键字，后面跟着一个值，例如``DESTINATION`` "
":command:`install` 命令的关键字。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:42
msgid ""
"The ``<multi_value_keywords>`` argument contains all keywords for this "
"macro which can be followed by more than one value, like e.g. the "
"``TARGETS`` or ``FILES`` keywords of the :command:`install` command."
msgstr ""
"``<multi_value_keywords>`` 参数包含此宏的所有关键字，后面可以跟多个值，例如 :command:`install` "
"命令的``TARGETS`` 或``FILES`` 关键字。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:46
msgid ""
"All keywords shall be unique. I.e. every keyword shall only be specified "
"once in either ``<options>``, ``<one_value_keywords>`` or "
"``<multi_value_keywords>``. A warning will be emitted if uniqueness is "
"violated."
msgstr ""
"所有关键字都应是唯一的。 "
"IE。每个关键字只能在“<options>”、“<one_value_keywords>”或“<multi_value_keywords>”中指定一次。如果违反唯一性，将发出警告。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:52
msgid ""
"When done, ``cmake_parse_arguments`` will consider for each of the "
"keywords listed in ``<options>``, ``<one_value_keywords>`` and "
"``<multi_value_keywords>`` a variable composed of the given ``<prefix>`` "
"followed by ``\"_\"`` and the name of the respective keyword.  These "
"variables will then hold the respective value from the argument list or be"
" undefined if the associated option could not be found. For the "
"``<options>`` keywords, these will always be defined, to ``TRUE`` or "
"``FALSE``, whether the option is in the argument list or not."
msgstr ""
"完成后，“cmake_parse_arguments”将为“<options>”、“<one_value_keywords>”和“<multi_value_keywords>”中列出的每个关键字考虑一个由给定的“<prefix”组成的变量>``"
" 后跟 ``\"_\"`` 和相应关键字的名称。然后这些变量将保存参数列表中的相应值，或者如果找不到关联的选项则未定义。对于 "
"``<options>`` 关键字，无论选项是否在参数列表中，它们将始终被定义为 ``TRUE`` 或 ``FALSE``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:61
msgid ""
"All remaining arguments are collected in a variable "
"``<prefix>_UNPARSED_ARGUMENTS`` that will be undefined if all arguments "
"were recognized. This can be checked afterwards to see whether your macro "
"was called with unrecognized parameters."
msgstr ""
"所有剩余的参数都收集在变量“<prefix>_UNPARSED_ARGUMENTS”中，如果所有参数都被识别，该变量将是未定义的。这可以在之后检查以查看是否使用无法识别的参数调用了您的宏。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:66
msgid ""
"``<one_value_keywords>`` and ``<multi_value_keywords>`` that were given no"
" values at all are collected in a variable "
"``<prefix>_KEYWORDS_MISSING_VALUES`` that will be undefined if all "
"keywords received values. This can be checked to see if there were "
"keywords without any values given."
msgstr ""
"``<one_value_keywords>`` 和``<multi_value_keywords>`` "
"根本没有给定任何值，它们被收集在变量``<prefix>_KEYWORDS_MISSING_VALUES`` "
"中，如果所有关键字都收到值，则该变量将是未定义的。这可以检查以查看是否存在没有给定任何值的关键字。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:73
msgid ""
"Consider the following example macro, ``my_install()``, which takes "
"similar arguments to the real :command:`install` command:"
msgstr "考虑以下示例宏，``my_install()``，它采用与实际 :command:`install` 命令类似的参数："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:87
msgid "Assume ``my_install()`` has been called like this:"
msgstr "假设 ``my_install()`` 被这样调用："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:93
msgid ""
"After the ``cmake_parse_arguments`` call the macro will have set or "
"undefined the following variables::"
msgstr "在 ``cmake_parse_arguments`` 调用之后，宏将设置或取消定义以下变量："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:106
msgid "You can then continue and process these variables."
msgstr "然后您可以继续并处理这些变量。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:108
msgid ""
"Keywords terminate lists of values, e.g. if directly after a "
"``one_value_keyword`` another recognized keyword follows, this is "
"interpreted as the beginning of the new option.  E.g. ``my_install(TARGETS"
" foo DESTINATION OPTIONAL)`` would result in ``MY_INSTALL_DESTINATION`` "
"set to ``\"OPTIONAL\"``, but as ``OPTIONAL`` is a keyword itself "
"``MY_INSTALL_DESTINATION`` will be empty (but added to "
"``MY_INSTALL_KEYWORDS_MISSING_VALUES``) and ``MY_INSTALL_OPTIONAL`` will "
"therefore be set to ``TRUE``."
msgstr ""
"关键字终止值列表，例如如果在 ``one_value_keyword`` 之后紧跟另一个可识别的关键字，这将被解释为新选项的开始。例如。 "
"``my_install(TARGETS foo DESTINATION OPTIONAL)`` 会导致 "
"``MY_INSTALL_DESTINATION`` 设置为 ``\"OPTIONAL\"``，但由于 ``OPTIONAL`` 本身就是关键字 "
"``MY_INSTALL_DESTINATION`` 将为空（但添加到 "
"``MY_INSTALL_KEYWORDS_MISSING_VALUES``) 并且 ``MY_INSTALL_OPTIONAL`` 将因此设置为 "
"``TRUE``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:120
#: ../../cmake-prefix/src/cmake/Help/command/return.rst:92
msgid ":command:`function`"
msgstr ":command:`功能`"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_parse_arguments.rst:121
msgid ":command:`macro`"
msgstr ":command:`宏`"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:2
msgid "cmake_path"
msgstr "路径"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:6
msgid ""
"This command is for the manipulation of paths.  Only syntactic aspects of "
"paths are handled, there is no interaction of any kind with any underlying"
" file system.  The path may represent a non-existing path or even one that"
" is not allowed to exist on the current file system or platform. For "
"operations that do interact with the filesystem, see the :command:`file` "
"command."
msgstr ""
"此命令用于操作路径。仅处理路径的语法方面，不与任何底层文件系统进行任何类型的交互。该路径可能表示不存在的路径，甚至是当前文件系统或平台上不允许存在的路径。对于与文件系统交互的操作，请参阅"
" :command:`file` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:15
msgid ""
"The ``cmake_path`` command handles paths in the format of the build system"
" (i.e. the host platform), not the target system.  When cross-compiling, "
"if the path contains elements that are not representable on the host "
"platform (e.g. a drive letter when the host is not Windows), the results "
"will be unpredictable."
msgstr ""
"``cmake_path`` "
"命令以构建系统（即主机平台）而非目标系统的格式处理路径。交叉编译时，如果路径包含在主机平台上无法表示的元素（例如，主机不是 Windows "
"时的盘符），结果将不可预测。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:79
msgid "Conventions"
msgstr "惯例"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:81
msgid "The following conventions are used in this command's documentation:"
msgstr "此命令的文档中使用了以下约定："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:85
msgid "``<path-var>``"
msgstr "``<路径变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:84
msgid ""
"Always the name of a variable.  For commands that expect a ``<path-var>`` "
"as input, the variable must exist and it is expected to hold a single "
"path."
msgstr "始终是变量的名称。对于期望 ``<path-var>`` 作为输入的命令，该变量必须存在并且它应该包含单个路径。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:90
#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:92
msgid "``<input>``"
msgstr "``<输入>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:88
msgid ""
"A string literal which may contain a path, path fragment, or multiple "
"paths with a special separator depending on the command.  See the "
"description of each command to see how this is interpreted."
msgstr "一个字符串文字，它可能包含一个路径、路径片段或多个带有特殊分隔符的路径，具体取决于命令。请参阅每个命令的描述以了解其解释方式。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:93
msgid "``<input>...``"
msgstr "``<输入>...``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:93
msgid "Zero or more string literal arguments."
msgstr "零个或多个字符串文字参数。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:97
msgid "``<out-var>``"
msgstr "``<输出变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:96
msgid ""
"The name of a variable into which the result of a command will be written."
msgstr "将写入命令结果的变量的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:102
msgid "Path Structure And Terminology"
msgstr "路径结构和术语"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:104
msgid ""
"A path has the following structure (all components are optional, with some"
" constraints):"
msgstr "路径具有以下结构（所有组件都是可选的，有一些限制）："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:113
msgid "``root-name``"
msgstr "``根名``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:112
msgid ""
"Identifies the root on a filesystem with multiple roots (such as "
"``\"C:\"`` or ``\"//myserver\"``). It is optional."
msgstr "标识具有多个根的文件系统上的根（例如 ``\"C:\"`` 或 ``\"//myserver\"``）。它是可选的。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:118
msgid "``root-directory-separator``"
msgstr "``根目录分隔符``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:116
msgid ""
"A directory separator that, if present, indicates that this path is "
"absolute.  If it is missing and the first element other than the ``root-"
"name`` is an ``item-name``, then the path is relative."
msgstr ""
"目录分隔符，如果存在，则表示此路径是绝对路径。如果它丢失并且除 ``root-name`` 之外的第一个元素是 ``item-"
"name``，那么路径是相对的。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:133
msgid "``item-name``"
msgstr "``项目名称``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:121
msgid ""
"A sequence of characters that aren't directory separators.  This name may "
"identify a file, a hard link, a symbolic link, or a directory.  Two "
"special cases are recognized:"
msgstr "不是目录分隔符的字符序列。此名称可以标识文件、硬链接、符号链接或目录。识别出两种特殊情况："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:125
msgid ""
"The item name consisting of a single dot character ``.`` is a directory "
"name that refers to the current directory."
msgstr "由单个点字符 ``.`` 组成的项目名称是指代当前目录的目录名称。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:128
msgid ""
"The item name consisting of two dot characters ``..`` is a directory name "
"that refers to the parent directory."
msgstr "由两个点字符``..`` 组成的项目名称是指代父目录的目录名称。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:131
msgid ""
"The ``(...)*`` pattern shown above is to indicate that there can be zero "
"or more item names, with multiple items separated by a ``directory-"
"separator``.  The ``()*`` characters are not part of the path."
msgstr ""
"上面显示的 ``(...)*`` 模式表示可以有零个或多个项目名称，多个项目由 ``directory-separator`` 分隔。 "
"``()*`` 字符不是路径的一部分。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:138
msgid "``directory-separator``"
msgstr "``目录分隔符``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:136
msgid ""
"The only recognized directory separator is a forward slash character "
"``/``. If this character is repeated, it is treated as a single directory "
"separator.  In other words, ``/usr///////lib`` is the same as "
"``/usr/lib``."
msgstr ""
"唯一可识别的目录分隔符是正斜杠字符“/”。如果此字符重复，则将其视为单个目录分隔符。换句话说，``/usr///////lib`` "
"与``/usr/lib`` 相同。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:163
msgid "``filename``"
msgstr "``文件名``"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:145
msgid ""
"A path has a ``filename`` if it does not end with a ``directory-"
"separator``. The ``filename`` is effectively the last ``item-name`` of the"
" path, so it can also be a hard link, symbolic link or a directory."
msgstr ""
"如果路径不以“目录分隔符”结尾，则它具有“文件名”。 ``filename`` 实际上是路径的最后一个 ``item-"
"name``，因此它也可以是硬链接、符号链接或目录。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:149
msgid ""
"A ``filename`` can have an *extension*.  By default, the extension is "
"defined as the sub-string beginning at the left-most period (including the"
" period) and until the end of the ``filename``.  In commands that accept a"
" ``LAST_ONLY`` keyword, ``LAST_ONLY`` changes the interpretation to the "
"sub-string beginning at the right-most period."
msgstr ""
"``文件名`` "
"可以有*扩展名*。默认情况下，扩展名定义为从最左边的句点（包括句点）开始到“文件名”结尾的子字符串。在接受“LAST_ONLY”关键字的命令中，“LAST_ONLY”将解释更改为从最右边的句点开始的子字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:155
msgid "The following exceptions apply to the above interpretation:"
msgstr "以下例外情况适用于上述解释："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:157
msgid ""
"If the first character in the ``filename`` is a period, that period is "
"ignored (i.e. a ``filename`` like ``\".profile\"`` is treated as having no"
" extension)."
msgstr ""
"如果 ``filename`` 中的第一个字符是句点，则忽略该句点（即像 ``\".profile\"`` 的 ``filename`` "
"被视为没有扩展名）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:161
msgid "If the ``filename`` is either ``.`` or ``..``, it has no extension."
msgstr "如果 ``filename`` 是 ``.`` 或 ``..``，则它没有扩展名。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:163
msgid "The *stem* is the part of the ``filename`` before the extension."
msgstr "*stem* 是扩展名之前的“文件名”部分。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:165
msgid ""
"Some commands refer to a ``root-path``.  This is the concatenation of "
"``root-name`` and ``root-directory-separator``, either or both of which "
"can be empty.  A ``relative-part`` refers to the full path with any "
"``root-path`` removed."
msgstr ""
"一些命令引用 ``root-path``。这是 ``root-name`` 和 ``root-directory-separator`` "
"的串联，其中一个或两个都可以为空。 ``relative-part`` 指的是删除了任何 ``root-path`` 的完整路径。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:172
msgid "Creating A Path Variable"
msgstr "创建路径变量"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:174
msgid ""
"While a path can be created with care using an ordinary :command:`set` "
"command, it is recommended to use :ref:`cmake_path(SET) <cmake_path-SET>` "
"instead, as it automatically converts the path to the required form where "
"required.  The :ref:`cmake_path(APPEND) <APPEND>` subcommand may be "
"another suitable alternative where a path needs to be constructed by "
"joining fragments.  The following example compares the three methods for "
"constructing the same path:"
msgstr ""
"虽然可以使用普通的 :command:`set` 命令小心创建路径，但建议改用 :ref:`cmake_path(SET) <cmake_path-"
"SET>`，因为它会自动将路径转换为所需的形式在需要的地方。 :ref:`cmake_path(APPEND) <APPEND>` "
"子命令可能是另一种合适的替代方法，其中需要通过连接片段来构建路径。下面的例子比较了三种构造相同路径的方法："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:190
msgid ""
"`Modification`_ and `Generation`_ sub-commands can either store the result"
" in-place, or in a separate variable named after an ``OUTPUT_VARIABLE`` "
"keyword.  All other sub-commands store the result in a mandatory ``<out-"
"var>`` variable."
msgstr ""
"`Modification`_ 和 `Generation`_ 子命令可以就地存储结果，或者存储在以 ``OUTPUT_VARIABLE`` "
"关键字命名的单独变量中。所有其他子命令将结果存储在强制性的“<out-var>”变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:198
msgid "Normalization"
msgstr "正常化"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:200
msgid ""
"Some sub-commands support *normalizing* a path.  The algorithm used to "
"normalize a path is as follows:"
msgstr "一些子命令支持*规范化*路径。用于规范化路径的算法如下："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:203
msgid ""
"If the path is empty, stop (the normalized form of an empty path is also "
"an empty path)."
msgstr "如果路径为空，则停止（空路径的规范化形式也是空路径）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:205
msgid ""
"Replace each ``directory-separator``, which may consist of multiple "
"separators, with a single ``/`` (``/a///b  --> /a/b``)."
msgstr "将每个可能由多个分隔符组成的“目录分隔符”替换为单个“/”（“/a///b --> /a/b”）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:207
msgid ""
"Remove each solitary period (``.``) and any immediately following "
"``directory-separator`` (``/a/./b/. --> /a/b``)."
msgstr "删除每个单独的句点 (``.``) 和紧跟在``目录分隔符`` 之后的所有句点 (``/a/./b/. --> /a/b``)。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:209
msgid ""
"Remove each ``item-name`` (other than ``..``) that is immediately followed"
" by a ``directory-separator`` and a ``..``, along with any immediately "
"following ``directory-separator`` (``/a/b/../c --> a/c``)."
msgstr ""
"删除紧跟在``目录分隔符``和``..``之后的每个``项目名称``（``..``除外），以及紧随其后的任何``目录-"
"分隔符``（``/a/b/../c --> a/c``）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:212
msgid ""
"If there is a ``root-directory``, remove any ``..`` and any ``directory-"
"separators`` immediately following them.  The parent of the root directory"
" is treated as still the root directory (``/../a --> /a``)."
msgstr ""
"如果有一个 ``root-directory``，删除任何 ``..`` 和紧随其后的任何 ``directory-"
"separators``。根目录的父目录仍被视为根目录 (``/../a --> /a``)。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:215
msgid ""
"If the last ``item-name`` is ``..``, remove any trailing ``directory-"
"separator`` (``../ --> ..``)."
msgstr ""
"如果最后一个 ``item-name`` 是 ``..``，删除任何尾随的 ``directory-separator`` (``../ --> "
"..``)。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:217
msgid ""
"If the path is empty by this stage, add a ``dot`` (normal form of ``./`` "
"is ``.``)."
msgstr "如果这个阶段路径是空的，添加一个``点``（``./``的正常形式是``.``）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:224
msgid "Decomposition"
msgstr "分解"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:236
msgid ""
"The following forms of the ``GET`` subcommand each retrieve a different "
"component or group of components from a path.  See `Path Structure And "
"Terminology`_ for the meaning of each path component."
msgstr "``GET`` 子命令的以下形式分别从路径中检索不同的组件或组件组。有关每个路径组件的含义，请参阅“路径结构和术语”。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:251
msgid ""
"If a requested component is not present in the path, an empty string will "
"be stored in ``<out-var>``.  For example, only Windows systems have the "
"concept of a ``root-name``, so when the host machine is non-Windows, the "
"``ROOT_NAME`` subcommand will always return an empty string."
msgstr ""
"如果路径中不存在请求的组件，则空字符串将存储在 ``<out-var>`` 中。例如，只有 Windows 系统有 ``root-name`` "
"的概念，所以当主机不是 Windows 时，``ROOT_NAME`` 子命令总是返回一个空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:256
msgid ""
"For ``PARENT_PATH``, if the `HAS_RELATIVE_PART`_ subcommand returns false,"
" the result is a copy of ``<path-var>``.  Note that this implies that a "
"root directory is considered to have a parent, with that parent being "
"itself. Where `HAS_RELATIVE_PART`_ returns true, the result will "
"essentially be ``<path-var>`` with one less element."
msgstr ""
"对于 ``PARENT_PATH``，如果 `HAS_RELATIVE_PART`_ 子命令返回 false，则结果是 ``<path-var>``"
" 的副本。请注意，这意味着根目录被认为具有父目录，而该父目录就是它本身。在 `HAS_RELATIVE_PART`_ 返回 true "
"的地方，结果基本上是 ``<path-var>`` 少了一个元素。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:263
msgid "Root examples"
msgstr "根示例"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:284
msgid "Filename examples"
msgstr "文件名示例"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:303
msgid "Extension and stem examples"
msgstr "扩展和词干示例"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:351
msgid "Relative part examples"
msgstr "相关部分示例"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:374
msgid "Path traversal examples"
msgstr "路径遍历示例"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:395
msgid "Query"
msgstr "询问"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:397
msgid ""
"Each of the ``GET`` subcommands has a corresponding ``HAS_...`` subcommand"
" which can be used to discover whether a particular path component is "
"present.  See `Path Structure And Terminology`_ for the meaning of each "
"path component."
msgstr ""
"每个 ``GET`` 子命令都有一个对应的 ``HAS_...`` "
"子命令，可用于发现特定路径组件是否存在。有关每个路径组件的含义，请参阅“路径结构和术语”。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:422
msgid ""
"Each of the above follows the predictable pattern of setting ``<out-var>``"
" to true if the path has the associated component, or false otherwise. "
"Note the following special cases:"
msgstr ""
"如果路径具有关联的组件，则上面的每一个都遵循将``<out-var>``设置为true的可预测模式，否则为false。注意以下特殊情况："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:426
msgid ""
"For ``HAS_ROOT_PATH``, a true result will only be returned if at least one"
" of ``root-name`` or ``root-directory`` is non-empty."
msgstr ""
"对于 ``HAS_ROOT_PATH``，仅当 ``root-name`` 或 ``root-directory`` 中至少有一个非空时，才会返回 "
"true 结果。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:429
msgid ""
"For ``HAS_PARENT_PATH``, the root directory is also considered to have a "
"parent, which will be itself.  The result is true except if the path "
"consists of just a :ref:`filename <FILENAME_DEF>`."
msgstr ""
"对于``HAS_PARENT_PATH``，根目录也被认为有一个父目录，就是它自己。结果为真，除非路径仅包含 :ref:`filename "
"<FILENAME_DEF>`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:439
msgid ""
"Sets ``<out-var>`` to true if ``<path-var>`` is absolute.  An absolute "
"path is a path that unambiguously identifies the location of a file "
"without reference to an additional starting location.  On Windows, this "
"means the path must have both a ``root-name`` and a ``root-directory-"
"separator`` to be considered absolute.  On other platforms, just a ``root-"
"directory-separator`` is sufficient.  Note that this means on Windows, "
"``IS_ABSOLUTE`` can be false while ``HAS_ROOT_DIRECTORY`` can be true."
msgstr ""
"如果 ``<path-var>`` 是绝对的，则将 ``<out-var>`` 设置为 "
"true。绝对路径是一种在不引用其他起始位置的情况下明确标识文件位置的路径。在 Windows 上，这意味着路径必须同时具有 ``root-"
"name`` 和 ``root-directory-separator`` 才能被视为绝对路径。在其他平台上，只需一个 ``root-"
"directory-separator`` 就足够了。请注意，这意味着在 Windows 上，``IS_ABSOLUTE`` "
"可以为假，而``HAS_ROOT_DIRECTORY`` 可以为真。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:453
msgid "This will store the opposite of ``IS_ABSOLUTE`` in ``<out-var>``."
msgstr "这将在 ``<out-var>`` 中存储 ``IS_ABSOLUTE`` 的对立面。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:461
msgid "Checks if ``<path-var>`` is the prefix of ``<input>``."
msgstr "检查 ``<path-var>`` 是否是 ``<input>`` 的前缀。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:463
msgid ""
"When the ``NORMALIZE`` option is specified, ``<path-var>`` and ``<input>``"
" are :ref:`normalized <Normalization>` before the check."
msgstr ""
"当指定了 ``NORMALIZE`` 选项时，``<path-var>`` 和 ``<input>`` 在检查之前被标准化 "
"<Normalization>`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:484
msgid ""
"Compares the lexical representations of two paths provided as string "
"literals. No normalization is performed on either path, except multiple "
"consecutive directory separators are effectively collapsed into a single "
"separator. Equality is determined according to the following pseudo-code "
"logic:"
msgstr ""
"比较作为字符串文字提供的两个路径的词法表示。除了多个连续的目录分隔符被有效地折叠成一个分隔符外，任何一个路径都没有执行规范化。根据以下伪代码逻辑确定相等性："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:502
msgid ""
"Unlike most other ``cmake_path()`` subcommands, the ``COMPARE`` subcommand"
" takes literal strings as input, not the names of variables."
msgstr "与大多数其他 ``cmake_path()`` 子命令不同，``COMPARE`` 子命令将文字字符串作为输入，而不是变量名。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:509
#: ../../cmake-prefix/src/cmake/Help/command/list.rst:123
msgid "Modification"
msgstr "修改"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:517
msgid ""
"Assign the ``<input>`` path to ``<path-var>``.  If ``<input>`` is a native"
" path, it is converted into a cmake-style path with forward-slashes "
"(``/``). On Windows, the long filename marker is taken into account."
msgstr ""
"将 ``<input>`` 路径分配给 ``<path-var>``。如果 ``<input>`` 是本机路径，它将转换为带有正斜杠 (``/``)"
" 的 cmake 样式路径。在 Windows 上，长文件名标记被考虑在内。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:521
msgid ""
"When the ``NORMALIZE`` option is specified, the path is :ref:`normalized "
"<Normalization>` after the conversion."
msgstr "当指定了 ``NORMALIZE`` 选项时，转换后的路径是 :ref:`normalized <Normalization>`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:524
#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:593
#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:770
#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:51
#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:64
msgid "For example:"
msgstr "例如："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:546
msgid ""
"Append all the ``<input>`` arguments to the ``<path-var>`` using ``/`` as "
"the ``directory-separator``.  Depending on the ``<input>``, the previous "
"contents of ``<path-var>`` may be discarded.  For each ``<input>`` "
"argument, the following algorithm (pseudo-code) applies:"
msgstr ""
"使用“/”作为“目录分隔符”将所有“<input>”参数附加到“<path-var>”。根据 ``<input>``，``<path-var>`` "
"的先前内容可能会被丢弃。对于每个 ``<input>`` 参数，应用以下算法（伪代码）："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:577
msgid ""
"Append all the ``<input>`` arguments to the ``<path-var>`` without adding "
"any ``directory-separator``."
msgstr ""
"将所有 ``<input>`` 参数附加到 ``<path-var>`` 而不添加任何 ``directory-separator``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:586
msgid ""
"Removes the :ref:`filename <FILENAME_DEF>` component (as returned by "
":ref:`GET ... FILENAME <GET_FILENAME>`) from ``<path-var>``.  After "
"removal, any trailing ``directory-separator`` is left alone, if present."
msgstr ""
"从 ``<path-var>`` 中删除 :ref:`filename <FILENAME_DEF>` 组件（由 :ref:`GET ... "
"FILENAME <GET_FILENAME>` 返回）。删除后，任何尾随的“目录分隔符”（如果存在）将保持不变。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:590
msgid ""
"If ``OUTPUT_VARIABLE`` is not given, then after this function returns, "
"`HAS_FILENAME`_ returns false for ``<path-var>``."
msgstr ""
"如果未给出 ``OUTPUT_VARIABLE``，则在此函数返回后，`HAS_FILENAME`_ 为 ``<path-var>`` 返回 "
"false。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:616
msgid ""
"Replaces the :ref:`filename <FILENAME_DEF>` component from ``<path-var>`` "
"with ``<input>``.  If ``<path-var>`` has no filename component (i.e. "
"`HAS_FILENAME`_ returns false), the path is unchanged.  The operation is "
"equivalent to the following:"
msgstr ""
"将 ``<path-var>`` 中的 :ref:`filename <FILENAME_DEF>` 组件替换为 ``<input>``。如果 "
"``<path-var>`` 没有文件名组件（即 `HAS_FILENAME`_ 返回 false），则路径不变。该操作等效于以下内容："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:636
msgid ""
"Removes the :ref:`extension <EXTENSION_DEF>`, if any, from ``<path-var>``."
msgstr "从 ``<path-var>`` 中删除 :ref:`extension <EXTENSION_DEF>`（如果有的话）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:645
msgid ""
"Replaces the :ref:`extension <EXTENSION_DEF>` with ``<input>``.  Its "
"effect is equivalent to the following:"
msgstr "用 ``<input>`` 替换 :ref:`extension <EXTENSION_DEF>`。其效果等同于以下内容："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:660
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:379
msgid "Generation"
msgstr "一代"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:668
msgid ""
"Normalize ``<path-var>`` according the steps described in "
":ref:`Normalization`."
msgstr "根据 :ref:`Normalization` 中描述的步骤规范化 ``<path-var>``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:678
msgid ""
"Modifies ``<path-var>`` to make it relative to the ``BASE_DIRECTORY`` "
"argument. If ``BASE_DIRECTORY`` is not specified, the default base "
"directory will be :variable:`CMAKE_CURRENT_SOURCE_DIR`."
msgstr ""
"修改 ``<path-var>`` 使其相对于 ``BASE_DIRECTORY`` 参数。如果未指定 "
"``BASE_DIRECTORY``，则默认基目录将为 :variable:`CMAKE_CURRENT_SOURCE_DIR`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:682
msgid ""
"For reference, the algorithm used to compute the relative path is the same"
" as that used by C++ `std::filesystem::path::lexically_relative "
"<https://en.cppreference.com/w/cpp/filesystem/path/lexically_normal>`_."
msgstr ""
"作为参考，用于计算相对路径的算法与 C++ `std::filesystem::path::lexically_relative "
"<https://en.cppreference.com/w/cpp/filesystem/path/lexically_normal "
"使用的算法相同>`_。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:694
msgid ""
"If ``<path-var>`` is a relative path (`IS_RELATIVE`_ is true), it is "
"evaluated relative to the given base directory specified by "
"``BASE_DIRECTORY`` option. If ``BASE_DIRECTORY`` is not specified, the "
"default base directory will be :variable:`CMAKE_CURRENT_SOURCE_DIR`."
msgstr ""
"如果 ``<path-var>`` 是相对路径（`IS_RELATIVE`_ 为真），则相对于 ``BASE_DIRECTORY`` "
"选项指定的给定基目录进行评估。如果未指定 "
"``BASE_DIRECTORY``，则默认基目录将为 :variable:`CMAKE_CURRENT_SOURCE_DIR`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:699
msgid ""
"When the ``NORMALIZE`` option is specified, the path is :ref:`normalized "
"<Normalization>` after the path computation."
msgstr "当指定 ``NORMALIZE`` 选项时，路径在路径计算之后是 :ref:`normalized <Normalization>`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:702
msgid ""
"Because ``cmake_path()`` does not access the filesystem, symbolic links "
"are not resolved and any leading tilde is not expanded.  To compute a real"
" path with symbolic links resolved and leading tildes expanded, use the "
":command:`file(REAL_PATH)` command instead."
msgstr ""
"因为 ``cmake_path()`` "
"不访问文件系统，所以符号链接没有解析，任何前导波浪号都没有展开。要计算解析了符号链接并扩展前导波浪号的真实路径，请改用 "
":command:`file(REAL_PATH)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:708
msgid "Native Conversion"
msgstr "本地转换"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:710
msgid ""
"For commands in this section, *native* refers to the host platform, not "
"the target platform when cross-compiling."
msgstr "本节命令中，*native*指的是宿主平台，交叉编译时不是目标平台。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:720
msgid ""
"Converts a cmake-style ``<path-var>`` into a native path with platform-"
"specific slashes (``\\`` on Windows hosts and ``/`` elsewhere)."
msgstr ""
"将 cmake 风格的 ``<path-var>`` 转换为带有特定平台斜杠的本机路径（Windows 主机上的``\\`` "
"和其他地方的``/``）。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:723
#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:742
#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:763
msgid ""
"When the ``NORMALIZE`` option is specified, the path is :ref:`normalized "
"<Normalization>` before the conversion."
msgstr "当指定 ``NORMALIZE`` 选项时，路径在转换之前是 :ref:`normalized <Normalization>`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:734
msgid ""
"Converts a native ``<input>`` path into a cmake-style path with forward "
"slashes (``/``).  On Windows hosts, the long filename marker is taken into"
" account.  The input can be a single path or a system search path like "
"``$ENV{PATH}``.  A search path will be converted to a cmake-style list "
"separated by ``;`` characters (on non-Windows platforms, this essentially "
"means ``:`` separators are replaced with ``;``).  The result of the "
"conversion is stored in the ``<out-var>`` variable."
msgstr ""
"将本机“<input>”路径转换为带有正斜杠（“/”）的 cmake 样式路径。在 Windows "
"主机上，长文件名标记被考虑在内。输入可以是单个路径或系统搜索路径，如 ``$ENV{PATH}``。搜索路径将转换为由 ``;`` 字符分隔的 "
"cmake 样式列表（在非 Windows 平台上，这实际上意味着 ``:`` 分隔符被替换为 ``;``）。转换的结果存储在 ``<out-"
"var>`` 变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:746
#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:767
msgid ""
"Unlike most other ``cmake_path()`` subcommands, the ``CONVERT`` subcommand"
" takes a literal string as input, not the name of a variable."
msgstr "与大多数其他``cmake_path()`` 子命令不同，``CONVERT`` 子命令将文字字符串作为输入，而不是变量名。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:756
msgid ""
"Converts a cmake-style ``<input>`` path into a native path with platform-"
"specific slashes (``\\`` on Windows hosts and ``/`` elsewhere). The input "
"can be a single path or a cmake-style list.  A list will be converted into"
" a native search path (``;``-separated on Windows, ``:``-separated on "
"other platforms).  The result of the conversion is stored in the ``<out-"
"var>`` variable."
msgstr ""
"将 cmake 风格的``<input>`` 路径转换为带有特定于平台的斜杠的本机路径（Windows 主机上的``\\`` "
"和其他地方的``/``）。输入可以是单个路径或 cmake 样式的列表。列表将转换为本机搜索路径（``;`` - 在 Windows "
"上分隔，``:`` - 在其他平台上分隔）。转换的结果存储在 ``<out-var>`` 变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:778
msgid "Output on Windows::"
msgstr "Windows 上的输出 ::"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:782
msgid "Output on all other platforms::"
msgstr "在所有其他平台上的输出 ::"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:787
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:343
msgid "Hashing"
msgstr "哈希"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_path.rst:795
msgid ""
"Compute a hash value of ``<path-var>`` such that for two paths ``p1`` and "
"``p2`` that compare equal (:ref:`COMPARE ... EQUAL <COMPARE>`), the hash "
"value of ``p1`` is equal to the hash value of ``p2``.  The path is always "
":ref:`normalized <Normalization>` before the hash is computed."
msgstr ""
"计算 ``<path-var>`` 的哈希值，使得对于比较相等的两条路径 ``p1`` 和 ``p2`` (:ref:`COMPARE ... "
"EQUAL <COMPARE>`)， ``p1`` 的哈希值等于``p2`` 的哈希值。在计算散列之前，路径总是 :ref:`normalized "
"<Normalization>`。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:2
msgid "cmake_policy"
msgstr "cmake_policy"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:4
msgid ""
"Manage CMake Policy settings.  See the :manual:`cmake-policies(7)` manual "
"for defined policies."
msgstr "管理 CMake 策略设置。有关定义的策略，请参阅 :manual:`cmake-policies(7)` 手册。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:7
msgid ""
"As CMake evolves it is sometimes necessary to change existing behavior in "
"order to fix bugs or improve implementations of existing features. The "
"CMake Policy mechanism is designed to help keep existing projects building"
" as new versions of CMake introduce changes in behavior.  Each new policy "
"(behavioral change) is given an identifier of the form ``CMP<NNNN>`` where"
" ``<NNNN>`` is an integer index.  Documentation associated with each "
"policy describes the ``OLD`` and ``NEW`` behavior and the reason the "
"policy was introduced.  Projects may set each policy to select the desired"
" behavior.  When CMake needs to know which behavior to use it checks for a"
" setting specified by the project.  If no setting is available the ``OLD``"
" behavior is assumed and a warning is produced requesting that the policy "
"be set."
msgstr ""
"随着 CMake 的发展，有时需要更改现有行为以修复错误或改进现有功能的实现。 CMake Policy 机制旨在帮助在新版本的 CMake "
"引入行为变化时保持现有项目的构建。每个新策略（行为变化）都被赋予一个形式为“CMP<NNNN>”的标识符，其中“<NNNN>”是一个整数索引。与每个策略相关的文档描述了“旧”和“新”行为以及引入该策略的原因。项目可以设置每个策略以选择所需的行为。当"
" CMake 需要知道使用哪种行为时，它会检查项目指定的设置。如果没有可用的设置，则假定“旧”行为并产生警告，要求设置策略。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:21
msgid "Setting Policies by CMake Version"
msgstr "按 CMake 版本设置策略"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:23
msgid ""
"The ``cmake_policy`` command is used to set policies to ``OLD`` or ``NEW``"
" behavior.  While setting policies individually is supported, we encourage"
" projects to set policies based on CMake versions:"
msgstr ""
"``cmake_policy`` 命令用于将策略设置为``OLD`` 或``NEW`` 行为。虽然支持单独设置策略，但我们鼓励项目根据 CMake "
"版本设置策略："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:31
msgid "The optional ``<max>`` version."
msgstr "可选的 ``<max>`` 版本。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:34
msgid ""
"``<min>`` and the optional ``<max>`` are each CMake versions of the form "
"``major.minor[.patch[.tweak]]``, and the ``...`` is literal.  The "
"``<min>`` version must be at least ``2.4`` and at most the running version"
" of CMake. The ``<max>`` version, if specified, must be at least the "
"``<min>`` version but may exceed the running version of CMake.  If the "
"running version of CMake is older than 3.12, the extra ``...`` dots will "
"be seen as version component separators, resulting in the ``...<max>`` "
"part being ignored and preserving the pre-3.12 behavior of basing policies"
" on ``<min>``."
msgstr ""
"``<min>`` 和可选的 ``<max>`` 都是 ``major.minor[.patch[.tweak]]`` 形式的每个 CMake "
"版本，而 ``...`` 是文字。 ``<min>`` 版本必须至少为 ``2.4`` 并且最多为 CMake 的运行版本。 ``<max>`` "
"版本（如果指定）必须至少为 ``<min>`` 版本，但可以超过 CMake 的运行版本。如果 CMake 的运行版本早于 3.12，额外的 "
"``...`` 点将被视为版本组件分隔符，导致 ``...<max>`` 部分被忽略并保留前- 3.12 基于 ``<min>`` 策略的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:43
msgid ""
"This specifies that the current CMake code is written for the given range "
"of CMake versions.  All policies known to the running version of CMake and"
" introduced in the ``<min>`` (or ``<max>``, if specified) version or "
"earlier will be set to use ``NEW`` behavior.  All policies introduced in "
"later versions will be unset (unless the "
":variable:`CMAKE_POLICY_DEFAULT_CMP<NNNN>` variable sets a default). This "
"effectively requests behavior preferred as of a given CMake version and "
"tells newer CMake versions to warn about their new policies."
msgstr ""
"这指定当前 CMake 代码是为给定范围的 CMake 版本编写的。 CMake "
"的运行版本已知并在“<min>”（或“<max>”，如果指定）版本或更早版本中引入的所有策略都将设置为使用“NEW”行为。以后版本中引入的所有策略都将被取消设置（除非"
" :variable:`CMAKE_POLICY_DEFAULT_CMP<NNNN>` 变量设置了默认值）。这有效地请求了给定 CMake "
"版本的首选行为，并告诉较新的 CMake 版本警告他们的新政策。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:52
msgid ""
"Note that the :command:`cmake_minimum_required(VERSION)` command "
"implicitly calls ``cmake_policy(VERSION)`` too."
msgstr ""
"请注意 :command:`cmake_minimum_required(VERSION)` "
"命令也隐式调用了``cmake_policy(VERSION)``。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:56
msgid "Setting Policies Explicitly"
msgstr "显式设置策略"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:63
msgid ""
"Tell CMake to use the ``OLD`` or ``NEW`` behavior for a given policy. "
"Projects depending on the old behavior of a given policy may silence a "
"policy warning by setting the policy state to ``OLD``.  Alternatively one "
"may fix the project to work with the new behavior and set the policy state"
" to ``NEW``."
msgstr ""
"告诉 CMake "
"对给定策略使用“旧”或“新”行为。依赖于给定策略的旧行为的项目可能会通过将策略状态设置为“旧”来消除策略警告。或者，可以修复项目以使用新行为并将策略状态设置为“NEW”。"

#: ../../cmake-prefix/src/cmake/Help/policy/DEPRECATED.txt:2
msgid ""
"The ``OLD`` behavior of a policy is :manual:`deprecated by definition "
"<cmake-policies(7)>` and may be removed in a future version of CMake."
msgstr "策略的“旧”行为是 :manual:根据定义 <cmake-policies(7)> 已弃用，并且可能会在未来版本的 CMake 中删除。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:72
msgid "Checking Policy Settings"
msgstr "检查策略设置"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:78
msgid ""
"Check whether a given policy is set to ``OLD`` or ``NEW`` behavior. The "
"output ``<variable>`` value will be ``OLD`` or ``NEW`` if the policy is "
"set, and empty otherwise."
msgstr "检查给定的策略是否设置为“旧”或“新”行为。如果设置了策略，则输出“<variable>”值将为“OLD”或“NEW”，否则为空。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:83
msgid "CMake Policy Stack"
msgstr "CMake 策略堆栈"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:85
msgid ""
"CMake keeps policy settings on a stack, so changes made by the "
"``cmake_policy`` command affect only the top of the stack.  A new entry on"
" the policy stack is managed automatically for each subdirectory to "
"protect its parents and siblings.  CMake also manages a new entry for "
"scripts loaded by :command:`include` and :command:`find_package` commands "
"except when invoked with the ``NO_POLICY_SCOPE`` option (see also policy "
":policy:`CMP0011`). The ``cmake_policy`` command provides an interface to "
"manage custom entries on the policy stack:"
msgstr ""
"CMake "
"将策略设置保存在堆栈中，因此“cmake_policy”命令所做的更改只会影响堆栈的顶部。为每个子目录自动管理策略堆栈上的新条目，以保护其父目录和同级目录。"
" CMake 还为由 :command:`include` 和 :command:`find_package` "
"命令加载的脚本管理一个新条目，除非使用 ``NO_POLICY_SCOPE`` 选项调用（另请参阅策略 :policy:`CMP0011`）。 "
"``cmake_policy`` 命令提供了一个接口来管理策略堆栈上的自定义条目："

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:100
msgid ""
"Each ``PUSH`` must have a matching ``POP`` to erase any changes. This is "
"useful to make temporary changes to policy settings. Calls to the "
":command:`cmake_minimum_required(VERSION)`, ``cmake_policy(VERSION)``, or "
"``cmake_policy(SET)`` commands influence only the current top of the "
"policy stack."
msgstr ""
"每个 ``PUSH`` 必须有一个匹配的 ``POP`` 来擦除任何更改。这对于对策略设置进行临时更改很有用。调用 "
":command:`cmake_minimum_required(VERSION)`、``cmake_policy(VERSION)`` 或 "
"``cmake_policy(SET)`` 命令只会影响当前策略堆栈的顶部。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:106
msgid ""
"The :command:`block` and :command:`endblock` commands offer a more "
"flexible and more secure way to manage the policy stack. The pop action is"
" done automatically when the :command:`endblock` command is executed, so "
"it avoid to call the :command:`cmake_policy(POP)` command before each "
":command:`return` command."
msgstr ""
":command:`block` 和 :command:`endblock` 命令提供了一种更灵活、更安全的方式来管理策略堆栈。 pop "
"操作是在执行 :command:`endblock` 命令时自动完成的，因此它避免在每个 :command:`return` 命令之前调用 "
":command:`cmake_policy(POP)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:147
msgid ""
"Commands created by the :command:`function` and :command:`macro` commands "
"record policy settings when they are created and use the pre-record "
"policies when they are invoked.  If the function or macro implementation "
"sets policies, the changes automatically propagate up through callers "
"until they reach the closest nested policy stack entry."
msgstr ""
":command:`function` 和 :command:`macro` "
"命令创建的命令在创建时记录策略设置，并在调用时使用预记录策略。如果函数或宏实现设置了策略，更改会自动向上传播到调用者，直到它们到达最近的嵌套策略堆栈条目。"

#: ../../cmake-prefix/src/cmake/Help/command/cmake_policy.rst:157
msgid ":command:`cmake_minimum_required`"
msgstr ":command:`cmake_minimum_required`"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:2
msgid "configure_file"
msgstr "配置文件"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:4
msgid "Copy a file to another location and modify its contents."
msgstr "将文件复制到另一个位置并修改其内容。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:14
msgid ""
"Copies an ``<input>`` file to an ``<output>`` file and substitutes "
"variable values referenced as ``@VAR@`` or ``${VAR}`` in the input file "
"content.  Each variable reference will be replaced with the current value "
"of the variable, or the empty string if the variable is not defined.  "
"Furthermore, input lines of the form"
msgstr ""
"将 ``<input>`` 文件复制到 ``<output>`` 文件，并在输入文件内容中替换引用为 ``@VAR@`` 或 ``${VAR}`` "
"的变量值。每个变量引用都将替换为变量的当前值，如果未定义变量，则替换为空字符串。此外，表格的输入行"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:24
#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:48
msgid "will be replaced with either"
msgstr "将被替换为"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:30
#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:54
msgid "or"
msgstr "或者"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:36
msgid ""
"depending on whether ``VAR`` is set in CMake to any value not considered a"
" false constant by the :command:`if` command.  The \"...\" content on the "
"line after the variable name, if any, is processed as above."
msgstr ""
"取决于是否在 CMake 中将 ``VAR`` 设置为任何不被 :command:`if` "
"命令视为错误常量的值。变量名后一行的“...”内容，如果有的话，同上处理。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:40
msgid ""
"Unlike lines of the form ``#cmakedefine VAR ...``, in lines of the form "
"``#cmakedefine01 VAR``, ``VAR`` itself will expand to ``VAR 0`` or ``VAR "
"1`` rather than being assigned the value ``...``. Therefore, input lines "
"of the form"
msgstr ""
"与``#cmakedefine VAR ...`` 形式的行不同，在``#cmakedefine01 VAR`` 形式的行中，``VAR`` "
"本身将扩展为``VAR 0`` 或``VAR 1` ` 而不是分配值 `...``。因此，表格的输入行"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:60
msgid ""
"Input lines of the form ``#cmakedefine01 VAR ...`` will expand as "
"``#cmakedefine01 VAR ... 0`` or ``#cmakedefine01 VAR ... 1``, which may "
"lead to undefined behavior."
msgstr ""
"``#cmakedefine01 VAR ...`` 形式的输入行将扩展为``#cmakedefine01 VAR ... 0`` "
"或``#cmakedefine01 VAR ... 1``，这可能会导致未定义的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:64
msgid ""
"The result lines (with the exception of the ``#undef`` comments) can be "
"indented using spaces and/or tabs between the ``#`` character and the "
"``cmakedefine`` or ``cmakedefine01`` words. This whitespace indentation "
"will be preserved in the output lines:"
msgstr ""
"结果行（“#undef”注释除外）可以在“#”字符和“cmakedefine”或“cmakedefine01”单词之间使用空格和/或制表符缩进。此空白缩进将保留在输出行中："

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:75
msgid "will be replaced, if ``VAR`` is defined, with"
msgstr "如果定义了``VAR``，将被替换为"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:82
msgid ""
"If the input file is modified the build system will re-run CMake to re-"
"configure the file and generate the build system again. The generated file"
" is modified and its timestamp updated on subsequent cmake runs only if "
"its content is changed."
msgstr ""
"如果修改了输入文件，构建系统将重新运行 CMake 以重新配置文件并再次生成构建系统。仅当其内容发生更改时，才会修改生成的文件，并在随后的 "
"cmake 运行中更新其时间戳。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:87
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:602
msgid "The arguments are:"
msgstr "论点是："

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:90
msgid ""
"Path to the input file.  A relative path is treated with respect to the "
"value of :variable:`CMAKE_CURRENT_SOURCE_DIR`.  The input path must be a "
"file, not a directory."
msgstr "输入文件的路径。相对路径根据 CMAKE_CURRENT_SOURCE_DIR 的值进行处理。输入路径必须是文件，而不是目录。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:99
msgid "``<output>``"
msgstr "``<输出>``"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:95
msgid ""
"Path to the output file or directory.  A relative path is treated with "
"respect to the value of :variable:`CMAKE_CURRENT_BINARY_DIR`. If the path "
"names an existing directory the output file is placed in that directory "
"with the same file name as the input file. If the path contains non-"
"existent directories, they are created."
msgstr ""
"输出文件或目录的路径。相对路径根据 CMAKE_CURRENT_BINARY_DIR "
"的值进行处理。如果路径命名为现有目录，则输出文件将放置在该目录中，文件名与输入文件相同。如果路径包含不存在的目录，则会创建它们。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:106
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:551
msgid "``NO_SOURCE_PERMISSIONS``"
msgstr "``NO_SOURCE_PERMISSIONS``"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:104
msgid ""
"Do not transfer the permissions of the input file to the output file. The "
"copied file permissions default to the standard 644 value (-rw-r--r--)."
msgstr "不要将输入文件的权限转移到输出文件。复制的文件权限默认为标准 644 值 (-rw-r--r--)。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:115
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:561
msgid "``USE_SOURCE_PERMISSIONS``"
msgstr "``USE_SOURCE_PERMISSIONS``"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:111
msgid ""
"Transfer the permissions of the input file to the output file. This is "
"already the default behavior if none of the three permissions-related "
"keywords are given (``NO_SOURCE_PERMISSIONS``, ``USE_SOURCE_PERMISSIONS`` "
"or ``FILE_PERMISSIONS``).  The ``USE_SOURCE_PERMISSIONS`` keyword mostly "
"serves as a way of making the intended behavior clearer at the call site."
msgstr ""
"将输入文件的权限转移到输出文件。如果没有给出三个与权限相关的关键字（``NO_SOURCE_PERMISSIONS``、``USE_SOURCE_PERMISSIONS``"
" 或``FILE_PERMISSIONS``），这已经是默认行为。 ``USE_SOURCE_PERMISSIONS`` "
"关键字主要用作在调用站点使预期行为更清晰的一种方式。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:121
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:566
msgid "``FILE_PERMISSIONS <permissions>...``"
msgstr "``FILE_PERMISSIONS <权限>...``"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:120
msgid ""
"Ignore the input file's permissions and use the specified "
"``<permissions>`` for the output file instead."
msgstr "忽略输入文件的权限并使用指定的 ``<permissions>`` 代替输出文件。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:125
msgid "``COPYONLY``"
msgstr "``只复制``"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:124
msgid ""
"Copy the file without replacing any variable references or other content."
"  This option may not be used with ``NEWLINE_STYLE``."
msgstr "复制文件而不替换任何变量引用或其他内容。此选项不能与 ``NEWLINE_STYLE`` 一起使用。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:128
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:614
msgid "``ESCAPE_QUOTES``"
msgstr "``ESCAPE_QUOTES``"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:128
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:614
msgid "Escape any substituted quotes with backslashes (C-style)."
msgstr "使用反斜杠（C 风格）转义任何替换的引号。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:132
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:618
msgid "``@ONLY``"
msgstr "``@只有``"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:131
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:617
msgid ""
"Restrict variable replacement to references of the form ``@VAR@``. This is"
" useful for configuring scripts that use ``${VAR}`` syntax."
msgstr "将变量替换限制为“@VAR@”形式的引用。这对于配置使用 ``${VAR}`` 语法的脚本很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:138
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:573
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:623
msgid "``NEWLINE_STYLE <style>``"
msgstr "``NEWLINE_STYLE <样式>``"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:135
msgid ""
"Specify the newline style for the output file.  Specify ``UNIX`` or ``LF``"
" for ``\\n`` newlines, or specify ``DOS``, ``WIN32``, or ``CRLF`` for "
"``\\r\\n`` newlines. This option may not be used with ``COPYONLY``."
msgstr ""
"指定输出文件的换行样式。为 `\\n`` 换行符指定 ``UNIX`` 或 ``LF``，或者为 ``\\r\\n`` 指定 "
"``DOS``、``WIN32`` 或 ``CRLF``换行符。此选项不能与 ``COPYONLY`` 一起使用。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:143
msgid "Consider a source tree containing a ``foo.h.in`` file:"
msgstr "考虑一个包含“foo.h.in”文件的源代码树："

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:150
msgid ""
"An adjacent ``CMakeLists.txt`` may use ``configure_file`` to configure the"
" header:"
msgstr "相邻的 ``CMakeLists.txt`` 可以使用 ``configure_file`` 来配置标头："

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:161
msgid ""
"This creates a ``foo.h`` in the build directory corresponding to this "
"source directory.  If the ``FOO_ENABLE`` option is on, the configured file"
" will contain:"
msgstr "这会在与此源目录对应的构建目录中创建一个“foo.h”。如果“FOO_ENABLE”选项打开，配置文件将包含："

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:170
msgid "Otherwise it will contain:"
msgstr "否则它将包含："

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:177
msgid ""
"One may then use the :command:`target_include_directories` command to "
"specify the output directory as an include directory:"
msgstr "然后可以使用 :command:`target_include_directories` 命令将输出目录指定为包含目录："

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:184
msgid "so that sources may include the header as ``#include <foo.h>``."
msgstr "这样源代码就可以将标题包含为``#include <foo.h>``。"

#: ../../cmake-prefix/src/cmake/Help/command/configure_file.rst:189
msgid ":command:`file(GENERATE)`"
msgstr ":command:`文件（生成）`"

#: ../../cmake-prefix/src/cmake/Help/command/continue.rst:2
msgid "continue"
msgstr "继续"

#: ../../cmake-prefix/src/cmake/Help/command/continue.rst:6
msgid "Continue to the top of enclosing foreach or while loop."
msgstr "继续到封闭 foreach 或 while 循环的顶部。"

#: ../../cmake-prefix/src/cmake/Help/command/continue.rst:12
msgid ""
"The ``continue()`` command allows a cmake script to abort the rest of the "
"current iteration of a :command:`foreach` or :command:`while` loop, and "
"start at the top of the next iteration."
msgstr ""
"``continue()`` 命令允许 cmake 脚本中止 :command:`foreach` 或 :command:`while` "
"循环的当前迭代的其余部分，并从下一次迭代的顶部开始。"

#: ../../cmake-prefix/src/cmake/Help/command/continue.rst:16
msgid "See also the :command:`break` command."
msgstr "另请参阅 :command:`break` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/create_test_sourcelist.rst:2
msgid "create_test_sourcelist"
msgstr "创建测试源列表"

#: ../../cmake-prefix/src/cmake/Help/command/create_test_sourcelist.rst:4
msgid "Create a test driver and source list for building test programs."
msgstr "创建用于构建测试程序的测试驱动程序和源列表。"

#: ../../cmake-prefix/src/cmake/Help/command/create_test_sourcelist.rst:13
msgid ""
"A test driver is a program that links together many small tests into a "
"single executable.  This is useful when building static executables with "
"large libraries to shrink the total required size.  The list of source "
"files needed to build the test driver will be in ``sourceListName``.  "
"``driverName`` is the name of the test driver program. The rest of the "
"arguments consist of a list of test source files, can be semicolon "
"separated.  Each test source file should have a function in it that is the"
" same name as the file with no extension (foo.cxx should have int foo(int,"
" char*[]);) ``driverName`` will be able to call each of the tests by name "
"on the command line.  If ``EXTRA_INCLUDE`` is specified, then the next "
"argument is included into the generated file. If ``FUNCTION`` is "
"specified, then the next argument is taken as a function name that is "
"passed a pointer to ac and av.  This can be used to add extra command line"
" processing to each test.  The ``CMAKE_TESTDRIVER_BEFORE_TESTMAIN`` cmake "
"variable can be set to have code that will be placed directly before "
"calling the test main function. ``CMAKE_TESTDRIVER_AFTER_TESTMAIN`` can be"
" set to have code that will be placed directly after the call to the test "
"main function."
msgstr ""
"测试驱动程序是将许多小测试链接在一起成为单个可执行文件的程序。这在使用大型库构建静态可执行文件以缩小所需的总大小时很有用。构建测试驱动程序所需的源文件列表将在“sourceListName”中。"
" ``driverName`` "
"是测试驱动程序的名称。其余参数由测试源文件列表组成，可以用分号分隔。每个测试源文件都应该有一个函数，它与没有扩展名的文件同名（foo.cxx 应该有"
" int foo(int, char*[]);）``driverName`` 将能够调用每个在命令行上按名称进行测试。如果指定了 "
"EXTRA_INCLUDE，那么下一个参数将包含在生成的文件中。如果指定了 ``FUNCTION``，那么下一个参数将作为函数名称传递给 ac 和 "
"av 的指针。这可用于为每个测试添加额外的命令行处理。 ``CMAKE_TESTDRIVER_BEFORE_TESTMAIN`` cmake "
"变量可以设置为在调用测试主函数之前直接放置代码。 ``CMAKE_TESTDRIVER_AFTER_TESTMAIN`` "
"可以设置为在调用测试主函数之后直接放置代码。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:2
msgid "ctest_build"
msgstr "ctest_build"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:4
msgid "Perform the :ref:`CTest Build Step` as a :ref:`Dashboard Client`."
msgstr "作为 :ref:`Dashboard Client` 执行 :ref:`CTest Build Step`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:20
msgid ""
"Build the project and store results in ``Build.xml`` for submission with "
"the :command:`ctest_submit` command."
msgstr "构建项目并将结果存储在 ``Build.xml`` 中，以便使用 :command:`ctest_submit` 命令提交。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:23
msgid ""
"The :variable:`CTEST_BUILD_COMMAND` variable may be set to explicitly "
"specify the build command line.  Otherwise the build command line is "
"computed automatically based on the options given."
msgstr ""
":variable:`CTEST_BUILD_COMMAND` 变量可以设置为明确指定构建命令行。否则，将根据给定的选项自动计算构建命令行。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:31
#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:19
#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:22
#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:43
msgid "``BUILD <build-dir>``"
msgstr "``构建<构建目录>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:30
#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:18
#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:21
#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:42
msgid ""
"Specify the top-level build directory.  If not given, the "
":variable:`CTEST_BINARY_DIRECTORY` variable is used."
msgstr "指定顶级构建目录。如果未给出，则使用 CTEST_BINARY_DIRECTORY 变量。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:34
msgid ""
"Mark ``Build.xml`` for append to results previously submitted to a "
"dashboard server since the last :command:`ctest_start` call. Append "
"semantics are defined by the dashboard server in use. This does *not* "
"cause results to be appended to a ``.xml`` file produced by a previous "
"call to this command."
msgstr ""
"标记 ``Build.xml`` 以追加到自上次 ctest_start 调用以来提交到仪表板服务器的结果。追加语义由正在使用的仪表板服务器定义。这"
" *不会* 导致将结果附加到先前调用此命令生成的 ``.xml`` 文件中。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:44
msgid "``CONFIGURATION <config>``"
msgstr "``配置<配置>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:41
msgid ""
"Specify the build configuration (e.g. ``Debug``).  If not specified the "
"``CTEST_BUILD_CONFIGURATION`` variable will be checked. Otherwise the "
":option:`-C \\<cfg\\> <ctest -C>` option given to the :manual:`ctest(1)` "
"command will be used, if any."
msgstr ""
"指定构建配置（例如``Debug``）。如果未指定，将检查“CTEST_BUILD_CONFIGURATION”变量。否则，将使用提供给 "
":manual:`ctest(1)` 命令的 :option:`-C \\<cfg\\> <ctest -C>` 选项（如果有的话）。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:51
msgid "``PARALLEL_LEVEL <parallel>``"
msgstr "``PARALLEL_LEVEL <平行>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:49
msgid ""
"Specify the parallel level of the underlying build system.  If not "
"specified, the :envvar:`CMAKE_BUILD_PARALLEL_LEVEL` environment variable "
"will be checked."
msgstr "指定底层构建系统的并行级别。如果未指定，将检查 :envvar:`CMAKE_BUILD_PARALLEL_LEVEL` 环境变量。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:58
msgid "``FLAGS <flags>``"
msgstr "``FLAGS <标志>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:54
msgid ""
"Pass additional arguments to the underlying build command. If not "
"specified the ``CTEST_BUILD_FLAGS`` variable will be checked. This can, "
"e.g., be used to trigger a parallel build using the ``-j`` option of "
"``make``. See the :module:`ProcessorCount` module for an example."
msgstr ""
"将附加参数传递给基础构建命令。如果未指定，将检查“CTEST_BUILD_FLAGS”变量。例如，这可以用于使用 ``make`` 的 ``-j``"
" 选项触发并行构建。有关示例，请参见 :module:`ProcessorCount` 模块。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:64
msgid "``PROJECT_NAME <project-name>``"
msgstr "``PROJECT_NAME <项目名称>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:61
msgid "Ignored since CMake 3.0."
msgstr "自 CMake 3.0 以来被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:63
msgid "This value is no longer required."
msgstr "不再需要此值。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:70
msgid "``TARGET <target-name>``"
msgstr "``TARGET <目标名称>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:67
msgid ""
"Specify the name of a target to build.  If not specified the "
"``CTEST_BUILD_TARGET`` variable will be checked.  Otherwise the default "
"target will be built.  This is the \"all\" target (called ``ALL_BUILD`` in"
" :ref:`Visual Studio Generators`)."
msgstr ""
"指定要构建的目标的名称。如果未指定，将检查“CTEST_BUILD_TARGET”变量。否则将构建默认目标。这是“所有”目标（在 Visual "
"Studio Generators 中称为 ALL_BUILD）。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:73
msgid "``NUMBER_ERRORS <num-err-var>``"
msgstr "``NUMBER_ERRORS <num-err-var>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:73
msgid "Store the number of build errors detected in the given variable."
msgstr "存储在给定变量中检测到的构建错误数。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:76
msgid "``NUMBER_WARNINGS <num-warn-var>``"
msgstr "``NUMBER_WARNINGS <num-warn-var>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:76
msgid "Store the number of build warnings detected in the given variable."
msgstr "存储在给定变量中检测到的构建警告数。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:79
#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:37
#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:37
#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:80
#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:151
#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:24
msgid "``RETURN_VALUE <result-var>``"
msgstr "``RETURN_VALUE <result-var>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:79
msgid ""
"Store the return value of the native build tool in the given variable."
msgstr "将本机构建工具的返回值存储在给定变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:85
#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:43
#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:43
#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:86
#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:157
#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:30
#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:25
msgid "``CAPTURE_CMAKE_ERROR <result-var>``"
msgstr "``CAPTURE_CMAKE_ERROR <result-var>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:84
#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:42
#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:42
#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:85
#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:156
#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:29
#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:25
msgid ""
"Store in the ``<result-var>`` variable -1 if there are any errors running "
"the command and prevent ctest from returning non-zero if an error occurs."
msgstr "如果运行命令有任何错误，则将 -1 存储在“<result-var>”变量中，并防止 ctest 在发生错误时返回非零值。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:92
#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:49
#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:49
#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:65
#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:92
#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:174
#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:38
#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:20
msgid "``QUIET``"
msgstr "``安静``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_build.rst:90
msgid ""
"Suppress any CTest-specific non-error output that would have been printed "
"to the console otherwise.  The summary of warnings / errors, as well as "
"the output from the native build tool is unaffected by this option."
msgstr "抑制任何本应打印到控制台的特定于 CTest 的非错误输出。警告/错误的摘要以及本机构建工具的输出不受此选项的影响。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:2
msgid "ctest_configure"
msgstr "ctest_configure"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:4
msgid ""
"Perform the :ref:`CTest Configure Step` as a :ref:`Dashboard Client`."
msgstr "执行 :ref:`CTest Configure Step` 作为 :ref:`Dashboard Client`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:12
msgid ""
"Configure the project build tree and record results in ``Configure.xml`` "
"for submission with the :command:`ctest_submit` command."
msgstr ""
"配置项目构建树并将结果记录在 ``Configure.xml`` 中，以便使用 :command:`ctest_submit` 命令提交。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:23
#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:20
msgid "``SOURCE <source-dir>``"
msgstr "``源<源目录>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:22
#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:19
msgid ""
"Specify the source directory.  If not given, the "
":variable:`CTEST_SOURCE_DIRECTORY` variable is used."
msgstr "指定源目录。如果未给出，则使用 CTEST_SOURCE_DIRECTORY 变量。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:26
msgid ""
"Mark ``Configure.xml`` for append to results previously submitted to a "
"dashboard server since the last :command:`ctest_start` call. Append "
"semantics are defined by the dashboard server in use. This does *not* "
"cause results to be appended to a ``.xml`` file produced by a previous "
"call to this command."
msgstr ""
"标记 ``Configure.xml`` 以追加到自上次 ctest_start "
"调用以来提交到仪表板服务器的结果。追加语义由正在使用的仪表板服务器定义。这 *不会* 导致将结果附加到先前调用此命令生成的 ``.xml`` "
"文件中。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:33
msgid "``OPTIONS <options>``"
msgstr "``选项<选项>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:33
msgid "Specify command-line arguments to pass to the configuration tool."
msgstr "指定要传递给配置工具的命令行参数。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:36
msgid ""
"Store in the ``<result-var>`` variable the return value of the native "
"configuration tool."
msgstr "在 ``<result-var>`` 变量中存储本机配置工具的返回值。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_configure.rst:48
msgid ""
"Suppress any CTest-specific non-error messages that would have otherwise "
"been printed to the console.  Output from the underlying configure command"
" is not affected."
msgstr "抑制任何本应打印到控制台的特定于 CTest 的非错误消息。底层配置命令的输出不受影响。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:2
msgid "ctest_coverage"
msgstr "ctest_coverage"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:4
msgid "Perform the :ref:`CTest Coverage Step` as a :ref:`Dashboard Client`."
msgstr "作为 :ref:`Dashboard Client` 执行 :ref:`CTest Coverage Step`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:15
msgid ""
"Collect coverage tool results and stores them in ``Coverage.xml`` for "
"submission with the :command:`ctest_submit` command."
msgstr "收集覆盖率工具结果并将它们存储在“Coverage.xml”中，以便使用 :command:“ctest_submit”命令提交。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:25
msgid ""
"Mark ``Coverage.xml`` for append to results previously submitted to a "
"dashboard server since the last :command:`ctest_start` call. Append "
"semantics are defined by the dashboard server in use. This does *not* "
"cause results to be appended to a ``.xml`` file produced by a previous "
"call to this command."
msgstr ""
"标记 ``Coverage.xml`` 以追加到自上次 ctest_start "
"调用以来提交到仪表板服务器的结果。追加语义由正在使用的仪表板服务器定义。这 *不会* 导致将结果附加到先前调用此命令生成的 ``.xml`` "
"文件中。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:33
msgid "``LABELS``"
msgstr "``标签``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:32
msgid ""
"Filter the coverage report to include only source files labeled with at "
"least one of the labels specified."
msgstr "过滤覆盖率报告以仅包括标有至少一个指定标签的源文件。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:36
msgid ""
"Store in the ``<result-var>`` variable ``0`` if coverage tools ran without"
" error and non-zero otherwise."
msgstr "如果覆盖工具运行没有错误，则存储在 ``<result-var>`` 变量 ``0`` 中，否则为非零。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_coverage.rst:48
msgid ""
"Suppress any CTest-specific non-error output that would have been printed "
"to the console otherwise.  The summary indicating how many lines of code "
"were covered is unaffected by this option."
msgstr "抑制任何本应打印到控制台的特定于 CTest 的非错误输出。指示涵盖了多少行代码的摘要不受此选项的影响。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_empty_binary_directory.rst:2
msgid "ctest_empty_binary_directory"
msgstr "ctest_empty_binary_directory"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_empty_binary_directory.rst:4
msgid "empties the binary directory"
msgstr "清空二进制目录"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_empty_binary_directory.rst:10
msgid ""
"Removes a binary directory.  This command will perform some checks prior "
"to deleting the directory in an attempt to avoid malicious or accidental "
"directory deletion."
msgstr "删除二进制目录。此命令将在删除目录之前执行一些检查，以避免恶意或意外删除目录。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_memcheck.rst:2
msgid "ctest_memcheck"
msgstr "ctest_memcheck"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_memcheck.rst:4
msgid "Perform the :ref:`CTest MemCheck Step` as a :ref:`Dashboard Client`."
msgstr "作为 :ref:`Dashboard Client` 执行 :ref:`CTest MemCheck Step`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_memcheck.rst:34
msgid ""
"Run tests with a dynamic analysis tool and store results in "
"``MemCheck.xml`` for submission with the :command:`ctest_submit` command."
msgstr ""
"使用动态分析工具运行测试并将结果存储在``MemCheck.xml`` 中，以便使用 :command:`ctest_submit` 命令提交。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_memcheck.rst:38
msgid ""
"Most options are the same as those for the :command:`ctest_test` command."
msgstr "大多数选项与 :command:`ctest_test` 命令的选项相同。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_memcheck.rst:40
msgid "The options unique to this command are:"
msgstr "此命令独有的选项是："

#: ../../cmake-prefix/src/cmake/Help/command/ctest_memcheck.rst:44
msgid "``DEFECT_COUNT <defect-count-var>``"
msgstr "``DEFECT_COUNT <缺陷计数变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_memcheck.rst:45
msgid "Store in the ``<defect-count-var>`` the number of defects found."
msgstr "将发现的缺陷数存储在 ``<defect-count-var>`` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_read_custom_files.rst:2
msgid "ctest_read_custom_files"
msgstr "ctest_read_custom_files"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_read_custom_files.rst:4
msgid "read CTestCustom files."
msgstr "读取 CTestCustom 文件。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_read_custom_files.rst:10
msgid ""
"Read all the CTestCustom.ctest or CTestCustom.cmake files from the given "
"directory."
msgstr "从给定目录读取所有 CTestCustom.ctest 或 CTestCustom.cmake 文件。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_read_custom_files.rst:13
msgid ""
"By default, invoking :manual:`ctest(1)` without a script will read custom "
"files from the binary directory."
msgstr "默认情况下，不使用脚本调用 ctest(1) 将从二进制目录中读取自定义文件。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_run_script.rst:2
msgid "ctest_run_script"
msgstr "ctest_run_script"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_run_script.rst:4
msgid "runs a :option:`ctest -S` script"
msgstr "运行 :option:`ctest -S` 脚本"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_run_script.rst:11
msgid ""
"Runs a script or scripts much like if it was run from :option:`ctest -S`. "
"If no argument is provided then the current script is run using the "
"current settings of the variables.  If ``NEW_PROCESS`` is specified then "
"each script will be run in a separate process.If ``RETURN_VALUE`` is "
"specified the return value of the last script run will be put into "
"``var``."
msgstr ""
"运行一个或多个脚本，就像从 :option:`ctest -S` "
"运行一样。如果未提供参数，则使用变量的当前设置运行当前脚本。如果指定了“NEW_PROCESS”，那么每个脚本将在一个单独的进程中运行。如果指定了“RETURN_VALUE”，最后一个脚本运行的返回值将被放入“var”中。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_sleep.rst:2
msgid "ctest_sleep"
msgstr "ctest_sleep"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_sleep.rst:4
msgid "sleeps for some amount of time"
msgstr "睡了一段时间"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_sleep.rst:10
msgid "Sleep for given number of seconds."
msgstr "睡眠给定的秒数。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_sleep.rst:16
msgid "Sleep for t=(time1 + duration - time2) seconds if t > 0."
msgstr "如果 t > 0，则休眠 t=(time1 + duration - time2) 秒。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:2
msgid "ctest_start"
msgstr "ctest_start"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:4
msgid "Starts the testing for a given model"
msgstr "开始测试给定模型"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:12
msgid ""
"Starts the testing for a given model.  The command should be called after "
"the binary directory is initialized."
msgstr "开始测试给定模型。该命令应在二进制目录初始化后调用。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:15
msgid "The parameters are as follows:"
msgstr "参数如下："

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:19
msgid "``<model>``"
msgstr "``<模型>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:18
msgid ""
"Set the dashboard model. Must be one of ``Experimental``, ``Continuous``, "
"or ``Nightly``. This parameter is required unless ``APPEND`` is specified."
msgstr ""
"设置仪表板模型。必须是“Experimental”、“Continuous”或“Nightly”之一。除非指定 APPEND ，否则此参数是必需的。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:23
msgid "``<source>``"
msgstr "``<来源>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:22
msgid ""
"Set the source directory. If not specified, the value of "
":variable:`CTEST_SOURCE_DIRECTORY` is used instead."
msgstr "设置源目录。如果未指定，则使用 CTEST_SOURCE_DIRECTORY 的值代替。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:27
msgid "``<binary>``"
msgstr "``<二进制>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:26
msgid ""
"Set the binary directory. If not specified, the value of "
":variable:`CTEST_BINARY_DIRECTORY` is used instead."
msgstr "设置二进制目录。如果未指定，则使用 CTEST_BINARY_DIRECTORY 的值代替。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:36
msgid "``GROUP <group>``"
msgstr "``组<组>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:30
msgid ""
"If ``GROUP`` is used, the submissions will go to the specified group on "
"the CDash server. If no ``GROUP`` is specified, the name of the model is "
"used by default."
msgstr "如果使用“GROUP”，提交将转到 CDash 服务器上的指定组。如果未指定“GROUP”，则默认使用模型名称。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:34
msgid ""
"This replaces the deprecated option ``TRACK``. Despite the name change its"
" behavior is unchanged."
msgstr "这取代了弃用的选项 ``TRACK``。尽管名称改变了，但它的行为没有改变。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:39
msgid ""
"If ``APPEND`` is used, the existing ``TAG`` is used rather than creating a"
" new one based on the current time stamp. If you use ``APPEND``, you can "
"omit the ``<model>`` and ``GROUP <group>`` parameters, because they will "
"be read from the generated ``TAG`` file. For example:"
msgstr ""
"如果使用 APPEND，则使用现有的 TAG，而不是根据当前时间戳创建新的 TAG。如果你使用 ``APPEND``，你可以省略 "
"``<model>`` 和 ``GROUP <group>`` 参数，因为它们将从生成的 ``TAG`` 文件中读取。例如："

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:48
msgid "Later, in another :option:`ctest -S` script:"
msgstr "稍后，在另一个 :option:`ctest -S` 脚本中："

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:54
msgid ""
"When the second script runs ``ctest_start(APPEND)``, it will read the "
"``Experimental`` model and ``GroupExperimental`` group from the ``TAG`` "
"file generated by the first ``ctest_start()`` command. Please note that if"
" you call ``ctest_start(APPEND)`` and specify a different model or group "
"than in the first ``ctest_start()`` command, a warning will be issued, and"
" the new model and group will be used."
msgstr ""
"当第二个脚本运行 ``ctest_start(APPEND)`` 时，它将从第一个 ``ctest_start()`` 生成的 ``TAG`` "
"文件中读取 ``Experimental`` 模型和 ``GroupExperimental`` 组命令。请注意，如果您调用 "
"``ctest_start(APPEND)`` 并指定与第一个 ``ctest_start()`` "
"命令不同的模型或组，将发出警告，并使用新模型和组。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:64
msgid ""
"If ``QUIET`` is used, CTest will suppress any non-error messages that it "
"otherwise would have printed to the console."
msgstr "如果使用“QUIET”，CTest 将抑制任何非错误消息，否则它会打印到控制台。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:67
msgid ""
"The parameters for ``ctest_start()`` can be issued in any order, with the "
"exception that ``<model>``, ``<source>``, and ``<binary>`` have to appear "
"in that order with respect to each other. The following are all valid and "
"equivalent:"
msgstr ""
"``ctest_start()`` 的参数可以按任何顺序发出，除了``<model>``、``<source>`` 和``<binary>`` "
"必须出现在那个顺序中相对于彼此的顺序。以下都是有效且等效的："

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:80
msgid ""
"However, for the sake of readability, it is recommended that you order "
"your parameters in the order listed at the top of this page."
msgstr "但是，为了便于阅读，建议您按照本页顶部列出的顺序对参数进行排序。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_start.rst:83
msgid ""
"If the :variable:`CTEST_CHECKOUT_COMMAND` variable (or the "
":variable:`CTEST_CVS_CHECKOUT` variable) is set, its content is treated as"
" command-line.  The command is invoked with the current working directory "
"set to the parent of the source directory, even if the source directory "
"already exists.  This can be used to create the source tree from a version"
" control repository."
msgstr ""
"如果设置了 CTEST_CHECKOUT_COMMAND 变量（或 CTEST_CVS_CHECKOUT "
"变量），则其内容被视为命令行。调用命令时将当前工作目录设置为源目录的父目录，即使源目录已经存在。这可用于从版本控制存储库创建源代码树。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:2
msgid "ctest_submit"
msgstr "ctest_提交"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:4
msgid "Perform the :ref:`CTest Submit Step` as a :ref:`Dashboard Client`."
msgstr "作为 :ref:`Dashboard Client` 执行 :ref:`CTest 提交步骤`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:19
msgid ""
"Submit results to a dashboard server. By default all available parts are "
"submitted."
msgstr "将结果提交到仪表板服务器。默认情况下提交所有可用的部分。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:39
msgid "``PARTS <part>...``"
msgstr "``部分 <部分>...``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:25
msgid "Specify a subset of parts to submit.  Valid part names are::"
msgstr "指定要提交的零件子集。有效的部件名称是："

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:43
#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:14
msgid "``FILES <file>...``"
msgstr "``文件 <文件>...``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:42
msgid ""
"Specify an explicit list of specific files to be submitted. Each "
"individual file must exist at the time of the call."
msgstr "指定要提交的特定文件的明确列表。每个单独的文件在调用时必须存在。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:49
msgid "``SUBMIT_URL <url>``"
msgstr "``SUBMIT_URL <url>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:48
msgid ""
"The ``http`` or ``https`` URL of the dashboard server to send the "
"submission to.  If not given, the :variable:`CTEST_SUBMIT_URL` variable is"
" used."
msgstr ""
"要将提交发送到的仪表板服务器的 ``http`` 或 ``https`` URL。如果未给出，则使用 CTEST_SUBMIT_URL 变量。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:55
msgid "``BUILD_ID <result-var>``"
msgstr "``BUILD_ID <result-var>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:54
msgid ""
"Store in the ``<result-var>`` variable the ID assigned to this build by "
"CDash."
msgstr "在 ``<result-var>`` 变量中存储由 CDash 分配给此构建的 ID。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:69
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1080
msgid "``HTTPHEADER <HTTP-header>``"
msgstr "``HTTPHEADER <HTTP 标头>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:60
msgid ""
"Specify HTTP header to be included in the request to CDash during "
"submission. For example, CDash can be configured to only accept "
"submissions from authenticated clients. In this case, you should provide a"
" bearer token in your header:"
msgstr ""
"在提交期间指定要包含在对 CDash 的请求中的 HTTP 标头。例如，CDash "
"可以配置为只接受来自经过身份验证的客户端的提交。在这种情况下，您应该在标头中提供不记名令牌："

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:69
msgid "This suboption can be repeated several times for multiple headers."
msgstr "对于多个标题，此子选项可以重复多次。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:72
msgid "``RETRY_COUNT <count>``"
msgstr "``RETRY_COUNT <计数>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:72
msgid "Specify how many times to retry a timed-out submission."
msgstr "指定重试超时提交的次数。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:76
msgid "``RETRY_DELAY <delay>``"
msgstr "``RETRY_DELAY <延迟>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:75
msgid ""
"Specify how long (in seconds) to wait after a timed-out submission before "
"attempting to re-submit."
msgstr "指定在超时提交后尝试重新提交之前等待的时间（以秒为单位）。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:79
msgid ""
"Store in the ``<result-var>`` variable ``0`` for success and non-zero on "
"failure."
msgstr "存储在 ``<result-var>`` 变量 ``0`` 表示成功，非零表示失败。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:91
msgid ""
"Suppress all non-error messages that would have otherwise been printed to "
"the console."
msgstr "抑制所有本应打印到控制台的非错误消息。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:95
msgid "Submit to CDash Upload API"
msgstr "提交到 CDash 上传 API"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:110
msgid ""
"This second signature is used to upload files to CDash via the CDash file "
"upload API. The API first sends a request to upload to CDash along with a "
"content hash of the file. If CDash does not already have the file, then it"
" is uploaded. Along with the file, a CDash type string is specified to "
"tell CDash which handler to use to process the data."
msgstr ""
"第二个签名用于通过 CDash 文件上传 API 将文件上传到 CDash。 API 首先发送上传到 CDash 的请求以及文件的内容哈希。如果 "
"CDash 还没有该文件，则将其上传。与该文件一起，指定了一个 CDash 类型字符串来告诉 CDash 使用哪个处理程序来处理数据。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:116
msgid "This signature interprets options in the same way as the first one."
msgstr "此签名以与第一个签名相同的方式解释选项。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:118
msgid "Added the ``RETRY_COUNT``, ``RETRY_DELAY``, ``QUIET`` options."
msgstr "添加了 ``RETRY_COUNT``、``RETRY_DELAY``、``QUIET`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:121
msgid "Added the ``HTTPHEADER`` option."
msgstr "添加了 ``HTTPHEADER`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:124
msgid "Added the ``RETURN_VALUE`` option."
msgstr "添加了 ``RETURN_VALUE`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:127
msgid "Added the ``SUBMIT_URL`` option."
msgstr "添加了 ``SUBMIT_URL`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_submit.rst:130
msgid "Added the ``BUILD_ID`` option."
msgstr "添加了 ``BUILD_ID`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:2
msgid "ctest_test"
msgstr "ctest_测试"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:4
msgid "Perform the :ref:`CTest Test Step` as a :ref:`Dashboard Client`."
msgstr "作为 :ref:`Dashboard Client` 执行 :ref:`CTest 测试步骤`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:36
msgid ""
"Run tests in the project build tree and store results in ``Test.xml`` for "
"submission with the :command:`ctest_submit` command."
msgstr ""
"在项目构建树中运行测试并将结果存储在 ``Test.xml`` 中，以便使用 :command:`ctest_submit` 命令提交。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:46
msgid ""
"Mark ``Test.xml`` for append to results previously submitted to a "
"dashboard server since the last :command:`ctest_start` call. Append "
"semantics are defined by the dashboard server in use. This does *not* "
"cause results to be appended to a ``.xml`` file produced by a previous "
"call to this command."
msgstr ""
"标记 ``Test.xml`` 以追加到自上次 ctest_start 调用以来提交到仪表板服务器的结果。追加语义由正在使用的仪表板服务器定义。这 "
"*不会* 导致将结果附加到先前调用此命令生成的 ``.xml`` 文件中。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:53
msgid "``START <start-number>``"
msgstr "``开始<起始编号>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:53
msgid "Specify the beginning of a range of test numbers."
msgstr "指定测试编号范围的开始。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:56
msgid "``END <end-number>``"
msgstr "``END <end-number>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:56
msgid "Specify the end of a range of test numbers."
msgstr "指定测试编号范围的结尾。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:59
msgid "``STRIDE <stride-number>``"
msgstr "``STRIDE <步幅>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:59
msgid "Specify the stride by which to step across a range of test numbers."
msgstr "指定跨越一系列测试数字的步幅。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:62
msgid "``EXCLUDE <exclude-regex>``"
msgstr "``排除 <exclude-regex>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:62
msgid "Specify a regular expression matching test names to exclude."
msgstr "指定要排除的正则表达式匹配测试名称。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:66
msgid "``INCLUDE <include-regex>``"
msgstr "``包括 <include-regex>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:65
msgid ""
"Specify a regular expression matching test names to include. Tests not "
"matching this expression are excluded."
msgstr "指定要包含的正则表达式匹配测试名称。不匹配此表达式的测试将被排除。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:69
msgid "``EXCLUDE_LABEL <label-exclude-regex>``"
msgstr "``EXCLUDE_LABEL <label-exclude-regex>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:69
msgid "Specify a regular expression matching test labels to exclude."
msgstr "指定要排除的正则表达式匹配测试标签。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:73
msgid "``INCLUDE_LABEL <label-include-regex>``"
msgstr "``INCLUDE_LABEL <label-include-regex>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:72
msgid ""
"Specify a regular expression matching test labels to include. Tests not "
"matching this expression are excluded."
msgstr "指定要包含的正则表达式匹配测试标签。不匹配此表达式的测试将被排除。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:83
msgid "``EXCLUDE_FIXTURE <regex>``"
msgstr "``EXCLUDE_FIXTURE <regex>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:78
msgid ""
"If a test in the set of tests to be executed requires a particular "
"fixture, that fixture's setup and cleanup tests would normally be added to"
" the test set automatically. This option prevents adding setup or cleanup "
"tests for fixtures matching the ``<regex>``. Note that all other fixture "
"behavior is retained, including test dependencies and skipping tests that "
"have fixture setup tests that fail."
msgstr ""
"如果要执行的测试集中的一个测试需要特定的夹具，则该夹具的设置和清理测试通常会自动添加到测试集中。此选项可防止为匹配 ``<regex>`` "
"的装置添加设置或清理测试。请注意，保留所有其他夹具行为，包括测试依赖项和跳过具有失败的夹具设置测试的测试。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:88
msgid "``EXCLUDE_FIXTURE_SETUP <regex>``"
msgstr "``EXCLUDE_FIXTURE_SETUP <regex>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:88
msgid ""
"Same as ``EXCLUDE_FIXTURE`` except only matching setup tests are excluded."
msgstr "与 EXCLUDE_FIXTURE 相同，除了只排除匹配的设置测试。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:93
msgid "``EXCLUDE_FIXTURE_CLEANUP <regex>``"
msgstr "``EXCLUDE_FIXTURE_CLEANUP <regex>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:93
msgid ""
"Same as ``EXCLUDE_FIXTURE`` except only matching cleanup tests are "
"excluded."
msgstr "与 EXCLUDE_FIXTURE 相同，除了只排除匹配的清理测试。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:97
msgid "``PARALLEL_LEVEL <level>``"
msgstr "``PARALLEL_LEVEL <level>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:96
msgid ""
"Specify a positive number representing the number of tests to be run in "
"parallel."
msgstr "指定一个正数，表示要并行运行的测试数。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:104
msgid "``RESOURCE_SPEC_FILE <file>``"
msgstr "``RESOURCE_SPEC_FILE <文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:102
msgid ""
"Specify a :ref:`resource specification file <ctest-resource-specification-"
"file>`. See :ref:`ctest-resource-allocation` for more information."
msgstr ""
"指定 :ref:`资源规范文件 <ctest-resource-specification-"
"file>`。有关详细信息，请参阅:ref:`ctest-resource-allocation`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:114
msgid "``TEST_LOAD <threshold>``"
msgstr "``TEST_LOAD <阈值>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:109
msgid ""
"While running tests in parallel, try not to start tests when they may "
"cause the CPU load to pass above a given threshold.  If not specified the "
":variable:`CTEST_TEST_LOAD` variable will be checked, and then the "
":option:`--test-load <ctest --test-load>` command-line argument to "
":manual:`ctest(1)`. See also the ``TestLoad`` setting in the :ref:`CTest "
"Test Step`."
msgstr ""
"并行运行测试时，尽量不要在可能导致 CPU 负载超过给定阈值时开始测试。如果未指定 :variable:`CTEST_TEST_LOAD` "
"变量将被检查，然后:option:`--test-load <ctest --test-load>` 命令行参数到:manual:`ctest(1)` "
".另请参阅 CTest 测试步骤中的 ``TestLoad`` 设置。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:135
msgid "``REPEAT <mode>:<n>``"
msgstr "``重复<模式>：<n>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:119
msgid ""
"Run tests repeatedly based on the given ``<mode>`` up to ``<n>`` times. "
"The modes are:"
msgstr "根据给定的``<mode>`` 重复运行测试最多``<n>`` 次。这些模式是："

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:124
msgid "``UNTIL_FAIL``"
msgstr "``UNTIL_FAIL``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:123
msgid ""
"Require each test to run ``<n>`` times without failing in order to pass. "
"This is useful in finding sporadic failures in test cases."
msgstr "要求每个测试运行 ``<n>`` 次而不失败才能通过。这对于查找测试用例中的零星故障很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:129
msgid "``UNTIL_PASS``"
msgstr "``UNTIL_PASS``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:127
msgid ""
"Allow each test to run up to ``<n>`` times in order to pass. Repeats tests"
" if they fail for any reason. This is useful in tolerating sporadic "
"failures in test cases."
msgstr "允许每个测试运行最多 ``<n>`` 次才能通过。如果由于任何原因失败，则重复测试。这对于容忍测试用例中的零星故障很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:135
msgid "``AFTER_TIMEOUT``"
msgstr "``超时后``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:132
msgid ""
"Allow each test to run up to ``<n>`` times in order to pass. Repeats tests"
" only if they timeout. This is useful in tolerating sporadic timeouts in "
"test cases on busy machines."
msgstr "允许每个测试运行最多 ``<n>`` 次才能通过。仅在超时时重复测试。这对于容忍繁忙机器上测试用例中的零星超时很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:139
msgid "``SCHEDULE_RANDOM <ON|OFF>``"
msgstr "``SCHEDULE_RANDOM <ON|OFF>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:138
msgid ""
"Launch tests in a random order.  This may be useful for detecting implicit"
" test dependencies."
msgstr "以随机顺序启动测试。这对于检测隐式测试依赖性可能很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:144
msgid "``STOP_ON_FAILURE``"
msgstr "``STOP_ON_FAILURE``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:144
msgid "Stop the execution of the tests once one has failed."
msgstr "一旦测试失败，停止执行测试。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:147
msgid "``STOP_TIME <time-of-day>``"
msgstr "``STOP_TIME <一天中的时间>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:147
msgid "Specify a time of day at which the tests should all stop running."
msgstr "指定测试应停止运行的一天中的某个时间。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:150
msgid ""
"Store in the ``<result-var>`` variable ``0`` if all tests passed. Store "
"non-zero if anything went wrong."
msgstr "如果所有测试都通过，则存储在“<result-var>”变量“0”中。如果出现任何问题，则存储非零值。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:166
msgid "``OUTPUT_JUNIT <file>``"
msgstr "``OUTPUT_JUNIT <文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:162
msgid ""
"Write test results to ``<file>`` in JUnit XML format. If ``<file>`` is a "
"relative path, it will be placed in the build directory. If ``<file>`` "
"already exists, it will be overwritten. Note that the resulting JUnit XML "
"file is **not** uploaded to CDash because it would be redundant with "
"CTest's ``Test.xml`` file."
msgstr ""
"以 JUnit XML 格式将测试结果写入``<file>``。如果 ``<file>`` 是相对路径，它将被放置在构建目录中。如果 "
"``<file>`` 已经存在，它将被覆盖。请注意，生成的 JUnit XML 文件**没有**上传到 CDash，因为它与 CTest 的 "
"``Test.xml`` 文件是多余的。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:171
msgid ""
"Suppress any CTest-specific non-error messages that would have otherwise "
"been printed to the console.  Output from the underlying test command is "
"not affected.  Summary info detailing the percentage of passing tests is "
"also unaffected by the ``QUIET`` option."
msgstr ""
"抑制任何本应打印到控制台的特定于 CTest 的非错误消息。底层测试命令的输出不受影响。详细说明通过测试百分比的摘要信息也不受 QUIET "
"选项的影响。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:176
msgid ""
"See also the :variable:`CTEST_CUSTOM_MAXIMUM_PASSED_TEST_OUTPUT_SIZE`, "
":variable:`CTEST_CUSTOM_MAXIMUM_FAILED_TEST_OUTPUT_SIZE` and "
":variable:`CTEST_CUSTOM_TEST_OUTPUT_TRUNCATION` variables, along with "
"their corresponding :manual:`ctest(1)` command line options "
":option:`--test-output-size-passed <ctest --test-output-size-passed>`, "
":option:`--test-output-size-failed <ctest --test-output-size-failed>`, and"
" :option:`--test-output-truncation <ctest --test-output-truncation>`."
msgstr ""
"另请参阅 :variable:`CTEST_CUSTOM_MAXIMUM_PASSED_TEST_OUTPUT_SIZE`、 :variable:`CTEST_CUSTOM_MAXIMUM_FAILED_TEST_OUTPUT_SIZE`"
" 和 :variable:`CTEST_CUSTOM_TEST_OUTPUT_TRUNCATION` 变量，以及它们相应的 :manual:`ctest(1)` "
"命令行选项:option:` --测试输出-size-passed <ctest --test-output-size-passed>`, "
":option:`--test-output-size-failed <ctest --test-output-size-failed>`, "
"和 :option:` --test-output-truncation <ctest --test-output-truncation>`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:187
msgid "Additional Test Measurements"
msgstr "额外的测试测量"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:189
msgid ""
"CTest can parse the output of your tests for extra measurements to report "
"to CDash."
msgstr "CTest 可以解析您的测试输出以获得额外的测量报告给 CDash。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:192
msgid ""
"When run as a :ref:`Dashboard Client`, CTest will include these custom "
"measurements in the ``Test.xml`` file that gets uploaded to CDash."
msgstr ""
"当作为 :ref:`Dashboard Client` 运行时，CTest 将在上传到 CDash 的 ``Test.xml`` "
"文件中包含这些自定义测量。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:195
msgid ""
"Check the `CDash test measurement documentation "
"<https://github.com/Kitware/CDash/blob/master/docs/test_measurements.md>`_"
" for more information on the types of test measurements that CDash "
"recognizes."
msgstr ""
"查看`CDash 测试测量文档 "
"<https://github.com/Kitware/CDash/blob/master/docs/test_measurements.md>`_"
" 了解有关 CDash 识别的测试测量类型的更多信息。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:204
msgid ""
"The following example demonstrates how to output a variety of custom test "
"measurements."
msgstr "以下示例演示如何输出各种自定义测试测量值。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:229
msgid "Image Measurements"
msgstr "图像测量"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:231
msgid ""
"The following example demonstrates how to upload test images to CDash."
msgstr "以下示例演示如何将测试图像上传到 CDash。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:248
msgid ""
"Images will be displayed together in an interactive comparison mode on "
"CDash if they are provided with two or more of the following names."
msgstr "如果提供了以下两个或更多名称，图像将在 CDash 上以交互式比较模式一起显示。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:251
msgid "``TestImage``"
msgstr "``测试图像``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:252
msgid "``ValidImage``"
msgstr "``有效图像``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:253
msgid "``BaselineImage``"
msgstr "``基线图像``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:254
msgid "``DifferenceImage2``"
msgstr "``DifferenceImage2``"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:256
msgid ""
"By convention, ``TestImage`` is the image generated by your test, and "
"``ValidImage`` (or ``BaselineImage``) is basis of comparison used to "
"determine if the test passed or failed."
msgstr ""
"按照惯例，``TestImage`` "
"是您的测试生成的图像，``ValidImage``（或``BaselineImage``）是用于确定测试是否通过的比较基础。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:260
msgid ""
"If another image name is used it will be displayed by CDash as a static "
"image separate from the interactive comparison UI."
msgstr "如果使用另一个图像名称，CDash 会将其显示为与交互式比较 UI 分开的静态图像。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:264
msgid "Attached Files"
msgstr "附加的文件"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:268
msgid ""
"The following example demonstrates how to upload non-image files to CDash."
msgstr "以下示例演示如何将非图像文件上传到 CDash。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:278
msgid ""
"If the name of the file to upload is known at configure time, you can use "
"the :prop_test:`ATTACHED_FILES` or :prop_test:`ATTACHED_FILES_ON_FAIL` "
"test properties instead."
msgstr ""
"如果要上传的文件的名称在配置时已知，则可以改用 :prop_test:`ATTACHED_FILES` 或 "
":prop_test:`ATTACHED_FILES_ON_FAIL` 测试属性。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:283
msgid "Custom Details"
msgstr "定制细节"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:287
msgid ""
"The following example demonstrates how to specify a custom value for the "
"``Test Details`` field displayed on CDash."
msgstr "以下示例演示如何为 CDash 上显示的“测试详细信息”字段指定自定义值。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:298
msgid "Additional Labels"
msgstr "附加标签"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:302
msgid ""
"The following example demonstrates how to add additional labels to a test "
"at runtime."
msgstr "以下示例演示了如何在运行时向测试添加附加标签。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_test.rst:311
msgid ""
"Use the :prop_test:`LABELS` test property instead for labels that can be "
"determined at configure time."
msgstr "使用 :prop_test:`LABELS` 测试属性代替可以在配置时确定的标签。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:2
msgid "ctest_update"
msgstr "ctest_update"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:4
msgid "Perform the :ref:`CTest Update Step` as a :ref:`Dashboard Client`."
msgstr "作为 :ref:`Dashboard Client` 执行 :ref:`CTest Update Step`。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:13
msgid ""
"Update the source tree from version control and record results in "
"``Update.xml`` for submission with the :command:`ctest_submit` command."
msgstr ""
"从版本控制更新源代码树并将结果记录在 ``Update.xml`` 中，以便使用 :command:`ctest_submit` 命令提交。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:23
msgid ""
"Store in the ``<result-var>`` variable the number of files updated or "
"``-1`` on error."
msgstr "在 ``<result-var>`` 变量中存储更新的文件数或 ``-1`` 错误。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:35
msgid ""
"Tell CTest to suppress most non-error messages that it would have "
"otherwise printed to the console.  CTest will still report the new "
"revision of the repository and any conflicting files that were found."
msgstr "告诉 CTest 抑制大多数非错误消息，否则它会打印到控制台。 CTest 仍将报告存储库的新修订版和发现的任何冲突文件。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_update.rst:40
msgid ""
"The update always follows the version control branch currently checked out"
" in the source directory.  See the :ref:`CTest Update Step` documentation "
"for information about variables that change the behavior of "
"``ctest_update()``."
msgstr ""
"更新始终遵循当前在源目录中签出的版本控制分支。有关更改 ``ctest_update()`` 行为的变量的信息，请参阅 :ref:`CTest "
"更新步骤` 文档。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:2
msgid "ctest_upload"
msgstr "ctest_upload"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:4
msgid "Upload files to a dashboard server as a :ref:`Dashboard Client`."
msgstr "作为 :ref:`Dashboard Client` 将文件上传到仪表板服务器。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:13
msgid ""
"Specify a list of files to be sent along with the build results to the "
"dashboard server."
msgstr "指定要与构建结果一起发送到仪表板服务器的文件列表。"

#: ../../cmake-prefix/src/cmake/Help/command/ctest_upload.rst:19
msgid ""
"Suppress any CTest-specific non-error output that would have been printed "
"to the console otherwise."
msgstr "抑制任何本应打印到控制台的特定于 CTest 的非错误输出。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:2
msgid "define_property"
msgstr "定义属性"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:4
msgid "Define and document custom properties."
msgstr "定义和记录自定义属性。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:15
msgid ""
"Defines one property in a scope for use with the :command:`set_property` "
"and :command:`get_property` commands. It is mainly useful for defining the"
" way a property is initialized or inherited. Historically, the command "
"also associated documentation with a property, but that is no longer "
"considered a primary use case."
msgstr ""
"在范围内定义一个属性，用于 :command:`set_property` 和 :command:`get_property` "
"命令。它主要用于定义属性的初始化或继承方式。从历史上看，该命令还将文档与属性相关联，但这不再被视为主要用例。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:21
msgid ""
"The first argument determines the kind of scope in which the property "
"should be used.  It must be one of the following:"
msgstr "第一个参数确定应该使用该属性的范围类型。它必须是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:34
msgid ""
"Note that unlike :command:`set_property` and :command:`get_property` no "
"actual scope needs to be given; only the kind of scope is important."
msgstr ""
"请注意，与 :command:`set_property` 和 :command:`get_property` "
"不同，不需要给出实际范围；只有范围的种类很重要。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:37
msgid ""
"The required ``PROPERTY`` option is immediately followed by the name of "
"the property being defined."
msgstr "所需的 ``PROPERTY`` 选项紧跟在被定义的属性的名称之后。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:40
msgid ""
"If the ``INHERITED`` option is given, then the :command:`get_property` "
"command will chain up to the next higher scope when the requested property"
" is not set in the scope given to the command."
msgstr ""
"如果给出了 ``INHERITED`` 选项，那么 :command:`get_property` "
"命令将链接到下一个更高的范围，当请求的属性没有在给定命令的范围内设置时。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:44
msgid ""
"``DIRECTORY`` scope chains to its parent directory's scope, continuing the"
" walk up parent directories until a directory has the property set or "
"there are no more parents.  If still not found at the top level directory,"
" it chains to the ``GLOBAL`` scope."
msgstr ""
"``DIRECTORY`` 范围链接到其父目录的范围，继续向上父目录直到目录具有属性集或没有更多的父目录。如果仍未在顶级目录中找到，它将链接到 "
"``GLOBAL`` 范围。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:48
msgid ""
"``TARGET``, ``SOURCE`` and ``TEST`` properties chain to ``DIRECTORY`` "
"scope, including further chaining up the directories, etc. as needed."
msgstr ""
"``TARGET``、``SOURCE`` 和 ``TEST`` 属性链接到 ``DIRECTORY`` 范围，包括根据需要进一步链接目录等。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:51
msgid ""
"Note that this scope chaining behavior only applies to calls to "
":command:`get_property`, :command:`get_directory_property`, "
":command:`get_target_property`, :command:`get_source_file_property` and "
":command:`get_test_property`.  There is no inheriting behavior when "
"*setting* properties, so using ``APPEND`` or ``APPEND_STRING`` with the "
":command:`set_property` command will not consider inherited values when "
"working out the contents to append to."
msgstr ""
"请注意，此范围链接行为仅适用于对 "
":command:`get_property`、 :command:`get_directory_property`、 :command:`get_target_property`、 :command:`get_source_file_property`"
" 和 :command:`get_test_property` 的调用。 *设置*属性时没有继承行为，因此使用 ``APPEND`` 或 "
"``APPEND_STRING`` 和 :command:`set_property` 命令在计算要附加到的内容时不会考虑继承值。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:59
msgid ""
"The ``BRIEF_DOCS`` and ``FULL_DOCS`` options are followed by strings to be"
" associated with the property as its brief and full documentation. CMake "
"does not use this documentation other than making it available to the "
"project via corresponding options to the :command:`get_property` command."
msgstr ""
"``BRIEF_DOCS`` 和 ``FULL_DOCS`` 选项后跟与属性相关联的字符串，作为其简短和完整的文档。除了通过 "
":command:`get_property` 命令的相应选项使其对项目可用之外，CMake 不使用此文档。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:66
msgid "The ``BRIEF_DOCS`` and ``FULL_DOCS`` options are optional."
msgstr "``BRIEF_DOCS`` 和 ``FULL_DOCS`` 选项是可选的。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:70
msgid ""
"The ``INITIALIZE_FROM_VARIABLE`` option specifies a variable from which "
"the property should be initialized. It can only be used with target "
"properties. The ``<variable>`` name must end with the property name and "
"must not begin with ``CMAKE_`` or ``_CMAKE_``. The property name must "
"contain at least one underscore. It is recommended that the property name "
"have a prefix specific to the project."
msgstr ""
"``INITIALIZE_FROM_VARIABLE`` 选项指定一个变量，应该从该变量初始化属性。它只能与目标属性一起使用。 "
"``<variable>`` 名称必须以属性名称结尾，并且不得以 ``CMAKE_`` 或 ``_CMAKE_`` "
"开头。属性名称必须至少包含一个下划线。建议属性名称具有特定于项目的前缀。"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:80
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:119
msgid ":command:`get_property`"
msgstr ":command:`get_property`"

#: ../../cmake-prefix/src/cmake/Help/command/define_property.rst:81
#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:107
msgid ":command:`set_property`"
msgstr ":command:`set_property`"

#: ../../cmake-prefix/src/cmake/Help/command/else.rst:2
msgid "else"
msgstr "别的"

#: ../../cmake-prefix/src/cmake/Help/command/else.rst:4
msgid "Starts the else portion of an if block."
msgstr "启动 if 块的 else 部分。"

#: ../../cmake-prefix/src/cmake/Help/command/else.rst:10
#: ../../cmake-prefix/src/cmake/Help/command/endif.rst:10
msgid "See the :command:`if` command."
msgstr "请参阅 :command:`if` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/elseif.rst:2
msgid "elseif"
msgstr "否则"

#: ../../cmake-prefix/src/cmake/Help/command/elseif.rst:4
msgid "Starts an elseif portion of an if block."
msgstr "启动 if 块的 elseif 部分。"

#: ../../cmake-prefix/src/cmake/Help/command/elseif.rst:10
msgid ""
"See the :command:`if` command, especially for the syntax and logic of the "
"``<condition>``."
msgstr "请参阅 :command:`if` 命令，尤其是``<condition>`` 的语法和逻辑。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_language.rst:2
msgid "enable_language"
msgstr "启用语言"

#: ../../cmake-prefix/src/cmake/Help/command/enable_language.rst:4
msgid "Enable languages (CXX/C/OBJC/OBJCXX/Fortran/etc)"
msgstr "启用语言（CXX/C/OBJC/OBJCXX/Fortran/等）"

#: ../../cmake-prefix/src/cmake/Help/command/enable_language.rst:10
msgid ""
"Enables support for the named languages in CMake.  This is the same as the"
" :command:`project` command but does not create any of the extra variables"
" that are created by the project command."
msgstr ""
"在 CMake 中启用对命名语言的支持。这与 :command:`project` 命令相同，但不会创建由 project 命令创建的任何额外变量。"

#: ../../cmake-prefix/src/cmake/Help/command/SUPPORTED_LANGUAGES.txt:2
msgid ""
"Supported languages are ``C``, ``CXX`` (i.e.  C++), ``CSharp`` (i.e.  C#),"
" ``CUDA``, ``OBJC`` (i.e. Objective-C), ``OBJCXX`` (i.e. Objective-C++), "
"``Fortran``, ``HIP``, ``ISPC``, ``Swift``, ``ASM``, ``ASM_NASM``, "
"``ASM_MARMASM``, ``ASM_MASM``, and ``ASM-ATT``."
msgstr ""
"支持的语言是``C``、``CXX``（即 C++）、``CSharp``（即 C#）、``CUDA``、``OBJC``（即 "
"Objective-C）、``OBJCXX ``（即 "
"Objective-C++）、``Fortran``、``HIP``、``ISPC``、``Swift``、``ASM``、``ASM_NASM``、``ASM_MARMASM``"
" ，``ASM_MASM`` 和``ASM-ATT``。"

#: ../../cmake-prefix/src/cmake/Help/command/SUPPORTED_LANGUAGES.txt:6
msgid "Added ``CSharp`` and ``CUDA`` support."
msgstr "添加了 ``CSharp`` 和 ``CUDA`` 支持。"

#: ../../cmake-prefix/src/cmake/Help/command/SUPPORTED_LANGUAGES.txt:9
msgid "Added ``Swift`` support."
msgstr "添加了``Swift`` 支持。"

#: ../../cmake-prefix/src/cmake/Help/command/SUPPORTED_LANGUAGES.txt:12
msgid "Added ``OBJC`` and ``OBJCXX`` support."
msgstr "添加了 ``OBJC`` 和 ``OBJCXX`` 支持。"

#: ../../cmake-prefix/src/cmake/Help/command/SUPPORTED_LANGUAGES.txt:15
msgid "Added ``ISPC`` support."
msgstr "添加了 ``ISPC`` 支持。"

#: ../../cmake-prefix/src/cmake/Help/command/SUPPORTED_LANGUAGES.txt:18
msgid "Added ``HIP`` support."
msgstr "添加了``HIP`` 支持。"

#: ../../cmake-prefix/src/cmake/Help/command/SUPPORTED_LANGUAGES.txt:21
msgid "Added ``ASM_MARMASM`` support."
msgstr "添加了 ``ASM_MARMASM`` 支持。"

#: ../../cmake-prefix/src/cmake/Help/command/SUPPORTED_LANGUAGES.txt:24
msgid ""
"If enabling ``ASM``, list it last so that CMake can check whether "
"compilers for other languages like ``C`` work for assembly too."
msgstr "如果启用 ``ASM``，请将其列在最后，以便 CMake 可以检查其他语言（如 ``C`` 的编译器是否也适用于汇编。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_language.rst:16
msgid ""
"By default ``C`` and ``CXX`` are enabled if no language options are given."
" Specify language ``NONE``, or use the ``LANGUAGES`` keyword and list no "
"languages, to skip enabling any languages."
msgstr ""
"如果没有给出语言选项，默认情况下启用 ``C`` 和 "
"``CXX``。指定语言“NONE”，或使用“LANGUAGES”关键字并且不列出任何语言，以跳过启用任何语言。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_language.rst:20
msgid ""
"This command must be called in file scope, not in a function call. "
"Furthermore, it must be called in the highest directory common to all "
"targets using the named language directly for compiling sources or "
"indirectly through link dependencies.  It is simplest to enable all needed"
" languages in the top-level directory of a project."
msgstr ""
"此命令必须在文件范围内调用，而不是在函数调用中。此外，它必须在所有使用命名语言的目标共有的最高目录中直接调用以编译源代码或通过链接依赖项间接调用。在项目的顶级目录中启用所有需要的语言是最简单的。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_language.rst:26
msgid ""
"The ``OPTIONAL`` keyword is a placeholder for future implementation and "
"does not currently work. Instead you can use the :module:`CheckLanguage` "
"module to verify support before enabling."
msgstr ""
"``OPTIONAL`` 关键字是未来实现的占位符，目前不起作用。相反，您可以使用 CheckLanguage 模块在启用之前验证支持。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_testing.rst:2
msgid "enable_testing"
msgstr "启用_测试"

#: ../../cmake-prefix/src/cmake/Help/command/enable_testing.rst:4
msgid "Enable testing for current directory and below."
msgstr "启用当前目录及以下目录的测试。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_testing.rst:10
msgid "Enables testing for this directory and below."
msgstr "启用此目录及以下目录的测试。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_testing.rst:12
msgid ""
"This command should be in the source directory root because ctest expects "
"to find a test file in the build directory root."
msgstr "该命令应该在源目录根目录中，因为 ctest 期望在构建目录根目录中找到一个测试文件。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_testing.rst:16
msgid ""
"This command is automatically invoked when the :module:`CTest` module is "
"included, except if the ``BUILD_TESTING`` option is turned off."
msgstr "包含 CTest 模块时会自动调用此命令，除非关闭了“BUILD_TESTING”选项。"

#: ../../cmake-prefix/src/cmake/Help/command/enable_testing.rst:20
msgid "See also the :command:`add_test` command."
msgstr "另请参阅 :command:`add_test` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/endblock.rst:2
msgid "endblock"
msgstr "端块"

#: ../../cmake-prefix/src/cmake/Help/command/endblock.rst:6
msgid ""
"Ends a list of commands in a :command:`block` and removes the scopes "
"created by the :command:`block` command."
msgstr "在 :command:`block` 中结束命令列表，并删除由 :command:`block` 命令创建的范围。"

#: ../../cmake-prefix/src/cmake/Help/command/endforeach.rst:2
msgid "endforeach"
msgstr "结束foreach"

#: ../../cmake-prefix/src/cmake/Help/command/endforeach.rst:4
msgid "Ends a list of commands in a foreach block."
msgstr "在 foreach 块中结束命令列表。"

#: ../../cmake-prefix/src/cmake/Help/command/endforeach.rst:10
msgid "See the :command:`foreach` command."
msgstr "请参阅 :command:`foreach` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/endforeach.rst:12
msgid ""
"The optional ``<loop_var>`` argument is supported for backward "
"compatibility only. If used it must be a verbatim repeat of the "
"``<loop_var>`` argument of the opening ``foreach`` clause."
msgstr ""
"可选的 ``<loop_var>`` 参数仅支持向后兼容。如果使用它，它必须逐字重复开头``foreach`` 子句的``<loop_var>`` "
"参数。"

#: ../../cmake-prefix/src/cmake/Help/command/endfunction.rst:2
msgid "endfunction"
msgstr "结束功能"

#: ../../cmake-prefix/src/cmake/Help/command/endfunction.rst:4
msgid "Ends a list of commands in a function block."
msgstr "结束功能块中的命令列表。"

#: ../../cmake-prefix/src/cmake/Help/command/endfunction.rst:10
msgid "See the :command:`function` command."
msgstr "请参阅 :command:`function` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/endfunction.rst:12
msgid ""
"The optional ``<name>`` argument is supported for backward compatibility "
"only. If used it must be a verbatim repeat of the ``<name>`` argument of "
"the opening ``function`` command."
msgstr "可选的 ``<name>`` 参数仅支持向后兼容。如果使用，它必须逐字重复开头的“函数”命令的“<名称>”参数。"

#: ../../cmake-prefix/src/cmake/Help/command/endif.rst:2
msgid "endif"
msgstr "万一"

#: ../../cmake-prefix/src/cmake/Help/command/endif.rst:4
msgid "Ends a list of commands in an if block."
msgstr "在 if 块中结束命令列表。"

#: ../../cmake-prefix/src/cmake/Help/command/endif.rst:12
msgid ""
"The optional ``<condition>`` argument is supported for backward "
"compatibility only. If used it must be a verbatim repeat of the argument "
"of the opening ``if`` clause."
msgstr "可选的 ``<condition>`` 参数仅支持向后兼容。如果使用，它必须逐字重复开头的“if”子句的参数。"

#: ../../cmake-prefix/src/cmake/Help/command/endmacro.rst:2
msgid "endmacro"
msgstr "结束宏"

#: ../../cmake-prefix/src/cmake/Help/command/endmacro.rst:4
msgid "Ends a list of commands in a macro block."
msgstr "结束宏块中的命令列表。"

#: ../../cmake-prefix/src/cmake/Help/command/endmacro.rst:10
msgid "See the :command:`macro` command."
msgstr "请参阅 :command:`macro` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/endmacro.rst:12
msgid ""
"The optional ``<name>`` argument is supported for backward compatibility "
"only. If used it must be a verbatim repeat of the ``<name>`` argument of "
"the opening ``macro`` command."
msgstr "可选的 ``<name>`` 参数仅支持向后兼容。如果使用它，则必须逐字重复打开“宏”命令的“<名称>”参数。"

#: ../../cmake-prefix/src/cmake/Help/command/endwhile.rst:2
msgid "endwhile"
msgstr "最后"

#: ../../cmake-prefix/src/cmake/Help/command/endwhile.rst:4
msgid "Ends a list of commands in a while block."
msgstr "在 while 块中结束命令列表。"

#: ../../cmake-prefix/src/cmake/Help/command/endwhile.rst:10
msgid "See the :command:`while` command."
msgstr "请参阅 :command:`while` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/endwhile.rst:12
msgid ""
"The optional ``<condition>`` argument is supported for backward "
"compatibility only. If used it must be a verbatim repeat of the argument "
"of the opening ``while`` clause."
msgstr "可选的 ``<condition>`` 参数仅支持向后兼容。如果使用，它必须逐字重复开头的“while”子句的参数。"

#: ../../cmake-prefix/src/cmake/Help/command/exec_program.rst:2
msgid "exec_program"
msgstr "执行程序"

#: ../../cmake-prefix/src/cmake/Help/command/exec_program.rst:6
msgid "Use the :command:`execute_process` command instead."
msgstr "请改用 :command:`execute_process` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/exec_program.rst:8
msgid ""
"Run an executable program during the processing of the CMakeList.txt file."
msgstr "在处理 CMakeList.txt 文件期间运行可执行程序。"

#: ../../cmake-prefix/src/cmake/Help/command/exec_program.rst:18
msgid ""
"The executable is run in the optionally specified directory.  The "
"executable can include arguments if it is double quoted, but it is better "
"to use the optional ``ARGS`` argument to specify arguments to the program."
"  This is because cmake will then be able to escape spaces in the "
"executable path.  An optional argument ``OUTPUT_VARIABLE`` specifies a "
"variable in which to store the output.  To capture the return value of the"
" execution, provide a ``RETURN_VALUE``.  If ``OUTPUT_VARIABLE`` is "
"specified, then no output will go to the stdout/stderr of the console "
"running cmake."
msgstr ""
"可执行文件在可选的指定目录中运行。如果可执行文件被双引号括起来，则可以包含参数，但最好使用可选的 ``ARGS`` 参数来指定程序的参数。这是因为 "
"cmake 随后将能够转义可执行文件路径中的空格。一个可选的参数 ``OUTPUT_VARIABLE`` "
"指定了一个变量来存储输出。要捕获执行的返回值，请提供“RETURN_VALUE”。如果指定了 ``OUTPUT_VARIABLE`` "
"，那么没有输出会进入运行 cmake 的控制台的标准输出/标准错误。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:2
msgid "execute_process"
msgstr "执行进程"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:4
msgid "Execute one or more child processes."
msgstr "执行一个或多个子进程。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:29
msgid "Runs the given sequence of one or more commands."
msgstr "运行一个或多个命令的给定序列。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:31
msgid ""
"Commands are executed concurrently as a pipeline, with the standard output"
" of each process piped to the standard input of the next. A single "
"standard error pipe is used for all processes."
msgstr "命令作为管道同时执行，每个进程的标准输出通过管道传输到下一个进程的标准输入。单个标准错误管道用于所有进程。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:35
msgid ""
"``execute_process`` runs commands while CMake is configuring the project, "
"prior to build system generation.  Use the :command:`add_custom_target` "
"and :command:`add_custom_command` commands to create custom commands that "
"run at build time."
msgstr ""
"``execute_process`` 在 CMake 配置项目时运行命令，然后生成系统生成。使用 "
":command:`add_custom_target` 和 :command:`add_custom_command` "
"命令创建在构建时运行的自定义命令。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:40
msgid "Options:"
msgstr "选项："

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:43
msgid "A child process command line."
msgstr "子进程命令行。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:45
msgid ""
"CMake executes the child process using operating system APIs directly:"
msgstr "CMake 直接使用操作系统 API 执行子进程："

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:47
msgid ""
"On POSIX platforms, the command line is passed to the child process in an "
"``argv[]`` style array."
msgstr "在 POSIX 平台上，命令行以 argv[] 样式数组传递给子进程。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:50
msgid ""
"On Windows platforms, the command line is encoded as a string such that "
"child processes using ``CommandLineToArgvW`` will decode the original "
"arguments."
msgstr "在 Windows 平台上，命令行被编码为字符串，这样使用 CommandLineToArgvW 的子进程将解码原始参数。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:54
msgid ""
"No intermediate shell is used, so shell operators such as ``>`` are "
"treated as normal arguments. (Use the ``INPUT_*``, ``OUTPUT_*``, and "
"``ERROR_*`` options to redirect stdin, stdout, and stderr.)"
msgstr ""
"没有使用中间 shell，因此 ``>`` 等 shell 运算符被视为普通参数。 （使用 ``INPUT_*``、``OUTPUT_*`` 和 "
"``ERROR_*`` 选项重定向标准输入、标准输出和标准错误。）"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:59
msgid ""
"For **sequential execution** of multiple commands use multiple "
"``execute_process`` calls each with a single ``COMMAND`` argument."
msgstr ""
"对于多个命令的**顺序执行**，使用多个 ``execute_process`` 调用，每个调用带有一个 ``COMMAND`` 参数。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:63
msgid ""
"The named directory will be set as the current working directory of the "
"child processes."
msgstr "命名目录将被设置为子进程的当前工作目录。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:69
msgid "``TIMEOUT``"
msgstr "``超时``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:67
msgid ""
"After the specified number of seconds (fractions allowed), all unfinished "
"child processes will be terminated, and the ``RESULT_VARIABLE`` will be "
"set to a string mentioning the \"timeout\"."
msgstr "在指定的秒数（允许小数）后，所有未完成的子进程将终止，并且 ``RESULT_VARIABLE`` 将设置为提及“超时”的字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:74
msgid "``RESULT_VARIABLE``"
msgstr "``RESULT_VARIABLE``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:72
msgid ""
"The variable will be set to contain the result of last child process. This"
" will be an integer return code from the last child or a string describing"
" an error condition."
msgstr "该变量将被设置为包含最后一个子进程的结果。这将是来自最后一个孩子的整数返回代码或描述错误情况的字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:82
msgid "``RESULTS_VARIABLE <variable>``"
msgstr "``RESULTS_VARIABLE <变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:79
msgid ""
"The variable will be set to contain the result of all processes as a "
":ref:`semicolon-separated list <CMake Language Lists>`, in order of the "
"given ``COMMAND`` arguments.  Each entry will be an integer return code "
"from the corresponding child or a string describing an error condition."
msgstr ""
"该变量将被设置为包含所有进程的结果，作为分号分隔的列表 <CMake Language Lists>，按照给定的 COMMAND "
"参数的顺序。每个条目将是来自相应子项的整数返回代码或描述错误情况的字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:86
msgid "``INPUT_FILE <file>``"
msgstr "``INPUT_FILE <文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:85
msgid ""
"``<file>`` is attached to the standard input pipe of the *first* "
"``COMMAND`` process."
msgstr "``<file>`` 附加到 *first* ``COMMAND`` 进程的标准输入管道。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:90
msgid "``OUTPUT_FILE <file>``"
msgstr "``OUTPUT_FILE <文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:89
msgid ""
"``<file>`` is attached to the standard output pipe of the *last* "
"``COMMAND`` process."
msgstr "``<file>`` 附加到*last* ``COMMAND`` 进程的标准输出管道。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:94
msgid "``ERROR_FILE <file>``"
msgstr "``错误文件<文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:93
msgid ""
"``<file>`` is attached to the standard error pipe of *all* ``COMMAND`` "
"processes."
msgstr "``<file>`` 附加到*所有* ``COMMAND`` 进程的标准错误管道。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:96
msgid ""
"If the same ``<file>`` is named for both ``OUTPUT_FILE`` and "
"``ERROR_FILE`` then it will be used for both standard output and standard "
"error pipes."
msgstr ""
"如果为 ``OUTPUT_FILE`` 和 ``ERROR_FILE`` 命名了相同的 ``<file>`` "
"那么它将同时用于标准输出和标准错误管道。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:103
msgid "``OUTPUT_QUIET``, ``ERROR_QUIET``"
msgstr "``OUTPUT_QUIET``，``ERROR_QUIET``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:101
msgid ""
"The standard output on ``OUTPUT_VARIABLE`` or standard error on "
"``ERROR_VARIABLE`` are not connected (no variable content). The  "
"``*_FILE`` and ``ECHO_*_VARIABLE`` options are not affected."
msgstr ""
"``OUTPUT_VARIABLE`` 上的标准输出或``ERROR_VARIABLE`` 上的标准错误未连接（无变量内容）。 ``*_FILE``"
" 和 ``ECHO_*_VARIABLE`` 选项不受影响。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:108
msgid "``OUTPUT_VARIABLE``, ``ERROR_VARIABLE``"
msgstr "``OUTPUT_VARIABLE``，``ERROR_VARIABLE``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:106
msgid ""
"The variable named will be set with the contents of the standard output "
"and standard error pipes, respectively.  If the same variable is named for"
" both pipes their output will be merged in the order produced."
msgstr "命名的变量将分别设置为标准输出和标准错误管道的内容。如果为两个管道命名相同的变量，它们的输出将按照产生的顺序合并。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:117
msgid "``ECHO_OUTPUT_VARIABLE``, ``ECHO_ERROR_VARIABLE``"
msgstr "``ECHO_OUTPUT_VARIABLE``，``ECHO_ERROR_VARIABLE``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:113
msgid ""
"The standard output or standard error will not be exclusively redirected "
"to the specified variables."
msgstr "标准输出或标准错误不会专门重定向到指定的变量。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:116
msgid ""
"The output will be duplicated into the specified variables and also onto "
"standard output or standard error analogous to the ``tee`` Unix command."
msgstr "输出将被复制到指定的变量中，也会被复制到类似于 ``tee`` Unix 命令的标准输出或标准错误中。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:120
msgid ""
"If more than one ``OUTPUT_*`` or ``ERROR_*`` option is given for the same "
"pipe the precedence is *not specified*. If no ``OUTPUT_*`` or ``ERROR_*`` "
"options are given the output will be shared with the corresponding pipes "
"of the CMake process itself."
msgstr ""
"如果为同一管道提供了多个 ``OUTPUT_*`` 或 ``ERROR_*`` 选项，则优先级*未指定*。如果没有给出 ``OUTPUT_*`` 或"
" ``ERROR_*`` 选项，输出将与 CMake 进程本身的相应管道共享。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:131
msgid "``COMMAND_ECHO <where>``"
msgstr "``COMMAND_ECHO <哪里>``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:128
msgid ""
"The command being run will be echo'ed to ``<where>`` with ``<where>`` "
"being set to one of ``STDERR``, ``STDOUT`` or ``NONE``. See the "
":variable:`CMAKE_EXECUTE_PROCESS_COMMAND_ECHO` variable for a way to "
"control the default behavior when this option is not present."
msgstr ""
"正在运行的命令将被回显到 ``<where>``，``<where>`` 被设置为 ``STDERR``、``STDOUT`` 或 ``NONE``"
" 之一。请参阅 :variable:`CMAKE_EXECUTE_PROCESS_COMMAND_ECHO` "
"变量，了解在不存在此选项时控制默认行为的方法。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:156
msgid "``ENCODING <name>``"
msgstr "``编码<名称>``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:136
msgid ""
"On Windows, the encoding that is used to decode output from the process. "
"Ignored on other platforms. Valid encoding names are:"
msgstr "在 Windows 上，用于解码进程输出的编码。在其他平台上被忽略。有效的编码名称是："

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:142
msgid "``NONE``"
msgstr "``没有``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:141
msgid ""
"Perform no decoding.  This assumes that the process output is encoded in "
"the same way as CMake's internal encoding (UTF-8). This is the default."
msgstr "不执行解码。这假定流程输出的编码方式与 CMake 的内部编码 (UTF-8) 相同。这是默认设置。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:145
msgid "``AUTO``"
msgstr "``自动``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:145
msgid ""
"Use the current active console's codepage or if that isn't available then "
"use ANSI."
msgstr "使用当前活动控制台的代码页，如果不可用，则使用 ANSI。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:147
msgid "``ANSI``"
msgstr "``ANSI``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:148
msgid "Use the ANSI codepage."
msgstr "使用 ANSI 代码页。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:149
msgid "``OEM``"
msgstr "``OEM``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:150
msgid "Use the original equipment manufacturer (OEM) code page."
msgstr "使用原始设备制造商 (OEM) 代码页。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:156
msgid "``UTF8`` or ``UTF-8``"
msgstr "``UTF8`` 或 ``UTF-8``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:152
msgid "Use the UTF-8 codepage."
msgstr "使用 UTF-8 代码页。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:154
msgid ""
"Accept ``UTF-8`` spelling for consistency with the `UTF-8 RFC "
"<https://www.ietf.org/rfc/rfc3629>`_ naming convention."
msgstr ""
"接受 ``UTF-8`` 拼写以与 `UTF-8 RFC <https://www.ietf.org/rfc/rfc3629>`_ "
"命名约定保持一致。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:170
msgid "``COMMAND_ERROR_IS_FATAL <ANY|LAST>``"
msgstr "``COMMAND_ERROR_IS_FATAL <ANY|LAST>``"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:161
msgid ""
"The option following ``COMMAND_ERROR_IS_FATAL`` determines the behavior "
"when an error is encountered:"
msgstr "``COMMAND_ERROR_IS_FATAL`` 后面的选项决定了遇到错误时的行为："

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:164
msgid ""
"``ANY`` If any of the commands in the list of commands fail, the "
"``execute_process()`` command halts with an error."
msgstr "``ANY`` 如果命令列表中的任何命令失败，``execute_process()`` 命令会因错误而停止。"

#: ../../cmake-prefix/src/cmake/Help/command/execute_process.rst:168
msgid ""
"``LAST`` If the last command in the list of commands fails, the "
"``execute_process()`` command halts with an error.  Commands earlier in "
"the list will not cause a fatal error."
msgstr ""
"``LAST`` 如果命令列表中的最后一个命令失败，``execute_process()`` 命令会因错误而停止。列表前面的命令不会导致致命错误。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:2
msgid "export"
msgstr "出口"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:4
msgid ""
"Export targets or packages for outside projects to use them directly from "
"the current project's build tree, without installation."
msgstr "导出外部项目的目标或包以直接从当前项目的构建树中使用它们，无需安装。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:7
msgid ""
"See the :command:`install(EXPORT)` command to export targets from an "
"install tree."
msgstr "请参阅 :command:`install(EXPORT)` 命令从安装树中导出目标。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:20
msgid "Exporting Targets"
msgstr "导出目标"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:31
msgid ""
"Creates a file ``<filename>`` that may be included by outside projects to "
"import targets named by ``<target>...`` from the current project's build "
"tree. This is useful during cross-compiling to build utility executables "
"that can run on the host platform in one project and then import them into"
" another project being compiled for the target platform."
msgstr ""
"创建一个文件 ``<filename>``，该文件可能被外部项目包含，以从当前项目的构建树中导入由``<target>...`` "
"命名的目标。这在交叉编译期间很有用，可以构建可在一个项目的主机平台上运行的实用程序可执行文件，然后将它们导入到为目标平台编译的另一个项目中。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:37
msgid ""
"The file created by this command is specific to the build tree and should "
"never be installed.  See the :command:`install(EXPORT)` command to export "
"targets from an install tree."
msgstr "此命令创建的文件特定于构建树，不应安装。请参阅 :command:`install(EXPORT)` 命令从安装树中导出目标。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:44
msgid "``NAMESPACE <namespace>``"
msgstr "``命名空间<命名空间>``"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:44
msgid ""
"Prepend the ``<namespace>`` string to all target names written to the "
"file."
msgstr "将 ``<namespace>`` 字符串添加到写入文件的所有目标名称。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:47
msgid ""
"Append to the file instead of overwriting it.  This can be used to "
"incrementally export multiple targets to the same file."
msgstr "附加到文件而不是覆盖它。这可用于将多个目标增量导出到同一文件。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:54
msgid "``EXPORT_LINK_INTERFACE_LIBRARIES``"
msgstr "``EXPORT_LINK_INTERFACE_LIBRARIES``"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:51
msgid ""
"Include the contents of the properties named with the pattern "
"``(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?`` in the export, even "
"when policy :policy:`CMP0022` is NEW.  This is useful to support consumers"
" using CMake versions older than 2.8.12."
msgstr ""
"在导出中包含以模式“(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?”命名的属性的内容，即使策略 :policy:`CMP0022`"
" 是新的。这对于支持使用早于 2.8.12 的 CMake 版本的消费者很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:56
msgid "``CXX_MODULES_DIRECTORY <directory>``"
msgstr "``CXX_MODULES_DIRECTORY <目录>``"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:60
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:222
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:862
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:88
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:98
msgid "Experimental. Gated by ``CMAKE_EXPERIMENTAL_CXX_MODULE_CMAKE_API``"
msgstr "实验性的。由 ``CMAKE_EXPERIMENTAL_CXX_MODULE_CMAKE_API`` 控制"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:62
msgid ""
"Export C++ module properties to files under the given directory. Each file"
" will be named according to the target's export name (without any "
"namespace). These files will automatically be included from the export "
"file."
msgstr "将 C++ 模块属性导出到给定目录下的文件。每个文件将根据目标的导出名称（没有任何名称空间）命名。这些文件将自动包含在导出文件中。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:66
msgid ""
"This signature requires all targets to be listed explicitly.  If a library"
" target is included in the export, but a target to which it links is not "
"included, the behavior is unspecified.  See the `export(EXPORT)`_ "
"signature to automatically export the same targets from the build tree as "
":command:`install(EXPORT)` would from an install tree."
msgstr ""
"此签名要求明确列出所有目标。如果库目标包含在导出中，但不包含它链接到的目标，则行为未指定。请参阅 `export(EXPORT)`_ "
"签名以自动从构建树中导出与 :command:`install(EXPORT)` 从安装树中导出相同的目标。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:74
msgid ""
":ref:`Object Libraries` under :generator:`Xcode` have special handling if "
"multiple architectures are listed in :variable:`CMAKE_OSX_ARCHITECTURES`. "
"In this case they will be exported as :ref:`Interface Libraries` with no "
"object files available to clients.  This is sufficient to satisfy "
"transitive usage requirements of other targets that link to the object "
"libraries in their implementation."
msgstr ""
"如果 CMAKE_OSX_ARCHITECTURES 中列出了多个体系结构，Xcode 下的 :ref:`Object Libraries` "
"有特殊处理。在这种情况下，它们将被导出为 :ref:`Interface "
"Libraries`，没有可供客户端使用的目标文件。这足以满足在其实现中链接到对象库的其他目标的传递使用要求。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:82
msgid "Exporting Targets to Android.mk"
msgstr "将目标导出到 Android.mk"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:90
msgid ""
"This signature exports cmake built targets to the android ndk build system"
" by creating an ``Android.mk`` file that references the prebuilt targets. "
"The Android NDK supports the use of prebuilt libraries, both static and "
"shared. This allows cmake to build the libraries of a project and make "
"them available to an ndk build system complete with transitive "
"dependencies, include flags and defines required to use the libraries. The"
" signature takes a list of targets and puts them in the ``Android.mk`` "
"file specified by the ``<filename>`` given. This signature can only be "
"used if policy :policy:`CMP0022` is NEW for all targets given. A error "
"will be issued if that policy is set to OLD for one of the targets."
msgstr ""
"此签名通过创建引用预构建目标的“Android.mk”文件将 cmake 构建的目标导出到 android ndk 构建系统。 Android "
"NDK 支持使用预建库，包括静态库和共享库。这允许 cmake 构建项目的库，并使它们可用于具有传递依赖性的 ndk "
"构建系统，包括使用库所需的标志和定义。签名采用目标列表并将它们放入由给定的 ``<filename>`` 指定的 ``Android.mk`` "
"文件中。仅当策略 CMP0022 对于给定的所有目标都是新的时，才能使用此签名。如果该策略针对其中一个目标设置为 OLD，则会发出错误。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:102
msgid "Exporting Targets matching install(EXPORT)"
msgstr "导出目标匹配安装（EXPORT）"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:112
msgid ""
"Creates a file ``<filename>`` that may be included by outside projects to "
"import targets from the current project's build tree.  This is the same as"
" the `export(TARGETS)`_ signature, except that the targets are not "
"explicitly listed.  Instead, it exports the targets associated with the "
"installation export ``<export-name>``.  Target installations may be "
"associated with the export ``<export-name>`` using the ``EXPORT`` option "
"of the :command:`install(TARGETS)` command."
msgstr ""
"创建一个文件 ``<filename>``，该文件可能被外部项目包含，以从当前项目的构建树中导入目标。这与 export(TARGETS) "
"签名相同，只是未明确列出目标。相反，它导出与安装导出关联的目标 ``<export-name>``。目标安装可以使用 "
":command:`install(TARGETS)` 命令的 ``EXPORT`` 选项与导出 ``<export-name>`` 相关联。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:121
msgid "Exporting Packages"
msgstr "导出包"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:130
msgid ""
"Store the current build directory in the CMake user package registry for "
"package ``<PackageName>``.  The :command:`find_package` command may "
"consider the directory while searching for package ``<PackageName>``.  "
"This helps dependent projects find and use a package from the current "
"project's build tree without help from the user.  Note that the entry in "
"the package registry that this command creates works only in conjunction "
"with a package configuration file (``<PackageName>Config.cmake``) that "
"works with the build tree. In some cases, for example for packaging and "
"for system wide installations, it is not desirable to write the user "
"package registry."
msgstr ""
"将当前构建目录存储在包“<PackageName>”的 CMake 用户包注册表中。 :command:`find_package` 命令在搜索包 "
"``<PackageName>`` "
"时可能会考虑该目录。这有助于依赖项目在没有用户帮助的情况下从当前项目的构建树中查找和使用包。请注意，此命令创建的包注册表中的条目只能与与构建树一起使用的包配置文件（``<PackageName>Config.cmake``）一起使用。在某些情况下，例如打包和系统范围的安装，不希望编写用户包注册表。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:141
msgid ""
"If the :variable:`CMAKE_EXPORT_NO_PACKAGE_REGISTRY` variable is enabled, "
"the ``export(PACKAGE)`` command will do nothing."
msgstr ""
"如果启用了 CMAKE_EXPORT_NO_PACKAGE_REGISTRY 变量，则 export(PACKAGE) 命令将不执行任何操作。"

#: ../../cmake-prefix/src/cmake/Help/command/export.rst:145
msgid ""
"By default the ``export(PACKAGE)`` command does nothing (see policy "
":policy:`CMP0090`) because populating the user package registry has "
"effects outside the source and build trees.  Set the "
":variable:`CMAKE_EXPORT_PACKAGE_REGISTRY` variable to add build "
"directories to the CMake user package registry."
msgstr ""
"默认情况下，``export(PACKAGE)`` "
"命令不执行任何操作（请参阅策略:policy:`CMP0090`），因为填充用户包注册表会在源代码和构建树之外产生影响。设置 "
":variable:`CMAKE_EXPORT_PACKAGE_REGISTRY` 变量以将构建目录添加到 CMake 用户包注册表。"

#: ../../cmake-prefix/src/cmake/Help/command/export_library_dependencies.rst:2
msgid "export_library_dependencies"
msgstr "export_library_dependencies"

#: ../../cmake-prefix/src/cmake/Help/command/export_library_dependencies.rst:4
msgid "Disallowed since version 3.0.  See CMake Policy :policy:`CMP0033`."
msgstr "3.0 版后不允许。请参阅 CMake 政策:policy:`CMP0033`。"

#: ../../cmake-prefix/src/cmake/Help/command/export_library_dependencies.rst:6
msgid "Use :command:`install(EXPORT)` or :command:`export` command."
msgstr "使用 :command:`install(EXPORT)` 或 :command:`export` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/export_library_dependencies.rst:8
msgid ""
"This command generates an old-style library dependencies file. Projects "
"requiring CMake 2.6 or later should not use the command.  Use instead the "
":command:`install(EXPORT)` command to help export targets from an "
"installation tree and the :command:`export` command to export targets from"
" a build tree."
msgstr ""
"此命令生成一个旧式库依赖文件。需要 CMake 2.6 或更高版本的项目不应使用该命令。使用 :command:`install(EXPORT)` "
"命令帮助从安装树导出目标，使用 :command:`export` 命令从构建树导出目标。"

#: ../../cmake-prefix/src/cmake/Help/command/export_library_dependencies.rst:14
msgid ""
"The old-style library dependencies file does not take into account per-"
"configuration names of libraries or the "
":prop_tgt:`LINK_INTERFACE_LIBRARIES` target property."
msgstr "旧式库依赖文件不考虑库的每个配置名称或 :prop_tgt:`LINK_INTERFACE_LIBRARIES` 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/command/export_library_dependencies.rst:22
msgid ""
"Create a file named ``<file>`` that can be included into a CMake listfile "
"with the INCLUDE command.  The file will contain a number of SET commands "
"that will set all the variables needed for library dependency information."
"  This should be the last command in the top level CMakeLists.txt file of "
"the project.  If the ``APPEND`` option is specified, the SET commands will"
" be appended to the given file instead of replacing it."
msgstr ""
"创建一个名为 ``<file>`` 的文件，可以使用 INCLUDE 命令将其包含到 CMake 列表文件中。该文件将包含许多 SET "
"命令，这些命令将设置库依赖信息所需的所有变量。这应该是项目顶层 CMakeLists.txt 文件中的最后一个命令。如果指定了 APPEND "
"选项，则 SET 命令将附加到给定文件而不是替换它。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:2
msgid "file"
msgstr "文件"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:4
msgid "File manipulation command."
msgstr "文件操作命令。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:6
msgid ""
"This command is dedicated to file and path manipulation requiring access "
"to the filesystem."
msgstr "此命令专用于需要访问文件系统的文件和路径操作。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:9
msgid ""
"For other path manipulation, handling only syntactic aspects, have a look "
"at :command:`cmake_path` command."
msgstr "对于其他路径操作，仅处理语法方面，请查看 :command:`cmake_path` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:14
msgid ""
"The sub-commands `RELATIVE_PATH`_, `TO_CMAKE_PATH`_ and `TO_NATIVE_PATH`_ "
"has been superseded, respectively, by sub-commands :ref:`RELATIVE_PATH "
"<cmake_path-RELATIVE_PATH>`, :ref:`CONVERT ... TO_CMAKE_PATH_LIST "
"<cmake_path-TO_CMAKE_PATH_LIST>` and :ref:`CONVERT ... TO_NATIVE_PATH_LIST"
" <cmake_path-TO_NATIVE_PATH_LIST>` of :command:`cmake_path` command."
msgstr ""
"子命令 `RELATIVE_PATH`_、`TO_CMAKE_PATH`_ 和 `TO_NATIVE_PATH`_ "
"已分别被子命令取代:ref:`RELATIVE_PATH <cmake_path-RELATIVE_PATH>`、 :ref:`CONVERT ..."
" TO_CMAKE_PATH_LIST < cmake_path-TO_CMAKE_PATH_LIST>` 和 :ref:`CONVERT ... "
"TO_NATIVE_PATH_LIST <cmake_path-TO_NATIVE_PATH_LIST>` of "
":command:`cmake_path` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:69
#: ../../cmake-prefix/src/cmake/Help/command/list.rst:67
msgid "Reading"
msgstr "阅读"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:78
msgid ""
"Read content from a file called ``<filename>`` and store it in a "
"``<variable>``.  Optionally start from the given ``<offset>`` and read at "
"most ``<max-in>`` bytes.  The ``HEX`` option causes data to be converted "
"to a hexadecimal representation (useful for binary data). If the ``HEX`` "
"option is specified, letters in the output (``a`` through ``f``) are in "
"lowercase."
msgstr ""
"从名为 ``<filename>`` 的文件中读取内容并将其存储在 ``<variable>`` 中。可选择从给定的``<offset>`` "
"开始，最多读取``<max-in>`` 字节。 ``HEX`` 选项将数据转换为十六进制表示形式（对二进制数据有用）。如果指定了 ``HEX`` "
"选项，则输出中的字母（``a`` 到 ``f``）为小写。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:91
msgid ""
"Parse a list of ASCII strings from ``<filename>`` and store it in "
"``<variable>``.  Binary data in the file are ignored.  Carriage return "
"(``\\r``, CR) characters are ignored.  The options are:"
msgstr ""
"从 ``<filename>`` 解析 ASCII 字符串列表，并将其存储在 ``<variable>`` "
"中。忽略文件中的二进制数据。回车（``\\r``，CR）字符被忽略。选项是："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:96
msgid "``LENGTH_MAXIMUM <max-len>``"
msgstr "``LENGTH_MAXIMUM <最大长度>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:96
msgid "Consider only strings of at most a given length."
msgstr "只考虑最多给定长度的字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:99
msgid "``LENGTH_MINIMUM <min-len>``"
msgstr "``LENGTH_MINIMUM <最小长度>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:99
msgid "Consider only strings of at least a given length."
msgstr "只考虑至少给定长度的字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:102
msgid "``LIMIT_COUNT <max-num>``"
msgstr "``限制计数 <max-number>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:102
msgid "Limit the number of distinct strings to be extracted."
msgstr "限制要提取的不同字符串的数量。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:105
msgid "``LIMIT_INPUT <max-in>``"
msgstr "``LIMIT_INPUT <最大输入>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:105
msgid "Limit the number of input bytes to read from the file."
msgstr "限制从文件中读取的输入字节数。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:108
msgid "``LIMIT_OUTPUT <max-out>``"
msgstr "``LIMIT_OUTPUT <最大输出>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:108
msgid "Limit the number of total bytes to store in the ``<variable>``."
msgstr "限制要存储在 ``<variable>`` 中的总字节数。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:112
msgid "``NEWLINE_CONSUME``"
msgstr "``NEWLINE_CONSUME``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:111
msgid ""
"Treat newline characters (``\\n``, LF) as part of string content instead "
"of terminating at them."
msgstr "将换行符（``\\n``，LF）视为字符串内容的一部分，而不是在它们处终止。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:116
msgid "``NO_HEX_CONVERSION``"
msgstr "``NO_HEX_CONVERSION``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:115
msgid ""
"Intel Hex and Motorola S-record files are automatically converted to "
"binary while reading unless this option is given."
msgstr "Intel Hex 和 Motorola S-record 文件在读取时会自动转换为二进制文件，除非给出此选项。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:120
msgid "``REGEX <regex>``"
msgstr "``REGEX <正则表达式>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:119
msgid ""
"Consider only strings that match the given regular expression, as "
"described under :ref:`string(REGEX) <Regex Specification>`."
msgstr "仅考虑与给定正则表达式匹配的字符串，如 :ref:`string(REGEX) <Regex Specification>` 中所述。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:131
msgid "``ENCODING <encoding-type>``"
msgstr "``ENCODING <编码类型>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:125
msgid ""
"Consider strings of a given encoding.  Currently supported encodings are: "
"``UTF-8``, ``UTF-16LE``, ``UTF-16BE``, ``UTF-32LE``, ``UTF-32BE``. If the "
"``ENCODING`` option is not provided and the file has a Byte Order Mark, "
"the ``ENCODING`` option will be defaulted to respect the Byte Order Mark."
msgstr ""
"考虑给定编码的字符串。目前支持的编码有：``UTF-8``、``UTF-16LE``、``UTF-16BE``、``UTF-32LE``、``UTF-32BE``。如果未提供"
" ``ENCODING`` 选项并且文件具有字节顺序标记，则 ``ENCODING`` 选项将默认遵循字节顺序标记。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:130
msgid ""
"Added the ``UTF-16LE``, ``UTF-16BE``, ``UTF-32LE``, ``UTF-32BE`` "
"encodings."
msgstr "添加了``UTF-16LE``、``UTF-16BE``、``UTF-32LE``、``UTF-32BE`` 编码。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:133
msgid "For example, the code"
msgstr "例如，代码"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:139
msgid ""
"stores a list in the variable ``myfile`` in which each item is a line from"
" the input file."
msgstr "在变量“myfile”中存储一个列表，其中每个项目都是来自输入文件的一行。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:148
msgid ""
"Compute a cryptographic hash of the content of ``<filename>`` and store it"
" in a ``<variable>``.  The supported ``<HASH>`` algorithm names are those "
"listed by the :ref:`string(\\<HASH\\>) <Supported Hash Algorithms>` "
"command."
msgstr ""
"计算 ``<filename>`` 内容的加密哈希并将其存储在 ``<variable>`` 中。受支持的``<HASH>`` 算法名称是由 "
":ref:`string(\\<HASH\\>) <Supported Hash Algorithms>` 命令列出的。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:159
msgid ""
"Compute a string representation of the modification time of ``<filename>``"
" and store it in ``<variable>``.  Should the command be unable to obtain a"
" timestamp variable will be set to the empty string (\"\")."
msgstr ""
"计算 ``<filename>`` 的修改时间的字符串表示，并将其存储在 ``<variable>`` "
"中。如果命令无法获取时间戳变量，则将设置为空字符串 (\"\")。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:163
msgid ""
"See the :command:`string(TIMESTAMP)` command for documentation of the "
"``<format>`` and ``UTC`` options."
msgstr ""
"有关 ``<format>`` 和 ``UTC`` 选项的文档，请参阅 :command:`string(TIMESTAMP)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:189
msgid ""
"Recursively get the list of libraries depended on by the given files."
msgstr "递归获取给定文件所依赖的库列表。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:191
msgid ""
"Please note that this sub-command is not intended to be used in project "
"mode. It is intended for use at install time, either from code generated "
"by the :command:`install(RUNTIME_DEPENDENCY_SET)` command, or from code "
"provided by the project via :command:`install(CODE)` or "
":command:`install(SCRIPT)`. For example:"
msgstr ""
"请注意，此子命令不适用于项目模式。它旨在在安装时使用，可以从 :command:`install(RUNTIME_DEPENDENCY_SET)` "
"命令生成的代码，或者来自项目通过 :command:`install(CODE)` 或 :command:`install(脚本）`。例如："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:205
msgid "The arguments are as follows:"
msgstr "论据如下："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:208
msgid "``RESOLVED_DEPENDENCIES_VAR <deps_var>``"
msgstr "``RESOLVED_DEPENDENCIES_VAR <deps_var>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:208
msgid ""
"Name of the variable in which to store the list of resolved dependencies."
msgstr "要在其中存储已解析依赖项列表的变量的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:213
msgid "``UNRESOLVED_DEPENDENCIES_VAR <unresolved_deps_var>``"
msgstr "``UNRESOLVED_DEPENDENCIES_VAR <unresolved_deps_var>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:211
msgid ""
"Name of the variable in which to store the list of unresolved "
"dependencies. If this variable is not specified, and there are any "
"unresolved dependencies, an error is issued."
msgstr "存储未解析依赖项列表的变量的名称。如果未指定此变量，并且存在任何未解决的依赖项，则会发出错误。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:221
msgid "``CONFLICTING_DEPENDENCIES_PREFIX <conflicting_deps_prefix>``"
msgstr "``CONFLICTING_DEPENDENCIES_PREFIX <conflicting_deps_prefix>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:216
msgid ""
"Variable prefix in which to store conflicting dependency information. "
"Dependencies are conflicting if two files with the same name are found in "
"two different directories. The list of filenames that conflict are stored "
"in ``<conflicting_deps_prefix>_FILENAMES``. For each filename, the list of"
" paths that were found for that filename are stored in "
"``<conflicting_deps_prefix>_<filename>``."
msgstr ""
"存储冲突依赖信息的变量前缀。如果在两个不同的目录中发现两个具有相同名称的文件，则相关性会发生冲突。冲突的文件名列表存储在“<conflicting_deps_prefix>_FILENAMES”中。对于每个文件名，为该文件名找到的路径列表存储在“<conflicting_deps_prefix>_<filename>”中。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:229
msgid "``EXECUTABLES <executable_files>``"
msgstr "``可执行文件 <executable_files>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:224
msgid ""
"List of executable files to read for dependencies. These are executables "
"that are typically created with :command:`add_executable`, but they do not"
" have to be created by CMake. On Apple platforms, the paths to these files"
" determine the value of ``@executable_path`` when recursively resolving "
"the libraries. Specifying any kind of library (``STATIC``, ``MODULE``, or "
"``SHARED``) here will result in undefined behavior."
msgstr ""
"要读取依赖项的可执行文件列表。这些是通常使用 :command:`add_executable` 创建的可执行文件，但它们不必由 CMake "
"创建。在 Apple "
"平台上，这些文件的路径决定了递归解析库时“@executable_path”的值。在此处指定任何类型的库（``STATIC``、``MODULE``"
" 或 ``SHARED``）将导致未定义的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:235
msgid "``LIBRARIES <library_files>``"
msgstr "``库 <library_files>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:232
msgid ""
"List of library files to read for dependencies. These are libraries that "
"are typically created with :command:`add_library(SHARED)`, but they do not"
" have to be created by CMake. Specifying ``STATIC`` libraries, ``MODULE`` "
"libraries, or executables here will result in undefined behavior."
msgstr ""
"要读取依赖项的库文件列表。这些库通常使用 :command:`add_library(SHARED)` 创建，但不必由 CMake 创建。在此处指定"
" ``STATIC`` 库、``MODULE`` 库或可执行文件将导致未定义的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:243
msgid "``MODULES <module_files>``"
msgstr "``模块 <module_files>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:238
msgid ""
"List of loadable module files to read for dependencies. These are modules "
"that are typically created with :command:`add_library(MODULE)`, but they "
"do not have to be created by CMake. They are typically used by calling "
"``dlopen()`` at runtime rather than linked at link time with ``ld -l``. "
"Specifying ``STATIC`` libraries, ``SHARED`` libraries, or executables here"
" will result in undefined behavior."
msgstr ""
"要读取依赖项的可加载模块文件列表。这些模块通常使用 :command:`add_library(MODULE)` 创建，但不必由 CMake "
"创建。它们通常通过在运行时调用 ``dlopen()`` 来使用，而不是在链接时与 ``ld -l`` 链接。在此处指定 ``STATIC`` "
"库、``SHARED`` 库或可执行文件将导致未定义的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:254
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:952
msgid "``DIRECTORIES <directories>``"
msgstr "``DIRECTORIES <目录>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:246
msgid ""
"List of additional directories to search for dependencies. On Linux "
"platforms, these directories are searched if the dependency is not found "
"in any of the other usual paths. If it is found in such a directory, a "
"warning is issued, because it means that the file is incomplete (it does "
"not list all of the directories that contain its dependencies). On Windows"
" platforms, these directories are searched if the dependency is not found "
"in any of the other search paths, but no warning is issued, because "
"searching other paths is a normal part of Windows dependency resolution. "
"On Apple platforms, this argument has no effect."
msgstr ""
"用于搜索依赖项的附加目录列表。在 Linux "
"平台上，如果在任何其他常用路径中找不到依赖项，则会搜索这些目录。如果在这样的目录中找到它，则会发出警告，因为这意味着该文件不完整（它没有列出包含其依赖项的所有目录）。在"
" Windows 平台上，如果在任何其他搜索路径中未找到依赖项，则会搜索这些目录，但不会发出警告，因为搜索其他路径是 Windows "
"依赖项解析的正常部分。在 Apple 平台上，此参数无效。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:263
msgid "``BUNDLE_EXECUTABLE <bundle_executable_file>``"
msgstr "``BUNDLE_EXECUTABLE <bundle_executable_file>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:257
msgid ""
"Executable to treat as the \"bundle executable\" when resolving libraries."
" On Apple platforms, this argument determines the value of "
"``@executable_path`` when recursively resolving libraries for "
"``LIBRARIES`` and ``MODULES`` files. It has no effect on ``EXECUTABLES`` "
"files. On other platforms, it has no effect. This is typically (but not "
"always) one of the executables in the ``EXECUTABLES`` argument which "
"designates the \"main\" executable of the package."
msgstr ""
"可执行文件在解析库时被视为“捆绑可执行文件”。在 Apple "
"平台上，当递归解析“LIBRARIES”和“MODULES”文件的库时，此参数确定“@executable_path”的值。它对“可执行文件”文件没有影响。在其他平台上，它没有效果。这通常（但不总是）是"
" ``EXECUTABLES`` 参数中的可执行文件之一，它指定包的“主要”可执行文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:265
msgid ""
"The following arguments specify filters for including or excluding "
"libraries to be resolved. See below for a full description of how they "
"work."
msgstr "以下参数指定用于包含或排除要解析的库的过滤器。有关它们如何工作的完整说明，请参见下文。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:270
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:953
msgid "``PRE_INCLUDE_REGEXES <regexes>``"
msgstr "``PRE_INCLUDE_REGEXES <正则表达式>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:269
msgid ""
"List of pre-include regexes through which to filter the names of not-yet-"
"resolved dependencies."
msgstr "预包含正则表达式列表，用于过滤尚未解析的依赖项的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:274
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:954
msgid "``PRE_EXCLUDE_REGEXES <regexes>``"
msgstr "``PRE_EXCLUDE_REGEXES <正则表达式>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:273
msgid ""
"List of pre-exclude regexes through which to filter the names of not-yet-"
"resolved dependencies."
msgstr "预先排除的正则表达式列表，用于过滤尚未解决的依赖项的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:278
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:955
msgid "``POST_INCLUDE_REGEXES <regexes>``"
msgstr "``POST_INCLUDE_REGEXES <正则表达式>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:277
msgid ""
"List of post-include regexes through which to filter the names of resolved"
" dependencies."
msgstr "post-include 正则表达式列表，用于过滤已解析依赖项的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:282
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:956
msgid "``POST_EXCLUDE_REGEXES <regexes>``"
msgstr "``POST_EXCLUDE_REGEXES <正则表达式>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:281
msgid ""
"List of post-exclude regexes through which to filter the names of resolved"
" dependencies."
msgstr "排除后正则表达式的列表，通过它来过滤已解析的依赖项的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:288
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:957
msgid "``POST_INCLUDE_FILES <files>``"
msgstr "``POST_INCLUDE_FILES <文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:287
msgid ""
"List of post-include filenames through which to filter the names of "
"resolved dependencies. Symlinks are resolved when attempting to match "
"these filenames."
msgstr "用于过滤已解析依赖项名称的后包含文件名列表。尝试匹配这些文件名时解析符号链接。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:294
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:958
msgid "``POST_EXCLUDE_FILES <files>``"
msgstr "``POST_EXCLUDE_FILES <文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:293
msgid ""
"List of post-exclude filenames through which to filter the names of "
"resolved dependencies. Symlinks are resolved when attempting to match "
"these filenames."
msgstr "排除后文件名列表，通过它过滤已解析依赖项的名称。尝试匹配这些文件名时解析符号链接。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:296
msgid ""
"These arguments can be used to exclude unwanted system libraries when "
"resolving the dependencies, or to include libraries from a specific "
"directory. The filtering works as follows:"
msgstr "这些参数可用于在解析依赖项时排除不需要的系统库，或包含来自特定目录的库。过滤工作如下："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:300
msgid ""
"If the not-yet-resolved dependency matches any of the "
"``PRE_INCLUDE_REGEXES``, steps 2 and 3 are skipped, and the dependency "
"resolution proceeds to step 4."
msgstr ""
"如果尚未解决的依赖项与任何一个``PRE_INCLUDE_REGEXES`` 匹配，则跳过第 2 步和第 3 步，并且依赖项解决方案继续进行到第 4"
" 步。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:303
msgid ""
"If the not-yet-resolved dependency matches any of the "
"``PRE_EXCLUDE_REGEXES``, dependency resolution stops for that dependency."
msgstr "如果尚未解决的依赖项与任何“PRE_EXCLUDE_REGEXES”匹配，则该依赖项的依赖项解析将停止。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:305
msgid "Otherwise, dependency resolution proceeds."
msgstr "否则，依赖解析继续进行。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:306
msgid ""
"``file(GET_RUNTIME_DEPENDENCIES)`` searches for the dependency according "
"to the linking rules of the platform (see below)."
msgstr "``file(GET_RUNTIME_DEPENDENCIES)`` 根据平台的链接规则搜索依赖（见下文）。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:308
msgid ""
"If the dependency is found, and its full path matches one of the "
"``POST_INCLUDE_REGEXES`` or ``POST_INCLUDE_FILES``, the full path is added"
" to the resolved dependencies, and ``file(GET_RUNTIME_DEPENDENCIES)`` "
"recursively resolves that library's own dependencies. Otherwise, "
"resolution proceeds to step 6."
msgstr ""
"如果找到依赖项，并且其完整路径与 POST_INCLUDE_REGEXES 或 POST_INCLUDE_FILES "
"之一匹配，则将完整路径添加到已解析的依赖项中，并且 file(GET_RUNTIME_DEPENDENCIES) "
"递归地解析该库自己的依赖项。否则，解决方案进行到步骤 6。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:313
msgid ""
"If the dependency is found, but its full path matches one of the "
"``POST_EXCLUDE_REGEXES`` or ``POST_EXCLUDE_FILES``, it is not added to the"
" resolved dependencies, and dependency resolution stops for that "
"dependency."
msgstr ""
"如果找到依赖项，但其完整路径与“POST_EXCLUDE_REGEXES”或“POST_EXCLUDE_FILES”之一匹配，则不会将其添加到已解析的依赖项中，并且该依赖项的依赖项解析将停止。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:316
msgid ""
"If the dependency is found, and its full path does not match either "
"``POST_INCLUDE_REGEXES``, ``POST_INCLUDE_FILES``, "
"``POST_EXCLUDE_REGEXES``, or ``POST_EXCLUDE_FILES``, the full path is "
"added to the resolved dependencies, and ``file(GET_RUNTIME_DEPENDENCIES)``"
"  recursively resolves that library's own dependencies."
msgstr ""
"如果找到依赖项，并且其完整路径与 "
"``POST_INCLUDE_REGEXES``、``POST_INCLUDE_FILES``、``POST_EXCLUDE_REGEXES`` 或"
" ``POST_EXCLUDE_FILES`` "
"不匹配，则将完整路径添加到已解析的依赖项中，并且``file(GET_RUNTIME_DEPENDENCIES)`` 递归解析该库自身的依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:322
msgid ""
"Different platforms have different rules for how dependencies are "
"resolved. These specifics are described here."
msgstr "不同的平台对于如何解决依赖关系有不同的规则。这些细节在此处描述。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:325
msgid "On Linux platforms, library resolution works as follows:"
msgstr "在 Linux 平台上，库解析的工作方式如下："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:327
msgid ""
"If the depending file does not have any ``RUNPATH`` entries, and the "
"library exists in one of the depending file's ``RPATH`` entries, or its "
"parents', in that order, the dependency is resolved to that file."
msgstr ""
"如果依赖文件没有任何 ``RUNPATH`` 条目，并且库按该顺序存在于依赖文件的 ``RPATH`` 条目之一或其父项中，则依赖项将解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:330
msgid ""
"Otherwise, if the depending file has any ``RUNPATH`` entries, and the "
"library exists in one of those entries, the dependency is resolved to that"
" file."
msgstr "否则，如果依赖文件有任何“RUNPATH”条目，并且库存在于其中一个条目中，则依赖项将解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:333
msgid ""
"Otherwise, if the library exists in one of the directories listed by "
"``ldconfig``, the dependency is resolved to that file."
msgstr "否则，如果库存在于 ldconfig 列出的目录之一中，则依赖项将解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:335
msgid ""
"Otherwise, if the library exists in one of the ``DIRECTORIES`` entries, "
"the dependency is resolved to that file. In this case, a warning is "
"issued, because finding a file in one of the ``DIRECTORIES`` means that "
"the depending file is not complete (it does not list all the directories "
"from which it pulls dependencies)."
msgstr ""
"否则，如果库存在于“DIRECTORIES”条目之一中，则依赖项将解析为该文件。在这种情况下，会发出警告，因为在“DIRECTORIES”之一中找到文件意味着依赖文件不完整（它没有列出从中提取依赖项的所有目录）。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:340
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:388
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:410
msgid "Otherwise, the dependency is unresolved."
msgstr "否则，依赖关系无法解决。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:342
msgid "On Windows platforms, library resolution works as follows:"
msgstr "在 Windows 平台上，库解析的工作方式如下："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:344
msgid ""
"The dependent DLL name is converted to lowercase. Windows DLL names are "
"case-insensitive, and some linkers mangle the case of the DLL dependency "
"names. However, this makes it more difficult for ``PRE_INCLUDE_REGEXES``, "
"``PRE_EXCLUDE_REGEXES``, ``POST_INCLUDE_REGEXES``, and "
"``POST_EXCLUDE_REGEXES`` to properly filter DLL names - every regex would "
"have to check for both uppercase and lowercase letters. For example:"
msgstr ""
"从属 DLL 名称转换为小写。 Windows DLL 名称不区分大小写，一些链接器会破坏 DLL 依赖项名称的大小写。然而，这使得 "
"``PRE_INCLUDE_REGEXES``、``PRE_EXCLUDE_REGEXES``、``POST_INCLUDE_REGEXES`` 和"
" ``POST_EXCLUDE_REGEXES`` 更难正确过滤 DLL 名称——每个正则表达式都必须检查大写和小写字母.例如："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:358
msgid ""
"Converting the DLL name to lowercase allows the regexes to only match "
"lowercase names, thus simplifying the regex. For example:"
msgstr "将 DLL 名称转换为小写允许正则表达式仅匹配小写名称，从而简化了正则表达式。例如："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:368
msgid ""
"This regex will match ``mylibrary.dll`` regardless of how it is cased, "
"either on disk or in the depending file. (For example, it will match "
"``mylibrary.dll``, ``MyLibrary.dll``, and ``MYLIBRARY.DLL``.)"
msgstr ""
"这个正则表达式将匹配 ``mylibrary.dll`` 而不管它是如何大小写的，无论是在磁盘上还是在依赖文件中。 "
"（例如，它将匹配“mylibrary.dll”、“MyLibrary.dll”和“MYLIBRARY.DLL”。）"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:372
msgid ""
"Please note that the directory portion of any resolved DLLs retains its "
"casing and is not converted to lowercase. Only the filename portion is "
"converted."
msgstr "请注意，任何解析的 DLL 的目录部分都保留其大小写，不会转换为小写。仅转换文件名部分。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:376
msgid ""
"(**Not yet implemented**) If the depending file is a Windows Store app, "
"and the dependency is listed as a dependency in the application's package "
"manifest, the dependency is resolved to that file."
msgstr ""
"（**尚未实现**）如果依赖文件是 Windows 应用商店应用程序，并且依赖项在应用程序的包清单中列为依赖项，则依赖项将解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:379
msgid ""
"Otherwise, if the library exists in the same directory as the depending "
"file, the dependency is resolved to that file."
msgstr "否则，如果库与依赖文件存在于同一目录中，则依赖项将解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:381
msgid ""
"Otherwise, if the library exists in either the operating system's "
"``system32`` directory or the ``Windows`` directory, in that order, the "
"dependency is resolved to that file."
msgstr "否则，如果该库存在于操作系统的 ``system32`` 目录或 ``Windows`` 目录中，则依序将依赖项解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:384
msgid ""
"Otherwise, if the library exists in one of the directories specified by "
"``DIRECTORIES``, in the order they are listed, the dependency is resolved "
"to that file. In this case, a warning is not issued, because searching "
"other directories is a normal part of Windows library resolution."
msgstr ""
"否则，如果库存在于 ``DIRECTORIES`` "
"指定的目录之一中，则按照它们列出的顺序，依赖项将解析为该文件。在这种情况下，不会发出警告，因为搜索其他目录是 Windows 库解析的正常部分。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:390
msgid "On Apple platforms, library resolution works as follows:"
msgstr "在 Apple 平台上，库解析的工作方式如下："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:392
msgid ""
"If the dependency starts with ``@executable_path/``, and an "
"``EXECUTABLES`` argument is in the process of being resolved, and "
"replacing ``@executable_path/`` with the directory of the executable "
"yields an existing file, the dependency is resolved to that file."
msgstr ""
"如果依赖项以“@executable_path/”开头，并且“EXECUTABLES”参数正在解析过程中，并且用可执行文件的目录替换“@executable_path/”会产生一个现有文件，则依赖项解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:396
msgid ""
"Otherwise, if the dependency starts with ``@executable_path/``, and there "
"is a ``BUNDLE_EXECUTABLE`` argument, and replacing ``@executable_path/`` "
"with the directory of the bundle executable yields an existing file, the "
"dependency is resolved to that file."
msgstr ""
"否则，如果依赖项以“@executable_path/”开头，并且有一个“BUNDLE_EXECUTABLE”参数，并且将“@executable_path/”替换为捆绑可执行文件的目录会产生一个现有文件，则依赖项是解析到那个文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:400
msgid ""
"Otherwise, if the dependency starts with ``@loader_path/``, and replacing "
"``@loader_path/`` with the directory of the depending file yields an "
"existing file, the dependency is resolved to that file."
msgstr ""
"否则，如果依赖项以“@loader_path/”开头，并且用依赖文件的目录替换“@loader_path/”会产生一个现有文件，则依赖项将解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:403
msgid ""
"Otherwise, if the dependency starts with ``@rpath/``, and replacing "
"``@rpath/`` with one of the ``RPATH`` entries of the depending file yields"
" an existing file, the dependency is resolved to that file. Note that "
"``RPATH`` entries that start with ``@executable_path/`` or "
"``@loader_path/`` also have these items replaced with the appropriate "
"path."
msgstr ""
"否则，如果依赖项以“@rpath/”开头，并将“@rpath/”替换为依赖文件的“RPATH”条目之一会产生一个现有文件，则依赖项将解析为该文件.请注意，以“@executable_path/”或“@loader_path/”开头的“RPATH”条目也将这些项目替换为适当的路径。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:408
msgid ""
"Otherwise, if the dependency is an absolute file that exists, the "
"dependency is resolved to that file."
msgstr "否则，如果依赖项是存在的绝对文件，则依赖项将解析为该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:412
msgid ""
"This function accepts several variables that determine which tool is used "
"for dependency resolution:"
msgstr "此函数接受几个变量，这些变量确定使用哪个工具来解决依赖关系："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:417
msgid ""
"Determines which operating system and executable format the files are "
"built for. This could be one of several values:"
msgstr "确定文件是为哪种操作系统和可执行格式构建的。这可能是以下几个值之一："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:420
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:436
msgid "``linux+elf``"
msgstr "``linux+精灵``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:421
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:437
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:438
msgid "``windows+pe``"
msgstr "``windows+pe``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:422
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:439
msgid "``macos+macho``"
msgstr "``macos+猛男``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:424
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:442
msgid ""
"If this variable is not specified, it is determined automatically by "
"system introspection."
msgstr "如果未指定此变量，则由系统自检自动确定。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:429
msgid ""
"Determines the tool to use for dependency resolution. It could be one of "
"several values, depending on the value of "
":variable:`CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM`:"
msgstr ""
"确定用于依赖项解析的工具。它可以是几个值之一，具体取决于 CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM 的值："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:434
msgid "``CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM``"
msgstr "``CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:434
msgid "``CMAKE_GET_RUNTIME_DEPENDENCIES_TOOL``"
msgstr "``CMAKE_GET_RUNTIME_DEPENDENCIES_TOOL``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:436
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:438
msgid "``objdump``"
msgstr "``objdump``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:437
msgid "``dumpbin``"
msgstr "``垃圾箱``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:439
msgid "``otool``"
msgstr "``otool``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:447
msgid ""
"Determines the path to the tool to use for dependency resolution. This is "
"the actual path to ``objdump``, ``dumpbin``, or ``otool``."
msgstr "确定用于依赖项解析的工具的路径。这是“objdump”、“dumpbin”或“otool”的实际路径。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:450
msgid ""
"If this variable is not specified, it is determined by the value of "
"``CMAKE_OBJDUMP`` if set, else by system introspection."
msgstr "如果未指定此变量，则由“CMAKE_OBJDUMP”的值（如果已设置）确定，否则由系统自检确定。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:453
msgid "Use ``CMAKE_OBJDUMP`` if set."
msgstr "如果设置，请使用 ``CMAKE_OBJDUMP``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:457
msgid "Writing"
msgstr "写作"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:467
msgid ""
"Write ``<content>`` into a file called ``<filename>``.  If the file does "
"not exist, it will be created.  If the file already exists, ``WRITE`` mode"
" will overwrite it and ``APPEND`` mode will append to the end. Any "
"directories in the path specified by ``<filename>`` that do not exist will"
" be created."
msgstr ""
"将 ``<content>`` 写入名为 ``<filename>`` 的文件中。如果该文件不存在，将创建它。如果文件已经存在，``WRITE`` "
"模式将覆盖它，``APPEND`` 模式将追加到末尾。将创建由 ``<filename>`` 指定的路径中不存在的任何目录。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:473
msgid ""
"If the file is a build input, use the :command:`configure_file` command to"
" update the file only when its content changes."
msgstr "如果该文件是构建输入，请使用 :command:`configure_file` 命令仅在其内容更改时更新文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:486
msgid ""
"Create a file with no content if it does not yet exist. If the file "
"already exists, its access and/or modification will be updated to the time"
" when the function call is executed."
msgstr "如果文件尚不存在，则创建一个没有内容的文件。如果文件已经存在，它的访问和/或修改将被更新到执行函数调用的时间。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:490
msgid ""
"Use TOUCH_NOCREATE to touch a file if it exists but not create it. If a "
"file does not exist it will be silently ignored."
msgstr "如果文件存在但不创建它，请使用 TOUCH_NOCREATE 来触摸它。如果文件不存在，它将被静默忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:493
msgid ""
"With TOUCH and TOUCH_NOCREATE the contents of an existing file will not be"
" modified."
msgstr "使用 TOUCH 和 TOUCH_NOCREATE 不会修改现有文件的内容。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:507
msgid ""
"Generate an output file for each build configuration supported by the "
"current :manual:`CMake Generator <cmake-generators(7)>`.  Evaluate "
":manual:`generator expressions <cmake-generator-expressions(7)>` from the "
"input content to produce the output content.  The options are:"
msgstr ""
"为当前 :manual:`CMake Generator <cmake-generators(7)>` "
"支持的每个构建配置生成一个输出文件。从输入内容中计算生成器表达式 <cmake-generator-expressions(7)> "
"以生成输出内容。选项是："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:515
msgid "``CONDITION <condition>``"
msgstr "``条件<条件>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:513
msgid ""
"Generate the output file for a particular configuration only if the "
"condition is true.  The condition must be either ``0`` or ``1`` after "
"evaluating generator expressions."
msgstr "仅当条件为真时才为特定配置生成输出文件。在评估生成器表达式后，条件必须是 ``0`` 或 ``1``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:518
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:611
msgid "``CONTENT <content>``"
msgstr "``内容<内容>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:518
msgid "Use the content given explicitly as input."
msgstr "使用明确给出的内容作为输入。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:525
msgid "``INPUT <input-file>``"
msgstr "``INPUT <输入文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:521
msgid "Use the content from a given file as input."
msgstr "使用给定文件的内容作为输入。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:523
msgid ""
"A relative path is treated with respect to the value of "
":variable:`CMAKE_CURRENT_SOURCE_DIR`.  See policy :policy:`CMP0070`."
msgstr "相对路径根据 CMAKE_CURRENT_SOURCE_DIR 的值进行处理。请参阅政策:policy:`CMP0070`。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:537
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:607
msgid "``OUTPUT <output-file>``"
msgstr "``OUTPUT <输出文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:528
msgid ""
"Specify the output file name to generate.  Use generator expressions such "
"as :genex:`$<CONFIG>` to specify a configuration-specific output file "
"name.  Multiple configurations may generate the same output file only if "
"the generated content is identical.  Otherwise, the ``<output-file>`` must"
" evaluate to an unique name for each configuration."
msgstr ""
"指定要生成的输出文件名。使用 :genex:`$<CONFIG>` "
"等生成器表达式来指定特定于配置的输出文件名。仅当生成的内容相同时，多个配置才可能生成相同的输出文件。否则，``<output-file>`` "
"必须为每个配置评估一个唯一的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:534
msgid ""
"A relative path (after evaluating generator expressions) is treated with "
"respect to the value of :variable:`CMAKE_CURRENT_BINARY_DIR`. See policy "
":policy:`CMP0070`."
msgstr ""
"相对路径（在评估生成器表达式之后）根据 CMAKE_CURRENT_BINARY_DIR 的值进行处理。请参阅政策:policy:`CMP0070`。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:545
msgid "``TARGET <target>``"
msgstr "``目标<目标>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:542
msgid ""
"Specify which target to use when evaluating generator expressions that "
"require a target for evaluation (e.g. :genex:`$<COMPILE_FEATURES:...>`, "
":genex:`$<TARGET_PROPERTY:prop>`)."
msgstr ""
"指定在评估需要评估目标的生成器表达式时使用哪个目标（例如:genex:`$<COMPILE_FEATURES:...>`、 :genex:`$<TARGET_PROPERTY:prop>`）。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:550
msgid ""
"The generated file permissions default to the standard 644 value (-rw-r--"
"r--)."
msgstr "生成的文件权限默认为标准 644 值 (-rw-r--r--)。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:556
msgid ""
"Transfer the file permissions of the ``INPUT`` file to the generated file."
" This is already the default behavior if none of the three permissions-"
"related keywords are given (``NO_SOURCE_PERMISSIONS``, "
"``USE_SOURCE_PERMISSIONS`` or ``FILE_PERMISSIONS``).  The "
"``USE_SOURCE_PERMISSIONS`` keyword mostly serves as a way of making the "
"intended behavior clearer at the call site. It is an error to specify this"
" option without ``INPUT``."
msgstr ""
"将 ``INPUT`` "
"文件的文件权限转移到生成的文件。如果没有给出三个与权限相关的关键字（``NO_SOURCE_PERMISSIONS``、``USE_SOURCE_PERMISSIONS``"
" 或``FILE_PERMISSIONS``），这已经是默认行为。 ``USE_SOURCE_PERMISSIONS`` "
"关键字主要用作在调用站点使预期行为更清晰的一种方式。在没有 ``INPUT`` 的情况下指定此选项是错误的。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:566
msgid "Use the specified permissions for the generated file."
msgstr "对生成的文件使用指定的权限。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:571
msgid ""
"Specify the newline style for the generated file.  Specify ``UNIX`` or "
"``LF`` for ``\\n`` newlines, or specify ``DOS``, ``WIN32``, or ``CRLF`` "
"for ``\\r\\n`` newlines."
msgstr ""
"为生成的文件指定换行样式。为 `\\n`` 换行符指定 ``UNIX`` 或 ``LF``，或者为 ``\\r\\n`` 指定 "
"``DOS``、``WIN32`` 或 ``CRLF``换行符。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:575
msgid ""
"Exactly one ``CONTENT`` or ``INPUT`` option must be given.  A specific "
"``OUTPUT`` file may be named by at most one invocation of "
"``file(GENERATE)``. Generated files are modified and their timestamp "
"updated on subsequent cmake runs only if their content is changed."
msgstr ""
"必须给出恰好一个 ``CONTENT`` 或 ``INPUT`` 选项。一个特定的 ``OUTPUT`` 文件最多可以通过调用 "
"``file(GENERATE)`` 来命名。仅当生成的文件的内容发生更改时，才会修改生成的文件，并在随后的 cmake 运行中更新它们的时间戳。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:580
msgid ""
"Note also that ``file(GENERATE)`` does not create the output file until "
"the generation phase. The output file will not yet have been written when "
"the ``file(GENERATE)`` command returns, it is written only after "
"processing all of a project's ``CMakeLists.txt`` files."
msgstr ""
"另请注意，``file(GENERATE)`` 直到生成阶段才会创建输出文件。当 ``file(GENERATE)`` "
"命令返回时，输出文件还没有被写入，只有在处理完项目的所有 ``CMakeLists.txt`` 文件后才会被写入。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:596
msgid ""
"Generate an output file using the input given by ``CONTENT`` and "
"substitute variable values referenced as ``@VAR@`` or ``${VAR}`` contained"
" therein. The substitution rules behave the same as the "
":command:`configure_file` command. In order to match "
":command:`configure_file`'s behavior, generator expressions are not "
"supported for both ``OUTPUT`` and ``CONTENT``."
msgstr ""
"使用“CONTENT”给出的输入生成一个输出文件，并替换其中包含的引用为“@VAR@”或“${VAR}”的变量值。替换规则的行为与 "
":command:`configure_file` 命令相同。为了匹配 :command:`configure_file` "
"的行为，``OUTPUT`` 和 ``CONTENT`` 都不支持生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:605
msgid ""
"Specify the output file name to generate. A relative path is treated with "
"respect to the value of :variable:`CMAKE_CURRENT_BINARY_DIR`. ``<output-"
"file>`` does not support generator expressions."
msgstr ""
"指定要生成的输出文件名。相对路径根据 CMAKE_CURRENT_BINARY_DIR 的值进行处理。 ``<output-file>`` "
"不支持生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:610
msgid ""
"Use the content given explicitly as input. ``<content>`` does not support "
"generator expressions."
msgstr "使用明确给出的内容作为输入。 ``<content>`` 不支持生成器表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:621
msgid ""
"Specify the newline style for the output file.  Specify ``UNIX`` or ``LF``"
" for ``\\n`` newlines, or specify ``DOS``, ``WIN32``, or ``CRLF`` for "
"``\\r\\n`` newlines."
msgstr ""
"指定输出文件的换行样式。为 `\\n`` 换行符指定 ``UNIX`` 或 ``LF``，或者为 ``\\r\\n`` 指定 "
"``DOS``、``WIN32`` 或 ``CRLF``换行符。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:626
msgid "Filesystem"
msgstr "文件系统"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:640
msgid ""
"Generate a list of files that match the ``<globbing-expressions>`` and "
"store it into the ``<variable>``.  Globbing expressions are similar to "
"regular expressions, but much simpler.  If ``RELATIVE`` flag is specified,"
" the results will be returned as relative paths to the given path."
msgstr ""
"生成匹配``<globbing-expressions>`` 的文件列表并将其存储到``<variable>`` 中。 Globbing "
"表达式类似于正则表达式，但更简单。如果指定了 ``RELATIVE`` 标志，结果将作为给定路径的相对路径返回。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:646
msgid "The results will be ordered lexicographically."
msgstr "结果将按字典顺序排列。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:649
msgid ""
"On Windows and macOS, globbing is case-insensitive even if the underlying "
"filesystem is case-sensitive (both filenames and globbing expressions are "
"converted to lowercase before matching).  On other platforms, globbing is "
"case-sensitive."
msgstr ""
"在 Windows 和 macOS "
"上，通配不区分大小写，即使底层文件系统区分大小写（文件名和通配表达式在匹配之前都转换为小写）。在其他平台上，globbing 区分大小写。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:654
msgid ""
"By default ``GLOB`` lists directories - directories are omitted in result "
"if ``LIST_DIRECTORIES`` is set to false."
msgstr "默认情况下，``GLOB`` 列出目录 - 如果 ``LIST_DIRECTORIES`` 设置为 false，则结果中会省略目录。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:658
msgid ""
"If the ``CONFIGURE_DEPENDS`` flag is specified, CMake will add logic to "
"the main build system check target to rerun the flagged ``GLOB`` commands "
"at build time. If any of the outputs change, CMake will regenerate the "
"build system."
msgstr ""
"如果指定了 ``CONFIGURE_DEPENDS`` 标志，CMake 将向主构建系统检查目标添加逻辑，以在构建时重新运行标记的 ``GLOB``"
" 命令。如果任何输出发生变化，CMake 将重新生成构建系统。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:665
msgid ""
"We do not recommend using GLOB to collect a list of source files from your"
" source tree.  If no CMakeLists.txt file changes when a source is added or"
" removed then the generated build system cannot know when to ask CMake to "
"regenerate. The ``CONFIGURE_DEPENDS`` flag may not work reliably on all "
"generators, or if a new generator is added in the future that cannot "
"support it, projects using it will be stuck. Even if ``CONFIGURE_DEPENDS``"
" works reliably, there is still a cost to perform the check on every "
"rebuild."
msgstr ""
"我们不建议使用 GLOB 从源代码树中收集源文件列表。如果在添加或删除源时没有 CMakeLists.txt "
"文件更改，则生成的构建系统无法知道何时要求 CMake 重新生成。 ``CONFIGURE_DEPENDS`` "
"标志可能无法在所有生成器上可靠地工作，或者如果将来添加不能支持它的新生成器，使用它的项目将被卡住。即使 ``CONFIGURE_DEPENDS`` "
"可靠地工作，对每次重建执行检查仍然需要成本。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:674
msgid "Examples of globbing expressions include::"
msgstr "通配表达式的示例包括："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:680
msgid ""
"The ``GLOB_RECURSE`` mode will traverse all the subdirectories of the "
"matched directory and match the files.  Subdirectories that are symlinks "
"are only traversed if ``FOLLOW_SYMLINKS`` is given or policy "
":policy:`CMP0009` is not set to ``NEW``."
msgstr ""
"``GLOB_RECURSE`` "
"模式会遍历匹配目录的所有子目录，匹配文件。只有在给出“FOLLOW_SYMLINKS”或策略:policy:“CMP0009”未设置为“NEW”时，才会遍历作为符号链接的子目录。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:685
msgid ""
"By default ``GLOB_RECURSE`` omits directories from result list - setting "
"``LIST_DIRECTORIES`` to true adds directories to result list. If "
"``FOLLOW_SYMLINKS`` is given or policy :policy:`CMP0009` is not set to "
"``NEW`` then ``LIST_DIRECTORIES`` treats symlinks as directories."
msgstr ""
"默认情况下，``GLOB_RECURSE`` 会从结果列表中省略目录 - 将 ``LIST_DIRECTORIES`` 设置为 true "
"会将目录添加到结果列表中。如果给出“FOLLOW_SYMLINKS”或策略:policy:“CMP0009”未设置为“NEW”，则“LIST_DIRECTORIES”将符号链接视为目录。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:691
msgid "Examples of recursive globbing include::"
msgstr "递归通配符的示例包括："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:701
msgid "Create the given directories and their parents as needed."
msgstr "根据需要创建给定目录及其父目录。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:711
msgid ""
"Remove the given files.  The ``REMOVE_RECURSE`` mode will remove the given"
" files and directories, also non-empty directories. No error is emitted if"
" a given file does not exist.  Relative input paths are evaluated with "
"respect to the current source directory."
msgstr ""
"删除给定的文件。 ``REMOVE_RECURSE`` "
"模式将删除给定的文件和目录，也包括非空目录。如果给定文件不存在，则不会发出错误。相对输入路径根据当前源目录进行评估。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:716
msgid ""
"Empty input paths are ignored with a warning.  Previous versions of CMake "
"interpreted empty strings as a relative path with respect to the current "
"directory and removed its contents."
msgstr "空输入路径将被忽略并发出警告。以前版本的 CMake 将空字符串解释为相对于当前目录的相对路径并删除其内容。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:729
msgid ""
"Move a file or directory within a filesystem from ``<oldname>`` to "
"``<newname>``, replacing the destination atomically."
msgstr "将文件系统中的文件或目录从 ``<oldname>`` 移动到 ``<newname>``，以原子方式替换目标。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:738
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:766
msgid "``RESULT <result>``"
msgstr "``结果<结果>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:737
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:765
msgid ""
"Set ``<result>`` variable to ``0`` on success or an error message "
"otherwise. If ``RESULT`` is not specified and the operation fails, an "
"error is emitted."
msgstr "成功时将“<result>”变量设置为“0”，否则会出现错误消息。如果未指定 RESULT 且操作失败，则会发出错误。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:745
msgid "``NO_REPLACE``"
msgstr "``NO_REPLACE``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:743
msgid ""
"If the ``<newname>`` path already exists, do not replace it. If ``RESULT "
"<result>`` is used, the result variable will be set to ``NO_REPLACE``.  "
"Otherwise, an error is emitted."
msgstr ""
"如果``<newname>``路径已经存在，不要替换它。如果使用``RESULT "
"<result>``，结果变量将被设置为``NO_REPLACE``。否则，将发出错误。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:758
msgid ""
"Copy a file from ``<oldname>`` to ``<newname>``. Directories are not "
"supported. Symlinks are ignored and ``<oldfile>``'s content is read and "
"written to ``<newname>`` as a new file."
msgstr ""
"将文件从 ``<oldname>`` 复制到 ``<newname>``。不支持目录。符号链接被忽略，``<oldfile>`` 的内容被读取并写入"
" ``<newname>`` 作为一个新文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:771
msgid "``ONLY_IF_DIFFERENT``"
msgstr "``ONLY_IF_DIFFERENT``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:769
msgid ""
"If the ``<newname>`` path already exists, do not replace it if the file's "
"contents are already the same as ``<oldname>`` (this avoids updating "
"``<newname>``'s timestamp)."
msgstr ""
"如果 ``<newname>`` 路径已经存在，如果文件内容已经与 ``<oldname>`` 相同，则不要替换它（这避免更新 "
"``<newname>`` 的时间戳）。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:779
msgid "``INPUT_MAY_BE_RECENT``"
msgstr "``INPUT_MAY_BE_RECENT``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:776
msgid ""
"Tell CMake that the input file may have been recently created.  This is "
"meaningful only on Windows, where files may be inaccessible for a short "
"time after they are created.  With this option, if permission is denied, "
"CMake will retry reading the input a few times."
msgstr ""
"告诉 CMake 输入文件可能是最近创建的。这仅在 Windows 上有意义，在 Windows "
"上，文件在创建后可能会在短时间内无法访问。使用此选项，如果权限被拒绝，CMake 将重试几次读取输入。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:781
msgid ""
"This sub-command has some similarities to :command:`configure_file` with "
"the ``COPYONLY`` option.  An important difference is that "
":command:`configure_file` creates a dependency on the source file, so "
"CMake will be re-run if it changes. The ``file(COPY_FILE)`` sub-command "
"does not create such a dependency."
msgstr ""
"这个子命令与带有 ``COPYONLY`` 选项的 :command:`configure_file` 有一些相似之处。一个重要的区别是 "
":command:`configure_file` 创建了对源文件的依赖，因此如果它发生变化，CMake 将重新运行。 "
"``file(COPY_FILE)`` 子命令不会创建这样的依赖关系。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:786
msgid ""
"See also the ``file(COPY)`` sub-command just below which provides further "
"file-copying capabilities."
msgstr "另请参阅下面的 ``file(COPY)`` 子命令，它提供了进一步的文件复制功能。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:805
msgid ""
"For a simple file copying operation, the ``file(COPY_FILE)`` sub-command "
"just above may be easier to use."
msgstr "对于简单的文件复制操作，上面的 ``file(COPY_FILE)`` 子命令可能更容易使用。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:808
msgid ""
"The ``COPY`` signature copies files, directories, and symlinks to a "
"destination folder.  Relative input paths are evaluated with respect to "
"the current source directory, and a relative destination is evaluated with"
" respect to the current build directory.  Copying preserves input file "
"timestamps, and optimizes out a file if it exists at the destination with "
"the same timestamp.  Copying preserves input permissions unless explicit "
"permissions or ``NO_SOURCE_PERMISSIONS`` are given (default is "
"``USE_SOURCE_PERMISSIONS``)."
msgstr ""
"``COPY`` "
"签名将文件、目录和符号链接复制到目标文件夹。相对输入路径是相对于当前源目录进行评估的，相对目标是相对于当前构建目录进行评估的。复制会保留输入文件时间戳，并优化文件（如果它存在于目标位置且具有相同时间戳）。复制保留输入权限，除非给出明确的权限或"
" ``NO_SOURCE_PERMISSIONS``（默认为 ``USE_SOURCE_PERMISSIONS``）。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:817
msgid ""
"If ``FOLLOW_SYMLINK_CHAIN`` is specified, ``COPY`` will recursively "
"resolve the symlinks at the paths given until a real file is found, and "
"install a corresponding symlink in the destination for each symlink "
"encountered. For each symlink that is installed, the resolution is "
"stripped of the directory, leaving only the filename, meaning that the new"
" symlink points to a file in the same directory as the symlink. This "
"feature is useful on some Unix systems, where libraries are installed as a"
" chain of symlinks with version numbers, with less specific versions "
"pointing to more specific versions. ``FOLLOW_SYMLINK_CHAIN`` will install "
"all of these symlinks and the library itself into the destination "
"directory. For example, if you have the following directory structure:"
msgstr ""
"如果指定了“FOLLOW_SYMLINK_CHAIN”，“COPY”将递归解析给定路径上的符号链接，直到找到真实文件，并在目标中为遇到的每个符号链接安装相应的符号链接。对于安装的每个符号链接，解析都会去掉目录，只留下文件名，这意味着新的符号链接指向与符号链接位于同一目录中的文件。此功能在某些"
" Unix 系统上很有用，其中库作为带有版本号的符号链接链安装，不太具体的版本指向更具体的版本。 ``FOLLOW_SYMLINK_CHAIN`` "
"会将所有这些符号链接和库本身安装到目标目录中。例如，如果您具有以下目录结构："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:830
msgid "``/opt/foo/lib/libfoo.so.1.2.3``"
msgstr "``/opt/foo/lib/libfoo.so.1.2.3``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:831
msgid "``/opt/foo/lib/libfoo.so.1.2 -> libfoo.so.1.2.3``"
msgstr "``/opt/foo/lib/libfoo.so.1.2 -> libfoo.so.1.2.3``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:832
msgid "``/opt/foo/lib/libfoo.so.1 -> libfoo.so.1.2``"
msgstr "``/opt/foo/lib/libfoo.so.1 -> libfoo.so.1.2``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:833
msgid "``/opt/foo/lib/libfoo.so -> libfoo.so.1``"
msgstr "``/opt/foo/lib/libfoo.so -> libfoo.so.1``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:835
msgid "and you do:"
msgstr "你也是："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:841
msgid ""
"This will install all of the symlinks and ``libfoo.so.1.2.3`` itself into "
"``lib``."
msgstr "这会将所有符号链接和 libfoo.so.1.2.3 本身安装到 lib 中。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:844
msgid ""
"See the :command:`install(DIRECTORY)` command for documentation of "
"permissions, ``FILES_MATCHING``, ``PATTERN``, ``REGEX``, and ``EXCLUDE`` "
"options.  Copying directories preserves the structure of their content "
"even if options are used to select a subset of files."
msgstr ""
"有关权限、FILES_MATCHING、PATTERN、REGEX 和 EXCLUDE "
"选项的文档，请参阅 :command:`install(DIRECTORY)` "
"命令。复制目录会保留其内容的结构，即使使用选项来选择文件的子集也是如此。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:850
msgid ""
"The ``INSTALL`` signature differs slightly from ``COPY``: it prints status"
" messages, and ``NO_SOURCE_PERMISSIONS`` is default."
msgstr ""
"``INSTALL`` 签名与``COPY`` 略有不同：它打印状态消息，``NO_SOURCE_PERMISSIONS`` 是默认的。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:853
msgid ""
"Installation scripts generated by the :command:`install` command use this "
"signature (with some undocumented options for internal use)."
msgstr ":command:`install` 命令生成的安装脚本使用此签名（带有一些供内部使用的未记录选项）。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:858
msgid ""
"The environment variable :envvar:`CMAKE_INSTALL_MODE` can override the "
"default copying behavior of :command:`file(INSTALL)`."
msgstr ""
"环境变量 :envvar:`CMAKE_INSTALL_MODE` 可以覆盖 :command:`file(INSTALL)` 的默认复制行为。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:869
msgid ""
"Determine the file size of the ``<filename>`` and put the result in "
"``<variable>`` variable. Requires that ``<filename>`` is a valid path "
"pointing to a file and is readable."
msgstr ""
"确定 ``<filename>`` 的文件大小并将结果放入 ``<variable>`` 变量中。要求 ``<filename>`` "
"是指向文件的有效路径并且是可读的。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:881
msgid ""
"This subcommand queries the symlink ``<linkname>`` and stores the path it "
"points to in the result ``<variable>``.  If ``<linkname>`` does not exist "
"or is not a symlink, CMake issues a fatal error."
msgstr ""
"此子命令查询符号链接“<linkname>”并将它指向的路径存储在结果“<variable>”中。如果 ``<linkname>`` "
"不存在或不是符号链接，CMake 会发出致命错误。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:885
msgid ""
"Note that this command returns the raw symlink path and does not resolve a"
" relative path.  The following is an example of how to ensure that an "
"absolute path is obtained:"
msgstr "请注意，此命令返回原始符号链接路径并且不解析相对路径。下面举例说明如何保证获取到的是绝对路径："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:907
msgid ""
"Create a link ``<linkname>`` that points to ``<original>``. It will be a "
"hard link by default, but providing the ``SYMBOLIC`` option results in a "
"symbolic link instead.  Hard links require that ``original`` exists and is"
" a file, not a directory.  If ``<linkname>`` already exists, it will be "
"overwritten."
msgstr ""
"创建指向“<original>”的链接“<linkname>”。默认情况下，它将是一个硬链接，但提供 ``SYMBOLIC`` "
"选项会导致符号链接。硬链接要求 ``original`` 存在并且是一个文件，而不是一个目录。如果 ``<linkname>`` "
"已经存在，它将被覆盖。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:913
msgid ""
"The ``<result>`` variable, if specified, receives the status of the "
"operation. It is set to ``0`` upon success or an error message otherwise."
"  If ``RESULT`` is not specified and the operation fails, a fatal error is"
" emitted."
msgstr ""
"``<result>`` 变量（如果指定）接收操作的状态。成功时将其设置为“0”，否则会出现错误消息。如果未指定 RESULT "
"且操作失败，则会发出致命错误。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:917
msgid ""
"Specifying ``COPY_ON_ERROR`` enables copying the file as a fallback if "
"creating the link fails.  It can be useful for handling situations such as"
" ``<original>`` and ``<linkname>`` being on different drives or mount "
"points, which would make them unable to support a hard link."
msgstr ""
"如果创建链接失败，指定 ``COPY_ON_ERROR`` 可以复制文件作为后备。它对于处理诸如``<original>`` "
"和``<linkname>`` 在不同的驱动器或安装点上的情况很有用，这会使它们无法支持硬链接。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:933
msgid ""
"Set the permissions for the ``<files>...`` and ``<directories>...`` "
"specified. Valid permissions are  ``OWNER_READ``, ``OWNER_WRITE``, "
"``OWNER_EXECUTE``, ``GROUP_READ``, ``GROUP_WRITE``, ``GROUP_EXECUTE``, "
"``WORLD_READ``, ``WORLD_WRITE``, ``WORLD_EXECUTE``, ``SETUID``, "
"``SETGID``."
msgstr ""
"为指定的 ``<files>...`` 和 ``<directories>...`` "
"设置权限。有效权限为``OWNER_READ``、``OWNER_WRITE``、``OWNER_EXECUTE``、``GROUP_READ``、``GROUP_WRITE``、``GROUP_EXECUTE``、``WORLD_READ``、``WORLD_WRITE``"
" ，``WORLD_EXECUTE``，``SETUID``，``SETGID``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:938
msgid "Valid combination of keywords are:"
msgstr "有效的关键字组合是："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:941
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:66
msgid "``PERMISSIONS``"
msgstr "``权限``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:941
msgid "All items are changed."
msgstr "所有项目都已更改。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:944
msgid "``FILE_PERMISSIONS``"
msgstr "``FILE_PERMISSIONS``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:944
msgid "Only files are changed."
msgstr "仅更改文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:947
msgid "``DIRECTORY_PERMISSIONS``"
msgstr "``DIRECTORY_PERMISSIONS``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:947
msgid "Only directories are changed."
msgstr "仅更改目录。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:950
msgid "``PERMISSIONS`` and ``FILE_PERMISSIONS``"
msgstr "``PERMISSIONS`` 和 ``FILE_PERMISSIONS``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:950
msgid "``FILE_PERMISSIONS`` overrides ``PERMISSIONS`` for files."
msgstr "``FILE_PERMISSIONS`` 覆盖文件的 ``PERMISSIONS``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:953
msgid "``PERMISSIONS`` and ``DIRECTORY_PERMISSIONS``"
msgstr "``PERMISSIONS`` 和 ``DIRECTORY_PERMISSIONS``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:953
msgid "``DIRECTORY_PERMISSIONS`` overrides ``PERMISSIONS`` for directories."
msgstr "``DIRECTORY_PERMISSIONS`` 覆盖目录的 ``PERMISSIONS``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:958
msgid "``FILE_PERMISSIONS`` and ``DIRECTORY_PERMISSIONS``"
msgstr "``FILE_PERMISSIONS`` 和 ``DIRECTORY_PERMISSIONS``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:956
msgid ""
"Use ``FILE_PERMISSIONS`` for files and ``DIRECTORY_PERMISSIONS`` for "
"directories."
msgstr "对文件使用 ``FILE_PERMISSIONS``，对目录使用 ``DIRECTORY_PERMISSIONS``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:971
msgid ""
"Same as `CHMOD`_, but change the permissions of files and directories "
"present in the ``<directories>...`` recursively."
msgstr "与 `CHMOD`_ 相同，但递归地更改 ``<directories>...`` 中存在的文件和目录的权限。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:975
msgid "Path Conversion"
msgstr "路径转换"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:985
msgid ""
"Compute the absolute path to an existing file or directory with symlinks "
"resolved."
msgstr "计算已解析符号链接的现有文件或目录的绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:991
msgid "``BASE_DIRECTORY <dir>``"
msgstr "``BASE_DIRECTORY <目录>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:989
msgid ""
"If the provided ``<path>`` is a relative path, it is evaluated relative to"
" the given base directory ``<dir>``. If no base directory is provided, the"
" default base directory will be :variable:`CMAKE_CURRENT_SOURCE_DIR`."
msgstr ""
"如果提供的 ``<path>`` 是相对路径，则相对于给定的基本目录 ``<dir>`` "
"进行评估。如果未提供基目录，则默认基目录将为 :variable:`CMAKE_CURRENT_SOURCE_DIR`。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1000
msgid "``EXPAND_TILDE``"
msgstr "``EXPAND_TILDE``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:996
msgid ""
"If the ``<path>`` is ``~`` or starts with ``~/``, the ``~`` is replaced by"
" the user's home directory.  The path to the home directory is obtained "
"from environment variables.  On Windows, the ``USERPROFILE`` environment "
"variable is used, falling back to the ``HOME`` environment variable if "
"``USERPROFILE`` is not defined.  On all other platforms, only ``HOME`` is "
"used."
msgstr ""
"如果 ``<path>`` 是 ``~`` 或以 ``~/`` 开头，则 ``~`` 将替换为用户的主目录。主目录的路径是从环境变量中获得的。在 "
"Windows 上，使用 ``USERPROFILE`` 环境变量，如果未定义 ``USERPROFILE``，则回退到 ``HOME`` "
"环境变量。在所有其他平台上，仅使用 ``HOME``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1008
msgid ""
"Compute the relative path from a ``<directory>`` to a ``<file>`` and store"
" it in the ``<variable>``."
msgstr "计算从 ``<directory>`` 到 ``<file>`` 的相对路径，并将其存储在 ``<variable>`` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1019
msgid ""
"The ``TO_CMAKE_PATH`` mode converts a native ``<path>`` into a cmake-style"
" path with forward-slashes (``/``).  The input can be a single path or a "
"system search path like ``$ENV{PATH}``.  A search path will be converted "
"to a cmake-style list separated by ``;`` characters."
msgstr ""
"``TO_CMAKE_PATH`` 模式将原生的 ``<path>`` 转换为带有正斜杠 (``/``) 的 cmake "
"风格路径。输入可以是单个路径或系统搜索路径，如 ``$ENV{PATH}``。搜索路径将被转换为由 ``;`` 字符分隔的 cmake 样式列表。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1024
msgid ""
"The ``TO_NATIVE_PATH`` mode converts a cmake-style ``<path>`` into a "
"native path with platform-specific slashes (``\\`` on Windows hosts and "
"``/`` elsewhere)."
msgstr ""
"``TO_NATIVE_PATH`` 模式将 cmake 风格的``<path>`` 转换为带有特定于平台的斜线的本机路径（Windows "
"主机上的``\\`` 和其他地方的``/``）。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1028
msgid ""
"Always use double quotes around the ``<path>`` to be sure it is treated as"
" a single argument to this command."
msgstr "始终在 ``<path>`` 周围使用双引号，以确保它被视为此命令的单个参数。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1032
msgid "Transfer"
msgstr "转移"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1042
msgid ""
"The ``DOWNLOAD`` subcommand downloads the given ``<url>`` to a local "
"``<file>``. The ``UPLOAD`` mode uploads a local ``<file>`` to a given "
"``<url>``."
msgstr ""
"``DOWNLOAD`` 子命令将给定的``<url>`` 下载到本地``<file>``。 ``UPLOAD`` 模式将本地``<file>`` "
"上传到给定的``<url>``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1045
msgid ""
"If ``<file>`` is not specified for ``file(DOWNLOAD)``, the file is not "
"saved. This can be useful if you want to know if a file can be downloaded "
"(for example, to check that it exists) without actually saving it "
"anywhere."
msgstr ""
"如果没有为 `file(DOWNLOAD)`` 指定 "
"``<file>``，则文件不会被保存。如果您想知道是否可以下载文件（例如，检查它是否存在）而不实际将其保存在任何地方，这将很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1050
msgid "Options to both ``DOWNLOAD`` and ``UPLOAD`` are:"
msgstr "``DOWNLOAD`` 和 ``UPLOAD`` 的选项是："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1053
msgid "``INACTIVITY_TIMEOUT <seconds>``"
msgstr "``INACTIVITY_TIMEOUT <秒数>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1053
msgid "Terminate the operation after a period of inactivity."
msgstr "一段时间不活动后终止操作。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1056
msgid "``LOG <variable>``"
msgstr "``日志<变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1056
msgid "Store a human-readable log of the operation in a variable."
msgstr "将人类可读的操作日志存储在变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1060
msgid "``SHOW_PROGRESS``"
msgstr "``显示进度``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1059
msgid ""
"Print progress information as status messages until the operation is "
"complete."
msgstr "将进度信息打印为状态消息，直到操作完成。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1067
msgid "``STATUS <variable>``"
msgstr "``状态<变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1063
msgid ""
"Store the resulting status of the operation in a variable. The status is a"
" ``;`` separated list of length 2. The first element is the numeric return"
" value for the operation, and the second element is a string value for the"
" error. A ``0`` numeric error means no error in the operation."
msgstr ""
"将操作的结果状态存储在变量中。状态是长度为 2 的“;”分隔列表。第一个元素是操作的数字返回值，第二个元素是错误的字符串值。 ``0`` "
"数字错误表示操作没有错误。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1070
msgid "``TIMEOUT <seconds>``"
msgstr "``超时<秒>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1070
msgid "Terminate the operation after a given total time has elapsed."
msgstr "在给定的总时间过去后终止操作。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1075
msgid "``USERPWD <username>:<password>``"
msgstr "``USERPWD <用户名>:<密码>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1075
msgid "Set username and password for operation."
msgstr "设置用户名和密码进行操作。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1080
msgid "HTTP header for operation. Suboption can be repeated several times."
msgstr "用于操作的 HTTP 标头。子选项可以重复多次。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1098
msgid "``NETRC <level>``"
msgstr "``NETRC <级别>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1085
msgid ""
"Specify whether the .netrc file is to be used for operation.  If this "
"option is not specified, the value of the :variable:`CMAKE_NETRC` variable"
" will be used instead. Valid levels are:"
msgstr ""
"指定是否使用.netrc 文件进行操作。如果未指定此选项，则将使用 :variable:`CMAKE_NETRC` 变量的值。有效级别是："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1091
msgid "``IGNORED``"
msgstr "``忽略``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1091
msgid "The .netrc file is ignored. This is the default."
msgstr ".netrc 文件被忽略。这是默认设置。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1095
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:109
msgid "``OPTIONAL``"
msgstr "``可选的``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1094
msgid ""
"The .netrc file is optional, and information in the URL is preferred. The "
"file will be scanned to find which ever information is not specified in "
"the URL."
msgstr ".netrc 文件是可选的，URL 中的信息是首选。将扫描文件以查找 URL 中未指定的信息。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:119
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1098
msgid "``REQUIRED``"
msgstr "``需要``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1098
msgid "The .netrc file is required, and information in the URL is ignored."
msgstr ".netrc 文件是必需的，URL 中的信息将被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1106
msgid "``NETRC_FILE <file>``"
msgstr "``NETRC_FILE <文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1103
msgid ""
"Specify an alternative .netrc file to the one in your home directory, if "
"the ``NETRC`` level is ``OPTIONAL`` or ``REQUIRED``. If this option is not"
" specified, the value of the :variable:`CMAKE_NETRC_FILE` variable will be"
" used instead."
msgstr ""
"如果 ``NETRC`` 级别是 ``OPTIONAL`` 或 ``REQUIRED``，请在您的主目录中指定一个替代 .netrc "
"文件。如果未指定此选项，则将使用 :variable:`CMAKE_NETRC_FILE` 变量的值。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1114
msgid "``TLS_VERIFY <ON|OFF>``"
msgstr "``TLS_VERIFY <ON|OFF>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1109
msgid ""
"Specify whether to verify the server certificate for ``https://`` URLs. "
"The default is to *not* verify. If this option is not specified, the value"
" of the :variable:`CMAKE_TLS_VERIFY` variable will be used instead."
msgstr ""
"指定是否验证 ``https://`` URL 的服务器证书。默认是*不*验证。如果未指定此选项，则将使用 "
":variable:`CMAKE_TLS_VERIFY` 变量的值。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1113
#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1121
msgid "Added support to ``file(UPLOAD)``."
msgstr "添加了对“文件（上传）”的支持。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1122
msgid "``TLS_CAINFO <file>``"
msgstr "``TLS_CAINFO <文件>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1117
msgid ""
"Specify a custom Certificate Authority file for ``https://`` URLs. If this"
" option is not specified, the value of the :variable:`CMAKE_TLS_CAINFO` "
"variable will be used instead."
msgstr ""
"为 ``https://`` URL 指定自定义证书颁发机构文件。如果未指定此选项，则将使用 "
":variable:`CMAKE_TLS_CAINFO` 变量的值。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1124
msgid ""
"For ``https://`` URLs CMake must be built with OpenSSL support.  "
"``TLS/SSL`` certificates are not checked by default.  Set ``TLS_VERIFY`` "
"to ``ON`` to check certificates."
msgstr ""
"对于 ``https://`` URL，CMake 必须使用 OpenSSL 支持来构建。默认情况下不检查 ``TLS/SSL`` 证书。将 "
"``TLS_VERIFY`` 设置为 ``ON`` 以检查证书。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1128
msgid "Additional options to ``DOWNLOAD`` are:"
msgstr "``DOWNLOAD`` 的附加选项是："

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1130
msgid "``EXPECTED_HASH ALGO=<value>``"
msgstr "``EXPECTED_HASH 算法=<值>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1132
msgid ""
"Verify that the downloaded content hash matches the expected value, where "
"``ALGO`` is one of the algorithms supported by ``file(<HASH>)``. If the "
"file already exists and matches the hash, the download is skipped. If the "
"file already exists and does not match the hash, the file is downloaded "
"again. If after download the file does not match the hash, the operation "
"fails with an error. It is an error to specify this option if ``DOWNLOAD``"
" is not given a ``<file>``."
msgstr ""
"验证下载的内容哈希是否与预期值匹配，其中 ALGO 是 file(<HASH>) "
"支持的算法之一。如果文件已经存在并且与哈希匹配，则跳过下载。如果该文件已存在且与哈希值不匹配，则重新下载该文件。如果下载后文件与哈希值不匹配，操作将失败并出现错误。如果未给"
" ``<file>`` ``DOWNLOAD``，则指定此选项是错误的。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1142
msgid "``EXPECTED_MD5 <value>``"
msgstr "``EXPECTED_MD5 <值>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1141
msgid ""
"Historical short-hand for ``EXPECTED_HASH MD5=<value>``. It is an error to"
" specify this if ``DOWNLOAD`` is not given a ``<file>``."
msgstr ""
"``EXPECTED_HASH MD5=<value>`` 的历史简写。如果没有给 ``<file>`` ``DOWNLOAD`` "
"指定这个是错误的。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1148
msgid "``RANGE_START <value>``"
msgstr "``RANGE_START <值>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1147
msgid ""
"Offset of the start of the range in file in bytes. Could be omitted to "
"download up to the specified ``RANGE_END``."
msgstr "文件中范围开始的偏移量（以字节为单位）。可以省略以下载指定的``RANGE_END``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1154
msgid "``RANGE_END <value>``"
msgstr "``RANGE_END <值>``"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1153
msgid ""
"Offset of the end of the range in file in bytes. Could be omitted to "
"download everything from the specified ``RANGE_START`` to the end of file."
msgstr "文件中范围末尾的偏移量（以字节为单位）。可以省略以下载从指定的“RANGE_START”到文件末尾的所有内容。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1157
msgid "Locking"
msgstr "锁定"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1170
msgid ""
"Lock a file specified by ``<path>`` if no ``DIRECTORY`` option present and"
" file ``<path>/cmake.lock`` otherwise. File will be locked for scope "
"defined by ``GUARD`` option (default value is ``PROCESS``). ``RELEASE`` "
"option can be used to unlock file explicitly. If option ``TIMEOUT`` is not"
" specified CMake will wait until lock succeed or until fatal error occurs."
" If ``TIMEOUT`` is set to ``0`` lock will be tried once and result will be"
" reported immediately. If ``TIMEOUT`` is not ``0`` CMake will try to lock "
"file for the period specified by ``<seconds>`` value. Any errors will be "
"interpreted as fatal if there is no ``RESULT_VARIABLE`` option. Otherwise "
"result will be stored in ``<variable>`` and will be ``0`` on success or "
"error message on failure."
msgstr ""
"如果不存在 ``DIRECTORY`` 选项，则锁定由 ``<path>`` 指定的文件，否则锁定文件 "
"``<path>/cmake.lock``。文件将被锁定在“保护”选项定义的范围内（默认值为“进程”）。 ``RELEASE`` "
"选项可用于显式解锁文件。如果未指定选项 ``TIMEOUT`` CMake 将等待锁定成功或发生致命错误。如果 ``TIMEOUT`` 设置为 "
"``0`` 锁定将尝试一次并立即报告结果。如果 ``TIMEOUT`` 不是 ``0`` CMake 将尝试在 ``<seconds>`` "
"值指定的时间段内锁定文件。如果没有 RESULT_VARIABLE "
"选项，任何错误都将被解释为致命错误。否则结果将存储在“<variable>”中，成功时将为“0”或失败时为错误消息。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1181
msgid ""
"Note that lock is advisory - there is no guarantee that other processes "
"will respect this lock, i.e. lock synchronize two or more CMake instances "
"sharing some modifiable resources. Similar logic applied to ``DIRECTORY`` "
"option - locking parent directory doesn't prevent other ``LOCK`` commands "
"to lock any child directory or file."
msgstr ""
"请注意，锁是建议性的——不能保证其他进程会遵守此锁，即锁同步两个或多个共享一些可修改资源的 CMake 实例。类似的逻辑适用于 "
"``DIRECTORY`` 选项 - 锁定父目录不会阻止其他 ``LOCK`` 命令锁定任何子目录或文件。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1187
msgid ""
"Trying to lock file twice is not allowed.  Any intermediate directories "
"and file itself will be created if they not exist.  ``GUARD`` and "
"``TIMEOUT`` options ignored on ``RELEASE`` operation."
msgstr ""
"不允许尝试锁定文件两次。如果不存在，将创建任何中间目录和文件本身。 ``GUARD`` 和 ``TIMEOUT`` 选项在 ``RELEASE`` "
"操作中被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1192
msgid "Archiving"
msgstr "归档"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1207
msgid ""
"Creates the specified ``<archive>`` file with the files and directories "
"listed in ``<paths>``.  Note that ``<paths>`` must list actual files or "
"directories, wildcards are not supported."
msgstr ""
"使用 ``<paths>`` 中列出的文件和目录创建指定的 ``<archive>`` 文件。请注意，``<paths>`` "
"必须列出实际的文件或目录，不支持通配符。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1211
msgid ""
"Use the ``FORMAT`` option to specify the archive format.  Supported values"
" for ``<format>`` are ``7zip``, ``gnutar``, ``pax``, ``paxr``, ``raw`` and"
" ``zip``.  If ``FORMAT`` is not given, the default format is ``paxr``."
msgstr ""
"使用 ``FORMAT`` 选项指定存档格式。 ``<format>`` 支持的值为 "
"``7zip``、``gnutar``、``pax``、``paxr``、``raw`` 和 ``zip``。如果未给出 "
"``FORMAT``，则默认格式为 ``paxr``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1215
msgid ""
"Some archive formats allow the type of compression to be specified. The "
"``7zip`` and ``zip`` archive formats already imply a specific type of "
"compression.  The other formats use no compression by default, but can be "
"directed to do so with the ``COMPRESSION`` option.  Valid values for "
"``<compression>`` are ``None``, ``BZip2``, ``GZip``, ``XZ``, and ``Zstd``."
msgstr ""
"某些存档格式允许指定压缩类型。 ``7zip`` 和 ``zip`` "
"存档​​格式已经暗示了特定类型的压缩。其他格式默认不使用压缩，但可以使用“COMPRESSION”选项进行定向。 ``<compression>``"
" 的有效值为 ``None``、``BZip2``、``GZip``、``XZ`` 和 ``Zstd``。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1221
msgid ""
"The compression level can be specified with the ``COMPRESSION_LEVEL`` "
"option. The ``<compression-level>`` should be between 0-9, with the "
"default being 0. The ``COMPRESSION`` option must be present when "
"``COMPRESSION_LEVEL`` is given."
msgstr ""
"可以使用 COMPRESSION_LEVEL 选项指定压缩级别。 ``<compression-level>`` 应介于 0-9 之间，默认值为 "
"0。``COMPRESSION`` 选项必须在给出 ``COMPRESSION_LEVEL`` 时出现。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1226
msgid ""
"The ``<compression-level>`` of the ``Zstd`` algorithm can be set between "
"0-19."
msgstr "``Zstd`` 算法的``<compression-level>`` 可以设置在 0-19 之间。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1230
msgid ""
"With ``FORMAT`` set to ``raw`` only one file will be compressed with the "
"compression type specified by ``COMPRESSION``."
msgstr "将 ``FORMAT`` 设置为 ``raw`` 只有一个文件将使用 ``COMPRESSION`` 指定的压缩类型进行压缩。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1233
msgid ""
"The ``VERBOSE`` option enables verbose output for the archive operation."
msgstr "``VERBOSE`` 选项为存档操作启用详细输出。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1235
msgid ""
"To specify the modification time recorded in tarball entries, use the "
"``MTIME`` option."
msgstr "要指定 tarball 条目中记录的修改时间，请使用“MTIME”选项。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1251
msgid "Extracts or lists the content of the specified ``<archive>``."
msgstr "提取或列出指定的 ``<archive>`` 的内容。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1253
msgid ""
"The directory where the content of the archive will be extracted to can be"
" specified using the ``DESTINATION`` option.  If the directory does not "
"exist, it will be created.  If ``DESTINATION`` is not given, the current "
"binary directory will be used."
msgstr ""
"可以使用 ``DESTINATION`` "
"选项指定存档内容将被提取到的目录。如果该目录不存在，将创建它。如果没有给出``DESTINATION``，将使用当前的二进制目录。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1258
msgid ""
"If required, you may select which files and directories to list or extract"
" from the archive using the specified ``<patterns>``.  Wildcards are "
"supported. If the ``PATTERNS`` option is not given, the entire archive "
"will be listed or extracted."
msgstr ""
"如果需要，您可以使用指定的 ``<patterns>`` 选择要列出或从存档中提取的文件和目录。支持通配符。如果没有给出 ``PATTERNS`` "
"选项，将列出或提取整个档案。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1263
msgid ""
"``LIST_ONLY`` will list the files in the archive rather than extract them."
msgstr "``LIST_ONLY`` 将列出存档中的文件而不是提取它们。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1265
msgid ""
"The ``TOUCH`` option gives extracted files a current local timestamp "
"instead of extracting file timestamps from the archive."
msgstr "``TOUCH`` 选项为提取的文件提供当前本地时间戳，而不是从存档中提取文件时间戳。"

#: ../../cmake-prefix/src/cmake/Help/command/file.rst:1269
msgid "With ``VERBOSE``, the command will produce verbose output."
msgstr "使用 ``VERBOSE``，该命令将产生详细的输出。"

#: ../../cmake-prefix/src/cmake/Help/command/find_file.rst:2
msgid "find_file"
msgstr "查找文件"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:1
msgid "A short-hand signature is:"
msgstr "速记签名是："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:7
msgid "The general signature is:"
msgstr "一般签名是："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:34
msgid ""
"This command is used to find a |SEARCH_XXX_DESC|. A cache entry, or a "
"normal variable if ``NO_CACHE`` is specified, named by ``<VAR>`` is "
"created to store the result of this command. If the |SEARCH_XXX| is found "
"the result is stored in the variable and the search will not be repeated "
"unless the variable is cleared. If nothing is found, the result will be "
"``<VAR>-NOTFOUND``."
msgstr ""
"此命令用于查找 |SEARCH_XXX_DESC|。如果指定了 ``NO_CACHE``，则创建缓存条目或普通变量，命名为``<VAR>`` "
"以存储此命令的结果。如果 "
"|SEARCH_XXX|找到结果存储在变量中，除非清除变量，否则不会重复搜索。如果什么都没有找到，结果将是``<VAR>-NOTFOUND``。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:41
msgid "Options include:"
msgstr "选项包括："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:49
msgid "``NAMES``"
msgstr "``名字``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:44
msgid "Specify one or more possible names for the |SEARCH_XXX|."
msgstr "为 |SEARCH_XXX| 指定一个或多个可能的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:46
msgid ""
"When using this to specify names with and without a version suffix, we "
"recommend specifying the unversioned name first so that locally-built "
"packages can be found before those provided by distributions."
msgstr "当使用它来指定带有和不带版本后缀的名称时，我们建议首先指定未版本化的名称，以便可以在分发提供的包之前找到本地构建的包。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:59
msgid "``HINTS``, ``PATHS``"
msgstr "``提示``，``路径``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:52
msgid ""
"Specify directories to search in addition to the default locations. The "
"``ENV var`` sub-option reads paths from a system environment variable."
msgstr "除默认位置外，还指定要搜索的目录。 ``ENV var`` 子选项从系统环境变量中读取路径。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:56
msgid ""
"On ``Windows`` platform, it is possible to include registry queries as "
"part of the directories, using a :ref:`dedicated syntax <Find Using "
"Windows Registry>`. Such specifications will be ignored on all other "
"platforms."
msgstr ""
"在 ``Windows`` 平台上，可以使用专用语法 <Find Using Windows Registry>` "
"将注册表查询作为目录的一部分包含在内。此类规范将在所有其他平台上被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:64
msgid "``REGISTRY_VIEW``"
msgstr "``REGISTRY_VIEW``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:1
msgid ""
"Specify which registry views must be queried. This option is only "
"meaningful on ``Windows`` platforms and will be ignored on other ones. "
"When not specified, the |FIND_XXX_REGISTRY_VIEW_DEFAULT| view is used when"
" the :policy:`CMP0134` policy is ``NEW``. Refer to :policy:`CMP0134` for "
"the default view when the policy is ``OLD``."
msgstr ""
"指定必须查询哪些注册表视图。此选项仅在 ``Windows`` "
"平台上有意义，在其他平台上将被忽略。未指定时，|FIND_XXX_REGISTRY_VIEW_DEFAULT|当 :policy:`CMP0134` "
"策略为``NEW`` 时使用视图。策略为“旧”时的默认视图，请参阅:policy:`CMP0134`。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:8
msgid ""
"Query the 64-bit registry. On 32-bit Windows, it always returns the string"
" ``/REGISTRY-NOTFOUND``."
msgstr "查询 64 位注册表。在 32 位 Windows 上，它总是返回字符串“/REGISTRY-NOTFOUND”。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:12
msgid "Query the 32-bit registry."
msgstr "查询 32 位注册表。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:15
msgid "Query both views (``64`` and ``32``) and generate a path for each."
msgstr "查询两个视图（``64`` 和``32``）并为每个视图生成一个路径。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:18
msgid "Query both views (``32`` and ``64``) and generate a path for each."
msgstr "查询两个视图（``32`` 和 ``64``）并为每个视图生成一个路径。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:21
msgid ""
"Query the registry matching the architecture of the host: ``64`` on 64-bit"
" Windows and ``32`` on 32-bit Windows."
msgstr "查询与主机架构相匹配的注册表：64 位 Windows 上为“64”，32 位 Windows 上为“32”。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:25
msgid ""
"Query the registry matching the architecture specified by the "
":variable:`CMAKE_SIZEOF_VOID_P` variable. If not defined, fall back to "
"``HOST`` view."
msgstr "查询与 CMAKE_SIZEOF_VOID_P 变量指定的体系结构相匹配的注册表。如果未定义，则返回到 ``HOST`` 视图。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:30
msgid ""
"Query both views (``32`` and ``64``). The order depends on the following "
"rules: If the :variable:`CMAKE_SIZEOF_VOID_P` variable is defined, use the"
" following view depending on the content of this variable:"
msgstr ""
"查询两个视图（``32`` 和 ``64``）。顺序取决于以下规则：如果定义了 :variable:`CMAKE_SIZEOF_VOID_P` "
"变量，则根据此变量的内容使用以下视图："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:37
msgid ""
"If the :variable:`CMAKE_SIZEOF_VOID_P` variable is not defined, rely on "
"the architecture of the host:"
msgstr "如果未定义 :variable:`CMAKE_SIZEOF_VOID_P` 变量，则依赖主机的体系结构："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:40
msgid "64-bit: ``64_32``"
msgstr "64 位：``64_32``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_REGISTRY_VIEW.txt:41
msgid "32-bit: ``32``"
msgstr "32 位：``32``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:68
msgid "``PATH_SUFFIXES``"
msgstr "``PATH_SUFFIXES``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:67
msgid ""
"Specify additional subdirectories to check below each directory location "
"otherwise considered."
msgstr "在每个目录位置下方指定额外的子目录以检查，否则将被考虑。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:93
msgid "``VALIDATOR``"
msgstr "``验证器``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:73
msgid ""
"Specify a :command:`function` to be called for each candidate item found "
"(a :command:`macro` cannot be provided, that will result in an error). Two"
" arguments will be passed to the validator function: the name of a result "
"variable, and the absolute path to the candidate item.  The item will be "
"accepted and the search will end unless the function sets the value in the"
" result variable to false in the calling scope.  The result variable will "
"hold a true value when the validator function is entered."
msgstr ""
"为找到的每个候选项指定要调用的 :command:`function`（无法提供 "
":command:`macro`，这将导致错误）。两个参数将传递给验证器函数：结果变量的名称和候选项的绝对路径。该项目将被接受并且搜索将结束，除非该函数在调用范围内将结果变量中的值设置为"
" false。当输入验证器函数时，结果变量将保存一个真值。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:91
msgid ""
"Note that if a cached result is used, the search is skipped and any "
"``VALIDATOR`` is ignored.  The cached result is not required to pass the "
"validation function."
msgstr "请注意，如果使用缓存结果，则会跳过搜索并忽略任何“VALIDATOR”。缓存的结果不需要通过验证功能。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:96
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:574
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:727
msgid "``DOC``"
msgstr "``文档``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:96
msgid "Specify the documentation string for the ``<VAR>`` cache entry."
msgstr "为 ``<VAR>`` 缓存条目指定文档字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:112
#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:205
msgid "``NO_CACHE``"
msgstr "``NO_CACHE``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:101
msgid ""
"The result of the search will be stored in a normal variable rather than a"
" cache entry."
msgstr "搜索结果将存储在一个普通变量中，而不是缓存条目中。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:106
msgid ""
"If the variable is already set before the call (as a normal or cache "
"variable) then the search will not occur."
msgstr "如果变量在调用之前已经设置（作为普通变量或缓存变量），则不会进行搜索。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:111
msgid ""
"This option should be used with caution because it can greatly increase "
"the cost of repeated configure steps."
msgstr "应谨慎使用此选项，因为它会大大增加重复配置步骤的成本。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:117
msgid ""
"Stop processing with an error message if nothing is found, otherwise the "
"search will be attempted again the next time |FIND_XXX| is invoked with "
"the same variable."
msgstr "如果未找到任何内容，则停止处理并显示错误消息，否则下次将再次尝试搜索 |FIND_XXX|使用相同的变量调用。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:121
msgid ""
"If ``NO_DEFAULT_PATH`` is specified, then no additional paths are added to"
" the search. If ``NO_DEFAULT_PATH`` is not specified, the search process "
"is as follows:"
msgstr ""
"如果指定了 ``NO_DEFAULT_PATH``，则不会将其他路径添加到搜索中。如果不指定``NO_DEFAULT_PATH``，搜索过程如下："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:143
msgid ""
"If called from within a find module or any other script loaded by a call "
"to :command:`find_package(<PackageName>)`, search prefixes unique to the "
"current package being found.  Specifically, look in the "
":variable:`<PackageName>_ROOT` CMake variable and the "
":envvar:`<PackageName>_ROOT` environment variable. The package root "
"variables are maintained as a stack, so if called from nested find modules"
" or config packages, root paths from the parent's find module or config "
"package will be searched after paths from the current module or package.  "
"In other words, the search order would be ``<CurrentPackage>_ROOT``, "
"``ENV{<CurrentPackage>_ROOT}``, ``<ParentPackage>_ROOT``, "
"``ENV{<ParentPackage>_ROOT}``, etc. This can be skipped if "
"``NO_PACKAGE_ROOT_PATH`` is passed or by setting the "
":variable:`CMAKE_FIND_USE_PACKAGE_ROOT_PATH` to ``FALSE``. See policy "
":policy:`CMP0074`."
msgstr ""
"如果从查找模块或通过调用 find_package(<PackageName>)` "
"加载的任何其他脚本中调用，搜索前缀对于当前找到的包是唯一的。具体来说，查看 :variable:`<PackageName>_ROOT` CMake"
" 变量和 :envvar:`<PackageName>_ROOT` "
"环境变量。包根变量作为堆栈维护，因此如果从嵌套的查找模块或配置包中调用，将在当前模块或包的路径之后搜索父查找模块或配置包的根路径。换句话说，搜索顺序是``<CurrentPackage>_ROOT``、``ENV{<CurrentPackage>_ROOT}``、``<ParentPackage>_ROOT``、``ENV{<ParentPackage>_ROOT}``等。如果传递了"
" ``NO_PACKAGE_ROOT_PATH`` 或通过将 "
":variable:`CMAKE_FIND_USE_PACKAGE_ROOT_PATH` 设置为 "
"``FALSE``，则可以跳过此步骤。请参阅政策:policy:`CMP0074`。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:159
msgid "|FIND_PACKAGE_ROOT_PREFIX_PATH_XXX|"
msgstr "|FIND_PACKAGE_ROOT_PREFIX_PATH_XXX|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:161
msgid ""
"Search paths specified in cmake-specific cache variables. These are "
"intended to be used on the command line with a ``-DVAR=value``. The values"
" are interpreted as :ref:`semicolon-separated lists <CMake Language "
"Lists>`. This can be skipped if ``NO_CMAKE_PATH`` is passed or by setting "
"the :variable:`CMAKE_FIND_USE_CMAKE_PATH` to ``FALSE``."
msgstr ""
"在特定于 cmake 的缓存变量中指定的搜索路径。这些旨在与“-DVAR=value”一起在命令行上使用。这些值被解释为:ref:`分号分隔的列表 "
"<CMake Language Lists>`。如果传递了 ``NO_CMAKE_PATH`` 或通过将 "
":variable:`CMAKE_FIND_USE_CMAKE_PATH` 设置为 ``FALSE`` 可以跳过这一步。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:167
#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:178
msgid "|CMAKE_PREFIX_PATH_XXX|"
msgstr "|CMAKE_PREFIX_PATH_XXX|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:168
#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:179
msgid "|CMAKE_XXX_PATH|"
msgstr "|CMAKE_XXX_PATH|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:169
#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:180
msgid "|CMAKE_XXX_MAC_PATH|"
msgstr "|CMAKE_XXX_MAC_PATH|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:171
msgid ""
"Search paths specified in cmake-specific environment variables. These are "
"intended to be set in the user's shell configuration, and therefore use "
"the host's native path separator (``;`` on Windows and ``:`` on UNIX). "
"This can be skipped if ``NO_CMAKE_ENVIRONMENT_PATH`` is passed or by "
"setting the :variable:`CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH` to "
"``FALSE``."
msgstr ""
"在特定于 cmake 的环境变量中指定的搜索路径。这些旨在在用户的 shell 配置中设置，因此使用主机的本机路径分隔符（Windows "
"上为“;”，UNIX 上为“ :”）。如果传递了 ``NO_CMAKE_ENVIRONMENT_PATH`` 或通过将 "
":variable:`CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH` 设置为 ``FALSE`` 可以跳过这一步。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:182
msgid ""
"Search the paths specified by the ``HINTS`` option. These should be paths "
"computed by system introspection, such as a hint provided by the location "
"of another item already found. Hard-coded guesses should be specified with"
" the ``PATHS`` option."
msgstr ""
"搜索由“HINTS”选项指定的路径。这些应该是系统自省计算出的路径，例如由已找到的另一个项目的位置提供的提示。硬编码的猜测应该用 ``PATHS``"
" 选项指定。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:187
msgid ""
"Search the standard system environment variables. This can be skipped if "
"``NO_SYSTEM_ENVIRONMENT_PATH`` is passed or by setting the "
":variable:`CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH` to ``FALSE``."
msgstr ""
"搜索标准系统环境变量。如果传递了 ``NO_SYSTEM_ENVIRONMENT_PATH`` 或通过将 "
":variable:`CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH` 设置为 ``FALSE`` 可以跳过这一步。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:191
msgid "|SYSTEM_ENVIRONMENT_PATH_XXX|"
msgstr "|SYSTEM_ENVIRONMENT_PATH_XXX|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:192
msgid "|SYSTEM_ENVIRONMENT_PATH_WINDOWS_XXX|"
msgstr "|SYSTEM_ENVIRONMENT_PATH_WINDOWS_XXX|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:194
msgid ""
"Search cmake variables defined in the Platform files for the current "
"system.  The searching of ``CMAKE_INSTALL_PREFIX`` and "
"``CMAKE_STAGING_PREFIX`` can be skipped if ``NO_CMAKE_INSTALL_PREFIX`` is "
"passed or by setting the :variable:`CMAKE_FIND_USE_INSTALL_PREFIX` to "
"``FALSE``. All these locations can be skipped if ``NO_CMAKE_SYSTEM_PATH`` "
"is passed or by setting the :variable:`CMAKE_FIND_USE_CMAKE_SYSTEM_PATH` "
"to ``FALSE``."
msgstr ""
"搜索在当前系统的平台文件中定义的 cmake 变量。如果传递了 NO_CMAKE_INSTALL_PREFIX 或将 "
"CMAKE_FIND_USE_INSTALL_PREFIX 设置为 FALSE，则可以跳过 CMAKE_INSTALL_PREFIX 和 "
"CMAKE_STAGING_PREFIX 的搜索。如果传递了 ``NO_CMAKE_SYSTEM_PATH`` 或通过将 "
":variable:`CMAKE_FIND_USE_CMAKE_SYSTEM_PATH` 设置为 ``FALSE``，则可以跳过所有这些位置。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:202
msgid "|CMAKE_SYSTEM_PREFIX_PATH_XXX|"
msgstr "|CMAKE_SYSTEM_PREFIX_PATH_XXX|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:203
msgid "|CMAKE_SYSTEM_XXX_PATH|"
msgstr "|CMAKE_SYSTEM_XXX_PATH|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:204
msgid "|CMAKE_SYSTEM_XXX_MAC_PATH|"
msgstr "|CMAKE_SYSTEM_XXX_MAC_PATH|"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:206
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:438
msgid ""
"The platform paths that these variables contain are locations that "
"typically include installed software. An example being ``/usr/local`` for "
"UNIX based platforms."
msgstr "这些变量包含的平台路径是通常包含已安装软件的位置。一个例子是 ``/usr/local`` 用于基于 UNIX 的平台。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:210
msgid ""
"Search the paths specified by the PATHS option or in the short-hand "
"version of the command. These are typically hard-coded guesses."
msgstr "搜索由 PATHS 选项或命令的简写版本指定的路径。这些通常是硬编码的猜测。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:214
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:454
msgid ""
"The :variable:`CMAKE_IGNORE_PATH`, :variable:`CMAKE_IGNORE_PREFIX_PATH`, "
":variable:`CMAKE_SYSTEM_IGNORE_PATH` and "
":variable:`CMAKE_SYSTEM_IGNORE_PREFIX_PATH` variables can also cause some "
"of the above locations to be ignored."
msgstr ""
"CMAKE_IGNORE_PATH、CMAKE_IGNORE_PREFIX_PATH、CMAKE_SYSTEM_IGNORE_PATH 和 "
"CMAKE_SYSTEM_IGNORE_PREFIX_PATH 变量也可能导致上述某些位置被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:219
msgid ""
"Added ``CMAKE_FIND_USE_<CATEGORY>_PATH`` variables to globally disable "
"various search locations."
msgstr "添加了 ``CMAKE_FIND_USE_<CATEGORY>_PATH`` 变量以全局禁用各种搜索位置。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX.txt:225
msgid ""
"On macOS the :variable:`CMAKE_FIND_FRAMEWORK` and "
":variable:`CMAKE_FIND_APPBUNDLE` variables determine the order of "
"preference between Apple-style and unix-style package components."
msgstr ""
"在 macOS 上 :variable:`CMAKE_FIND_FRAMEWORK` 和 :variable:`CMAKE_FIND_APPBUNDLE` 变量确定 Apple"
" 风格和 unix 风格的包组件之间的优先顺序。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:1
msgid ""
"The CMake variable :variable:`CMAKE_FIND_ROOT_PATH` specifies one or more "
"directories to be prepended to all other search directories.  This "
"effectively \"re-roots\" the entire search under given locations. Paths "
"which are descendants of the :variable:`CMAKE_STAGING_PREFIX` are excluded"
" from this re-rooting, because that variable is always a path on the host "
"system. By default the :variable:`CMAKE_FIND_ROOT_PATH` is empty."
msgstr ""
"CMake 变量 :variable:`CMAKE_FIND_ROOT_PATH` "
"指定一个或多个要添加到所有其他搜索目录之前的目录。这有效地“重新定位”了给定位置下的整个搜索。作为 CMAKE_STAGING_PREFIX "
"后代的路径被排除在这个重新生根之外，因为该变量始终是主机系统上的路径。默认情况下 :variable:`CMAKE_FIND_ROOT_PATH` 为空。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:8
msgid ""
"The :variable:`CMAKE_SYSROOT` variable can also be used to specify exactly"
" one directory to use as a prefix.  Setting :variable:`CMAKE_SYSROOT` also"
" has other effects.  See the documentation for that variable for more."
msgstr ""
":variable:`CMAKE_SYSROOT` 变量也可以用来指定一个目录作为前缀。设置 :variable:`CMAKE_SYSROOT` "
"也有其他影响。有关更多信息，请参阅该变量的文档。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:12
msgid ""
"These variables are especially useful when cross-compiling to point to the"
" root directory of the target environment and CMake will search there too."
"  By default at first the directories listed in "
":variable:`CMAKE_FIND_ROOT_PATH` are searched, then the "
":variable:`CMAKE_SYSROOT` directory is searched, and then the non-rooted "
"directories will be searched.  The default behavior can be adjusted by "
"setting |CMAKE_FIND_ROOT_PATH_MODE_XXX|.  This behavior can be manually "
"overridden on a per-call basis using options:"
msgstr ""
"这些变量在交叉编译指向目标环境的根目录时特别有用，CMake 也会在那里搜索。默认情况下，首先搜索 "
":variable:`CMAKE_FIND_ROOT_PATH` 中列出的目录，然后搜索 :variable:`CMAKE_SYSROOT` "
"目录，然后搜索非根目录。可以通过设置 |CMAKE_FIND_ROOT_PATH_MODE_XXX| "
"来调整默认行为。可以使用选项在每次调用的基础上手动覆盖此行为："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:22
msgid "``CMAKE_FIND_ROOT_PATH_BOTH``"
msgstr "``CMAKE_FIND_ROOT_PATH_BOTH``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:22
msgid "Search in the order described above."
msgstr "按上述顺序搜索。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:25
msgid "``NO_CMAKE_FIND_ROOT_PATH``"
msgstr "``NO_CMAKE_FIND_ROOT_PATH``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:25
msgid "Do not use the :variable:`CMAKE_FIND_ROOT_PATH` variable."
msgstr "不要使用 :variable:`CMAKE_FIND_ROOT_PATH` 变量。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:29
msgid "``ONLY_CMAKE_FIND_ROOT_PATH``"
msgstr "``ONLY_CMAKE_FIND_ROOT_PATH``"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ROOT.txt:28
msgid ""
"Search only the re-rooted directories and directories below "
":variable:`CMAKE_STAGING_PREFIX`."
msgstr "仅搜索重新根目录和以下目录 :variable:`CMAKE_STAGING_PREFIX`。"

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ORDER.txt:1
msgid ""
"The default search order is designed to be most-specific to least-specific"
" for common use cases. Projects may override the order by simply calling "
"the command multiple times and using the ``NO_*`` options:"
msgstr "默认搜索顺序旨在针对常见用例从最具体到最不具体。项目可以通过简单地多次调用命令并使用 ``NO_*`` 选项来覆盖顺序："

#: ../../cmake-prefix/src/cmake/Help/command/FIND_XXX_ORDER.txt:11
msgid ""
"Once one of the calls succeeds the result variable will be set and stored "
"in the cache so that no call will search again."
msgstr "一旦其中一个调用成功，结果变量将被设置并存储在缓存中，这样就不会再进行任何调用。"

#: ../../cmake-prefix/src/cmake/Help/command/find_library.rst:2
msgid "find_library"
msgstr "查找库"

#: ../../cmake-prefix/src/cmake/Help/command/find_library.rst:41
#: ../../cmake-prefix/src/cmake/Help/command/find_program.rst:35
msgid ""
"When more than one value is given to the ``NAMES`` option this command by "
"default will consider one name at a time and search every directory for "
"it.  The ``NAMES_PER_DIR`` option tells this command to consider one "
"directory at a time and search for all names in it."
msgstr ""
"当为 ``NAMES`` 选项提供多个值时，默认情况下此命令将一次考虑一个名称并在每个目录中搜索它。 ``NAMES_PER_DIR`` "
"选项告诉此命令一次考虑一个目录并搜索其中的所有名称。"

#: ../../cmake-prefix/src/cmake/Help/command/find_library.rst:46
msgid ""
"Each library name given to the ``NAMES`` option is first considered as a "
"library file name and then considered with platform-specific prefixes "
"(e.g. ``lib``) and suffixes (e.g. ``.so``).  Therefore one may specify "
"library file names such as ``libfoo.a`` directly. This can be used to "
"locate static libraries on UNIX-like systems."
msgstr ""
"赋予 ``NAMES`` 选项的每个库名称首先被视为库文件名，然后被视为具有特定于平台的前缀（例如 ``lib``）和后缀（例如 "
"``.so``）。因此，可以直接指定库文件名，例如 ``libfoo.a``。这可用于在类 UNIX 系统上定位静态库。"

#: ../../cmake-prefix/src/cmake/Help/command/find_library.rst:52
msgid ""
"If the library found is a framework, then ``<VAR>`` will be set to the "
"full path to the framework ``<fullPath>/A.framework``.  When a full path "
"to a framework is used as a library, CMake will use a ``-framework A``, "
"and a ``-F<fullPath>`` to link the framework to the target."
msgstr ""
"如果找到的库是框架，则``<VAR>`` 将设置为框架``<fullPath>/A.framework`` "
"的完整路径。当框架的完整路径用作库时，CMake 将使用“-framework A”和“-F<fullPath>”将框架链接到目标。"

#: ../../cmake-prefix/src/cmake/Help/command/find_library.rst:57
msgid ""
"If the :variable:`CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX` variable is set "
"all search paths will be tested as normal, with the suffix appended, and "
"with all matches of ``lib/`` replaced with "
"``lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/``.  This variable overrides "
"the :prop_gbl:`FIND_LIBRARY_USE_LIB32_PATHS`, "
":prop_gbl:`FIND_LIBRARY_USE_LIBX32_PATHS`, and "
":prop_gbl:`FIND_LIBRARY_USE_LIB64_PATHS` global properties."
msgstr ""
"如果设置了 :variable:`CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX` "
"变量，所有搜索路径将被正常测试，并附加后缀，并将所有匹配的 ``lib/`` 替换为 "
"``lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/``。此变量覆盖 "
":prop_gbl:`FIND_LIBRARY_USE_LIB32_PATHS`、 :prop_gbl:`FIND_LIBRARY_USE_LIBX32_PATHS`"
" 和 :prop_gbl:`FIND_LIBRARY_USE_LIB64_PATHS` 全局属性。"

#: ../../cmake-prefix/src/cmake/Help/command/find_library.rst:65
msgid ""
"If the :prop_gbl:`FIND_LIBRARY_USE_LIB32_PATHS` global property is set all"
" search paths will be tested as normal, with ``32/`` appended, and with "
"all matches of ``lib/`` replaced with ``lib32/``.  This property is "
"automatically set for the platforms that are known to need it if at least "
"one of the languages supported by the :command:`project` command is "
"enabled."
msgstr ""
"如果 :prop_gbl:`FIND_LIBRARY_USE_LIB32_PATHS` 全局属性被设置，所有搜索路径将被正常测试，附加 "
"``32/``，并将所有匹配的 ``lib/`` 替换为 ``lib32/``。如果至少启用了 :command:`project` "
"命令支持的一种语言，则此属性会自动为已知需要它的平台设置。"

#: ../../cmake-prefix/src/cmake/Help/command/find_library.rst:72
msgid ""
"If the :prop_gbl:`FIND_LIBRARY_USE_LIBX32_PATHS` global property is set "
"all search paths will be tested as normal, with ``x32/`` appended, and "
"with all matches of ``lib/`` replaced with ``libx32/``.  This property is "
"automatically set for the platforms that are known to need it if at least "
"one of the languages supported by the :command:`project` command is "
"enabled."
msgstr ""
"如果 :prop_gbl:`FIND_LIBRARY_USE_LIBX32_PATHS` 全局属性被设置，所有搜索路径将被正常测试，附加 "
"``x32/``，并将所有匹配的 ``lib/`` 替换为 ``libx32/``。如果至少启用了 :command:`project` "
"命令支持的一种语言，则此属性会自动为已知需要它的平台设置。"

#: ../../cmake-prefix/src/cmake/Help/command/find_library.rst:79
msgid ""
"If the :prop_gbl:`FIND_LIBRARY_USE_LIB64_PATHS` global property is set all"
" search paths will be tested as normal, with ``64/`` appended, and with "
"all matches of ``lib/`` replaced with ``lib64/``.  This property is "
"automatically set for the platforms that are known to need it if at least "
"one of the languages supported by the :command:`project` command is "
"enabled."
msgstr ""
"如果 :prop_gbl:`FIND_LIBRARY_USE_LIB64_PATHS` 全局属性被设置，所有搜索路径将被正常测试，附加 "
"``64/``，并将所有匹配的 ``lib/`` 替换为 ``lib64/``。如果至少启用了 :command:`project` "
"命令支持的一种语言，则此属性会自动为已知需要它的平台设置。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:2
msgid "find_package"
msgstr "查找包"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:14
msgid ""
"The :guide:`Using Dependencies Guide` provides a high-level introduction "
"to this general topic. It provides a broader overview of where the "
"``find_package()`` command fits into the bigger picture, including its "
"relationship to the :module:`FetchContent` module. The guide is "
"recommended pre-reading before moving on to the details below."
msgstr ""
":guide:`Using Dependencies Guide` "
"提供了对此一般主题的高级介绍。它更广泛地概述了``find_package()`` 命令在更大范围内的位置，包括它与 "
":module:`FetchContent` 模块的关系。建议在继续阅读以下详细信息之前先阅读该指南。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:20
msgid ""
"Find a package (usually provided by something external to the project), "
"and load its package-specific details.  Calls to this command can also be "
"intercepted by :ref:`dependency providers <dependency_providers>`."
msgstr ""
"找到一个包（通常由项目外部的东西提供），并加载其特定于包的详细信息。调用此命令也可以被 :ref:`dependency providers "
"<dependency_providers>` 拦截。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:25
msgid "Search Modes"
msgstr "搜索模式"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:27
msgid "The command has a few modes by which it searches for packages:"
msgstr "该命令有几种搜索包的模式："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:47
msgid "**Module mode**"
msgstr "**模块模式**"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:30
msgid ""
"In this mode, CMake searches for a file called "
"``Find<PackageName>.cmake``, looking first in the locations listed in the "
":variable:`CMAKE_MODULE_PATH`, then among the :ref:`Find Modules` provided"
" by the CMake installation. If the file is found, it is read and processed"
" by CMake.  It is responsible for finding the package, checking the "
"version, and producing any needed messages.  Some Find modules provide "
"limited or no support for versioning; check the Find module's "
"documentation."
msgstr ""
"在这种模式下，CMake 搜索名为“Find<PackageName>.cmake”的文件，首先在 CMAKE_MODULE_PATH "
"中列出的位置中查找，然后在 CMake 提供的 Find Modules 中查找安装。如果找到该文件，CMake "
"将读取并处理该文件。它负责查找包、检查版本并生成任何需要的消息。一些 Find 模块对版本控制提供有限支持或不支持；检查查找模块的文档。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:38
msgid ""
"The ``Find<PackageName>.cmake`` file is not typically provided by the "
"package itself.  Rather, it is normally provided by something external to "
"the package, such as the operating system, CMake itself, or even the "
"project from which the ``find_package()`` command was called.  Being "
"externally provided, :ref:`Find Modules` tend to be heuristic in nature "
"and are susceptible to becoming out-of-date.  They typically search for "
"certain libraries, files and other package artifacts."
msgstr ""
"``Find<PackageName>.cmake`` 文件通常不由包本身提供。相反，它通常由包外部的某些东西提供，例如操作系统、CMake "
"本身，甚至是调用“find_package()”命令的项目。由于是外部提供的， :ref:`Find Modules` "
"本质上往往是启发式的，很容易变得过时。他们通常搜索某些库、文件和其他包工件。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:46
msgid ""
"Module mode is only supported by the :ref:`basic command signature <Basic "
"Signature>`."
msgstr "模块模式仅由 :ref:`basic 命令签名 <Basic Signature>` 支持。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:68
msgid "**Config mode**"
msgstr "**配置模式**"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:50
msgid ""
"In this mode, CMake searches for a file called "
"``<lowercasePackageName>-config.cmake`` or ``<PackageName>Config.cmake``. "
"It will also look for ``<lowercasePackageName>-config-version.cmake`` or "
"``<PackageName>ConfigVersion.cmake`` if version details were specified "
"(see :ref:`version selection` for an explanation of how these separate "
"version files are used)."
msgstr ""
"在这种模式下，CMake "
"搜索名为“<lowercasePackageName>-config.cmake”或“<PackageName>Config.cmake”的文件。如果指定了版本详细信息，它还将查找``<lowercasePackageName>-config-"
"version.cmake`` 或``<PackageName>ConfigVersion.cmake``（请参阅:ref:`version "
"selection` 以了解如何将它们分开使用版本文件）。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:57
msgid ""
"In config mode, the command can be given a list of names to search for as "
"package names.  The locations where CMake searches for the config and "
"version files is considerably more complicated than for Module mode (see "
":ref:`search procedure`)."
msgstr ""
"在配置模式下，可以为该命令提供一个名称列表，以作为包名称进行搜索。 CMake "
"搜索配置和版本文件的位置比模块模式复杂得多（请参阅 :ref:`搜索过程`）。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:62
msgid ""
"The config and version files are typically installed as part of the "
"package, so they tend to be more reliable than Find modules.  They usually"
" contain direct knowledge of the package contents, so no searching or "
"heuristics are needed within the config or version files themselves."
msgstr ""
"配置和版本文件通常作为包的一部分安装，因此它们往往比查找模块更可靠。它们通常包含包内容的直接知识，因此不需要在配置或版本文件本身中进行搜索或试探。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:67
msgid ""
"Config mode is supported by both the :ref:`basic <Basic Signature>` and "
":ref:`full <Full Signature>` command signatures."
msgstr ""
":ref:`basic <Basic Signature>` 和 :ref:`full <Full Signature>` 命令签名都支持配置模式。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:77
msgid "**FetchContent redirection mode**"
msgstr "**FetchContent 重定向模式**"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:71
msgid ""
"A call to ``find_package()`` can be redirected internally to a package "
"provided by the :module:`FetchContent` module.  To the caller, the "
"behavior will appear similar to Config mode, except that the search logic "
"is by-passed and the component information is not used.  See "
":command:`FetchContent_Declare` and :command:`FetchContent_MakeAvailable` "
"for further details."
msgstr ""
"对 ``find_package()`` 的调用可以在内部重定向到 FetchContent 模块提供的包。对于调用者来说，行为将类似于 "
"Config 模式，除了绕过搜索逻辑并且不使用组件信息。有关更多详细信息，请参阅 :command:`FetchContent_Declare` "
"和 :command:`FetchContent_MakeAvailable`。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:79
msgid ""
"When not redirected to a package provided by :module:`FetchContent`, the "
"command arguments determine whether Module or Config mode is used.  When "
"the `basic signature`_ is used, the command searches in Module mode first."
" If the package is not found, the search falls back to Config mode. A user"
" may set the :variable:`CMAKE_FIND_PACKAGE_PREFER_CONFIG` variable to true"
" to reverse the priority and direct CMake to search using Config mode "
"first before falling back to Module mode.  The basic signature can also be"
" forced to use only Module mode with a ``MODULE`` keyword.  If the `full "
"signature`_ is used, the command only searches in Config mode."
msgstr ""
"当未重定向到 FetchContent 提供的包时，命令参数决定是使用 Module 还是 Config 模式。当使用 `basic "
"signature`_ 时，命令首先以 Module 模式搜索。如果未找到包，则搜索返回到配置模式。用户可以将 "
":variable:`CMAKE_FIND_PACKAGE_PREFER_CONFIG` 变量设置为 true 以反转优先级并指示 CMake "
"在返回到模块模式之前首先使用配置模式进行搜索。也可以强制基本签名仅使用带有“MODULE”关键字的模块模式。如果使用 `full "
"signature`_，则该命令仅在 Config 模式下搜索。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:89
msgid ""
"Where possible, user code should generally look for packages using the "
"`basic signature`_, since that allows the package to be found with any "
"mode. Project maintainers wishing to provide a config package should "
"understand the bigger picture, as explained in :ref:`Full Signature` and "
"all subsequent sections on this page."
msgstr ""
"在可能的情况下，用户代码通常应该使用 `basic signature`_ "
"查找包，因为这允许使用任何模式找到包。希望提供配置包的项目维护者应该了解全局，如 :ref:`Full Signature` "
"和本页所有后续部分中所述。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:98
msgid "Basic Signature"
msgstr "基本签名"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:110
msgid ""
"The basic signature is supported by both Module and Config modes. The "
"``MODULE`` keyword implies that only Module mode can be used to find the "
"package, with no fallback to Config mode."
msgstr ""
"Module 和 Config 模式都支持基本签名。 ``MODULE`` 关键字意味着只能使用 Module 模式来查找包，而不能回退到 "
"Config 模式。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:114
msgid ""
"Regardless of the mode used, a ``<PackageName>_FOUND`` variable will be "
"set to indicate whether the package was found.  When the package is found,"
" package-specific information may be provided through other variables and "
":ref:`Imported Targets` documented by the package itself.  The ``QUIET`` "
"option disables informational messages, including those indicating that "
"the package cannot be found if it is not ``REQUIRED``.  The ``REQUIRED`` "
"option stops processing with an error message if the package cannot be "
"found."
msgstr ""
"无论使用何种模式，都会设置一个``<PackageName>_FOUND`` 变量来指示是否找到了包。找到包后，可以通过其他变量和包本身记录的 "
":ref:`Imported Targets` 提供特定于包的信息。 ``QUIET`` "
"选项禁用信息性消息，包括那些指示如果包不是``REQUIRED`` 就找不到的消息。如果找不到包，“REQUIRED”选项会停止处理并显示错误消息。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:122
msgid ""
"A package-specific list of required components may be listed after the "
"``COMPONENTS`` keyword.  If any of these components are not able to be "
"satisfied, the package overall is considered to be not found.  If the "
"``REQUIRED`` option is also present, this is treated as a fatal error, "
"otherwise execution still continues.  As a form of shorthand, if the "
"``REQUIRED`` option is present, the ``COMPONENTS`` keyword can be omitted "
"and the required components can be listed directly after ``REQUIRED``."
msgstr ""
"在“COMPONENTS”关键字之后可能会列出特定于包的所需组件列表。如果无法满足这些组件中的任何一个，则认为整个包未找到。如果 "
"``REQUIRED`` 选项也存在，这将被视为致命错误，否则执行仍将继续。作为一种简写形式，如果存在 REQUIRED 选项，则可以省略 "
"COMPONENTS 关键字，所需的组件可以直接列在 REQUIRED 之后。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:130
msgid ""
"Additional optional components may be listed after "
"``OPTIONAL_COMPONENTS``.  If these cannot be satisfied, the package "
"overall can still be considered found, as long as all required components "
"are satisfied."
msgstr ""
"额外的可选组件可能会列在 ``OPTIONAL_COMPONENTS`` "
"之后。如果这些都不能满足，只要满足所有要求的组件，仍然可以认为包整体找到了。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:135
msgid ""
"The set of available components and their meaning are defined by the "
"target package.  Formally, it is up to the target package how to interpret"
" the component information given to it, but it should follow the "
"expectations stated above.  For calls where no components are specified, "
"there is no single expected behavior and target packages should clearly "
"define what occurs in such cases.  Common arrangements include assuming it"
" should find all components, no components or some well-defined subset of "
"the available components."
msgstr ""
"可用组件集及其含义由目标包定义。形式上，目标包如何解释提供给它的组件信息取决于目标包，但它应该遵循上述期望。对于没有指定组件的调用，没有单一的预期行为，目标包应该清楚地定义在这种情况下会发生什么。常见的安排包括假设它应该找到所有组件、没有组件或可用组件的一些明确定义的子集。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:144
msgid ""
"The ``REGISTRY_VIEW`` keyword specifies which registry views should be "
"queried. This keyword is only meaningful on ``Windows`` platforms and will"
" be ignored on all others. Formally, it is up to the target package how to"
" interpret the registry view information given to it."
msgstr ""
"``REGISTRY_VIEW`` "
"关键字指定应查询哪些注册表视图。此关键字仅在“Windows”平台上有意义，在所有其他平台上将被忽略。形式上，目标包如何解释提供给它的注册表视图信息由目标包决定。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:150
msgid ""
"Specifying the ``GLOBAL`` keyword will promote all imported targets to a "
"global scope in the importing project. Alternatively, this functionality "
"can be enabled by setting the "
":variable:`CMAKE_FIND_PACKAGE_TARGETS_GLOBAL` variable."
msgstr ""
"指定 ``GLOBAL`` 关键字会将所有导入的目标提升到导入项目中的全局范围。或者，可以通过设置 "
"CMAKE_FIND_PACKAGE_TARGETS_GLOBAL 变量来启用此功能。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:158
msgid ""
"The ``[version]`` argument requests a version with which the package found"
" should be compatible. There are two possible forms in which it may be "
"specified:"
msgstr "``[version]`` 参数请求找到的包应该兼容的版本。有两种可能的形式可以指定它："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:162
msgid ""
"A single version with the format ``major[.minor[.patch[.tweak]]]``, where "
"each component is a numeric value."
msgstr "格式为“major[.minor[.patch[.tweak]]]”的单一版本，其中每个组件都是一个数值。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:164
msgid ""
"A version range with the format ``versionMin...[<]versionMax`` where "
"``versionMin`` and ``versionMax`` have the same format and constraints on "
"components being integers as the single version.  By default, both end "
"points are included.  By specifying ``<``, the upper end point will be "
"excluded. Version ranges are only supported with CMake 3.19 or later."
msgstr ""
"格式为 ``versionMin...[<]versionMax`` 的版本范围，其中 ``versionMin`` 和 "
"``versionMax`` 与单一版本具有相同的格式和对组件为整数的约束。默认情况下，包括两个端点。通过指定``<``，将排除上端点。仅 "
"CMake 3.19 或更高版本支持版本范围。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:170
msgid ""
"The ``EXACT`` option requests that the version be matched exactly. This "
"option is incompatible with the specification of a version range."
msgstr "``EXACT`` 选项要求版本完全匹配。此选项与版本范围的规范不兼容。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:173
msgid ""
"If no ``[version]`` and/or component list is given to a recursive "
"invocation inside a find-module, the corresponding arguments are forwarded"
" automatically from the outer call (including the ``EXACT`` flag for "
"``[version]``).  Version support is currently provided only on a package-"
"by-package basis (see the `Version Selection`_ section below). When a "
"version range is specified but the package is only designed to expect a "
"single version, the package will ignore the upper end point of the range "
"and only take the single version at the lower end of the range into "
"account."
msgstr ""
"如果没有 ``[version]`` 和/或组件列表被提供给查找模块内的递归调用，则相应的参数会自动从外部调用转发（包括 ``[version] 的"
" ``EXACT`` "
"标志]``）。目前仅在逐个软件包的基础上提供版本支持（请参阅下面的“版本选择”部分）。当指定了版本范围但包仅设计为期望单个版本时，包将忽略范围的上限点，而仅考虑范围下限的单个版本。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:182
#: ../../cmake-prefix/src/cmake/Help/command/include.rst:24
msgid ""
"See the :command:`cmake_policy` command documentation for discussion of "
"the ``NO_POLICY_SCOPE`` option."
msgstr "有关 ``NO_POLICY_SCOPE`` 选项的讨论，请参阅 :command:`cmake_policy` 命令文档。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:185
msgid ""
"The ``BYPASS_PROVIDER`` keyword is only allowed when ``find_package()`` is"
" being called by a :ref:`dependency provider <dependency_providers>`. It "
"can be used by providers to call the built-in ``find_package()`` "
"implementation directly and prevent that call from being re-routed back to"
" itself.  Future versions of CMake may detect attempts to use this keyword"
" from places other than a dependency provider and halt with a fatal error."
msgstr ""
"``BYPASS_PROVIDER`` 关键字仅在 ``find_package()`` 被 :ref:`dependency provider "
"<dependency_providers>` "
"调用时才被允许。提供者可以使用它来直接调用内置的“find_package()”实现，并防止该调用被重新路由回自身。 CMake "
"的未来版本可能会检测到从依赖项提供程序以外的地方使用此关键字的尝试，并因致命错误而停止。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:196
msgid "Full Signature"
msgstr "完整签名"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:227
msgid ""
"The ``CONFIG`` option, the synonymous ``NO_MODULE`` option, or the use of "
"options not specified in the `basic signature`_ all enforce pure Config "
"mode.  In pure Config mode, the command skips Module mode search and "
"proceeds at once with Config mode search."
msgstr ""
"``CONFIG`` 选项，同义的 ``NO_MODULE`` 选项，或使用未在 `basic signature` "
"中指定的选项都强制执行纯配置模式。在纯 Config 模式下，该命令会跳过 Module 模式搜索并立即进行 Config 模式搜索。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:232
msgid ""
"Config mode search attempts to locate a configuration file provided by the"
" package to be found.  A cache entry called ``<PackageName>_DIR`` is "
"created to hold the directory containing the file.  By default, the "
"command searches for a package with the name ``<PackageName>``.  If the "
"``NAMES`` option is given, the names following it are used instead of "
"``<PackageName>``.  The names are also considered when determining whether"
" to redirect the call to a package provided by :module:`FetchContent`."
msgstr ""
"配置模式搜索尝试定位要查找的包提供的配置文件。创建一个名为“<PackageName>_DIR”的缓存条目来保存包含该文件的目录。默认情况下，该命令搜索名称为“<PackageName>”的包。如果给出了"
" ``NAMES`` 选项，则使用它后面的名称而不是 ``<PackageName>``。在确定是否将调用重定向到 FetchContent "
"提供的包时，也会考虑这些名称。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:240
msgid ""
"The command searches for a file called ``<PackageName>Config.cmake`` or "
"``<lowercasePackageName>-config.cmake`` for each name specified. A "
"replacement set of possible configuration file names may be given using "
"the ``CONFIGS`` option.  The :ref:`search procedure` is specified below. "
"Once found, any :ref:`version constraint <version selection>` is checked, "
"and if satisfied, the configuration file is read and processed by CMake. "
"Since the file is provided by the package it already knows the location of"
" package contents.  The full path to the configuration file is stored in "
"the cmake variable ``<PackageName>_CONFIG``."
msgstr ""
"该命令为每个指定的名称搜索名为“<PackageName>Config.cmake”或“<lowercasePackageName>-config.cmake”的文件。可以使用"
" ``CONFIGS`` 选项给出一组可能的配置文件名的替换。 :ref:`搜索程序`在下面指定。一旦找到，就会检查任何 :ref:`version"
" constraint <version selection>`，如果满足，CMake "
"将读取和处理配置文件。由于文件是由包提供的，它已经知道包内容的位置。配置文件的完整路径存储在 cmake "
"变量“<PackageName>_CONFIG”中。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:250
msgid ""
"All configuration files which have been considered by CMake while "
"searching for the package with an appropriate version are stored in the "
"``<PackageName>_CONSIDERED_CONFIGS`` variable, and the associated versions"
" in the ``<PackageName>_CONSIDERED_VERSIONS`` variable."
msgstr ""
"CMake 在搜索具有适当版本的包时考虑的所有配置文件都存储在``<PackageName>_CONSIDERED_CONFIGS`` "
"变量中，相关版本存储在``<PackageName>_CONSIDERED_VERSIONS`` 变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:255
msgid ""
"If the package configuration file cannot be found CMake will generate an "
"error describing the problem unless the ``QUIET`` argument is specified.  "
"If ``REQUIRED`` is specified and the package is not found a fatal error is"
" generated and the configure step stops executing.  If "
"``<PackageName>_DIR`` has been set to a directory not containing a "
"configuration file CMake will ignore it and search from scratch."
msgstr ""
"如果找不到包配置文件，CMake 将生成一个描述问题的错误，除非指定了“QUIET”参数。如果指定了 REQUIRED "
"并且未找到包，则会生成致命错误并且配置步骤将停止执行。如果``<PackageName>_DIR`` 被设置为不包含配置文件的目录，CMake "
"将忽略它并从头开始搜索。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:262
msgid ""
"Package maintainers providing CMake package configuration files are "
"encouraged to name and install them such that the :ref:`search procedure` "
"outlined below will find them without requiring use of additional options."
msgstr "鼓励提供 CMake 包配置文件的包维护者命名和安装它们，以便下面概述的 :ref:`搜索过程` 无需使用其他选项即可找到它们。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:269
msgid "Config Mode Search Procedure"
msgstr "配置模式搜索过程"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:272
msgid ""
"When Config mode is used, this search procedure is applied regardless of "
"whether the :ref:`full <full signature>` or :ref:`basic <basic signature>`"
" signature was given."
msgstr ""
"使用 Config 模式时，无论是否给出了 :ref:`full <full signature>` 或 :ref:`basic <basic "
"signature>` 签名，都会应用此搜索过程。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:276
msgid ""
"All calls to ``find_package()`` (even in Module mode) first look for a "
"config package file in the :variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` "
"directory. The :module:`FetchContent` module, or even the project itself, "
"may write files to that location to redirect ``find_package()`` calls to "
"content already provided by the project.  If no config package file is "
"found in that location, the search proceeds with the logic described "
"below."
msgstr ""
"所有对 ``find_package()`` 的调用（即使在模块模式下）首先在 "
":variable:`CMAKE_FIND_PACKAGE_REDIRECTS_DIR` 目录中查找配置包文件。 "
":module:`FetchContent` 模块，甚至项目本身，都可以将文件写入该位置，以将 ``find_package()`` "
"调用重定向到项目已经提供的内容。如果在该位置没有找到配置包文件，则搜索将按照下面描述的逻辑继续进行。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:284
msgid ""
"CMake constructs a set of possible installation prefixes for the package."
"  Under each prefix several directories are searched for a configuration "
"file.  The tables below show the directories searched. Each entry is meant"
" for installation trees following Windows (``W``), UNIX (``U``), or Apple "
"(``A``) conventions:"
msgstr ""
"CMake 为包构建了一组可能的安装前缀。在每个前缀下的几个目录中搜索配置文件。下表显示了搜索的目录。每个条目都适用于遵循 Windows "
"(``W``)、UNIX (``U``) 或 Apple (``A``) 约定的安装树："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:291
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:313
msgid "Entry"
msgstr "入口"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:291
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:313
msgid "Convention"
msgstr "习俗"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:293
msgid "``<prefix>/``"
msgstr "``<前缀>/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:293
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:294
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:295
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:296
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:297
msgid "W"
msgstr "W"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:294
msgid "``<prefix>/(cmake|CMake)/``"
msgstr "``<前缀>/(cmake|CMake)/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:295
msgid "``<prefix>/<name>*/``"
msgstr "``<前缀>/<名称>*/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:296
msgid "``<prefix>/<name>*/(cmake|CMake)/``"
msgstr "``<前缀>/<名称>*/(cmake|CMake)/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:297
msgid "``<prefix>/<name>*/(cmake|CMake)/<name>*/`` [#]_"
msgstr "``<前缀>/<名称>*/(cmake|CMake)/<名称>*/`` [#]_"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:298
msgid "``<prefix>/(lib/<arch>|lib*|share)/cmake/<name>*/``"
msgstr "``<prefix>/(lib/<arch>|lib*|share)/cmake/<name>*/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:298
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:299
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:300
msgid "U"
msgstr "ü"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:299
msgid "``<prefix>/(lib/<arch>|lib*|share)/<name>*/``"
msgstr "``<前缀>/(lib/<arch>|lib*|share)/<名称>*/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:300
msgid "``<prefix>/(lib/<arch>|lib*|share)/<name>*/(cmake|CMake)/``"
msgstr "``<前缀>/(lib/<arch>|lib*|share)/<名称>*/(cmake|CMake)/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:301
msgid "``<prefix>/<name>*/(lib/<arch>|lib*|share)/cmake/<name>*/``"
msgstr "``<prefix>/<name>*/(lib/<arch>|lib*|share)/cmake/<name>*/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:301
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:302
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:303
msgid "W/U"
msgstr "W/U"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:302
msgid "``<prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/``"
msgstr "``<前缀>/<名称>*/(lib/<arch>|lib*|share)/<名称>*/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:303
msgid "``<prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/(cmake|CMake)/``"
msgstr "``<前缀>/<名称>*/(lib/<arch>|lib*|share)/<名称>*/(cmake|CMake)/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:308
msgid ""
"On systems supporting macOS :prop_tgt:`FRAMEWORK` and :prop_tgt:`BUNDLE`, "
"the following directories are searched for Frameworks or Application "
"Bundles containing a configuration file:"
msgstr ""
"在支持 macOS :prop_tgt:`FRAMEWORK` 和 :prop_tgt:`BUNDLE` "
"的系统上，搜索以下目录以查找包含配置文件的框架或应用程序包："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:315
msgid "``<prefix>/<name>.framework/Resources/``"
msgstr "``<前缀>/<名称>.framework/Resources/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:315
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:316
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:317
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:318
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:319
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:320
msgid "A"
msgstr "A"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:316
msgid "``<prefix>/<name>.framework/Resources/CMake/``"
msgstr "``<前缀>/<名称>.framework/Resources/CMake/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:317
msgid "``<prefix>/<name>.framework/Versions/*/Resources/``"
msgstr "``<前缀>/<名称>.framework/Versions/*/Resources/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:318
msgid "``<prefix>/<name>.framework/Versions/*/Resources/CMake/``"
msgstr "``<前缀>/<名称>.framework/Versions/*/Resources/CMake/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:319
msgid "``<prefix>/<name>.app/Contents/Resources/``"
msgstr "``<前缀>/<名称>.app/Contents/Resources/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:320
msgid "``<prefix>/<name>.app/Contents/Resources/CMake/``"
msgstr "``<前缀>/<名称>.app/Contents/Resources/CMake/``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:323
msgid ""
"In all cases the ``<name>`` is treated as case-insensitive and corresponds"
" to any of the names specified (``<PackageName>`` or names given by "
"``NAMES``)."
msgstr ""
"在所有情况下，``<name>`` 都被视为不区分大小写，并对应于指定的任何名称（``<PackageName>`` 或由``NAMES`` "
"给出的名称）。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:326
msgid ""
"Paths with ``lib/<arch>`` are enabled if the "
":variable:`CMAKE_LIBRARY_ARCHITECTURE` variable is set. ``lib*`` includes "
"one or more of the values ``lib64``, ``lib32``, ``libx32`` or ``lib`` "
"(searched in that order)."
msgstr ""
"如果设置了 CMAKE_LIBRARY_ARCHITECTURE 变量，则启用带有 lib/<arch> 的路径。 ``lib*`` "
"包括一个或多个值 ``lib64``、``lib32``、``libx32`` 或 ``lib``（按顺序搜索）。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:331
msgid ""
"Paths with ``lib64`` are searched on 64 bit platforms if the "
":prop_gbl:`FIND_LIBRARY_USE_LIB64_PATHS` property is set to ``TRUE``."
msgstr ""
"如果 :prop_gbl:`FIND_LIBRARY_USE_LIB64_PATHS` 属性设置为 ``TRUE``，则在 64 位平台上搜索带有 "
"``lib64`` 的路径。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:333
msgid ""
"Paths with ``lib32`` are searched on 32 bit platforms if the "
":prop_gbl:`FIND_LIBRARY_USE_LIB32_PATHS` property is set to ``TRUE``."
msgstr ""
"如果 :prop_gbl:`FIND_LIBRARY_USE_LIB32_PATHS` 属性设置为 ``TRUE``，则在 32 位平台上搜索带有 "
"``lib32`` 的路径。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:335
msgid ""
"Paths with ``libx32`` are searched on platforms using the x32 ABI if the "
":prop_gbl:`FIND_LIBRARY_USE_LIBX32_PATHS` property is set to ``TRUE``."
msgstr ""
"如果 :prop_gbl:`FIND_LIBRARY_USE_LIBX32_PATHS` 属性设置为 ``TRUE``，则使用 x32 ABI "
"在平台上搜索带有 ``libx32`` 的路径。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:337
msgid "The ``lib`` path is always searched."
msgstr "始终搜索 ``lib`` 路径。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:339
msgid ""
"On ``Windows`` platform, it is possible to include registry queries as "
"part of the directories specified through ``HINTS`` and ``PATHS`` "
"keywords, using a :ref:`dedicated syntax <Find Using Windows Registry>`. "
"Such specifications will be ignored on all other platforms."
msgstr ""
"在 ``Windows`` 平台上，可以将注册表查询作为通过 ``HINTS`` 和 ``PATHS`` "
"关键字指定的目录的一部分，使用 :ref:`专用语法 <Find Using Windows Registry>` "
".此类规范将在所有其他平台上被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:345
msgid ""
"``REGISTRY_VIEW`` can be specified to manage ``Windows`` registry queries "
"specified as part of ``PATHS`` and ``HINTS``."
msgstr ""
"可以指定``REGISTRY_VIEW`` 来管理``Windows`` 注册表查询，这些查询指定为``PATHS`` 和``HINTS`` "
"的一部分。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:351
msgid ""
"If ``PATH_SUFFIXES`` is specified, the suffixes are appended to each "
"(``W``) or (``U``) directory entry one-by-one."
msgstr "如果指定了 ``PATH_SUFFIXES``，则后缀将一个接一个地附加到每个 (``W``) 或 (``U``) 目录条目。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:354
msgid ""
"This set of directories is intended to work in cooperation with projects "
"that provide configuration files in their installation trees. Directories "
"above marked with (``W``) are intended for installations on Windows where "
"the prefix may point at the top of an application's installation "
"directory.  Those marked with (``U``) are intended for installations on "
"UNIX platforms where the prefix is shared by multiple packages.  This is "
"merely a convention, so all (``W``) and (``U``) directories are still "
"searched on all platforms.  Directories marked with (``A``) are intended "
"for installations on Apple platforms.  The "
":variable:`CMAKE_FIND_FRAMEWORK` and :variable:`CMAKE_FIND_APPBUNDLE` "
"variables determine the order of preference."
msgstr ""
"这组目录旨在与在其安装树中提供配置文件的项目合作。上面标有 (``W``) 的目录用于在 Windows "
"上安装，其中前缀可能指向应用程序安装目录的顶部。那些标有 (``U``) 的用于安装在 UNIX "
"平台上，其中前缀由多个包共享。这只是一个约定，所以所有 (``W``) 和 (``U``) 目录仍然在所有平台上搜索。标有 (``A``) "
"的目录用于在 Apple 平台上安装。 :variable:`CMAKE_FIND_FRAMEWORK` 和 "
":variable:`CMAKE_FIND_APPBUNDLE` 变量决定优先顺序。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:366
msgid ""
"The set of installation prefixes is constructed using the following steps."
"  If ``NO_DEFAULT_PATH`` is specified all ``NO_*`` options are enabled."
msgstr "安装前缀集是使用以下步骤构建的。如果指定了 ``NO_DEFAULT_PATH``，则启用所有 ``NO_*`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:370
msgid ""
"Search paths specified in the :variable:`<PackageName>_ROOT` CMake "
"variable and the :envvar:`<PackageName>_ROOT` environment variable, where "
"``<PackageName>`` is the package to be found (the case-preserved first "
"argument to ``find_package``). The package root variables are maintained "
"as a stack so if called from within a find module, root paths from the "
"parent's find module will also be searched after paths for the current "
"package. This can be skipped if ``NO_PACKAGE_ROOT_PATH`` is passed or by "
"setting the :variable:`CMAKE_FIND_USE_PACKAGE_ROOT_PATH` to ``FALSE``. See"
" policy :policy:`CMP0074`."
msgstr ""
"在 :variable:`<PackageName>_ROOT` CMake 变量和 :envvar:`<PackageName>_ROOT` "
"环境变量中指定的搜索路径，其中``<PackageName>`` 是要查找的包（大小写优先） ``find_package`` "
"的参数）。包根变量作为堆栈维护，因此如果从查找模块中调用，父查找模块的根路径也将在当前包的路径之后进行搜索。如果传递了 "
"``NO_PACKAGE_ROOT_PATH`` 或者通过将 "
":variable:`CMAKE_FIND_USE_PACKAGE_ROOT_PATH` 设置为 ``FALSE`` "
"可以跳过这一步。请参阅政策:policy:`CMP0074`。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:382
msgid ""
"Search paths specified in cmake-specific cache variables.  These are "
"intended to be used on the command line with a :option:`-DVAR=VALUE <cmake"
" -D>`. The values are interpreted as :ref:`semicolon-separated lists "
"<CMake Language Lists>`. This can be skipped if ``NO_CMAKE_PATH`` is "
"passed or by setting the :variable:`CMAKE_FIND_USE_CMAKE_PATH` to "
"``FALSE``:"
msgstr ""
"在特定于 cmake 的缓存变量中指定的搜索路径。这些旨在与 :option:`-DVAR=VALUE <cmake -D>` "
"在命令行上使用。这些值被解释为:ref:`分号分隔的列表 <CMake Language Lists>`。如果传递了 "
"``NO_CMAKE_PATH`` 或通过将 :variable:`CMAKE_FIND_USE_CMAKE_PATH` 设置为 "
"``FALSE``，则可以跳过此步骤："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:388
msgid ":variable:`CMAKE_PREFIX_PATH`"
msgstr ":variable:`CMAKE_PREFIX_PATH`"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:389
msgid ":variable:`CMAKE_FRAMEWORK_PATH`"
msgstr ":variable:`CMAKE_FRAMEWORK_PATH`"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:390
msgid ":variable:`CMAKE_APPBUNDLE_PATH`"
msgstr ":variable:`CMAKE_APPBUNDLE_PATH`"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:392
msgid ""
"Search paths specified in cmake-specific environment variables. These are "
"intended to be set in the user's shell configuration, and therefore use "
"the host's native path separator (``;`` on Windows and ``:`` on UNIX). "
"This can be skipped if ``NO_CMAKE_ENVIRONMENT_PATH`` is passed or by "
"setting the :variable:`CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH` to "
"``FALSE``:"
msgstr ""
"在特定于 cmake 的环境变量中指定的搜索路径。这些旨在在用户的 shell 配置中设置，因此使用主机的本机路径分隔符（Windows "
"上为“;”，UNIX 上为“ :”）。如果传递了 ``NO_CMAKE_ENVIRONMENT_PATH`` 或通过将 "
":variable:`CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH` 设置为 ``FALSE``，则可以跳过此步骤："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:399
msgid "``<PackageName>_DIR``"
msgstr "``<PackageName>_DIR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:400
msgid ":envvar:`CMAKE_PREFIX_PATH`"
msgstr ":envvar:`CMAKE_PREFIX_PATH`"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:401
msgid "``CMAKE_FRAMEWORK_PATH``"
msgstr "``CMAKE_FRAMEWORK_PATH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:402
msgid "``CMAKE_APPBUNDLE_PATH``"
msgstr "``CMAKE_APPBUNDLE_PATH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:404
msgid ""
"Search paths specified by the ``HINTS`` option.  These should be paths "
"computed by system introspection, such as a hint provided by the location "
"of another item already found.  Hard-coded guesses should be specified "
"with the ``PATHS`` option."
msgstr ""
"搜索由 ``HINTS`` 选项指定的路径。这些应该是系统自省计算出的路径，例如由已找到的另一个项目的位置提供的提示。硬编码的猜测应该用 "
"``PATHS`` 选项指定。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:409
msgid ""
"Search the standard system environment variables.  This can be skipped if "
"``NO_SYSTEM_ENVIRONMENT_PATH`` is passed  or by setting the "
":variable:`CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH` to ``FALSE``. Path "
"entries ending in ``/bin`` or ``/sbin`` are automatically converted to "
"their parent directories:"
msgstr ""
"搜索标准系统环境变量。如果传递了 ``NO_SYSTEM_ENVIRONMENT_PATH`` 或通过将 "
":variable:`CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH` 设置为 ``FALSE`` "
"可以跳过这一步。以“/bin”或“/sbin”结尾的路径条目会自动转换为其父目录："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:415
#: ../../cmake-prefix/src/cmake/Help/command/set.rst:58
msgid "``PATH``"
msgstr "``路径``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:417
msgid ""
"Search paths stored in the CMake :ref:`User Package Registry`. This can be"
" skipped if ``NO_CMAKE_PACKAGE_REGISTRY`` is passed or by setting the "
"variable :variable:`CMAKE_FIND_USE_PACKAGE_REGISTRY` to ``FALSE`` or the "
"deprecated variable :variable:`CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY` to "
"``TRUE``."
msgstr ""
"搜索存储在 CMake :ref:`User Package Registry` 中的路径。如果传递了 "
"``NO_CMAKE_PACKAGE_REGISTRY`` 或通过将变量 :variable:`CMAKE_FIND_USE_PACKAGE_REGISTRY` "
"设置为 ``FALSE`` 或将已弃用的变量 :variable:`CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY` 设置为 "
"``TRUE``，则可以跳过此步骤。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:423
msgid ""
"See the :manual:`cmake-packages(7)` manual for details on the user package"
" registry."
msgstr "有关用户包注册表的详细信息，请参阅 :manual:`cmake-packages(7)` 手册。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:426
msgid ""
"Search cmake variables defined in the Platform files for the current "
"system. The searching of :variable:`CMAKE_INSTALL_PREFIX` and "
":variable:`CMAKE_STAGING_PREFIX` can be skipped if "
"``NO_CMAKE_INSTALL_PREFIX`` is passed or by setting the "
":variable:`CMAKE_FIND_USE_INSTALL_PREFIX` to ``FALSE``. All these "
"locations can be skipped if ``NO_CMAKE_SYSTEM_PATH`` is passed or by "
"setting the :variable:`CMAKE_FIND_USE_CMAKE_SYSTEM_PATH` to ``FALSE``:"
msgstr ""
"搜索在当前系统的平台文件中定义的 cmake 变量。如果传递了 NO_CMAKE_INSTALL_PREFIX 或将 "
"CMAKE_FIND_USE_INSTALL_PREFIX 设置为 FALSE，则可以跳过 CMAKE_INSTALL_PREFIX 和 "
"CMAKE_STAGING_PREFIX 的搜索。如果传递 ``NO_CMAKE_SYSTEM_PATH`` 或通过将 "
":variable:`CMAKE_FIND_USE_CMAKE_SYSTEM_PATH` 设置为 ``FALSE``，则可以跳过所有这些位置："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:434
msgid ":variable:`CMAKE_SYSTEM_PREFIX_PATH`"
msgstr ":variable:`CMAKE_SYSTEM_PREFIX_PATH`"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:435
msgid ":variable:`CMAKE_SYSTEM_FRAMEWORK_PATH`"
msgstr ":variable:`CMAKE_SYSTEM_FRAMEWORK_PATH`"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:436
msgid ":variable:`CMAKE_SYSTEM_APPBUNDLE_PATH`"
msgstr ":variable:`CMAKE_SYSTEM_APPBUNDLE_PATH`"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:442
msgid ""
"Search paths stored in the CMake :ref:`System Package Registry`. This can "
"be skipped if ``NO_CMAKE_SYSTEM_PACKAGE_REGISTRY`` is passed or by setting"
" the :variable:`CMAKE_FIND_USE_SYSTEM_PACKAGE_REGISTRY` variable to "
"``FALSE`` or the deprecated variable "
":variable:`CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY` to ``TRUE``."
msgstr ""
"搜索存储在 CMake :ref:`System Package Registry` 中的路径。如果传递了 "
"``NO_CMAKE_SYSTEM_PACKAGE_REGISTRY`` "
"或通过将 :variable:`CMAKE_FIND_USE_SYSTEM_PACKAGE_REGISTRY` 变量设置为 ``FALSE`` "
"或将已弃用的变量 :variable:`CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY` 设置为 "
"``TRUE``，则可以跳过此步骤。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:448
msgid ""
"See the :manual:`cmake-packages(7)` manual for details on the system "
"package registry."
msgstr "有关系统包注册表的详细信息，请参阅 :manual:`cmake-packages(7)` 手册。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:451
msgid ""
"Search paths specified by the ``PATHS`` option.  These are typically hard-"
"coded guesses."
msgstr "搜索由 ``PATHS`` 选项指定的路径。这些通常是硬编码的猜测。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:459
msgid ""
"Added the ``CMAKE_FIND_USE_<CATEGORY>`` variables to globally disable "
"various search locations."
msgstr "添加了 ``CMAKE_FIND_USE_<CATEGORY>`` 变量以全局禁用各种搜索位置。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:466
msgid ""
"By default the value stored in the result variable will be the path at "
"which the file is found.  The "
":variable:`CMAKE_FIND_PACKAGE_RESOLVE_SYMLINKS` variable may be set to "
"``TRUE`` before calling ``find_package`` in order to resolve symbolic "
"links and store the real path to the file."
msgstr ""
"默认情况下，存储在结果变量中的值将是找到文件的路径。 :variable:`CMAKE_FIND_PACKAGE_RESOLVE_SYMLINKS`"
" 变量可以在调用 ``find_package`` 之前设置为 ``TRUE`` 以解析符号链接并存储文件的真实路径。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:471
msgid ""
"Every non-REQUIRED ``find_package`` call can be disabled or made REQUIRED:"
msgstr "每个非必需的 ``find_package`` 调用都可以被禁用或成为必需的："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:473
msgid ""
"Setting the :variable:`CMAKE_DISABLE_FIND_PACKAGE_<PackageName>` variable "
"to ``TRUE`` disables the package.  This also disables redirection to a "
"package provided by :module:`FetchContent`."
msgstr ""
"将 :variable:`CMAKE_DISABLE_FIND_PACKAGE_<PackageName>` 变量设置为 ``TRUE`` "
"会禁用包。这也会禁用重定向到 FetchContent 提供的包。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:477
msgid ""
"Setting the :variable:`CMAKE_REQUIRE_FIND_PACKAGE_<PackageName>` variable "
"to ``TRUE`` makes the package REQUIRED."
msgstr ""
"将 :variable:`CMAKE_REQUIRE_FIND_PACKAGE_<PackageName>` 变量设置为 ``TRUE`` "
"使包成为必需的。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:480
msgid "Setting both variables to ``TRUE`` simultaneously is an error."
msgstr "同时将两个变量设置为“TRUE”是错误的。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:485
msgid "Config Mode Version Selection"
msgstr "配置模式版本选择"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:488
msgid ""
"When Config mode is used, this version selection process is applied "
"regardless of whether the :ref:`full <full signature>` or :ref:`basic "
"<basic signature>` signature was given."
msgstr ""
"当使用 Config 模式时，无论是否给出了 :ref:`full <full signature>` 或 :ref:`basic <basic "
"signature>` 签名，都会应用此版本选择过程。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:492
msgid ""
"When the ``[version]`` argument is given, Config mode will only find a "
"version of the package that claims compatibility with the requested "
"version (see :ref:`format specification <FIND_PACKAGE_VERSION_FORMAT>`). "
"If the ``EXACT`` option is given, only a version of the package claiming "
"an exact match of the requested version may be found.  CMake does not "
"establish any convention for the meaning of version numbers.  Package "
"version numbers are checked by \"version\" files provided by the packages "
"themselves or by :module:`FetchContent`.  For a candidate package "
"configuration file ``<config-file>.cmake`` the corresponding version file "
"is located next to it and named either ``<config-file>-version.cmake`` or "
"``<config-file>Version.cmake``.  If no such version file is available then"
" the configuration file is assumed to not be compatible with any requested"
" version.  A basic version file containing generic version matching code "
"can be created using the :module:`CMakePackageConfigHelpers` module.  When"
" a version file is found it is loaded to check the requested version "
"number.  The version file is loaded in a nested scope in which the "
"following variables have been defined:"
msgstr ""
"当给出 ``[version]`` 参数时，Config 模式将仅查找声称与所请求版本兼容的包版本（请参阅:ref:`格式规范 "
"<FIND_PACKAGE_VERSION_FORMAT>`）。如果给出了 EXACT 选项，则只能找到声称与所请求版本完全匹配的包版本。 "
"CMake 没有为版本号的含义建立任何约定。包版本号由包本身提供的“版本”文件或 :module:`FetchContent` "
"检查。对于候选包配置文件 ``<config-file>.cmake`` 相应的版本文件位于其旁边并命名为 ``<config-"
"file>-version.cmake`` 或 ``<config-"
"file>版本.cmake``。如果没有这样的版本文件可用，则假定配置文件与任何请求的版本不兼容。可以使用 "
"CMakePackageConfigHelpers "
"模块创建包含通用版本匹配代码的基本版本文件。当找到版本文件时，它会被加载以检查请求的版本号。版本文件加载到嵌套范围内，其中定义了以下变量："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:511
msgid "``PACKAGE_FIND_NAME``"
msgstr "``PACKAGE_FIND_NAME``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:512
msgid "The ``<PackageName>``"
msgstr "``<PackageName>``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:513
msgid "``PACKAGE_FIND_VERSION``"
msgstr "``PACKAGE_FIND_VERSION``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:514
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:637
msgid "Full requested version string"
msgstr "完整请求的版本字符串"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:515
msgid "``PACKAGE_FIND_VERSION_MAJOR``"
msgstr "``PACKAGE_FIND_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:516
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:639
msgid "Major version if requested, else 0"
msgstr "如果需要，则为主要版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:517
msgid "``PACKAGE_FIND_VERSION_MINOR``"
msgstr "``PACKAGE_FIND_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:518
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:641
msgid "Minor version if requested, else 0"
msgstr "如果要求是次要版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:519
msgid "``PACKAGE_FIND_VERSION_PATCH``"
msgstr "``PACKAGE_FIND_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:520
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:643
msgid "Patch version if requested, else 0"
msgstr "如果要求补丁版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:521
msgid "``PACKAGE_FIND_VERSION_TWEAK``"
msgstr "``PACKAGE_FIND_VERSION_TWEAK``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:522
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:645
msgid "Tweak version if requested, else 0"
msgstr "如果需要调整版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:524
msgid "``PACKAGE_FIND_VERSION_COUNT``"
msgstr "``PACKAGE_FIND_VERSION_COUNT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:524
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:601
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:647
msgid "Number of version components, 0 to 4"
msgstr "版本组件数，0 到 4"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:526
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:656
msgid ""
"When a version range is specified, the above version variables will hold "
"values based on the lower end of the version range.  This is to preserve "
"compatibility with packages that have not been implemented to expect "
"version ranges.  In addition, the version range will be described by the "
"following variables:"
msgstr ""
"指定版本范围后，上述版本变量将保存基于版本范围下限的值。这是为了保持与尚未实现预期版本范围的包的兼容性。此外，版本范围将由以下变量描述："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:532
msgid "``PACKAGE_FIND_VERSION_RANGE``"
msgstr "``PACKAGE_FIND_VERSION_RANGE``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:533
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:663
msgid "Full requested version range string"
msgstr "完整请求的版本范围字符串"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:536
msgid "``PACKAGE_FIND_VERSION_RANGE_MIN``"
msgstr "``PACKAGE_FIND_VERSION_RANGE_MIN``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:535
msgid ""
"This specifies whether the lower end point of the version range should be "
"included or excluded.  Currently, the only supported value for this "
"variable is ``INCLUDE``."
msgstr "这指定是否应包括或排除版本范围的下端点。目前，此变量唯一支持的值是 ``INCLUDE``。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:541
msgid "``PACKAGE_FIND_VERSION_RANGE_MAX``"
msgstr "``PACKAGE_FIND_VERSION_RANGE_MAX``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:539
msgid ""
"This specifies whether the upper end point of the version range should be "
"included or excluded.  The supported values for this variable are "
"``INCLUDE`` and ``EXCLUDE``."
msgstr "这指定是否应包括或排除版本范围的上限。此变量支持的值是 ``INCLUDE`` 和 ``EXCLUDE``。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:543
msgid "``PACKAGE_FIND_VERSION_MIN``"
msgstr "``PACKAGE_FIND_VERSION_MIN``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:544
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:673
msgid "Full requested version string of the lower end point of the range"
msgstr "范围下端点的完整请求版本字符串"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:545
msgid "``PACKAGE_FIND_VERSION_MIN_MAJOR``"
msgstr "``PACKAGE_FIND_VERSION_MIN_MAJOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:546
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:675
msgid "Major version of the lower end point if requested, else 0"
msgstr "如果需要，则为下端点的主要版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:547
msgid "``PACKAGE_FIND_VERSION_MIN_MINOR``"
msgstr "``PACKAGE_FIND_VERSION_MIN_MINOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:548
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:677
msgid "Minor version of the lower end point if requested, else 0"
msgstr "如果需要，则为下端点的次要版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:549
msgid "``PACKAGE_FIND_VERSION_MIN_PATCH``"
msgstr "``PACKAGE_FIND_VERSION_MIN_PATCH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:550
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:679
msgid "Patch version of the lower end point if requested, else 0"
msgstr "如果需要，则为下端点的补丁版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:551
msgid "``PACKAGE_FIND_VERSION_MIN_TWEAK``"
msgstr "``PACKAGE_FIND_VERSION_MIN_TWEAK``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:552
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:681
msgid "Tweak version of the lower end point if requested, else 0"
msgstr "如果需要，调整下端点的版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:554
msgid "``PACKAGE_FIND_VERSION_MIN_COUNT``"
msgstr "``PACKAGE_FIND_VERSION_MIN_COUNT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:554
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:683
msgid "Number of version components of the lower end point, 0 to 4"
msgstr "下端点版本组件个数，0~4"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:556
msgid "``PACKAGE_FIND_VERSION_MAX``"
msgstr "``PACKAGE_FIND_VERSION_MAX``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:557
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:686
msgid "Full requested version string of the upper end point of the range"
msgstr "范围上端点的完整请求版本字符串"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:558
msgid "``PACKAGE_FIND_VERSION_MAX_MAJOR``"
msgstr "``PACKAGE_FIND_VERSION_MAX_MAJOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:559
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:688
msgid "Major version of the upper end point if requested, else 0"
msgstr "如果需要，则为上端点的主要版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:560
msgid "``PACKAGE_FIND_VERSION_MAX_MINOR``"
msgstr "``PACKAGE_FIND_VERSION_MAX_MINOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:561
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:690
msgid "Minor version of the upper end point if requested, else 0"
msgstr "如果需要，则为上端点的次要版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:562
msgid "``PACKAGE_FIND_VERSION_MAX_PATCH``"
msgstr "``PACKAGE_FIND_VERSION_MAX_PATCH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:563
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:692
msgid "Patch version of the upper end point if requested, else 0"
msgstr "如果请求，则为上端点的补丁版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:564
msgid "``PACKAGE_FIND_VERSION_MAX_TWEAK``"
msgstr "``PACKAGE_FIND_VERSION_MAX_TWEAK``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:565
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:694
msgid "Tweak version of the upper end point if requested, else 0"
msgstr "如果需要，调整上端点的版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:567
msgid "``PACKAGE_FIND_VERSION_MAX_COUNT``"
msgstr "``PACKAGE_FIND_VERSION_MAX_COUNT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:567
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:696
msgid "Number of version components of the upper end point, 0 to 4"
msgstr "上端点版本组件个数，0~4"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:569
msgid ""
"Regardless of whether a single version or a version range is specified, "
"the variable ``PACKAGE_FIND_VERSION_COMPLETE`` will be defined and will "
"hold the full requested version string as specified."
msgstr ""
"无论指定的是单个版本还是版本范围，变量“PACKAGE_FIND_VERSION_COMPLETE”都将被定义并将保存指定的完整请求版本字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:573
msgid ""
"The version file checks whether it satisfies the requested version and "
"sets these variables:"
msgstr "版本文件检查它是否满足请求的版本并设置这些变量："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:576
msgid "``PACKAGE_VERSION``"
msgstr "``PACKAGE_VERSION``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:577
#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:591
msgid "Full provided version string"
msgstr "完整提供的版本字符串"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:578
msgid "``PACKAGE_VERSION_EXACT``"
msgstr "``PACKAGE_VERSION_EXACT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:579
msgid "True if version is exact match"
msgstr "如果版本完全匹配则为真"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:580
msgid "``PACKAGE_VERSION_COMPATIBLE``"
msgstr "``PACKAGE_VERSION_COMPATIBLE``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:581
msgid "True if version is compatible"
msgstr "如果版本兼容则为真"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:583
msgid "``PACKAGE_VERSION_UNSUITABLE``"
msgstr "``PACKAGE_VERSION_UNSUITABLE``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:583
msgid "True if unsuitable as any version"
msgstr "如果不适合任何版本，则为真"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:585
msgid ""
"These variables are checked by the ``find_package`` command to determine "
"whether the configuration file provides an acceptable version.  They are "
"not available after the ``find_package`` call returns.  If the version is "
"acceptable the following variables are set:"
msgstr ""
"这些变量由 ``find_package`` 命令检查以确定配置文件是否提供可接受的版本。它们在 find_package "
"调用返回后不可用。如果版本是可接受的，则设置以下变量："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:590
msgid "``<PackageName>_VERSION``"
msgstr "``<PackageName>_VERSION``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:592
msgid "``<PackageName>_VERSION_MAJOR``"
msgstr "``<PackageName>_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:593
msgid "Major version if provided, else 0"
msgstr "如果提供主要版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:594
msgid "``<PackageName>_VERSION_MINOR``"
msgstr "``<PackageName>_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:595
msgid "Minor version if provided, else 0"
msgstr "如果提供次要版本，否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:596
msgid "``<PackageName>_VERSION_PATCH``"
msgstr "``<PackageName>_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:597
msgid "Patch version if provided, else 0"
msgstr "补丁版本（如果提供），否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:598
msgid "``<PackageName>_VERSION_TWEAK``"
msgstr "``<PackageName>_VERSION_TWEAK``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:599
msgid "Tweak version if provided, else 0"
msgstr "调整版本（如果提供），否则为 0"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:601
msgid "``<PackageName>_VERSION_COUNT``"
msgstr "``<PackageName>_VERSION_COUNT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:603
msgid ""
"and the corresponding package configuration file is loaded. When multiple "
"package configuration files are available whose version files claim "
"compatibility with the version requested it is unspecified which one is "
"chosen: unless the variable :variable:`CMAKE_FIND_PACKAGE_SORT_ORDER` is "
"set no attempt is made to choose a highest or closest version number."
msgstr ""
"并加载相应的包配置文件。当多个包配置文件可用时，其版本文件声称与所请求的版本兼容，则未指定选择哪个版本：除非设置了变量 :variable:`CMAKE_FIND_PACKAGE_SORT_ORDER`，否则不会尝试选择最高或最接近的版本号。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:609
msgid ""
"To control the order in which ``find_package`` checks for compatibility "
"use the two variables :variable:`CMAKE_FIND_PACKAGE_SORT_ORDER` and "
":variable:`CMAKE_FIND_PACKAGE_SORT_DIRECTION`. For instance in order to "
"select the highest version one can set"
msgstr ""
"要控制 ``find_package`` 检查兼容性的顺序，请使用两个变量 :variable:`CMAKE_FIND_PACKAGE_SORT_ORDER` "
"和 :variable:`CMAKE_FIND_PACKAGE_SORT_DIRECTION`。例如，为了选择可以设置的最高版本"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:619
msgid "before calling ``find_package``."
msgstr "在调用 ``find_package`` 之前。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:622
msgid "Package File Interface Variables"
msgstr "包文件接口变量"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:624
msgid ""
"When loading a find module or package configuration file ``find_package`` "
"defines variables to provide information about the call arguments (and "
"restores their original state before returning):"
msgstr "加载查找模块或包配置文件时，``find_package`` 定义变量以提供有关调用参数的信息（并在返回前恢复其原始状态）："

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:628
msgid "``CMAKE_FIND_PACKAGE_NAME``"
msgstr "``CMAKE_FIND_PACKAGE_NAME``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:629
msgid "The ``<PackageName>`` which is searched for"
msgstr "搜索的``<PackageName>``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:630
msgid "``<PackageName>_FIND_REQUIRED``"
msgstr "``<PackageName>_FIND_REQUIRED``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:631
msgid "True if ``REQUIRED`` option was given"
msgstr "如果给出了 ``REQUIRED`` 选项则为真"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:632
msgid "``<PackageName>_FIND_QUIETLY``"
msgstr "``<PackageName>_FIND_QUIETLY``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:633
msgid "True if ``QUIET`` option was given"
msgstr "如果给出了 ``QUIET`` 选项则为真"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:634
msgid "``<PackageName>_FIND_REGISTRY_VIEW``"
msgstr "``<PackageName>_FIND_REGISTRY_VIEW``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:635
msgid "The requested view if ``REGISTRY_VIEW`` option was given"
msgstr "如果给出了 ``REGISTRY_VIEW`` 选项，则请求的视图"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:636
msgid "``<PackageName>_FIND_VERSION``"
msgstr "``<PackageName>_FIND_VERSION``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:638
msgid "``<PackageName>_FIND_VERSION_MAJOR``"
msgstr "``<PackageName>_FIND_VERSION_MAJOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:640
msgid "``<PackageName>_FIND_VERSION_MINOR``"
msgstr "``<PackageName>_FIND_VERSION_MINOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:642
msgid "``<PackageName>_FIND_VERSION_PATCH``"
msgstr "``<PackageName>_FIND_VERSION_PATCH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:644
msgid "``<PackageName>_FIND_VERSION_TWEAK``"
msgstr "``<PackageName>_FIND_VERSION_TWEAK``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:646
msgid "``<PackageName>_FIND_VERSION_COUNT``"
msgstr "``<PackageName>_FIND_VERSION_COUNT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:648
msgid "``<PackageName>_FIND_VERSION_EXACT``"
msgstr "``<PackageName>_FIND_VERSION_EXACT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:649
msgid "True if ``EXACT`` option was given"
msgstr "如果给出了 ``EXACT`` 选项则为真"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:650
msgid "``<PackageName>_FIND_COMPONENTS``"
msgstr "``<PackageName>_FIND_COMPONENTS``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:651
msgid "List of specified components (required and optional)"
msgstr "指定组件列表（必需和可选）"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:654
msgid "``<PackageName>_FIND_REQUIRED_<c>``"
msgstr "``<PackageName>_FIND_REQUIRED_<c>``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:653
msgid ""
"True if component ``<c>`` is required, false if component ``<c>`` is "
"optional"
msgstr "如果组件 ``<c>`` 是必需的，则为 True，如果组件 ``<c>`` 是可选的，则为 false"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:662
msgid "``<PackageName>_FIND_VERSION_RANGE``"
msgstr "``<PackageName>_FIND_VERSION_RANGE``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:665
msgid "``<PackageName>_FIND_VERSION_RANGE_MIN``"
msgstr "``<PackageName>_FIND_VERSION_RANGE_MIN``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:665
msgid ""
"This specifies whether the lower end point of the version range is "
"included or excluded.  Currently, ``INCLUDE`` is the only supported value."
msgstr "这指定是包含还是排除版本范围的下端点。目前，``INCLUDE`` 是唯一受支持的值。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:670
msgid "``<PackageName>_FIND_VERSION_RANGE_MAX``"
msgstr "``<PackageName>_FIND_VERSION_RANGE_MAX``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:668
msgid ""
"This specifies whether the upper end point of the version range is "
"included or excluded.  The possible values for this variable are "
"``INCLUDE`` or ``EXCLUDE``."
msgstr "这指定是包含还是排除版本范围的上限。此变量的可能值为 ``INCLUDE`` 或 ``EXCLUDE``。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:672
msgid "``<PackageName>_FIND_VERSION_MIN``"
msgstr "``<PackageName>_FIND_VERSION_MIN``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:674
msgid "``<PackageName>_FIND_VERSION_MIN_MAJOR``"
msgstr "``<PackageName>_FIND_VERSION_MIN_MAJOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:676
msgid "``<PackageName>_FIND_VERSION_MIN_MINOR``"
msgstr "``<PackageName>_FIND_VERSION_MIN_MINOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:678
msgid "``<PackageName>_FIND_VERSION_MIN_PATCH``"
msgstr "``<PackageName>_FIND_VERSION_MIN_PATCH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:680
msgid "``<PackageName>_FIND_VERSION_MIN_TWEAK``"
msgstr "``<PackageName>_FIND_VERSION_MIN_TWEAK``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:683
msgid "``<PackageName>_FIND_VERSION_MIN_COUNT``"
msgstr "``<PackageName>_FIND_VERSION_MIN_COUNT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:685
msgid "``<PackageName>_FIND_VERSION_MAX``"
msgstr "``<PackageName>_FIND_VERSION_MAX``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:687
msgid "``<PackageName>_FIND_VERSION_MAX_MAJOR``"
msgstr "``<PackageName>_FIND_VERSION_MAX_MAJOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:689
msgid "``<PackageName>_FIND_VERSION_MAX_MINOR``"
msgstr "``<PackageName>_FIND_VERSION_MAX_MINOR``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:691
msgid "``<PackageName>_FIND_VERSION_MAX_PATCH``"
msgstr "``<PackageName>_FIND_VERSION_MAX_PATCH``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:693
msgid "``<PackageName>_FIND_VERSION_MAX_TWEAK``"
msgstr "``<PackageName>_FIND_VERSION_MAX_TWEAK``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:696
msgid "``<PackageName>_FIND_VERSION_MAX_COUNT``"
msgstr "``<PackageName>_FIND_VERSION_MAX_COUNT``"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:698
msgid ""
"Regardless of whether a single version or a version range is specified, "
"the variable ``<PackageName>_FIND_VERSION_COMPLETE`` will be defined and "
"will hold the full requested version string as specified."
msgstr ""
"无论指定的是单个版本还是版本范围，变量“<PackageName>_FIND_VERSION_COMPLETE”都将被定义并将保存指定的完整请求版本字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/find_package.rst:702
msgid ""
"In Module mode the loaded find module is responsible to honor the request "
"detailed by these variables; see the find module for details. In Config "
"mode ``find_package`` handles ``REQUIRED``, ``QUIET``, and ``[version]`` "
"options automatically but leaves it to the package configuration file to "
"handle components in a way that makes sense for the package.  The package "
"configuration file may set ``<PackageName>_FOUND`` to false to tell "
"``find_package`` that component requirements are not satisfied."
msgstr ""
"在模块模式下，加载的查找模块负责处理由这些变量详细说明的请求；有关详细信息，请参阅查找模块。在 Config "
"模式下，``find_package`` 会自动处理 ``REQUIRED``、``QUIET`` 和 ``[version]`` "
"选项，但将其留给包配置文件，以对组件有意义的方式处理组件包裹。包配置文件可以将“<PackageName>_FOUND”设置为 false "
"以告知“find_package”组件要求未得到满足。"

#: ../../cmake-prefix/src/cmake/Help/command/find_path.rst:2
msgid "find_path"
msgstr "查找路径"

#: ../../cmake-prefix/src/cmake/Help/command/find_path.rst:41
msgid ""
"When searching for frameworks, if the file is specified as ``A/b.h``, then"
" the framework search will look for ``A.framework/Headers/b.h``.  If that "
"is found the path will be set to the path to the framework.  CMake will "
"convert this to the correct ``-F`` option to include the file."
msgstr ""
"搜索框架时，如果文件指定为“A/b.h”，则框架搜索将查找“A.framework/Headers/b.h”。如果找到，路径将被设置为框架的路径。 "
"CMake 会将其转换为正确的“-F”选项以包含该文件。"

#: ../../cmake-prefix/src/cmake/Help/command/find_program.rst:2
msgid "find_program"
msgstr "查找程序"

#: ../../cmake-prefix/src/cmake/Help/command/fltk_wrap_ui.rst:2
msgid "fltk_wrap_ui"
msgstr "fltk_wrap_ui"

#: ../../cmake-prefix/src/cmake/Help/command/fltk_wrap_ui.rst:4
msgid "Create FLTK user interfaces Wrappers."
msgstr "创建 FLTK 用户界面包装器。"

#: ../../cmake-prefix/src/cmake/Help/command/fltk_wrap_ui.rst:11
msgid ""
"Produce .h and .cxx files for all the .fl and .fld files listed.  The "
"resulting .h and .cxx files will be added to a variable named "
"``resultingLibraryName_FLTK_UI_SRCS`` which should be added to your "
"library."
msgstr ""
"为列出的所有 .fl 和 .fld 文件生成 .h 和 .cxx 文件。生成的 .h 和 .cxx "
"文件将添加到一个名为“resultingLibraryName_FLTK_UI_SRCS”的变量中，该变量应该添加到您的库中。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:2
msgid "foreach"
msgstr "foreach"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:4
msgid "Evaluate a group of commands for each value in a list."
msgstr "为列表中的每个值评估一组命令。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:12
msgid ""
"where ``<items>`` is a list of items that are separated by semicolon or "
"whitespace. All commands between ``foreach`` and the matching "
"``endforeach`` are recorded without being invoked.  Once the "
"``endforeach`` is evaluated, the recorded list of commands is invoked once"
" for each item in ``<items>``. At the beginning of each iteration the "
"variable ``<loop_var>`` will be set to the value of the current item."
msgstr ""
"其中 ``<items>`` 是由分号或空格分隔的项目列表。 ``foreach`` 和匹配的``endforeach`` "
"之间的所有命令都被记录下来而不被调用。一旦评估了 "
"``endforeach``，就会为``<items>``中的每个项目调用一次记录的命令列表。在每次迭代开始时，变量 ``<loop_var>`` "
"将被设置为当前项的值。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:20
msgid ""
"The scope of ``<loop_var>`` is restricted to the loop scope. See policy "
":policy:`CMP0124` for details."
msgstr "``<loop_var>`` 的范围仅限于循环范围。有关详细信息，请参阅政策:policy:`CMP0124`。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:23
#: ../../cmake-prefix/src/cmake/Help/command/while.rst:19
msgid ""
"The commands :command:`break` and :command:`continue` provide means to "
"escape from the normal control flow."
msgstr "命令 :command:`break` 和 :command:`continue` 提供了逃离正常控制流的方法。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:26
msgid ""
"Per legacy, the :command:`endforeach` command admits an optional "
"``<loop_var>`` argument. If used, it must be a verbatim repeat of the "
"argument of the opening ``foreach`` command."
msgstr ""
"按照传统， :command:`endforeach` 命令接受一个可选的 ``<loop_var>`` "
"参数。如果使用，它必须逐字重复开头的“foreach”命令的参数。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:36
msgid ""
"In this variant, ``foreach`` iterates over the numbers 0, 1, ... up to "
"(and including) the nonnegative integer ``<stop>``."
msgstr "在此变体中，``foreach`` 遍历数字 0、1，...直到（并包括）非负整数 ``<stop>``。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:43
msgid ""
"In this variant, ``foreach`` iterates over the numbers from ``<start>`` up"
" to at most ``<stop>`` in steps of ``<step>``. If ``<step>`` is not "
"specified, then the step size is 1. The three arguments ``<start>`` "
"``<stop>`` ``<step>`` must all be nonnegative integers, and ``<stop>`` "
"must not be smaller than ``<start>``; otherwise you enter the danger zone "
"of undocumented behavior that may change in future releases."
msgstr ""
"在此变体中，``foreach`` 以``<step>`` 的步骤迭代从``<start>`` 到最多``<stop>`` 的数字。如果未指定 "
"``<step>``，则步长为 1。三个参数 ``<start>`` ``<stop>`` ``<step>`` "
"必须都是非负整数，并且``<stop>`` 不能小于 ``<start>``；否则，您将进入可能在未来版本中更改的未记录行为的危险区域。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:55
msgid ""
"In this variant, ``<lists>`` is a whitespace or semicolon separated list "
"of list-valued variables. The ``foreach`` command iterates over each item "
"in each given list. The ``<items>`` following the ``ITEMS`` keyword are "
"processed as in the first variant of the ``foreach`` command. The forms "
"``LISTS A`` and ``ITEMS ${A}`` are equivalent."
msgstr ""
"在此变体中，``<lists>`` 是一个空格或分号分隔的列表值变量列表。 ``foreach`` 命令迭代每个给定列表中的每个项目。 "
"``ITEMS`` 关键字后面的``<items>`` 与``foreach`` 命令的第一个变体一样处理。 ``LISTS A`` "
"和``ITEMS ${A}`` 的形式是等价的。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:63
msgid "The following example shows how the ``LISTS`` option is processed:"
msgstr "以下示例显示了如何处理 ``LISTS`` 选项："

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:77
#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:121
msgid "yields::"
msgstr "产量 ::"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:95
msgid ""
"In this variant, ``<lists>`` is a whitespace or semicolon separated list "
"of list-valued variables. The ``foreach`` command iterates over each list "
"simultaneously setting the iteration variables as follows:"
msgstr ""
"在此变体中，``<lists>`` 是一个空格或分号分隔的列表值变量列表。 ``foreach`` 命令同时遍历每个列表，设置迭代变量如下："

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:100
msgid ""
"if the only ``loop_var`` given, then it sets a series of ``loop_var_N`` "
"variables to the current item from the corresponding list;"
msgstr "如果只给出了 ``loop_var``，那么它将一系列 ``loop_var_N`` 变量设置为相应列表中的当前项；"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:103
msgid ""
"if multiple variable names passed, their count should match the lists "
"variables count;"
msgstr "如果传递了多个变量名，它们的计数应该与列表变量计数相匹配；"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:105
msgid ""
"if any of the lists are shorter, the corresponding iteration variable is "
"not defined for the current iteration."
msgstr "如果任何列表较短，则不会为当前迭代定义相应的迭代变量。"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:135
#: ../../cmake-prefix/src/cmake/Help/command/while.rst:30
msgid ":command:`break`"
msgstr ":command:`中断`"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:136
#: ../../cmake-prefix/src/cmake/Help/command/while.rst:31
msgid ":command:`continue`"
msgstr ":command:`继续`"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:137
msgid ":command:`endforeach`"
msgstr ":command:`endforeach`"

#: ../../cmake-prefix/src/cmake/Help/command/foreach.rst:138
msgid ":command:`while`"
msgstr ":command:`而`"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:2
msgid "function"
msgstr "功能"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:4
msgid "Start recording a function for later invocation as a command."
msgstr "开始记录函数以供以后作为命令调用。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:12
msgid ""
"Defines a function named ``<name>`` that takes arguments named ``<arg1>``,"
" ...  The ``<commands>`` in the function definition are recorded; they are"
" not executed until the function is invoked."
msgstr ""
"定义一个名为 ``<name>`` 的函数，它接受名为 ``<arg1>`` 的参数，...函数定义中的 ``<commands>`` "
"被记录下来；在函数被调用之前它们不会被执行。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:16
msgid ""
"Per legacy, the :command:`endfunction` command admits an optional "
"``<name>`` argument. If used, it must be a verbatim repeat of the argument"
" of the opening ``function`` command."
msgstr ""
"按照传统， :command:`endfunction` 命令接受一个可选的 ``<name>`` "
"参数。如果使用，则必须逐字重复开头的“function”命令的参数。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:20
msgid ""
"A function opens a new scope: see :command:`set(var PARENT_SCOPE)` for "
"details."
msgstr "一个函数打开一个新的范围：查看:command:`set(var PARENT_SCOPE)` 了解详情。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:23
msgid ""
"See the :command:`cmake_policy()` command documentation for the behavior "
"of policies inside functions."
msgstr "请参阅 :command:`cmake_policy()` 命令文档以了解函数内部策略的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:26
msgid ""
"See the :command:`macro()` command documentation for differences between "
"CMake functions and macros."
msgstr "有关 CMake 函数和宏之间的差异，请参阅 :command:`macro()` 命令文档。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:30
#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:28
msgid "Invocation"
msgstr "调用"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:32
msgid "The function invocation is case-insensitive. A function defined as"
msgstr "函数调用不区分大小写。函数定义为"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:40
#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:38
msgid "can be invoked through any of"
msgstr "可以通过任何调用"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:49
msgid ""
"and so on. However, it is strongly recommended to stay with the case "
"chosen in the function definition. Typically functions use all-lowercase "
"names."
msgstr "等等。但是，强烈建议保留函数定义中选择的大小写。通常函数使用全小写的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:53
msgid ""
"The :command:`cmake_language(CALL ...)` command can also be used to invoke"
" the function."
msgstr ":command:`cmake_language(CALL ...)` 命令也可用于调用函数。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:60
msgid ""
"When the function is invoked, the recorded ``<commands>`` are first "
"modified by replacing formal parameters (``${arg1}``, ...) with the "
"arguments passed, and then invoked as normal commands."
msgstr ""
"当函数被调用时，记录的``<commands>``首先通过用传递的参数替换形式参数（``${arg1}``，...）进行修改，然后作为普通命令调用。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:64
msgid ""
"In addition to referencing the formal parameters you can reference the "
"``ARGC`` variable which will be set to the number of arguments passed into"
" the function as well as ``ARGV0``, ``ARGV1``, ``ARGV2``, ...  which will "
"have the actual values of the arguments passed in.  This facilitates "
"creating functions with optional arguments."
msgstr ""
"除了引用形式参数之外，您还可以引用 ``ARGC`` 变量，该变量将设置为传递给函数的参数数量以及 "
"``ARGV0``、``ARGV1``、``ARGV2`` , ... 这将具有传入参数的实际值。这有助于创建具有可选参数的函数。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:70
msgid ""
"Furthermore, ``ARGV`` holds the list of all arguments given to the "
"function and ``ARGN`` holds the list of arguments past the last expected "
"argument.  Referencing to ``ARGV#`` arguments beyond ``ARGC`` have "
"undefined behavior.  Checking that ``ARGC`` is greater than ``#`` is the "
"only way to ensure that ``ARGV#`` was passed to the function as an extra "
"argument."
msgstr ""
"此外，``ARGV`` 保存给函数的所有参数列表，``ARGN`` 保存最后一个预期参数之后的参数列表。引用 ``ARGC`` 之外的 "
"``ARGV#`` 参数具有未定义的行为。检查 ``ARGC`` 是否大于 ``#`` 是确保 ``ARGV#`` "
"作为额外参数传递给函数的唯一方法。"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:80
#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:156
msgid ":command:`cmake_parse_arguments`"
msgstr ":command:`cmake_parse_arguments`"

#: ../../cmake-prefix/src/cmake/Help/command/function.rst:81
msgid ":command:`endfunction`"
msgstr ":command:`结束功能`"

#: ../../cmake-prefix/src/cmake/Help/command/get_cmake_property.rst:2
msgid "get_cmake_property"
msgstr "get_cmake_property"

#: ../../cmake-prefix/src/cmake/Help/command/get_cmake_property.rst:4
msgid "Get a global property of the CMake instance."
msgstr "获取 CMake 实例的全局属性。"

#: ../../cmake-prefix/src/cmake/Help/command/get_cmake_property.rst:10
msgid ""
"Gets a global property from the CMake instance.  The value of the "
"``<property>`` is stored in the variable ``<var>``. If the property is not"
" found, ``<var>`` will be set to ``NOTFOUND``. See the :manual:`cmake-"
"properties(7)` manual for available properties."
msgstr ""
"从 CMake 实例获取全局属性。 ``<property>`` 的值存储在变量``<var>`` 中。如果未找到该属性，``<var>`` "
"将被设置为 ``NOTFOUND``。有关可用属性，请参阅 :manual:`cmake-properties(7)` 手册。"

#: ../../cmake-prefix/src/cmake/Help/command/get_cmake_property.rst:15
msgid ""
"In addition to global properties, this command (for historical reasons) "
"also supports the :prop_dir:`VARIABLES` and :prop_dir:`MACROS` directory "
"properties.  It also supports a special ``COMPONENTS`` global property "
"that lists the components given to the :command:`install` command."
msgstr ""
"除了全局属性，此命令（出于历史原因）还支持 :prop_dir:`VARIABLES` 和 :prop_dir:`MACROS` "
"目录属性。它还支持一个特殊的 ``COMPONENTS`` 全局属性，该属性列出了提供给 :command:`install` 命令的组件。"

#: ../../cmake-prefix/src/cmake/Help/command/get_cmake_property.rst:23
msgid "the :command:`get_property` command ``GLOBAL`` option"
msgstr ":command:`get_property` 命令``GLOBAL`` 选项"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:2
msgid "get_directory_property"
msgstr "获取目录属性"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:4
msgid "Get a property of ``DIRECTORY`` scope."
msgstr "获取 ``DIRECTORY`` 范围的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:10
msgid "Stores a property of directory scope in the named ``<variable>``."
msgstr "将目录范围的属性存储在命名的``<variable>``中。"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:12
msgid ""
"The ``DIRECTORY`` argument specifies another directory from which to "
"retrieve the property value instead of the current directory. Relative "
"paths are treated as relative to the current source directory.  CMake must"
" already know about the directory, either by having added it through a "
"call to :command:`add_subdirectory` or being the top level directory."
msgstr ""
"``DIRECTORY`` 参数指定从中检索属性值的另一个目录，而不是当前目录。相对路径被视为相对于当前源目录。 CMake "
"必须已经知道该目录，或者通过调用 add_subdirectory 添加它或者是顶级目录。"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:19
#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:37
#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:58
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:34
msgid "``<dir>`` may reference a binary directory."
msgstr "``<dir>`` 可以引用一个二进制目录。"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:22
msgid ""
"If the property is not defined for the nominated directory scope, an empty"
" string is returned.  In the case of ``INHERITED`` properties, if the "
"property is not found for the nominated directory scope, the search will "
"chain to a parent scope as described for the :command:`define_property` "
"command."
msgstr ""
"如果没有为指定的目录范围定义该属性，则返回一个空字符串。对于 ``INHERITED`` "
"属性，如果在指定的目录范围内找不到该属性，则搜索将链接到父范围，如 :command:`define_property` 命令所述。"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:33
msgid ""
"Get a variable definition from a directory.  This form is useful to get a "
"variable definition from another directory."
msgstr "从目录中获取变量定义。这种形式对于从另一个目录获取变量定义很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:40
#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:106
#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:50
#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:28
#: ../../cmake-prefix/src/cmake/Help/command/get_test_property.rst:25
#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:20
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:118
#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:45
#: ../../cmake-prefix/src/cmake/Help/command/set_target_properties.rst:21
#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:21
msgid ":command:`define_property`"
msgstr ":command:`define_property`"

#: ../../cmake-prefix/src/cmake/Help/command/get_directory_property.rst:41
#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:51
#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:29
#: ../../cmake-prefix/src/cmake/Help/command/get_test_property.rst:26
msgid "the more general :command:`get_property` command"
msgstr "更通用的 :command:`get_property` 命令"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:2
msgid "get_filename_component"
msgstr "获取文件名组件"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:4
msgid "Get a specific component of a full filename."
msgstr "获取完整文件名的特定组件。"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:6
msgid ""
"This command has been superseded by :command:`cmake_path` command, except "
"``REALPATH`` now offered by :ref:`file(REAL_PATH)<REAL_PATH>` command and "
"``PROGRAM`` now available in :command:`separate_arguments(PROGRAM)` "
"command."
msgstr ""
"此命令已被 :command:`cmake_path` 命令取代，除了 ``REALPATH`` 现在由 "
":ref:`file(REAL_PATH)<REAL_PATH>` 命令和 ``PROGRAM`` 现在在 "
":command:`separate_arguments 中提供（程序）` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:11
msgid ""
"The undocumented feature offering the capability to query the ``Windows`` "
"registry is superseded by :ref:`cmake_host_system_information(QUERY "
"WINDOWS_REGISTRY)<Query Windows registry>` command."
msgstr ""
"提供查询 ``Windows`` 注册表功能的未记录功能已被 :ref:`cmake_host_system_information(QUERY "
"WINDOWS_REGISTRY)<Query Windows registry>` 命令取代。"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:21
msgid ""
"Sets ``<var>`` to a component of ``<FileName>``, where ``<mode>`` is one "
"of:"
msgstr "将 ``<var>`` 设置为 ``<FileName>`` 的一个组件，其中 ``<mode>`` 是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:33
msgid "Added the ``LAST_EXT`` and ``NAME_WLE`` modes."
msgstr "添加了``LAST_EXT`` 和``NAME_WLE`` 模式。"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:36
msgid ""
"Paths are returned with forward slashes and have no trailing slashes. If "
"the optional ``CACHE`` argument is specified, the result variable is added"
" to the cache."
msgstr "返回的路径带有正斜杠，没有尾随斜杠。如果指定了可选的 ``CACHE`` 参数，结果变量将被添加到缓存中。"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:46
msgid ""
"Sets ``<var>`` to the absolute path of ``<FileName>``, where ``<mode>`` is"
" one of:"
msgstr "将 ``<var>`` 设置为 ``<FileName>`` 的绝对路径，其中 ``<mode>`` 是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:54
msgid ""
"If the provided ``<FileName>`` is a relative path, it is evaluated "
"relative to the given base directory ``<dir>``.  If no base directory is "
"provided, the default base directory will be "
":variable:`CMAKE_CURRENT_SOURCE_DIR`."
msgstr ""
"如果提供的 ``<FileName>`` 是相对路径，则相对于给定的基本目录 ``<dir>`` "
"进行评估。如果未提供基目录，则默认基目录将为 :variable:`CMAKE_CURRENT_SOURCE_DIR`。"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:59
msgid ""
"Paths are returned with forward slashes and have no trailing slashes.  If "
"the optional ``CACHE`` argument is specified, the result variable is added"
" to the cache."
msgstr "返回的路径带有正斜杠，没有尾随斜杠。如果指定了可选的 ``CACHE`` 参数，结果变量将被添加到缓存中。"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:67
msgid ""
"The program in ``<FileName>`` will be found in the system search path or "
"left as a full path.  If ``PROGRAM_ARGS`` is present with ``PROGRAM``, "
"then any command-line arguments present in the ``<FileName>`` string are "
"split from the program name and stored in ``<arg_var>``.  This is used to "
"separate a program name from its arguments in a command line string."
msgstr ""
"``<FileName>`` 中的程序将在系统搜索路径中找到或保留为完整路径。如果 ``PROGRAM_ARGS`` 与 ``PROGRAM`` "
"一起出现，则 ``<FileName>`` 字符串中出现的任何命令行参数都会从程序名称中分离出来并存储在 ``<arg_var>`` "
"中。这用于在命令行字符串中将程序名称与其参数分开。"

#: ../../cmake-prefix/src/cmake/Help/command/get_filename_component.rst:76
msgid ":command:`cmake_path`"
msgstr ":command:`cmake_path`"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:2
msgid "get_property"
msgstr "获取属性"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:4
msgid "Get a property."
msgstr "获得财产。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:21
msgid "Gets one property from one object in a scope."
msgstr "从范围内的一个对象获取一个属性。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:23
msgid ""
"The first argument specifies the variable in which to store the result. "
"The second argument determines the scope from which to get the property. "
"It must be one of the following:"
msgstr "第一个参数指定存储结果的变量。第二个参数确定从中获取属性的范围。它必须是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:28
#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:36
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:26
msgid "``GLOBAL``"
msgstr "``全球``"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:28
#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:80
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:26
msgid "Scope is unique and does not accept a name."
msgstr "范围是唯一的，不接受名称。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:38
#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:32
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:35
msgid "``DIRECTORY``"
msgstr "``目录``"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:31
msgid ""
"Scope defaults to the current directory but another directory (already "
"processed by CMake) may be named by the full or relative path ``<dir>``. "
"Relative paths are treated as relative to the current source directory. "
"See also the :command:`get_directory_property` command."
msgstr ""
"作用域默认为当前目录，但另一个目录（已由 CMake 处理）可能由完整或相对路径命名为“<dir>”。相对路径被视为相对于当前源目录。另请参阅 "
":command:`get_directory_property` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:41
msgid ""
"Scope must name one existing target. See also the "
":command:`get_target_property` command."
msgstr "范围必须命名一个现有目标。另请参阅 :command:`get_target_property` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:65
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:64
msgid "``SOURCE``"
msgstr "``来源``"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:45
msgid ""
"Scope must name one source file.  By default, the source file's property "
"will be read from the current source directory's scope."
msgstr "范围必须命名一个源文件。默认情况下，将从当前源目录的范围读取源文件的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:48
#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:24
msgid ""
"Directory scope can be overridden with one of the following sub-options:"
msgstr "可以使用以下子选项之一覆盖目录范围："

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:52
msgid ""
"The source file property will be read from the ``<dir>`` directory's "
"scope.  CMake must already know about the directory, either by having "
"added it through a call to :command:`add_subdirectory` or ``<dir>`` being "
"the top level directory. Relative paths are treated as relative to the "
"current source directory."
msgstr ""
"源文件属性将从 ``<dir>`` 目录的范围中读取。 CMake "
"必须已经知道目录，或者通过调用添加它:command:`add_subdirectory` 或``<dir>`` "
"作为顶级目录。相对路径被视为相对于当前源目录。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:62
#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:35
msgid "``TARGET_DIRECTORY <target>``"
msgstr "``TARGET_DIRECTORY <目标>``"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:62
#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:35
msgid ""
"The source file property will be read from the directory scope in which "
"``<target>`` was created (``<target>`` must therefore already exist)."
msgstr "源文件属性将从创建``<target>``的目录范围中读取（因此``<target>``必须已经存在）。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:65
msgid "See also the :command:`get_source_file_property` command."
msgstr "另请参阅 :command:`get_source_file_property` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:70
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:82
msgid "``INSTALL``"
msgstr "``安装``"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:70
msgid "Scope must name one installed file path."
msgstr "范围必须命名一个已安装的文件路径。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:74
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:90
msgid "``TEST``"
msgstr "``测试``"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:73
msgid ""
"Scope must name one existing test. See also the "
":command:`get_test_property` command."
msgstr "范围必须命名一个现有的测试。另请参阅 :command:`get_test_property` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:77
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:93
msgid "``CACHE``"
msgstr "``缓存``"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:77
msgid "Scope must name one cache entry."
msgstr "范围必须命名一个缓存条目。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:80
msgid "``VARIABLE``"
msgstr "``变量``"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:82
msgid ""
"The required ``PROPERTY`` option is immediately followed by the name of "
"the property to get.  If the property is not set an empty value is "
"returned, although some properties support inheriting from a parent scope "
"if defined to behave that way (see :command:`define_property`)."
msgstr ""
"所需的 ``PROPERTY`` "
"选项紧跟在要获取的属性的名称之后。如果未设置该属性，则返回一个空值，尽管某些属性支持从父作用域继承（如果定义为那样）（请参阅:command:`define_property`）。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:87
msgid ""
"If the ``SET`` option is given the variable is set to a boolean value "
"indicating whether the property has been set.  If the ``DEFINED`` option "
"is given the variable is set to a boolean value indicating whether the "
"property has been defined such as with the :command:`define_property` "
"command."
msgstr ""
"如果给出了 ``SET`` 选项，变量将被设置为一个布尔值，指示该属性是否已被设置。如果给出了 ``DEFINED`` "
"选项，变量将被设置为一个布尔值，指示该属性是否已被定义，例如使用 define_property 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:93
msgid ""
"If ``BRIEF_DOCS`` or ``FULL_DOCS`` is given then the variable is set to a "
"string containing documentation for the requested property.  If "
"documentation is requested for a property that has not been defined "
"``NOTFOUND`` is returned."
msgstr ""
"如果给出了``BRIEF_DOCS`` "
"或``FULL_DOCS``，那么该变量将被设置为一个字符串，其中包含所请求属性的文档。如果为尚未定义的属性请求文档，则返回“NOTFOUND”。"

#: ../../cmake-prefix/src/cmake/Help/command/get_property.rst:100
#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:44
#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:112
#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:39
msgid ""
"The :prop_sf:`GENERATED` source file property may be globally visible. See"
" its documentation for details."
msgstr ":prop_sf:`GENERATED` 源文件属性可能是全局可见的。有关详细信息，请参阅其文档。"

#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:2
msgid "get_source_file_property"
msgstr "获取源文件属性"

#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:4
msgid "Get a property for a source file."
msgstr "获取源文件的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:12
msgid ""
"Gets a property from a source file.  The value of the property is stored "
"in the specified ``<variable>``.  If the source property is not found, the"
" behavior depends on whether it has been defined to be an ``INHERITED`` "
"property or not (see :command:`define_property`).  Non-inherited "
"properties will set ``variable`` to ``NOTFOUND``, whereas inherited "
"properties will search the relevant parent scope as described for the "
":command:`define_property` command and if still unable to find the "
"property, ``variable`` will be set to an empty string."
msgstr ""
"从源文件中获取属性。属性的值存储在指定的``<variable>``中。如果未找到源属性，则行为取决于它是否已被定义为 ``INHERITED`` "
"属性（请参阅:command:`define_property`）。非继承属性会将 ``variable`` 设置为 "
"``NOTFOUND``，而继承属性将搜索相关的父范围，如 :command:`define_property` "
"命令所述，如果仍然找不到属性，``variable `` 将被设置为空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:21
msgid ""
"By default, the source file's property will be read from the current "
"source directory's scope."
msgstr "默认情况下，将从当前源目录的范围读取源文件的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:28
msgid ""
"The source file property will be read from the ``<dir>`` directory's "
"scope.  CMake must already know about that source directory, either by "
"having added it through a call to :command:`add_subdirectory` or ``<dir>``"
" being the top level source directory.  Relative paths are treated as "
"relative to the current source directory."
msgstr ""
"源文件属性将从 ``<dir>`` 目录的范围中读取。 CMake 必须已经知道该源目录，通过调用 add_subdirectory "
"或作为顶级源目录的 ``<dir>`` 添加它。相对路径被视为相对于当前源目录。"

#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:38
msgid ""
"Use :command:`set_source_files_properties` to set property values.  Source"
" file properties usually control how the file is built. One property that "
"is always there is :prop_sf:`LOCATION`."
msgstr ""
"使用 :command:`set_source_files_properties` "
"设置属性值。源文件属性通常控制文件的构建方式。一个始终存在的属性是 :prop_sf:`LOCATION`。"

#: ../../cmake-prefix/src/cmake/Help/command/get_source_file_property.rst:52
msgid ":command:`set_source_files_properties`"
msgstr ":command:`set_source_files_properties`"

#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:2
msgid "get_target_property"
msgstr "获取目标属性"

#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:4
msgid "Get a property from a target."
msgstr "从目标获取属性。"

#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:10
msgid ""
"Get a property from a target.  The value of the property is stored in the "
"variable ``<VAR>``.  If the target property is not found, the behavior "
"depends on whether it has been defined to be an ``INHERITED`` property or "
"not (see :command:`define_property`).  Non-inherited properties will set "
"``<VAR>`` to ``<VAR>-NOTFOUND``, whereas inherited properties will search "
"the relevant parent scope as described for the :command:`define_property` "
"command and if still unable to find the property, ``<VAR>`` will be set to"
" an empty string."
msgstr ""
"从目标获取属性。属性的值存储在变量“<VAR>”中。如果未找到目标属性，则行为取决于它是否已被定义为 ``INHERITED`` "
"属性（请参阅:command:`define_property`）。非继承属性会将``<VAR>``设置为``<VAR>-NOTFOUND``，而继承属性将搜索相关的父范围，如"
" :command:`define_property` 命令所述，如果仍然找不到属性 ``<VAR>`` 将被设置为空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:19
msgid ""
"Use :command:`set_target_properties` to set target property values. "
"Properties are usually used to control how a target is built, but some "
"query the target instead.  This command can get properties for any target "
"so far created.  The targets do not need to be in the current "
"``CMakeLists.txt`` file."
msgstr ""
"使用 :command:`set_target_properties` "
"设置目标属性值。属性通常用于控制目标的构建方式，但有些属性会查询目标。此命令可以获得迄今为止创建的任何目标的属性。目标不需要位于当前的 "
"CMakeLists.txt 文件中。"

#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:30
msgid ":command:`set_target_properties`"
msgstr ":command:`set_target_properties`"

#: ../../cmake-prefix/src/cmake/Help/command/get_target_property.rst:31
#: ../../cmake-prefix/src/cmake/Help/command/set_target_properties.rst:24
#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:23
msgid ":ref:`Target Properties` for the list of properties known to CMake"
msgstr ":ref:`Target Properties` 获取 CMake 已知的属性列表"

#: ../../cmake-prefix/src/cmake/Help/command/get_test_property.rst:2
msgid "get_test_property"
msgstr "获取测试属性"

#: ../../cmake-prefix/src/cmake/Help/command/get_test_property.rst:4
msgid "Get a property of the test."
msgstr "获取测试的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/get_test_property.rst:10
msgid ""
"Get a property from the test.  The value of the property is stored in the "
"variable ``VAR``.  If the test property is not found, the behavior depends"
" on whether it has been defined to be an ``INHERITED`` property or not "
"(see :command:`define_property`).  Non-inherited properties will set "
"``VAR`` to \"NOTFOUND\", whereas inherited properties will search the "
"relevant parent scope as described for the :command:`define_property` "
"command and if still unable to find the property, ``VAR`` will be set to "
"an empty string."
msgstr ""
"从测试中获取属性。属性的值存储在变量“VAR”中。如果未找到测试属性，则行为取决于它是否已被定义为“INHERITED”属性（请参阅:command:“define_property”）。非继承属性会将``VAR``设置为“NOTFOUND”，而继承属性将搜索相关的父范围，如:command:`define_property`命令所述，如果仍然找不到属性，``VAR``将被设置为一个空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/get_test_property.rst:19
msgid ""
"For a list of standard properties you can type :option:`cmake --help-"
"property-list`."
msgstr "对于标准属性列表，您可以键入:option:`cmake --help-property-list`。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:2
msgid "if"
msgstr "如果"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:4
msgid "Conditionally execute a group of commands."
msgstr "有条件地执行一组命令。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:19
msgid ""
"Evaluates the ``condition`` argument of the ``if`` clause according to the"
" `Condition syntax`_ described below. If the result is true, then the "
"``commands`` in the ``if`` block are executed. Otherwise, optional "
"``elseif`` blocks are processed in the same way. Finally, if no "
"``condition`` is true, ``commands`` in the optional ``else`` block are "
"executed."
msgstr ""
"根据下面描述的“条件语法”评估“if”子句的“条件”参数。如果结果为真，则执行 ``if`` 块中的``commands``。否则，可选的 "
"elseif 块以相同的方式处理。最后，如果没有“条件”为真，则执行可选“else”块中的“命令”。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:26
msgid ""
"Per legacy, the :command:`else` and :command:`endif` commands admit an "
"optional ``<condition>`` argument. If used, it must be a verbatim repeat "
"of the argument of the opening ``if`` command."
msgstr ""
"根据传统， :command:`else` 和 :command:`endif` 命令接受一个可选的 ``<condition>`` "
"参数。如果使用，它必须逐字重复开头的“if”命令的参数。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:35
msgid "Condition Syntax"
msgstr "条件语法"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:37
msgid ""
"The following syntax applies to the ``condition`` argument of the ``if``, "
"``elseif`` and :command:`while` clauses."
msgstr "以下语法适用于 ``if``、``elseif`` 和 :command:`while` 子句的 ``condition`` 参数。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:40
msgid ""
"Compound conditions are evaluated in the following order of precedence:"
msgstr "复合条件按以下优先顺序进行评估："

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:42
msgid "Parentheses."
msgstr "括号。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:44
msgid "Unary tests such as `EXISTS`_, `COMMAND`_, and `DEFINED`_."
msgstr "一元测试，例如 `EXISTS`_、`COMMAND`_ 和 `DEFINED`_。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:46
msgid ""
"Binary tests such as `EQUAL`_, `LESS`_, `LESS_EQUAL`_, `GREATER`_, "
"`GREATER_EQUAL`_, `STREQUAL`_, `STRLESS`_, `STRLESS_EQUAL`_, "
"`STRGREATER`_, `STRGREATER_EQUAL`_, `VERSION_EQUAL`_, `VERSION_LESS`_, "
"`VERSION_LESS_EQUAL`_, `VERSION_GREATER`_, `VERSION_GREATER_EQUAL`_, "
"`PATH_EQUAL`_, and `MATCHES`_."
msgstr ""
"二进制测试，例如`EQUAL`_、`LESS`_、`LESS_EQUAL`_、`GREATER`_、`GREATER_EQUAL`_、`STREQUAL`_、`STRLESS`_、`STRLESS_EQUAL`_、`STRGREATER`_、`"
" "
"STRGREATER_EQUAL`_、`VERSION_EQUAL`_、`VERSION_LESS`_、`VERSION_LESS_EQUAL`_、`VERSION_GREATER`_、`VERSION_GREATER_EQUAL`_、`PATH_EQUAL`_"
" 和 `MATCHES`_。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:52
msgid "Unary logical operator `NOT`_."
msgstr "一元逻辑运算符“NOT”_。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:54
msgid ""
"Binary logical operators `AND`_ and `OR`_, from left to right, without any"
" short-circuit."
msgstr "二元逻辑运算符 `AND`_ 和 `OR`_，从左到右，没有任何短路。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:58
msgid "Basic Expressions"
msgstr "基本表达式"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:68
msgid "``if(<constant>)``"
msgstr "``如果（<常量>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:61
msgid ""
"True if the constant is ``1``, ``ON``, ``YES``, ``TRUE``, ``Y``, or a non-"
"zero number (including floating point numbers). False if the constant is "
"``0``, ``OFF``, ``NO``, ``FALSE``, ``N``, ``IGNORE``, ``NOTFOUND``, the "
"empty string, or ends in the suffix ``-NOTFOUND``.  Named boolean "
"constants are case-insensitive.  If the argument is not one of these "
"specific constants, it is treated as a variable or string (see `Variable "
"Expansion`_ further below) and one of the following two forms applies."
msgstr ""
"如果常量为“1”、“ON”、“YES”、“TRUE”、“Y”或非零数（包括浮点数），则为真。如果常量为 "
"``0``、``OFF``、``NO``、``FALSE``、``N``、``IGNORE``、``NOTFOUND``、空字符串则为假，或以后缀“-NOTFOUND”结尾。命名的布尔常量不区分大小写。如果参数不是这些特定常量之一，则将其视为变量或字符串（请参阅下面的“变量扩展”），并且适用以下两种形式之一。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:76
msgid "``if(<variable>)``"
msgstr "``如果（<变量>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:71
msgid ""
"True if given a variable that is defined to a value that is not a false "
"constant.  False otherwise, including if the variable is undefined. Note "
"that macro arguments are not variables. :ref:`Environment Variables <CMake"
" Language Environment Variables>` also cannot be tested this way, e.g. "
"``if(ENV{some_var})`` will always evaluate to false."
msgstr ""
"如果给定的变量定义为非假常量的值，则为真。否则为假，包括变量是否未定义。请注意，宏参数不是变量。 :ref:`Environment "
"Variables <CMake Language Environment Variables>` "
"也不能以这种方式进行测试，例如``if(ENV{some_var})`` 将始终评估为 false。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:84
msgid "``if(<string>)``"
msgstr "``如果（<字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:79
msgid "A quoted string always evaluates to false unless:"
msgstr "带引号的字符串总是计算为 false，除非："

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:81
msgid "The string's value is one of the true constants, or"
msgstr "字符串的值是真正的常量之一，或者"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:82
msgid ""
"Policy :policy:`CMP0054` is not set to ``NEW`` and the string's value "
"happens to be a variable name that is affected by :policy:`CMP0054`'s "
"behavior."
msgstr ""
"策略 :policy:`CMP0054` 未设置为 ``NEW`` 并且字符串的值恰好是受 :policy:`CMP0054` 的行为影响的变量名称。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:87
msgid "Logic Operators"
msgstr "逻辑运算符"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:92
msgid "``if(NOT <condition>)``"
msgstr "``如果（不是<条件>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:92
msgid "True if the condition is not true."
msgstr "如果条件不为真，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:97
msgid "``if(<cond1> AND <cond2>)``"
msgstr "``如果（<cond1> 和 <cond2>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:97
msgid "True if both conditions would be considered true individually."
msgstr "如果两个条件都被认为是真实的，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:102
msgid "``if(<cond1> OR <cond2>)``"
msgstr "``如果（<cond1> 或 <cond2>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:102
msgid "True if either condition would be considered true individually."
msgstr "如果任一条件被单独视为真，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:108
msgid "``if((condition) AND (condition OR (condition)))``"
msgstr "``如果（（条件）和（条件或（条件）））``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:105
msgid ""
"The conditions inside the parenthesis are evaluated first and then the "
"remaining condition is evaluated as in the other examples. Where there are"
" nested parenthesis the innermost are evaluated as part of evaluating the "
"condition that contains them."
msgstr "首先评估括号内的条件，然后像其他示例一样评估其余条件。在有嵌套括号的地方，最里面的括号被评估为评估包含它们的条件的一部分。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:111
msgid "Existence Checks"
msgstr "存在检查"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:117
msgid "``if(COMMAND command-name)``"
msgstr "``if（COMMAND 命令名）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:116
msgid ""
"True if the given name is a command, macro or function that can be "
"invoked."
msgstr "如果给定名称是可以调用的命令、宏或函数，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:120
msgid "``if(POLICY policy-id)``"
msgstr "``如果（策略策略-id）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:120
msgid ""
"True if the given name is an existing policy (of the form ``CMP<NNNN>``)."
msgstr "如果给定名称是现有策略（形式为“CMP<NNNN>”），则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:126
msgid "``if(TARGET target-name)``"
msgstr "``如果（目标目标名称）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:123
msgid ""
"True if the given name is an existing logical target name created by a "
"call to the :command:`add_executable`, :command:`add_library`, or "
":command:`add_custom_target` command that has already been invoked (in any"
" directory)."
msgstr ""
"如果给定的名称是通过调用 add_executable 、 add_library 或 add_custom_target "
"已经调用的命令创建的现有逻辑目标名称（在任何目录中），则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:131
msgid "``if(TEST test-name)``"
msgstr "``如果（测试测试名称）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:129
msgid ""
"True if the given name is an existing test name created by the "
":command:`add_test` command."
msgstr "如果给定名称是由 add_test 命令创建的现有测试名称，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:150
msgid "``if(DEFINED <name>|CACHE{<name>}|ENV{<name>})``"
msgstr "``if(DEFINED <name>|CACHE{<name>}|ENV{<name>})``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:136
msgid ""
"True if a variable, cache variable or environment variable with given "
"``<name>`` is defined. The value of the variable does not matter. Note the"
" following caveats:"
msgstr "如果定义了具有给定“<名称>”的变量、缓存变量或环境变量，则为真。变量的值无关紧要。请注意以下注意事项："

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:140
msgid "Macro arguments are not variables."
msgstr "宏参数不是变量。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:141
msgid ""
"It is not possible to test directly whether a `<name>` is a non-cache "
"variable.  The expression ``if(DEFINED someName)`` will evaluate to true "
"if either a cache or non-cache variable ``someName`` exists.  In "
"comparison, the expression ``if(DEFINED CACHE{someName})`` will only "
"evaluate to true if a cache variable ``someName`` exists.  Both "
"expressions need to be tested if you need to know whether a non-cache "
"variable exists: ``if(DEFINED someName AND NOT DEFINED CACHE{someName})``."
msgstr ""
"无法直接测试 `<name>` 是否为非缓存变量。如果存在缓存或非缓存变量“someName”，则表达式“if(DEFINED "
"someName)”的计算结果为真。相比之下，表达式 if(DEFINED CACHE{someName}) 只有在存在缓存变量 someName "
"时才会计算为真。如果您需要知道是否存在非缓存变量，则需要测试这两个表达式：``if(DEFINED someName AND NOT DEFINED"
" CACHE{someName})``。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:149
msgid "Added support for ``CACHE{<name>}`` variables."
msgstr "添加了对 ``CACHE{<name>}`` 变量的支持。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:154
msgid "``if(<variable|string> IN_LIST <variable>)``"
msgstr "``如果（<变量|字符串> IN_LIST <变量>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:153
msgid "True if the given element is contained in the named list variable."
msgstr "如果给定元素包含在命名列表变量中，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:157
msgid "File Operations"
msgstr "文件操作"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:168
msgid "``if(EXISTS path-to-file-or-directory)``"
msgstr "``如果（EXISTS 路径到文件或目录）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:162
msgid ""
"True if the named file or directory exists.  Behavior is well-defined only"
" for explicit full paths (a leading ``~/`` is not expanded as a home "
"directory and is considered a relative path). Resolves symbolic links, "
"i.e. if the named file or directory is a symbolic link, returns true if "
"the target of the symbolic link exists."
msgstr ""
"如果指定的文件或目录存在则为真。行为仅针对显式完整路径进行了明确定义（前导的 ``~/`` "
"不会扩展为主目录，而是被视为相对路径）。解析符号链接，即如果指定的文件或目录是符号链接，则如果符号链接的目标存在则返回 true。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:168
#: ../../cmake-prefix/src/cmake/Help/command/if.rst:182
msgid "False if the given path is an empty string."
msgstr "如果给定路径为空字符串，则为 False。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:176
msgid "``if(file1 IS_NEWER_THAN file2)``"
msgstr "``如果（file1 IS_NEWER_THAN file2）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:171
msgid ""
"True if ``file1`` is newer than ``file2`` or if one of the two files "
"doesn't exist.  Behavior is well-defined only for full paths.  If the file"
" time stamps are exactly the same, an ``IS_NEWER_THAN`` comparison returns"
" true, so that any dependent build operations will occur in the event of a"
" tie.  This includes the case of passing the same file name for both file1"
" and file2."
msgstr ""
"如果 ``file1`` 比 ``file2`` 新，或者两个文件之一不存在，则为真。行为仅针对完整路径进行了明确定义。如果文件时间戳完全相同，则 "
"``IS_NEWER_THAN`` 比较返回 true，因此在出现平局时将发生任何相关的构建操作。这包括为 file1 和 file2 "
"传递相同文件名的情况。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:182
msgid "``if(IS_DIRECTORY path)``"
msgstr "``如果（IS_DIRECTORY 路径）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:179
msgid ""
"True if ``path`` is a directory.  Behavior is well-defined only for full "
"paths."
msgstr "如果 ``path`` 是目录，则为真。行为仅针对完整路径进行了明确定义。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:186
msgid "``if(IS_SYMLINK file-name)``"
msgstr "``如果（IS_SYMLINK 文件名）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:185
msgid ""
"True if the given name is a symbolic link.  Behavior is well-defined only "
"for full paths."
msgstr "如果给定名称是符号链接，则为真。行为仅针对完整路径进行了明确定义。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:198
msgid "``if(IS_ABSOLUTE path)``"
msgstr "``如果（IS_ABSOLUTE 路径）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:189
msgid ""
"True if the given path is an absolute path.  Note the following special "
"cases:"
msgstr "如果给定路径是绝对路径，则为真。注意以下特殊情况："

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:192
msgid "An empty ``path`` evaluates to false."
msgstr "空的 ``path`` 计算结果为 false。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:193
msgid ""
"On Windows hosts, any ``path`` that begins with a drive letter and colon "
"(e.g. ``C:``), a forward slash or a backslash will evaluate to true. This "
"means a path like ``C:no\\base\\dir`` will evaluate to true, even though "
"the non-drive part of the path is relative."
msgstr ""
"在 Windows 主机上，任何以驱动器号和冒号（例如 "
"``C:``）、正斜杠或反斜杠开头的“路径”都将计算为真。这意味着像“C:no\\base\\dir”这样的路径将评估为真，即使路径的非驱动器部分是相对的。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:197
msgid ""
"On non-Windows hosts, any ``path`` that begins with a tilde (``~``) "
"evaluates to true."
msgstr "在非 Windows 主机上，任何以波浪号 (``~``) 开头的``路径`` 计算结果为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:201
msgid "Comparisons"
msgstr "比较"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:210
msgid "``if(<variable|string> MATCHES regex)``"
msgstr "``如果（<变量|字符串>匹配正则表达式）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:206
msgid ""
"True if the given string or variable's value matches the given regular "
"expression.  See :ref:`Regex Specification` for regex format."
msgstr ""
"如果给定的字符串或变量的值与给定的正则表达式匹配则为真。请参阅 :ref:`Regex Specification` 了解正则表达式格式。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:209
msgid "``()`` groups are captured in :variable:`CMAKE_MATCH_<n>` variables."
msgstr "``()`` 组在 :variable:`CMAKE_MATCH_<n>` 变量中捕获。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:216
msgid "``if(<variable|string> LESS <variable|string>)``"
msgstr "``如果（<变量|字符串> LESS <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:215
msgid ""
"True if the given string or variable's value is a valid number and less "
"than that on the right."
msgstr "如果给定的字符串或变量的值是有效数字并且小于右边的数字，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:222
msgid "``if(<variable|string> GREATER <variable|string>)``"
msgstr "``如果（<变量|字符串> GREATER <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:221
msgid ""
"True if the given string or variable's value is a valid number and greater"
" than that on the right."
msgstr "如果给定的字符串或变量的值是有效数字并且大于右边的数字，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:228
msgid "``if(<variable|string> EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串>等于<变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:227
msgid ""
"True if the given string or variable's value is a valid number and equal "
"to that on the right."
msgstr "如果给定的字符串或变量的值是有效数字并且等于右边的数字，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:235
msgid "``if(<variable|string> LESS_EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> LESS_EQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:233
msgid ""
"True if the given string or variable's value is a valid number and less "
"than or equal to that on the right."
msgstr "如果给定的字符串或变量的值是有效数字并且小于或等于右边的数字，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:242
msgid "``if(<variable|string> GREATER_EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> GREATER_EQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:240
msgid ""
"True if the given string or variable's value is a valid number and greater"
" than or equal to that on the right."
msgstr "如果给定的字符串或变量的值是有效数字并且大于或等于右边的数字，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:248
msgid "``if(<variable|string> STRLESS <variable|string>)``"
msgstr "``如果（<变量|字符串> STRLESS <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:247
msgid ""
"True if the given string or variable's value is lexicographically less "
"than the string or variable on the right."
msgstr "如果给定的字符串或变量的值按字典顺​​序小于右侧的字符串或变量，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:254
msgid "``if(<variable|string> STRGREATER <variable|string>)``"
msgstr "``如果（<变量|字符串> STRGREATER <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:253
msgid ""
"True if the given string or variable's value is lexicographically greater "
"than the string or variable on the right."
msgstr "如果给定的字符串或变量的值在字典序上大于右侧的字符串或变量，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:260
msgid "``if(<variable|string> STREQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> STREQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:259
msgid ""
"True if the given string or variable's value is lexicographically equal to"
" the string or variable on the right."
msgstr "如果给定的字符串或变量的值在字典序上等于右侧的字符串或变量，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:267
msgid "``if(<variable|string> STRLESS_EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> STRLESS_EQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:265
msgid ""
"True if the given string or variable's value is lexicographically less "
"than or equal to the string or variable on the right."
msgstr "如果给定的字符串或变量的值按字典顺​​序小于或等于右侧的字符串或变量，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:274
msgid "``if(<variable|string> STRGREATER_EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> STRGREATER_EQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:272
msgid ""
"True if the given string or variable's value is lexicographically greater "
"than or equal to the string or variable on the right."
msgstr "如果给定字符串或变量的值按字典顺​​序大于或等于右侧的字符串或变量，则为真。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:277
msgid "Version Comparisons"
msgstr "版本比较"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:285
msgid "``if(<variable|string> VERSION_LESS <variable|string>)``"
msgstr "``如果（<变量|字符串> VERSION_LESS <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:282
#: ../../cmake-prefix/src/cmake/Help/command/if.rst:290
#: ../../cmake-prefix/src/cmake/Help/command/if.rst:298
#: ../../cmake-prefix/src/cmake/Help/command/if.rst:306
#: ../../cmake-prefix/src/cmake/Help/command/if.rst:315
msgid ""
"Component-wise integer version number comparison (version format is "
"``major[.minor[.patch[.tweak]]]``, omitted components are treated as "
"zero). Any non-integer version component or non-integer trailing part of a"
" version component effectively truncates the string at that point."
msgstr ""
"组件方面的整数版本号比较（版本格式为``major[.minor[.patch[.tweak]]]``，省略的组件被视为零）。任何非整数版本组件或版本组件的非整数尾随部分都会在该点有效截断字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:293
msgid "``if(<variable|string> VERSION_GREATER <variable|string>)``"
msgstr "``如果（<变量|字符串> VERSION_GREATER <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:301
msgid "``if(<variable|string> VERSION_EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> VERSION_EQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:310
msgid "``if(<variable|string> VERSION_LESS_EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> VERSION_LESS_EQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:319
msgid "``if(<variable|string> VERSION_GREATER_EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> VERSION_GREATER_EQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:322
msgid "Path Comparisons"
msgstr "路径比较"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:352
msgid "``if(<variable|string> PATH_EQUAL <variable|string>)``"
msgstr "``如果（<变量|字符串> PATH_EQUAL <变量|字符串>）``"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:329
msgid ""
"Compares the two paths component-by-component.  Only if every component of"
" both paths match will the two paths compare equal.  Multiple path "
"separators are effectively collapsed into a single separator, but note "
"that backslashes are not converted to forward slashes.  No other "
":ref:`path normalization <Normalization>` is performed."
msgstr ""
"逐个组件地比较两条路径。只有当两条路径的每个组件都匹配时，两条路径才会比较相等。多个路径分隔符有效地折叠成一个分隔符，但请注意，反斜杠不会转换为正斜杠。没有执行其他"
" :ref:`path normalization <Normalization>`。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:335
msgid ""
"Component-wise comparison is superior to string-based comparison due to "
"the handling of multiple path separators.  In the following example, the "
"expression evaluates to true using ``PATH_EQUAL``, but false with "
"``STREQUAL``:"
msgstr ""
"由于对多个路径分隔符的处理，基于组件的比较优于基于字符串的比较。在以下示例中，表达式使用 ``PATH_EQUAL`` 计算结果为真，但使用 "
"``STREQUAL`` 计算结果为假："

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:352
msgid "See :ref:`cmake_path(COMPARE) <Path COMPARE>` for more details."
msgstr "有关详细信息，请参见:ref:`cmake_path(COMPARE) <Path COMPARE>`。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:355
msgid "Variable Expansion"
msgstr "变量扩展"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:357
msgid ""
"The if command was written very early in CMake's history, predating the "
"``${}`` variable evaluation syntax, and for convenience evaluates "
"variables named by its arguments as shown in the above signatures. Note "
"that normal variable evaluation with ``${}`` applies before the if command"
" even receives the arguments.  Therefore code like"
msgstr ""
"if 命令在 CMake 的历史中很早就编写了，早于 ``${}`` 变量评估语法，并且为了方便评估由其参数命名的变量，如上面的签名所示。请注意，在"
" if 命令甚至接收到参数之前，使用 ``${}`` 的普通变量评估就适用了。因此代码像"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:369
msgid "appears to the if command as"
msgstr "在 if 命令中显示为"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:375
msgid ""
"and is evaluated according to the ``if(<variable>)`` case documented "
"above.  The result is ``OFF`` which is false.  However, if we remove the "
"``${}`` from the example then the command sees"
msgstr ""
"并根据上面记录的 ``if(<variable>)`` 案例进行评估。结果是 ``OFF``，这是错误的。但是，如果我们从示例中删除 ``${}``"
" 那么命令会看到"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:383
msgid ""
"which is true because ``var2`` is defined to ``var1`` which is not a false"
" constant."
msgstr "这是真的，因为 ``var2`` 被定义为 ``var1`` 而不是假常量。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:386
msgid ""
"Automatic evaluation applies in the other cases whenever the above-"
"documented condition syntax accepts ``<variable|string>``:"
msgstr "只要上面记录的条件语法接受``<variable|string>``，自动评估就适用于其他情况："

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:389
msgid ""
"The left hand argument to ``MATCHES`` is first checked to see if it is a "
"defined variable, if so the variable's value is used, otherwise the "
"original value is used."
msgstr "首先检查“MATCHES”的左手参数，看它是否是已定义的变量，如果是，则使用变量的值，否则使用原始值。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:393
msgid ""
"If the left hand argument to ``MATCHES`` is missing it returns false "
"without error"
msgstr "如果缺少“MATCHES”的左手参数，它将返回 false 而不会出错"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:396
msgid ""
"Both left and right hand arguments to ``LESS``, ``GREATER``, ``EQUAL``, "
"``LESS_EQUAL``, and ``GREATER_EQUAL``, are independently tested to see if "
"they are defined variables, if so their defined values are used otherwise "
"the original value is used."
msgstr ""
"``LESS``、``GREATER``、``EQUAL``、``LESS_EQUAL`` 和 ``GREATER_EQUAL`` "
"的左手和右手参数都被独立测试以查看它们是否是已定义的变量，如果因此使用它们定义的值，否则使用原始值。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:401
msgid ""
"Both left and right hand arguments to ``STRLESS``, ``STRGREATER``, "
"``STREQUAL``, ``STRLESS_EQUAL``, and ``STRGREATER_EQUAL`` are "
"independently tested to see if they are defined variables, if so their "
"defined values are used otherwise the original value is used."
msgstr ""
"``STRLESS``、``STRGREATER``、``STREQUAL``、``STRLESS_EQUAL`` 和 "
"``STRGREATER_EQUAL`` 的左手和右手参数都被独立测试以查看它们是否是已定义的变量，如果是的话使用它们定义的值，否则使用原始值。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:406
msgid ""
"Both left and right hand arguments to ``VERSION_LESS``, "
"``VERSION_GREATER``, ``VERSION_EQUAL``, ``VERSION_LESS_EQUAL``, and "
"``VERSION_GREATER_EQUAL`` are independently tested to see if they are "
"defined variables, if so their defined values are used otherwise the "
"original value is used."
msgstr ""
"``VERSION_LESS``、``VERSION_GREATER``、``VERSION_EQUAL``、``VERSION_LESS_EQUAL``"
" 和 ``VERSION_GREATER_EQUAL`` "
"的左手和右手参数都被独立测试以查看它们是否是已定义的变量，如果是的话使用它们定义的值，否则使用原始值。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:412
msgid ""
"The right hand argument to ``NOT`` is tested to see if it is a boolean "
"constant, if so the value is used, otherwise it is assumed to be a "
"variable and it is dereferenced."
msgstr "测试“NOT”的右侧参数以查看它是否是布尔常量，如果是则使用该值，否则假定它是变量并取消引用。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:416
msgid ""
"The left and right hand arguments to ``AND`` and ``OR`` are independently "
"tested to see if they are boolean constants, if so they are used as such, "
"otherwise they are assumed to be variables and are dereferenced."
msgstr ""
"``AND`` 和 ``OR`` 的左手和右手参数被独立测试以查看它们是否是布尔常量，如果是，则按原样使用，否则它们被假定为变量并被取消引用。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:420
msgid ""
"To prevent ambiguity, potential variable or keyword names can be specified"
" in a :ref:`Quoted Argument` or a :ref:`Bracket Argument`. A quoted or "
"bracketed variable or keyword will be interpreted as a string and not "
"dereferenced or interpreted. See policy :policy:`CMP0054`."
msgstr ""
"为防止歧义，可以在 :ref:`Quoted Argument` 或 :ref:`Bracket Argument` "
"中指定潜在的变量或关键字名称。带引号或括号的变量或关键字将被解释为字符串，而不是取消引用或解释。请参阅政策:policy:`CMP0054`。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:427
msgid ""
"There is no automatic evaluation for environment or cache :ref:`Variable "
"References`.  Their values must be referenced as ``$ENV{<name>}`` or "
"``$CACHE{<name>}`` wherever the above-documented condition syntax accepts "
"``<variable|string>``."
msgstr ""
"没有针对环境或缓存的自动评估 :ref:`Variable References`。它们的值必须被引用为 ``$ENV{<name>}`` 或 "
"``$CACHE{<name>}`` 只要上面记录的条件语法接受 ``<variable|string>``。"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:433
msgid "See also"
msgstr "也可以看看"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:435
msgid ":command:`else`"
msgstr ":command:`其他`"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:436
msgid ":command:`elseif`"
msgstr ":command:`elseif`"

#: ../../cmake-prefix/src/cmake/Help/command/if.rst:437
msgid ":command:`endif`"
msgstr ":command:`endif`"

#: ../../cmake-prefix/src/cmake/Help/command/include.rst:2
msgid "include"
msgstr "包括"

#: ../../cmake-prefix/src/cmake/Help/command/include.rst:4
msgid "Load and run CMake code from a file or module."
msgstr "从文件或模块加载并运行 CMake 代码。"

#: ../../cmake-prefix/src/cmake/Help/command/include.rst:11
msgid ""
"Loads and runs CMake code from the file given.  Variable reads and writes "
"access the scope of the caller (dynamic scoping).  If ``OPTIONAL`` is "
"present, then no error is raised if the file does not exist.  If "
"``RESULT_VARIABLE`` is given the variable ``<var>`` will be set to the "
"full filename which has been included or ``NOTFOUND`` if it failed."
msgstr ""
"从给定的文件加载并运行 CMake "
"代码。变量读取和写入访问调用者的范围（动态范围）。如果存在“OPTIONAL”，那么如果文件不存在则不会引发错误。如果给出了 "
"RESULT_VARIABLE，变量 `<var>`` 将被设置为已包含的完整文件名，如果失败则为 `NOTFOUND``。"

#: ../../cmake-prefix/src/cmake/Help/command/include.rst:17
msgid ""
"If a module is specified instead of a file, the file with name "
"``<modulename>.cmake`` is searched first in :variable:`CMAKE_MODULE_PATH`,"
" then in the CMake module directory.  There is one exception to this: if "
"the file which calls ``include()`` is located itself in the CMake builtin "
"module directory, then first the CMake builtin module directory is "
"searched and :variable:`CMAKE_MODULE_PATH` afterwards.  See also policy "
":policy:`CMP0017`."
msgstr ""
"如果指定了模块而不是文件，则首先在 CMAKE_MODULE_PATH 中搜索名为 ``<modulename>.cmake`` 的文件，然后在 "
"CMake 模块目录中搜索。有一个例外：如果调用 ``include()`` 的文件本身位于 CMake 内置模块目录中，则首先搜索 CMake "
"内置模块目录，然后搜索 :variable:`CMAKE_MODULE_PATH`。另请参阅政策:policy:`CMP0017`。"

#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:2
msgid "include_directories"
msgstr "包含目录"

#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:4
msgid "Add include directories to the build."
msgstr "将包含目录添加到构建中。"

#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:10
msgid ""
"Add the given directories to those the compiler uses to search for include"
" files.  Relative paths are interpreted as relative to the current source "
"directory."
msgstr "将给定目录添加到编译器用于搜索包含文件的目录。相对路径被解释为相对于当前源目录。"

#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:14
msgid ""
"The include directories are added to the :prop_dir:`INCLUDE_DIRECTORIES` "
"directory property for the current ``CMakeLists`` file.  They are also "
"added to the :prop_tgt:`INCLUDE_DIRECTORIES` target property for each "
"target in the current ``CMakeLists`` file.  The target property values are"
" the ones used by the generators."
msgstr ""
"包含目录被添加到当前 CMakeLists 文件的 INCLUDE_DIRECTORIES 目录属性中。它们也被添加到当前 CMakeLists "
"文件中每个目标的 INCLUDE_DIRECTORIES 目标属性中。目标属性值是生成器使用的值。"

#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:20
msgid ""
"By default the directories specified are appended onto the current list of"
" directories.  This default behavior can be changed by setting "
":variable:`CMAKE_INCLUDE_DIRECTORIES_BEFORE` to ``ON``.  By using "
"``AFTER`` or ``BEFORE`` explicitly, you can select between appending and "
"prepending, independent of the default."
msgstr ""
"默认情况下，指定的目录附加到当前目录列表中。可以通过将 :variable:`CMAKE_INCLUDE_DIRECTORIES_BEFORE` "
"设置为 ``ON`` 来更改此默认行为。通过显式使用 ``AFTER`` 或 ``BEFORE``，您可以独立于默认值在追加和前置之间进行选择。"

#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:26
msgid ""
"If the ``SYSTEM`` option is given, the compiler will be told the "
"directories are meant as system include directories on some platforms. "
"Signalling this setting might achieve effects such as the compiler "
"skipping warnings, or these fixed-install system files not being "
"considered in dependency calculations - see compiler docs."
msgstr ""
"如果给出了“SYSTEM”选项，编译器将被告知这些目录在某些平台上是系统包含目录。发出此设置信号可能会达到编译器跳过警告等效果，或者这些固定安装的系统文件在依赖项计算中不被考虑"
" - 请参阅编译器文档。"

#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:37
msgid ""
"Prefer the :command:`target_include_directories` command to add include "
"directories to individual targets and optionally propagate/export them to "
"dependents."
msgstr ""
"首选 :command:`target_include_directories` 命令将包含目录添加到各个目标，并可选择将它们传播/导出到依赖项。"

#: ../../cmake-prefix/src/cmake/Help/command/include_directories.rst:44
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:56
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:44
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:65
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:417
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:60
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:129
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:214
msgid ":command:`target_include_directories`"
msgstr ":command:`target_include_directories`"

#: ../../cmake-prefix/src/cmake/Help/command/include_external_msproject.rst:2
msgid "include_external_msproject"
msgstr "include_external_msproject"

#: ../../cmake-prefix/src/cmake/Help/command/include_external_msproject.rst:4
msgid "Include an external Microsoft project file in a workspace."
msgstr "在工作区中包含一个外部 Microsoft 项目文件。"

#: ../../cmake-prefix/src/cmake/Help/command/include_external_msproject.rst:14
msgid ""
"Includes an external Microsoft project in the generated workspace file.  "
"Currently does nothing on UNIX.  This will create a target named "
"``[projectname]``.  This can be used in the :command:`add_dependencies` "
"command to make things depend on the external project."
msgstr ""
"在生成的工作区文件中包含一个外部 Microsoft 项目。当前在 UNIX "
"上不执行任何操作。这将创建一个名为“[projectname]”的目标。这可以在 :command:`add_dependencies` "
"命令中使用，使事情依赖于外部项目。"

#: ../../cmake-prefix/src/cmake/Help/command/include_external_msproject.rst:19
msgid ""
"``TYPE``, ``GUID`` and ``PLATFORM`` are optional parameters that allow one"
" to specify the type of project, id (``GUID``) of the project and the name"
" of the target platform.  This is useful for projects requiring values "
"other than the default (e.g.  WIX projects)."
msgstr ""
"``TYPE``、``GUID`` 和 ``PLATFORM`` 是可选参数，允许指定项目类型、项目 ID (``GUID``) "
"和目标平台的名称。这对于需要默认值以外的值的项目（例如 WIX 项目）很有用。"

#: ../../cmake-prefix/src/cmake/Help/command/include_external_msproject.rst:24
msgid ""
"If the imported project has different configuration names than the current"
" project, set the :prop_tgt:`MAP_IMPORTED_CONFIG_<CONFIG>` target property"
" to specify the mapping."
msgstr "如果导入项目的配置名称与当前项目不同，请设置 MAP_IMPORTED_CONFIG_<CONFIG> 目标属性以指定映射。"

#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:2
msgid "include_guard"
msgstr "include_guard"

#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:6
msgid ""
"Provides an include guard for the file currently being processed by CMake."
msgstr "为 CMake 当前正在处理的文件提供一个包含保护。"

#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:12
msgid ""
"Sets up an include guard for the current CMake file (see the "
":variable:`CMAKE_CURRENT_LIST_FILE` variable documentation)."
msgstr "为当前的 CMake 文件设置一个包含保护（参见 :variable:`CMAKE_CURRENT_LIST_FILE` 变量文档）。"

#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:15
msgid ""
"CMake will end its processing of the current file at the location of the "
"``include_guard`` command if the current file has already been processed "
"for the applicable scope (see below). This provides functionality similar "
"to the include guards commonly used in source headers or to the ``#pragma "
"once`` directive. If the current file has been processed previously for "
"the applicable scope, the effect is as though :command:`return` had been "
"called. Do not call this command from inside a function being defined "
"within the current file."
msgstr ""
"如果当前文件已经针对适用范围进行了处理（见下文），CMake 将在 ``include_guard`` "
"命令的位置结束对当前文件的处理。这提供了类似于源头文件中常用的包含防护或“#pragma "
"once”指令的功能。如果当前文件之前已经针对适用范围进行了处理，则效果就像调用了 :command:`return` "
"一样。不要从当前文件中定义的函数内部调用此命令。"

#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:24
msgid ""
"An optional argument specifying the scope of the guard may be provided. "
"Possible values for the option are:"
msgstr "可以提供指定守卫范围的可选参数。该选项的可能值为："

#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:28
msgid ""
"The include guard applies within the current directory and below. The file"
" will only be included once within this directory scope, but may be "
"included again by other files outside of this directory (i.e. a parent "
"directory or another directory not pulled in by "
":command:`add_subdirectory` or :command:`include` from the current file or"
" its children)."
msgstr ""
"include guard 适用于当前目录及以下目录。该文件只会在此目录范围内包含一次，但可能会被此目录外的其他文件再次包含（即父目录或另一个未被 "
":command:`add_subdirectory` 或 :command:`include` 从当前文件或其子文件）。"

#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:35
msgid ""
"The include guard applies globally to the whole build. The current file "
"will only be included once regardless of the scope."
msgstr "include guard 全局适用于整个构建。无论范围如何，当前文件只会被包含一次。"

#: ../../cmake-prefix/src/cmake/Help/command/include_guard.rst:38
msgid ""
"If no arguments given, ``include_guard`` has the same scope as a variable,"
" meaning that the include guard effect is isolated by the most recent "
"function scope or current directory if no inner function scopes exist. In "
"this case the command behavior is the same as:"
msgstr ""
"如果没有给出参数，``include_guard`` "
"具有与变量相同的作用域，这意味着如果不存在内部函数作用域，则包含保护作用被最近的函数作用域或当前目录隔离。在这种情况下，命令行为与以下相同："

#: ../../cmake-prefix/src/cmake/Help/command/include_regular_expression.rst:2
msgid "include_regular_expression"
msgstr "include_regular_expression"

#: ../../cmake-prefix/src/cmake/Help/command/include_regular_expression.rst:4
msgid "Set the regular expression used for dependency checking."
msgstr "设置用于依赖性检查的正则表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/include_regular_expression.rst:10
msgid ""
"Sets the regular expressions used in dependency checking.  Only files "
"matching ``regex_match`` will be traced as dependencies.  Only files "
"matching ``regex_complain`` will generate warnings if they cannot be found"
" (standard header paths are not searched).  The defaults are:"
msgstr ""
"设置用于依赖性检查的正则表达式。只有与 regex_match 匹配的文件才会被跟踪为依赖项。只有匹配 regex_complain "
"的文件才会在找不到时生成警告（不搜索标准标题路径）。默认值是："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:2
msgid "install"
msgstr "安装"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:4
msgid "Specify rules to run at install time."
msgstr "指定要在安装时运行的规则。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:23
msgid ""
"This command generates installation rules for a project.  Install rules "
"specified by calls to the ``install()`` command within a source directory "
"are executed in order during installation."
msgstr "此命令为项目生成安装规则。在安装期间按顺序执行在源目录中调用 ``install()`` 命令指定的安装规则。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:27
msgid ""
"Install rules in subdirectories added by calls to the "
":command:`add_subdirectory` command are interleaved with those in the "
"parent directory to run in the order declared (see policy "
":policy:`CMP0082`)."
msgstr ""
"通过调用 :command:`add_subdirectory` "
"命令添加的子目录中的安装规则与父目录中的规则交错，以按照声明的顺序运行（请参阅策略：`CMP0082`）。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:33
msgid ""
"The environment variable :envvar:`CMAKE_INSTALL_MODE` can override the "
"default copying behavior of ``install()``."
msgstr "环境变量 :envvar:`CMAKE_INSTALL_MODE` 可以覆盖 ``install()`` 的默认复制行为。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:37
msgid ""
"There are multiple signatures for this command.  Some of them define "
"installation options for files and targets.  Options common to multiple "
"signatures are covered here but they are valid only for signatures that "
"specify them.  The common options are:"
msgstr "此命令有多个签名。其中一些定义了文件和目标的安装选项。此处涵盖了多个签名共有的选项，但它们仅对指定它们的签名有效。常见的选项有："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:59
msgid "``DESTINATION``"
msgstr "``目的地``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:43
msgid ""
"Specify the directory on disk to which a file will be installed. Arguments"
" can be relative or absolute paths."
msgstr "指定磁盘上将安装文件的目录。参数可以是相对或绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:46
msgid ""
"If a relative path is given it is interpreted relative to the value of the"
" :variable:`CMAKE_INSTALL_PREFIX` variable. The prefix can be relocated at"
" install time using the ``DESTDIR`` mechanism explained in the "
":variable:`CMAKE_INSTALL_PREFIX` variable documentation."
msgstr ""
"如果给出了相对路径，则相对于 CMAKE_INSTALL_PREFIX 变量的值进行解释。前缀可以在安装时使用 "
"CMAKE_INSTALL_PREFIX 变量文档中解释的 ``DESTDIR`` 机制重新定位。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:52
msgid ""
"If an absolute path (with a leading slash or drive letter) is given it is "
"used verbatim."
msgstr "如果给出了绝对路径（带有前导斜杠或驱动器号），则将逐字使用。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:55
msgid ""
"As absolute paths are not supported by :manual:`cpack <cpack(1)>` "
"installer generators, it is preferable to use relative paths throughout. "
"In particular, there is no need to make paths absolute by prepending "
":variable:`CMAKE_INSTALL_PREFIX`; this prefix is used by default if the "
"DESTINATION is a relative path."
msgstr ""
"由于 :manual:`cpack <cpack(1)>` 安装程序生成器不支持绝对路径，因此最好始终使用相对路径。特别是，不需要通过在前面加上 "
"CMAKE_INSTALL_PREFIX 来使路径成为绝对路径；如果 DESTINATION 是相对路径，则默认使用此前缀。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:62
msgid ""
"Specify permissions for installed files.  Valid permissions are "
"``OWNER_READ``, ``OWNER_WRITE``, ``OWNER_EXECUTE``, ``GROUP_READ``, "
"``GROUP_WRITE``, ``GROUP_EXECUTE``, ``WORLD_READ``, ``WORLD_WRITE``, "
"``WORLD_EXECUTE``, ``SETUID``, and ``SETGID``.  Permissions that do not "
"make sense on certain platforms are ignored on those platforms."
msgstr ""
"指定安装文件的权限。有效权限为``OWNER_READ``、``OWNER_WRITE``、``OWNER_EXECUTE``、``GROUP_READ``、``GROUP_WRITE``、``GROUP_EXECUTE``、``WORLD_READ``、``WORLD_WRITE``"
" ，``WORLD_EXECUTE``，``SETUID`` 和``SETGID``。在某些平台上没有意义的权限在这些平台上会被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:69
msgid ""
"Specify a list of build configurations for which the install rule applies "
"(Debug, Release, etc.). Note that the values specified for this option "
"only apply to options listed AFTER the ``CONFIGURATIONS`` option. For "
"example, to set separate install paths for the Debug and Release "
"configurations, do the following:"
msgstr ""
"指定适用安装规则的构建配置列表（调试、发布等）。请注意，为此选项指定的值仅适用于 ``CONFIGURATIONS`` "
"选项之后列出的选项。例如，要为调试和发布配置设置单独的安装路径，请执行以下操作："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:84
msgid "Note that ``CONFIGURATIONS`` appears BEFORE ``RUNTIME DESTINATION``."
msgstr "请注意，``CONFIGURATIONS`` 出现在 ``RUNTIME DESTINATION`` 之前。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:94
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:976
msgid "``COMPONENT``"
msgstr "``组件``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:87
msgid ""
"Specify an installation component name with which the install rule is "
"associated, such as ``Runtime`` or ``Development``.  During component-"
"specific installation only install rules associated with the given "
"component name will be executed.  During a full installation all "
"components are installed unless marked with ``EXCLUDE_FROM_ALL``. If "
"``COMPONENT`` is not provided a default component \"Unspecified\" is "
"created.  The default component name may be controlled with the "
":variable:`CMAKE_INSTALL_DEFAULT_COMPONENT_NAME` variable."
msgstr ""
"指定与安装规则关联的安装组件名称，例如 ``Runtime`` 或 "
"``Development``。在特定于组件的安装期间，只会执行与给定组件名称关联的安装规则。在完整安装期间，所有组件都会安装，除非标有 "
"``EXCLUDE_FROM_ALL``。如果未提供 ``COMPONENT``，则会创建默认组件“Unspecified”。默认组件名称可以通过 "
"CMAKE_INSTALL_DEFAULT_COMPONENT_NAME 变量控制。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:100
msgid "``EXCLUDE_FROM_ALL``"
msgstr "``EXCLUDE_FROM_ALL``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:99
msgid ""
"Specify that the file is excluded from a full installation and only "
"installed as part of a component-specific installation"
msgstr "指定该文件从完整安装中排除，仅作为组件特定安装的一部分安装"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:105
msgid "``RENAME``"
msgstr "``重命名``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:103
msgid ""
"Specify a name for an installed file that may be different from the "
"original file.  Renaming is allowed only when a single file is installed "
"by the command."
msgstr "为安装的文件指定一个名称，该名称可能与原始文件不同。只有在命令安装单个文件时才允许重命名。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:108
msgid ""
"Specify that it is not an error if the file to be installed does not "
"exist."
msgstr "指定如果要安装的文件不存在则不报错。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:111
msgid ""
"Command signatures that install files may print messages during "
"installation.  Use the :variable:`CMAKE_INSTALL_MESSAGE` variable to "
"control which messages are printed."
msgstr ""
"安装文件的命令签名可能会在安装期间打印消息。使用 :variable:`CMAKE_INSTALL_MESSAGE` 变量来控制打印哪些消息。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:116
msgid ""
"Many of the ``install()`` variants implicitly create the directories "
"containing the installed files. If "
":variable:`CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS` is set, these "
"directories will be created with the permissions specified. Otherwise, "
"they will be created according to the uname rules on Unix-like platforms. "
"Windows platforms are unaffected."
msgstr ""
"许多 ``install()`` 变体隐式创建包含已安装文件的目录。如果设置了 "
":variable:`CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS`，将使用指定的权限创建这些目录。否则，它们将根据类"
" Unix 平台上的 uname 规则创建。 Windows 平台不受影响。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:125
msgid "Installing Targets"
msgstr "安装目标"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:147
msgid ""
"The ``TARGETS`` form specifies rules for installing targets from a "
"project.  There are several kinds of target :ref:`Output Artifacts` that "
"may be installed:"
msgstr "``TARGETS`` 形式指定了从项目安装目标的规则。有几种目标可以安装:ref:`Output Artifacts`："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:160
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:262
msgid "``ARCHIVE``"
msgstr "``存档``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:152
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:163
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:171
msgid "Target artifacts of this kind include:"
msgstr "此类目标工件包括："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:154
msgid ""
"*Static libraries* (except on macOS when marked as ``FRAMEWORK``, see "
"below);"
msgstr "*静态库*（标记为“FRAMEWORK”的 macOS 除外，见下文）；"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:156
msgid ""
"*DLL import libraries* (on all Windows-based systems including Cygwin; "
"they have extension ``.lib``, in contrast to the ``.dll`` libraries that "
"go to ``RUNTIME``);"
msgstr ""
"*DLL 导入库*（在包括 Cygwin 在内的所有基于 Windows 的系统上；它们具有扩展名 ``.lib``，与进入 ``RUNTIME``"
" 的 ``.dll`` 库形成对比）；"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:159
msgid ""
"On AIX, the *linker import file* created for executables with "
":prop_tgt:`ENABLE_EXPORTS` enabled."
msgstr "在 AIX 上，为启用了 :prop_tgt:`ENABLE_EXPORTS` 的可执行文件创建的*链接器导入文件*。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:168
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:261
msgid "``LIBRARY``"
msgstr "``图书馆``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:165
msgid "*Shared libraries*, except"
msgstr "*共享库*，除了"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:167
msgid "DLLs (these go to ``RUNTIME``, see below),"
msgstr "DLL（这些进入``RUNTIME``，见下文），"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:168
msgid "on macOS when marked as ``FRAMEWORK`` (see below)."
msgstr "在 macOS 上标记为 ``FRAMEWORK``（见下文）。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:176
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:260
msgid "``RUNTIME``"
msgstr "``运行时``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:173
msgid ""
"*Executables* (except on macOS when marked as ``MACOSX_BUNDLE``, see "
"``BUNDLE`` below);"
msgstr "*可执行文件*（标记为 ``MACOSX_BUNDLE`` 的 macOS 除外，请参阅下面的 ``BUNDLE``）；"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:175
msgid ""
"DLLs (on all Windows-based systems including Cygwin; note that the "
"accompanying import libraries are of kind ``ARCHIVE``)."
msgstr "DLL（在包括 Cygwin 在内的所有基于 Windows 的系统上；请注意，随附的导入库属于“ARCHIVE”类型）。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:181
msgid "``OBJECTS``"
msgstr "``对象``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:181
msgid "Object files associated with *object libraries*."
msgstr "与*对象库*关联的对象文件。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:185
msgid "``FRAMEWORK``"
msgstr "``框架``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:184
msgid ""
"Both static and shared libraries marked with the ``FRAMEWORK`` property "
"are treated as ``FRAMEWORK`` targets on macOS."
msgstr "在 macOS 上，标有“FRAMEWORK”属性的静态库和共享库都被视为“FRAMEWORK”目标。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:189
msgid "``BUNDLE``"
msgstr "``捆绑``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:188
msgid ""
"Executables marked with the :prop_tgt:`MACOSX_BUNDLE` property are treated"
" as ``BUNDLE`` targets on macOS."
msgstr "标有 :prop_tgt:`MACOSX_BUNDLE` 属性的可执行文件在 macOS 上被视为 ``BUNDLE`` 目标。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:197
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:264
msgid "``PUBLIC_HEADER``"
msgstr "``PUBLIC_HEADER``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:192
msgid ""
"Any :prop_tgt:`PUBLIC_HEADER` files associated with a library are "
"installed in the destination specified by the ``PUBLIC_HEADER`` argument "
"on non-Apple platforms. Rules defined by this argument are ignored for "
":prop_tgt:`FRAMEWORK` libraries on Apple platforms because the associated "
"files are installed into the appropriate locations inside the framework "
"folder. See :prop_tgt:`PUBLIC_HEADER` for details."
msgstr ""
"与库关联的任何 :prop_tgt:`PUBLIC_HEADER` 文件都安装在非 Apple 平台上由 ``PUBLIC_HEADER`` "
"参数指定的目标中。对于 Apple 平台上的 :prop_tgt:`FRAMEWORK` "
"库，此参数定义的规则将被忽略，因为相关文件已安装到框架文件夹内的适当位置。有关详细信息，请参阅 :prop_tgt:`PUBLIC_HEADER`。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:201
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:263
msgid "``PRIVATE_HEADER``"
msgstr "``PRIVATE_HEADER``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:200
msgid ""
"Similar to ``PUBLIC_HEADER``, but for ``PRIVATE_HEADER`` files. See "
":prop_tgt:`PRIVATE_HEADER` for details."
msgstr ""
"类似于 ``PUBLIC_HEADER``，但用于 ``PRIVATE_HEADER`` 文件。有关详细信息，请参阅 "
":prop_tgt:`PRIVATE_HEADER`。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:205
msgid "``RESOURCE``"
msgstr "``资源``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:204
msgid ""
"Similar to ``PUBLIC_HEADER`` and ``PRIVATE_HEADER``, but for ``RESOURCE`` "
"files. See :prop_tgt:`RESOURCE` for details."
msgstr ""
"类似于 ``PUBLIC_HEADER`` 和 ``PRIVATE_HEADER``，但用于 ``RESOURCE`` "
"文件。有关详细信息，请参阅:prop_tgt:`RESOURCE`。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:216
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:116
msgid "``FILE_SET <set>``"
msgstr "``FILE_SET <设置>``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:210
msgid ""
"File sets are defined by the :command:`target_sources(FILE_SET)` command. "
"If the file set ``<set>`` exists and is ``PUBLIC`` or ``INTERFACE``, any "
"files in the set are installed under the destination (see below). The "
"directory structure relative to the file set's base directories is "
"preserved. For example, a file added to the file set as "
"``/blah/include/myproj/here.h`` with a base directory ``/blah/include`` "
"would be installed to ``myproj/here.h`` below the destination."
msgstr ""
"文件集由 :command:`target_sources(FILE_SET)` 命令定义。如果文件集 ``<set>`` 存在并且是 "
"``PUBLIC`` 或 "
"``INTERFACE``，则集合中的任何文件都安装在目标下（见下文）。相对于文件集的基本目录的目录结构被保留。例如，添加到文件集为“/blah/include/myproj/here.h”且基目录为“/blah/include”的文件将安装到“myproj/here.h”目的地下方。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:218
msgid "``CXX_MODULES_BMI``"
msgstr "``CXX_MODULES_BMI``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:224
msgid ""
"Any module files from C++ modules from ``PUBLIC`` sources in a file set of"
" type ``CXX_MODULES`` will be installed to the given ``DESTINATION``. All "
"modules are placed directly in the destination as no directory structure "
"is derived from the names of the modules. An empty ``DESTINATION`` may be "
"used to suppress installing these files (for use in generic code)."
msgstr ""
"类型为“CXX_MODULES”的文件集中来自“PUBLIC”源的 C++ "
"模块的任何模块文件都将安装到给定的“DESTINATION”。所有模块都直接放在目标中，因为没有目录结构是从模块名称派生的。空的``DESTINATION``"
" 可用于禁止安装这些文件（用于通用代码）。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:230
msgid ""
"For each of these arguments given, the arguments following them only apply"
" to the target or file type specified in the argument. If none is given, "
"the installation properties apply to all target types."
msgstr "对于给定的每个参数，它们后面的参数仅适用于参数中指定的目标或文件类型。如果未给出，则安装属性适用于所有目标类型。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:234
msgid ""
"For regular executables, static libraries and shared libraries, the "
"``DESTINATION`` argument is not required.  For these target types, when "
"``DESTINATION`` is omitted, a default destination will be taken from the "
"appropriate variable from :module:`GNUInstallDirs`, or set to a built-in "
"default value if that variable is not defined.  The same is true for file "
"sets, and the public and private headers associated with the installed "
"targets through the :prop_tgt:`PUBLIC_HEADER` and "
":prop_tgt:`PRIVATE_HEADER` target properties. A destination must always be"
" provided for module libraries, Apple bundles and frameworks.  A "
"destination can be omitted for interface and object libraries, but they "
"are handled differently (see the discussion of this topic toward the end "
"of this section)."
msgstr ""
"对于常规可执行文件、静态库和共享库，不需要 DESTINATION 参数。对于这些目标类型，当省略 DESTINATION 时，默认目标将从 "
"GNUInstallDirs 的适当变量中获取，或者如果未定义该变量，则设置为内置默认值。对于文件集以及通过 "
":prop_tgt:`PUBLIC_HEADER` 和 :prop_tgt:`PRIVATE_HEADER` "
"目标属性与已安装目标关联的公共和私有标头也是如此。必须始终为模块库、Apple "
"捆绑包和框架提供目的地。接口库和对象库可以省略目的地，但它们的处理方式不同（请参阅本节末尾对该主题的讨论）。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:246
msgid ""
"For shared libraries on DLL platforms, if neither ``RUNTIME`` nor "
"``ARCHIVE`` destinations are specified, both the ``RUNTIME`` and "
"``ARCHIVE`` components are installed to their default destinations. If "
"either a ``RUNTIME`` or ``ARCHIVE`` destination is specified, the "
"component is installed to that destination, and the other component is not"
" installed. If both ``RUNTIME`` and ``ARCHIVE`` destinations are "
"specified, then both components are installed to their respective "
"destinations."
msgstr ""
"对于 DLL 平台上的共享库，如果既未指定 ``RUNTIME`` 也未指定 ``ARCHIVE`` 目的地，则 ``RUNTIME`` 和 "
"``ARCHIVE`` 组件都安装到它们的默认目的地。如果指定了 ``RUNTIME`` 或 ``ARCHIVE`` "
"目的地，则该组件将安装到该目的地，而不会安装其他组件。如果同时指定了 ``RUNTIME`` 和 ``ARCHIVE`` "
"目的地，那么这两个组件都将安装到它们各自的目的地。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:254
msgid ""
"The following table shows the target types with their associated variables"
" and built-in defaults that apply when no destination is given:"
msgstr "下表显示了目标类型及其关联变量和在未指定目标时适用的内置默认值："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:258
msgid "Target Type"
msgstr "目标类型"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:258
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:560
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:713
msgid "GNUInstallDirs Variable"
msgstr "GNUInstallDirs 变量"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:258
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:560
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:713
msgid "Built-In Default"
msgstr "内置默认值"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:260
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:562
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:715
msgid "``${CMAKE_INSTALL_BINDIR}``"
msgstr "``${CMAKE_INSTALL_BINDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:260
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:562
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:715
msgid "``bin``"
msgstr "``bin``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:261
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:262
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:564
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:717
msgid "``${CMAKE_INSTALL_LIBDIR}``"
msgstr "``${CMAKE_INSTALL_LIBDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:261
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:262
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:564
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:717
msgid "``lib``"
msgstr "``库``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:263
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:264
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:265
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:565
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:718
msgid "``${CMAKE_INSTALL_INCLUDEDIR}``"
msgstr "``${CMAKE_INSTALL_INCLUDEDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:263
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:264
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:265
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:565
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:718
msgid "``include``"
msgstr "``包括``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:265
msgid "``FILE_SET`` (type ``HEADERS``)"
msgstr "``FILE_SET``（输入``HEADERS``）"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:268
msgid ""
"Projects wishing to follow the common practice of installing headers into "
"a project-specific subdirectory may prefer using file sets with "
"appropriate paths and base directories. Otherwise, they must provide a "
"``DESTINATION`` instead of being able to rely on the above (see next "
"example below)."
msgstr ""
"希望遵循将标头安装到项目特定子目录的常见做法的项目可能更喜欢使用具有适当路径和基本目录的文件集。否则，他们必须提供一个``DESTINATION``"
" 而不是能够依赖上面的（见下面的下一个例子）。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:273
msgid ""
"To make packages compliant with distribution filesystem layout policies, "
"if projects must specify a ``DESTINATION``, it is recommended that they "
"use a path that begins with the appropriate :module:`GNUInstallDirs` "
"variable. This allows package maintainers to control the install "
"destination by setting the appropriate cache variables.  The following "
"example shows a static library being installed to the default destination "
"provided by :module:`GNUInstallDirs`, but with its headers installed to a "
"project-specific subdirectory without using file sets:"
msgstr ""
"为了使包符合分发文件系统布局策略，如果项目必须指定一个``DESTINATION``，建议他们使用以适当的 GNUInstallDirs "
"变量开头的路径。这允许包维护者通过设置适当的缓存变量来控制安装目的地。以下示例显示了一个静态库被安装到 GNUInstallDirs "
"提供的默认目标，但其标头安装到项目特定的子目录而不使用文件集："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:292
msgid ""
"In addition to the common options listed above, each target can accept the"
" following additional arguments:"
msgstr "除了上面列出的常见选项之外，每个目标还可以接受以下附加参数："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:336
msgid "``NAMELINK_COMPONENT``"
msgstr "``NAMELINK_COMPONENT``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:298
msgid ""
"On some platforms a versioned shared library has a symbolic link such as::"
msgstr "在某些平台上，版本化的共享库有一个符号链接，例如："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:303
msgid ""
"where ``lib<name>.so.1`` is the soname of the library and ``lib<name>.so``"
" is a \"namelink\" allowing linkers to find the library when given "
"``-l<name>``. The ``NAMELINK_COMPONENT`` option is similar to the "
"``COMPONENT`` option, but it changes the installation component of a "
"shared library namelink if one is generated. If not specified, this "
"defaults to the value of ``COMPONENT``. It is an error to use this "
"parameter outside of a ``LIBRARY`` block."
msgstr ""
"其中 ``lib<name>.so.1`` 是库的名称，``lib<name>.so`` 是一个“名称链接”，允许链接器在给定 ``-l<name>"
" 时找到库``。 ``NAMELINK_COMPONENT`` 选项类似于 ``COMPONENT`` "
"选项，但它会更改共享库名称链接的安装组件（如果生成的话）。如果未指定，则默认为 COMPONENT 的值。在 ``LIBRARY`` "
"块之外使用此参数是错误的。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:311
msgid "Consider the following example:"
msgstr "考虑以下示例："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:323
msgid ""
"In this scenario, if you choose to install only the ``Development`` "
"component, both the headers and namelink will be installed without the "
"library. (If you don't also install the ``Libraries`` component, the "
"namelink will be a dangling symlink, and projects that link to the library"
" will have build errors.) If you install only the ``Libraries`` component,"
" only the library will be installed, without the headers and namelink."
msgstr ""
"在这种情况下，如果您选择仅安装“开发”组件，则将在不安装库的情况下安装标头和名称链接。 （如果你不同时安装 ``Libraries`` "
"组件，namelink 将是一个悬挂的符号链接，链接到库的项目将出现构建错误。）如果您只安装 ``Libraries`` "
"组件，只有库将被安装，没有标题和名称链接。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:330
msgid ""
"This option is typically used for package managers that have separate "
"runtime and development packages. For example, on Debian systems, the "
"library is expected to be in the runtime package, and the headers and "
"namelink are expected to be in the development package."
msgstr "此选项通常用于具有独立运行时和开发包的包管理器。例如，在 Debian 系统上，库应该在运行时包中，标头和名称链接应该在开发包中。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:335
msgid ""
"See the :prop_tgt:`VERSION` and :prop_tgt:`SOVERSION` target properties "
"for details on creating versioned shared libraries."
msgstr ""
"有关创建版本化共享库的详细信息，请参阅 :prop_tgt:`VERSION` 和 :prop_tgt:`SOVERSION` 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:347
msgid "``NAMELINK_ONLY``"
msgstr "``NAMELINK_ONLY``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:339
msgid ""
"This option causes the installation of only the namelink when a library "
"target is installed. On platforms where versioned shared libraries do not "
"have namelinks or when a library is not versioned, the ``NAMELINK_ONLY`` "
"option installs nothing. It is an error to use this parameter outside of a"
" ``LIBRARY`` block."
msgstr ""
"安装库目标时，此选项会导致仅安装名称链接。在版本化共享库没有名称链接的平台上，或者当库没有版本化时，``NAMELINK_ONLY`` "
"选项不安装任何东西。在 ``LIBRARY`` 块之外使用此参数是错误的。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:345
msgid ""
"When ``NAMELINK_ONLY`` is given, either ``NAMELINK_COMPONENT`` or "
"``COMPONENT`` may be used to specify the installation component of the "
"namelink, but ``COMPONENT`` should generally be preferred."
msgstr ""
"当给出 ``NAMELINK_ONLY`` 时，``NAMELINK_COMPONENT`` 或 ``COMPONENT`` "
"可用于指定名称链接的安装组件，但通常应首选 ``COMPONENT``。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:360
msgid "``NAMELINK_SKIP``"
msgstr "``NAMELINK_SKIP``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:350
msgid ""
"Similar to ``NAMELINK_ONLY``, but it has the opposite effect: it causes "
"the installation of library files other than the namelink when a library "
"target is installed. When neither ``NAMELINK_ONLY`` or ``NAMELINK_SKIP`` "
"are given, both portions are installed. On platforms where versioned "
"shared libraries do not have symlinks or when a library is not versioned, "
"``NAMELINK_SKIP`` installs the library. It is an error to use this "
"parameter outside of a ``LIBRARY`` block."
msgstr ""
"类似于``NAMELINK_ONLY``，但它有相反的效果：它会导致在安装库目标时安装名称链接以外的库文件。当 ``NAMELINK_ONLY`` "
"或 ``NAMELINK_SKIP`` "
"都没有给出时，这两个部分都会被安装。在版本化共享库没有符号链接的平台上，或者当库没有版本化时，``NAMELINK_SKIP`` 安装库。在 "
"``LIBRARY`` 块之外使用此参数是错误的。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:358
msgid ""
"If ``NAMELINK_SKIP`` is specified, ``NAMELINK_COMPONENT`` has no effect. "
"It is not recommended to use ``NAMELINK_SKIP`` in conjunction with "
"``NAMELINK_COMPONENT``."
msgstr ""
"如果指定了“NAMELINK_SKIP”，则“NAMELINK_COMPONENT”无效。不建议将 ``NAMELINK_SKIP`` 与 "
"``NAMELINK_COMPONENT`` 结合使用。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:362
msgid ""
"The `install(TARGETS)`_ command can also accept the following options at "
"the top level:"
msgstr "`install(TARGETS)`_ 命令也可以在顶层接受以下选项："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:375
msgid "``EXPORT``"
msgstr "``出口``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:366
msgid ""
"This option associates the installed target files with an export called "
"``<export-name>``.  It must appear before any target options.  To actually"
" install the export file itself, call `install(EXPORT)`_, documented "
"below. See documentation of the :prop_tgt:`EXPORT_NAME` target property to"
" change the name of the exported target."
msgstr ""
"此选项将已安装的目标文件与名为“<export-name>”的导出相关联。它必须出现在任何目标选项之前。要实际安装导出文件本身，请调用 "
"`install(EXPORT)`_，如下所述。请参阅 :prop_tgt:`EXPORT_NAME` 目标属性的文档以更改导出目标的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:372
msgid ""
"If ``EXPORT`` is used and the targets include ``PUBLIC`` or ``INTERFACE`` "
"file sets, all of them must be specified with ``FILE_SET`` arguments. All "
"``PUBLIC`` or ``INTERFACE`` file sets associated with a target are "
"included in the export."
msgstr ""
"如果使用 EXPORT 并且目标包括 PUBLIC 或 INTERFACE 文件集，则所有这些都必须使用 FILE_SET "
"参数指定。与目标关联的所有“PUBLIC”或“INTERFACE”文件集都包含在导出中。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:382
msgid "``INCLUDES DESTINATION``"
msgstr "``包括目的地``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:378
msgid ""
"This option specifies a list of directories which will be added to the "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` target property of the "
"``<targets>`` when exported by the `install(EXPORT)`_ command. If a "
"relative path is specified, it is treated as relative to the "
":genex:`$<INSTALL_PREFIX>`."
msgstr ""
"此选项指定一个目录列表，当通过 `install(EXPORT)`_ 命令导出时，这些目录将被添加到 ``<targets>`` 的 "
"INTERFACE_INCLUDE_DIRECTORIES 目标属性中。如果指定了相对路径，它将被视为相对于 "
":genex:`$<INSTALL_PREFIX>`。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:393
msgid "``RUNTIME_DEPENDENCY_SET``"
msgstr "``RUNTIME_DEPENDENCY_SET``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:387
msgid ""
"This option causes all runtime dependencies of installed executable, "
"shared library, and module targets to be added to the specified runtime "
"dependency set. This set can then be installed with an "
"`install(RUNTIME_DEPENDENCY_SET)`_ command."
msgstr ""
"此选项会导致将已安装的可执行文件、共享库和模块目标的所有运行时依赖项添加到指定的运行时依赖项集中。然后可以使用 "
"`install(RUNTIME_DEPENDENCY_SET)`_ 命令安装这个集合。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:392
msgid ""
"This keyword and the ``RUNTIME_DEPENDENCIES`` keyword are mutually "
"exclusive."
msgstr "这个关键字和``RUNTIME_DEPENDENCIES`` 关键字是互斥的。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:425
msgid "``RUNTIME_DEPENDENCIES``"
msgstr "``RUNTIME_DEPENDENCIES``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:398
msgid ""
"This option causes all runtime dependencies of installed executable, "
"shared library, and module targets to be installed along with the targets "
"themselves. The ``RUNTIME``, ``LIBRARY``, ``FRAMEWORK``, and generic "
"arguments are used to determine the properties (``DESTINATION``, "
"``COMPONENT``, etc.) of the installation of these dependencies."
msgstr ""
"此选项会导致已安装的可执行文件、共享库和模块目标的所有运行时依赖项与目标本身一起安装。 "
"``RUNTIME``、``LIBRARY``、``FRAMEWORK`` "
"和通用参数用于确定这些依赖项安装的属性（``DESTINATION``、``COMPONENT`` 等） ."

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:404
msgid ""
"``RUNTIME_DEPENDENCIES`` is semantically equivalent to the following pair "
"of calls:"
msgstr "``RUNTIME_DEPENDENCIES`` 在语义上等同于以下一对调用："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:412
msgid ""
"where ``<set-name>`` will be a randomly generated set name. The "
"``args...`` may include any of the following keywords supported by the "
"`install(RUNTIME_DEPENDENCY_SET)`_ command:"
msgstr ""
"其中 ``<set-name>`` 将是随机生成的集合名称。 ``args...`` 可能包括以下任何受 "
"`install(RUNTIME_DEPENDENCY_SET)` 命令支持的关键字："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:416
msgid "``DIRECTORIES``"
msgstr "``目录``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:417
msgid "``PRE_INCLUDE_REGEXES``"
msgstr "``PRE_INCLUDE_REGEXES``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:418
msgid "``PRE_EXCLUDE_REGEXES``"
msgstr "``PRE_EXCLUDE_REGEXES``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:419
msgid "``POST_INCLUDE_REGEXES``"
msgstr "``POST_INCLUDE_REGEXES``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:420
msgid "``POST_EXCLUDE_REGEXES``"
msgstr "``POST_EXCLUDE_REGEXES``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:421
msgid "``POST_INCLUDE_FILES``"
msgstr "``POST_INCLUDE_FILES``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:422
msgid "``POST_EXCLUDE_FILES``"
msgstr "``POST_EXCLUDE_FILES``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:424
msgid ""
"The ``RUNTIME_DEPENDENCIES`` and ``RUNTIME_DEPENDENCY_SET`` keywords are "
"mutually exclusive."
msgstr "``RUNTIME_DEPENDENCIES`` 和 ``RUNTIME_DEPENDENCY_SET`` 关键字是互斥的。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:427
msgid ""
"One or more groups of properties may be specified in a single call to the "
"``TARGETS`` form of this command.  A target may be installed more than "
"once to different locations.  Consider hypothetical targets ``myExe``, "
"``mySharedLib``, and ``myStaticLib``.  The code:"
msgstr ""
"可以在对该命令的“TARGETS”形式的单个调用中指定一组或多组属性。目标可以多次安装到不同位置。考虑假设目标“myExe”、“mySharedLib”和“myStaticLib”。代码："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:440
msgid ""
"will install ``myExe`` to ``<prefix>/bin`` and ``myStaticLib`` to "
"``<prefix>/lib/static``.  On non-DLL platforms ``mySharedLib`` will be "
"installed to ``<prefix>/lib`` and ``/some/full/path``.  On DLL platforms "
"the ``mySharedLib`` DLL will be installed to ``<prefix>/bin`` and "
"``/some/full/path`` and its import library will be installed to "
"``<prefix>/lib/static`` and ``/some/full/path``."
msgstr ""
"将安装 ``myExe`` 到 ``<prefix>/bin`` 和 ``myStaticLib`` 到 "
"``<prefix>/lib/static``。在非 DLL 平台上，``mySharedLib`` 将安装到 ``<prefix>/lib`` 和"
" ``/some/full/path``。在 DLL 平台上，``mySharedLib`` DLL 将安装到``<prefix>/bin`` "
"和``/some/full/path``，它的导入库将安装到``<prefix>/lib/ static`` 和 "
"``/some/full/path``。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:447
msgid ""
":ref:`Interface Libraries` may be listed among the targets to install. "
"They install no artifacts but will be included in an associated "
"``EXPORT``. If :ref:`Object Libraries` are listed but given no destination"
" for their object files, they will be exported as :ref:`Interface "
"Libraries`. This is sufficient to satisfy transitive usage requirements of"
" other targets that link to the object libraries in their implementation."
msgstr ""
":ref:`Interface Libraries` 可能会列在要安装的目标中。它们不安装任何工件，但将包含在关联的“EXPORT”中。如果列出了 "
":ref:`Object Libraries` 但没有为其目标文件指定目的地，它们将被导出为 :ref:`Interface "
"Libraries`。这足以满足在其实现中链接到对象库的其他目标的传递使用要求。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:454
msgid ""
"Installing a target with the :prop_tgt:`EXCLUDE_FROM_ALL` target property "
"set to ``TRUE`` has undefined behavior."
msgstr "安装 :prop_tgt:`EXCLUDE_FROM_ALL` 目标属性设置为 ``TRUE`` 的目标具有未定义的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:457
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:603
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:742
msgid ""
"An install destination given as a ``DESTINATION`` argument may use "
"\"generator expressions\" with the syntax ``$<...>``.  See the "
":manual:`cmake-generator-expressions(7)` manual for available expressions."
msgstr ""
"作为 ``DESTINATION`` 参数给出的安装目的地可以使用语法为 ``$<...>`` 的“生成器表达式”。请参阅 "
":manual:`cmake-generator-expressions(7)` 手册了解可用的表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:462
msgid ""
"`install(TARGETS)`_ can install targets that were created in other "
"directories.  When using such cross-directory install rules, running "
"``make install`` (or similar) from a subdirectory will not guarantee that "
"targets from other directories are up-to-date.  You can use "
":command:`target_link_libraries` or :command:`add_dependencies` to ensure "
"that such out-of-directory targets are built before the subdirectory-"
"specific install rules are run."
msgstr ""
"`install(TARGETS)`_ 可以安装在其他目录中创建的目标。当使用这样的跨目录安装规则时，从子目录运行``make "
"install``（或类似的）将不能保证来自其他目录的目标是最新的。您可以使用 :command:`target_link_libraries` 或"
" :command:`add_dependencies` 来确保在运行特定于子目录的安装规则之前构建此类目录外目标。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:472
msgid "Installing Imported Runtime Artifacts"
msgstr "安装导入的运行时工件"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:492
msgid ""
"The ``IMPORTED_RUNTIME_ARTIFACTS`` form specifies rules for installing the"
" runtime artifacts of imported targets. Projects may do this if they want "
"to bundle outside executables or modules inside their installation. The "
"``LIBRARY``, ``RUNTIME``, ``FRAMEWORK``, and ``BUNDLE`` arguments have the"
" same semantics that they do in the `TARGETS`_ mode. Only the runtime "
"artifacts of imported targets are installed (except in the case of "
":prop_tgt:`FRAMEWORK` libraries, :prop_tgt:`MACOSX_BUNDLE` executables, "
"and :prop_tgt:`BUNDLE` CFBundles.) For example, headers and import "
"libraries associated with DLLs are not installed. In the case of "
":prop_tgt:`FRAMEWORK` libraries, :prop_tgt:`MACOSX_BUNDLE` executables, "
"and :prop_tgt:`BUNDLE` CFBundles, the entire directory is installed."
msgstr ""
"``IMPORTED_RUNTIME_ARTIFACTS`` "
"形式指定了安装导入目标的运行时工件的规则。如果项目想要在其安装中捆绑外部可执行文件或模块，则可以这样做。 "
"``LIBRARY``、``RUNTIME``、``FRAMEWORK`` 和 ``BUNDLE`` 参数与它们在 `TARGETS`_ "
"模式下的语义相同。仅安装导入目标的运行时工件（除了 :prop_tgt:`FRAMEWORK` "
"库、 :prop_tgt:`MACOSX_BUNDLE` 可执行文件和 :prop_tgt:`BUNDLE` CFBundles。）例如，与未安装 "
"DLL。对于 :prop_tgt:`FRAMEWORK` 库、 :prop_tgt:`MACOSX_BUNDLE` 可执行文件和 "
":prop_tgt:`BUNDLE` CFBundles，将安装整个目录。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:504
msgid ""
"The ``RUNTIME_DEPENDENCY_SET`` option causes the runtime artifacts of the "
"imported executable, shared library, and module library ``targets`` to be "
"added to the ``<set-name>`` runtime dependency set. This set can then be "
"installed with an `install(RUNTIME_DEPENDENCY_SET)`_ command."
msgstr ""
"``RUNTIME_DEPENDENCY_SET`` 选项导致导入的可执行文件、共享库和模块库``targets`` "
"的运行时工件被添加到``<set-name>`` 运行时依赖集。然后可以使用 `install(RUNTIME_DEPENDENCY_SET)`_ "
"命令安装这个集合。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:510
msgid "Installing Files"
msgstr "安装文件"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:519
msgid ""
"If installing header files, consider using file sets defined by "
":command:`target_sources(FILE_SET)` instead. File sets associate headers "
"with a target and they install as part of the target."
msgstr ""
"如果安装头文件，请考虑使用由 :command:`target_sources(FILE_SET)` "
"定义的文件集。文件集将标头与目标相关联，并且它们作为目标的一部分安装。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:532
msgid ""
"The ``FILES`` form specifies rules for installing files for a project. "
"File names given as relative paths are interpreted with respect to the "
"current source directory.  Files installed by this form are by default "
"given permissions ``OWNER_WRITE``, ``OWNER_READ``, ``GROUP_READ``, and "
"``WORLD_READ`` if no ``PERMISSIONS`` argument is given."
msgstr ""
"``FILES`` 形式指定了为项目安装文件的规则。作为相对路径给出的文件名根据当前源目录进行解释。如果没有给出 ``PERMISSIONS`` "
"参数，则默认情况下，通过这种形式安装的文件被授予权限 ``OWNER_WRITE``、``OWNER_READ``、``GROUP_READ`` 和"
" ``WORLD_READ``。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:538
msgid ""
"The ``PROGRAMS`` form is identical to the ``FILES`` form except that the "
"default permissions for the installed file also include ``OWNER_EXECUTE``,"
" ``GROUP_EXECUTE``, and ``WORLD_EXECUTE``.  This form is intended to "
"install programs that are not targets, such as shell scripts.  Use the "
"``TARGETS`` form to install targets built within the project."
msgstr ""
"``PROGRAMS`` 形式与 ``FILES`` 形式相同，只是安装文件的默认权限还包括 "
"``OWNER_EXECUTE``、``GROUP_EXECUTE`` 和 ``WORLD_EXECUTE``。这种形式旨在安装不是目标的程序，例如"
" shell 脚本。使用``TARGETS`` 形式安装项目中构建的目标。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:544
msgid ""
"The list of ``files...`` given to ``FILES`` or ``PROGRAMS`` may use "
"\"generator expressions\" with the syntax ``$<...>``.  See the "
":manual:`cmake-generator-expressions(7)` manual for available expressions."
" However, if any item begins in a generator expression it must evaluate to"
" a full path."
msgstr ""
"给 ``FILES`` 或 ``PROGRAMS`` 的 ``files...`` 列表可以使用语法为 ``$<...>`` "
"的“生成器表达式”。请参阅 :manual:`cmake-generator-expressions(7)` "
"手册了解可用的表达式。但是，如果任何项目以生成器表达式开头，则它必须评估为完整路径。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:550
msgid ""
"Either a ``TYPE`` or a ``DESTINATION`` must be provided, but not both. A "
"``TYPE`` argument specifies the generic file type of the files being "
"installed.  A destination will then be set automatically by taking the "
"corresponding variable from :module:`GNUInstallDirs`, or by using a built-"
"in default if that variable is not defined.  See the table below for the "
"supported file types and their corresponding variables and built-in "
"defaults.  Projects can provide a ``DESTINATION`` argument instead of a "
"file type if they wish to explicitly define the install destination."
msgstr ""
"必须提供 ``TYPE`` 或 ``DESTINATION``，但不能同时提供两者。 ``TYPE`` "
"参数指定正在安装的文件的通用文件类型。然后将通过从 GNUInstallDirs "
"中获取相应的变量来自动设置目的地，或者如果未定义该变量，则使用内置默认值。有关支持的文件类型及其对应的变量和内置默认值，请参见下表。如果项目希望显式定义安装目标，则项目可以提供一个``DESTINATION``"
" 参数而不是文件类型。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:560
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:713
msgid "``TYPE`` Argument"
msgstr "``TYPE`` 参数"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:562
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:715
msgid "``BIN``"
msgstr "``BIN``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:563
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:716
msgid "``SBIN``"
msgstr "``SBIN``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:563
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:716
msgid "``${CMAKE_INSTALL_SBINDIR}``"
msgstr "``${CMAKE_INSTALL_SBINDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:563
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:716
msgid "``sbin``"
msgstr "``sbin``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:564
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:717
msgid "``LIB``"
msgstr "``库``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:565
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:718
msgid "``INCLUDE``"
msgstr "``包括``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:566
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:719
msgid "``SYSCONF``"
msgstr "``SYSCONF``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:566
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:719
msgid "``${CMAKE_INSTALL_SYSCONFDIR}``"
msgstr "``${CMAKE_INSTALL_SYSCONFDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:566
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:719
msgid "``etc``"
msgstr "``等``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:567
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:720
msgid "``SHAREDSTATE``"
msgstr "``共享状态``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:567
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:720
msgid "``${CMAKE_INSTALL_SHARESTATEDIR}``"
msgstr "``${CMAKE_INSTALL_SHARESTATEDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:567
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:720
msgid "``com``"
msgstr "``com``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:568
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:721
msgid "``LOCALSTATE``"
msgstr "``本地状态``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:568
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:721
msgid "``${CMAKE_INSTALL_LOCALSTATEDIR}``"
msgstr "``${CMAKE_INSTALL_LOCALSTATEDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:568
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:721
msgid "``var``"
msgstr "``变量``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:569
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:722
msgid "``RUNSTATE``"
msgstr "``运行状态``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:569
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:722
msgid "``${CMAKE_INSTALL_RUNSTATEDIR}``"
msgstr "``${CMAKE_INSTALL_RUNSTATEDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:569
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:722
msgid "``<LOCALSTATE dir>/run``"
msgstr "``<本地目录>/运行``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:570
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:723
msgid "``DATA``"
msgstr "``数据``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:570
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:723
msgid "``${CMAKE_INSTALL_DATADIR}``"
msgstr "``${CMAKE_INSTALL_DATADIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:570
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:723
msgid "``<DATAROOT dir>``"
msgstr "``<DATAROOT 目录>``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:571
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:724
msgid "``INFO``"
msgstr "``信息``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:571
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:724
msgid "``${CMAKE_INSTALL_INFODIR}``"
msgstr "``${CMAKE_INSTALL_INFODIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:571
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:724
msgid "``<DATAROOT dir>/info``"
msgstr "``<DATAROOT 目录>/info``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:572
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:725
msgid "``LOCALE``"
msgstr "``语言环境``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:572
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:725
msgid "``${CMAKE_INSTALL_LOCALEDIR}``"
msgstr "``${CMAKE_INSTALL_LOCALEDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:572
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:725
msgid "``<DATAROOT dir>/locale``"
msgstr "``<DATAROOT 目录>/locale``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:573
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:726
msgid "``MAN``"
msgstr "``男人``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:573
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:726
msgid "``${CMAKE_INSTALL_MANDIR}``"
msgstr "``${CMAKE_INSTALL_MANDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:573
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:726
msgid "``<DATAROOT dir>/man``"
msgstr "``<DATAROOT 目录>/man``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:574
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:727
msgid "``${CMAKE_INSTALL_DOCDIR}``"
msgstr "``${CMAKE_INSTALL_DOCDIR}``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:574
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:727
msgid "``<DATAROOT dir>/doc``"
msgstr "``<DATAROOT 目录>/doc``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:577
msgid ""
"Projects wishing to follow the common practice of installing headers into "
"a project-specific subdirectory will need to provide a destination rather "
"than rely on the above. Using file sets for headers instead of "
"``install(FILES)`` would be even better (see "
":command:`target_sources(FILE_SET)`)."
msgstr ""
"希望遵循将标头安装到项目特定子目录中的常见做法的项目将需要提供目的地而不是依赖上述内容。使用文件集作为标头而不是``install(FILES)``"
" 会更好（参见 :command:`target_sources(FILE_SET)`）。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:582
#: ../../cmake-prefix/src/cmake/Help/command/install.rst:730
msgid ""
"Note that some of the types' built-in defaults use the ``DATAROOT`` "
"directory as a prefix. The ``DATAROOT`` prefix is calculated similarly to "
"the types, with ``CMAKE_INSTALL_DATAROOTDIR`` as the variable and "
"``share`` as the built-in default. You cannot use ``DATAROOT`` as a "
"``TYPE`` parameter; please use ``DATA`` instead."
msgstr ""
"请注意，某些类型的内置默认值使用 ``DATAROOT`` 目录作为前缀。 ``DATAROOT`` "
"前缀的计算类似于类型，``CMAKE_INSTALL_DATAROOTDIR`` 作为变量，``share`` 作为内置默认值。你不能使用 "
"``DATAROOT`` 作为 ``TYPE`` 参数；请改用``DATA``。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:588
msgid ""
"To make packages compliant with distribution filesystem layout policies, "
"if projects must specify a ``DESTINATION``, it is recommended that they "
"use a path that begins with the appropriate :module:`GNUInstallDirs` "
"variable. This allows package maintainers to control the install "
"destination by setting the appropriate cache variables.  The following "
"example shows how to follow this advice while installing an image to a "
"project-specific documentation subdirectory:"
msgstr ""
"为了使包符合分发文件系统布局策略，如果项目必须指定一个``DESTINATION``，建议他们使用以适当的 GNUInstallDirs "
"变量开头的路径。这允许包维护者通过设置适当的缓存变量来控制安装目的地。以下示例显示了在将图像安装到特定于项目的文档子目录时如何遵循此建议："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:608
msgid ""
"An install rename given as a ``RENAME`` argument may use \"generator "
"expressions\" with the syntax ``$<...>``.  See the :manual:`cmake-"
"generator-expressions(7)` manual for available expressions."
msgstr ""
"作为 ``RENAME`` 参数给出的安装重命名可以使用语法为 ``$<...>`` 的“生成器表达式”。请参阅 :manual:`cmake-"
"generator-expressions(7)` 手册了解可用的表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:614
msgid "Installing Directories"
msgstr "安装目录"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:621
msgid ""
"To install a directory sub-tree of headers, consider using file sets "
"defined by :command:`target_sources(FILE_SET)` instead. File sets not only"
" preserve directory structure, they also associate headers with a target "
"and install as part of the target."
msgstr ""
"要安装标头的目录子树，请考虑使用由 :command:`target_sources(FILE_SET)` "
"定义的文件集。文件集不仅保留目录结构，它们还将标头与目标相关联并作为目标的一部分进行安装。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:639
msgid ""
"The ``DIRECTORY`` form installs contents of one or more directories to a "
"given destination.  The directory structure is copied verbatim to the "
"destination.  The last component of each directory name is appended to the"
" destination directory but a trailing slash may be used to avoid this "
"because it leaves the last component empty.  Directory names given as "
"relative paths are interpreted with respect to the current source "
"directory.  If no input directory names are given the destination "
"directory will be created but nothing will be installed into it.  The "
"``FILE_PERMISSIONS`` and ``DIRECTORY_PERMISSIONS`` options specify "
"permissions given to files and directories in the destination. If "
"``USE_SOURCE_PERMISSIONS`` is specified and ``FILE_PERMISSIONS`` is not, "
"file permissions will be copied from the source directory structure. If no"
" permissions are specified files will be given the default permissions "
"specified in the ``FILES`` form of the command, and the directories will "
"be given the default permissions specified in the ``PROGRAMS`` form of the"
" command."
msgstr ""
"``DIRECTORY`` "
"形式将一个或多个目录的内容安装到给定的目的地。目录结构被逐字复制到目的地。每个目录名称的最后一个组成部分附加到目标目录，但可以使用尾部斜杠来避免这种情况，因为它使最后一个组成部分为空。作为相对路径给出的目录名称根据当前源目录进行解释。如果没有给出输入目录名称，将创建目标目录，但不会将任何内容安装到其中。"
" ``FILE_PERMISSIONS`` 和 ``DIRECTORY_PERMISSIONS`` 选项指定给予目标中的文件和目录的权限。如果指定了"
" ``USE_SOURCE_PERMISSIONS`` 而未指定 "
"``FILE_PERMISSIONS``，文件权限将从源目录结构中复制。如果没有指定权限，文件将被赋予命令的 ``FILES`` "
"形式中指定的默认权限，目录将被赋予命令的 ``PROGRAMS`` 形式中指定的默认权限。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:656
msgid ""
"The ``MESSAGE_NEVER`` option disables file installation status output."
msgstr "``MESSAGE_NEVER`` 选项禁用文件安装状态输出。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:659
msgid ""
"Installation of directories may be controlled with fine granularity using "
"the ``PATTERN`` or ``REGEX`` options.  These \"match\" options specify a "
"globbing pattern or regular expression to match directories or files "
"encountered within input directories.  They may be used to apply certain "
"options (see below) to a subset of the files and directories encountered."
"  The full path to each input file or directory (with forward slashes) is "
"matched against the expression.  A ``PATTERN`` will match only complete "
"file names: the portion of the full path matching the pattern must occur "
"at the end of the file name and be preceded by a slash.  A ``REGEX`` will "
"match any portion of the full path but it may use ``/`` and ``$`` to "
"simulate the ``PATTERN`` behavior.  By default all files and directories "
"are installed whether or not they are matched. The ``FILES_MATCHING`` "
"option may be given before the first match option to disable installation "
"of files (but not directories) not matched by any expression.  For "
"example, the code"
msgstr ""
"可以使用“PATTERN”或“REGEX”选项以精细的粒度控制目录的安装。这些“匹配”选项指定通配模式或正则表达式以匹配输入目录中遇到的目录或文件。它们可用于将某些选项（见下文）应用于遇到的文件和目录的子集。每个输入文件或目录（带正斜杠）的完整路径与表达式匹配。"
" ``PATTERN`` 将只匹配完整的文件名：与模式匹配的完整路径部分必须出现在文件名的末尾，并且前面有一个斜杠。 ``REGEX`` "
"将匹配完整路径的任何部分，但它可以使用 ``/`` 和 ``$`` 来模拟 ``PATTERN`` "
"行为。默认情况下，安装所有文件和目录，无论它们是否匹配。 ``FILES_MATCHING`` "
"选项可以在第一个匹配选项之前给出，以禁用与任何表达式都不匹配的文件（但不是目录）的安装。例如，代码"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:680
msgid "will extract and install images from a source tree."
msgstr "将从源代码树中提取并安装图像。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:682
msgid ""
"Some options may follow a ``PATTERN`` or ``REGEX`` expression as described"
" under :ref:`string(REGEX) <Regex Specification>` and are applied only to "
"files or directories matching them.  The ``EXCLUDE`` option will skip the "
"matched file or directory.  The ``PERMISSIONS`` option overrides the "
"permissions setting for the matched file or directory.  For example the "
"code"
msgstr ""
"某些选项可能遵循 ``PATTERN`` 或 ``REGEX`` 表达式，如 :ref:`string(REGEX) <Regex "
"Specification>` 中所述，并且仅应用于匹配它们的文件或目录。 ``EXCLUDE`` 选项将跳过匹配的文件或目录。 "
"``PERMISSIONS`` 选项覆盖匹配文件或目录的权限设置。例如代码"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:697
msgid ""
"will install the ``icons`` directory to ``share/myproj/icons`` and the "
"``scripts`` directory to ``share/myproj``.  The icons will get default "
"file permissions, the scripts will be given specific permissions, and any "
"``CVS`` directories will be excluded."
msgstr ""
"会将``icons`` 目录安装到``share/myproj/icons`` 并将``scripts`` "
"目录安装到``share/myproj``。图标将获得默认文件权限，脚本将获得特定权限，并且将排除任何“CVS”目录。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:702
msgid ""
"Either a ``TYPE`` or a ``DESTINATION`` must be provided, but not both. A "
"``TYPE`` argument specifies the generic file type of the files within the "
"listed directories being installed.  A destination will then be set "
"automatically by taking the corresponding variable from "
":module:`GNUInstallDirs`, or by using a built-in default if that variable "
"is not defined.  See the table below for the supported file types and "
"their corresponding variables and built-in defaults.  Projects can provide"
" a ``DESTINATION`` argument instead of a file type if they wish to "
"explicitly define the install destination."
msgstr ""
"必须提供 ``TYPE`` 或 ``DESTINATION``，但不能同时提供两者。 ``TYPE`` "
"参数指定正在安装的列出目录中文件的通用文件类型。然后将通过从 GNUInstallDirs "
"中获取相应的变量来自动设置目的地，或者如果未定义该变量，则使用内置默认值。有关支持的文件类型及其对应的变量和内置默认值，请参见下表。如果项目希望显式定义安装目标，则项目可以提供一个``DESTINATION``"
" 参数而不是文件类型。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:736
msgid ""
"To make packages compliant with distribution filesystem layout policies, "
"if projects must specify a ``DESTINATION``, it is recommended that they "
"use a path that begins with the appropriate :module:`GNUInstallDirs` "
"variable. This allows package maintainers to control the install "
"destination by setting the appropriate cache variables."
msgstr ""
"为了使包符合分发文件系统布局策略，如果项目必须指定一个``DESTINATION``，建议他们使用以适当的 GNUInstallDirs "
"变量开头的路径。这允许包维护者通过设置适当的缓存变量来控制安装目的地。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:747
msgid ""
"The list of ``dirs...`` given to ``DIRECTORY`` may use \"generator "
"expressions\" too."
msgstr "给 ``DIRECTORY`` 的 ``dirs...`` 列表也可以使用“生成器表达式”。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:752
msgid "Custom Installation Logic"
msgstr "自定义安装逻辑"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:765
msgid ""
"The ``SCRIPT`` form will invoke the given CMake script files during "
"installation.  If the script file name is a relative path it will be "
"interpreted with respect to the current source directory.  The ``CODE`` "
"form will invoke the given CMake code during installation.  Code is "
"specified as a single argument inside a double-quoted string.  For "
"example, the code"
msgstr ""
"``SCRIPT`` 形式将在安装期间调用给定的 CMake 脚本文件。如果脚本文件名是相对路径，它将相对于当前源目录进行解释。 ``CODE`` "
"形式将在安装期间调用给定的 CMake 代码。代码被指定为双引号字符串中的单个参数。例如，代码"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:776
msgid "will print a message during installation."
msgstr "将在安装过程中打印一条消息。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:778
msgid ""
"When the ``ALL_COMPONENTS`` option is given, the custom installation "
"script code will be executed for every component of a component-specific "
"installation.  This option is mutually exclusive with the ``COMPONENT`` "
"option."
msgstr ""
"当给出 ``ALL_COMPONENTS`` 选项时，将为特定组件安装的每个组件执行自定义安装脚本代码。此选项与 ``COMPONENT`` "
"选项互斥。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:784
msgid ""
"``<file>`` or ``<code>`` may use \"generator expressions\" with the syntax"
" ``$<...>`` (in the case of ``<file>``, this refers to their use in the "
"file name, not the file's contents).  See the :manual:`cmake-generator-"
"expressions(7)` manual for available expressions."
msgstr ""
"``<file>`` 或 ``<code>`` 可以使用语法为 ``$<...>`` 的“生成器表达式”（在 ``<file>`` "
"的情况下，这是指它们在文件名中的使用，而不是文件的内容）。请参阅 :manual:`cmake-generator-expressions(7)` "
"手册了解可用的表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:791
msgid "Installing Exports"
msgstr "安装出口"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:808
msgid ""
"The ``EXPORT`` form generates and installs a CMake file containing code to"
" import targets from the installation tree into another project. Target "
"installations are associated with the export ``<export-name>`` using the "
"``EXPORT`` option of the `install(TARGETS)`_ signature documented above.  "
"The ``NAMESPACE`` option will prepend ``<namespace>`` to the target names "
"as they are written to the import file.  By default the generated file "
"will be called ``<export-name>.cmake`` but the ``FILE`` option may be used"
" to specify a different name.  The value given to the ``FILE`` option must"
" be a file name with the ``.cmake`` extension. If a ``CONFIGURATIONS`` "
"option is given then the file will only be installed when one of the named"
" configurations is installed.  Additionally, the generated import file "
"will reference only the matching target configurations.  The "
"``EXPORT_LINK_INTERFACE_LIBRARIES`` keyword, if present, causes the "
"contents of the properties matching "
"``(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?`` to be exported, when "
"policy :policy:`CMP0022` is ``NEW``."
msgstr ""
"``EXPORT`` 形式生成并安装一个 CMake 文件，其中包含将目标从安装树导入另一个项目的代码。使用上面记录的 "
"`install(TARGETS)`_ 签名的 ``EXPORT`` 选项，目标安装与导出 ``<export-name>`` 相关联。 "
"``NAMESPACE`` 选项将在将目标名称写入导入文件时将 ``<namespace>`` 添加到目标名称之前。默认情况下，生成的文件将被称为 "
"``<export-name>.cmake`` 但可以使用 ``FILE`` 选项指定不同的名称。赋予 ``FILE`` 选项的值必须是带有 "
"``.cmake`` 扩展名的文件名。如果给出了 ``CONFIGURATIONS`` "
"选项，那么只有在安装了指定配置之一时才会安装该文件。此外，生成的导入文件将仅引用匹配的目标配置。 "
"``EXPORT_LINK_INTERFACE_LIBRARIES`` "
"关键字（如果存在）会导致匹配``(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?`` "
"的属性的内容被导出，当策略:policy:`CMP0022` 为``NEW ``。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:826
msgid ""
"The installed ``<export-name>.cmake`` file may come with additional per-"
"configuration ``<export-name>-*.cmake`` files to be loaded by globbing.  "
"Do not use an export name that is the same as the package name in "
"combination with installing a ``<package-name>-config.cmake`` file or the "
"latter may be incorrectly matched by the glob and loaded."
msgstr ""
"安装的``<export-name>.cmake`` 文件可能会附带额外的每个配置``<export-name>-*.cmake`` "
"文件以通过通配加载。不要将与包名称相同的导出名称与安装“<package-name>-config.cmake”文件结合使用，否则后者可能会被 "
"glob 错误匹配并加载。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:832
msgid ""
"When a ``COMPONENT`` option is given, the listed ``<component>`` "
"implicitly depends on all components mentioned in the export set. The "
"exported ``<name>.cmake`` file will require each of the exported "
"components to be present in order for dependent projects to build "
"properly. For example, a project may define components ``Runtime`` and "
"``Development``, with shared libraries going into the ``Runtime`` "
"component and static libraries and headers going into the ``Development`` "
"component. The export set would also typically be part of the "
"``Development`` component, but it would export targets from both the "
"``Runtime`` and ``Development`` components. Therefore, the ``Runtime`` "
"component would need to be installed if the ``Development`` component was "
"installed, but not vice versa. If the ``Development`` component was "
"installed without the ``Runtime`` component, dependent projects that try "
"to link against it would have build errors. Package managers, such as APT "
"and RPM, typically handle this by listing the ``Runtime`` component as a "
"dependency of the ``Development`` component in the package metadata, "
"ensuring that the library is always installed if the headers and CMake "
"export file are present."
msgstr ""
"当给出 ``COMPONENT`` 选项时，列出的 ``<component>`` 隐式依赖于导出集中提到的所有组件。导出的 "
"``<name>.cmake`` "
"文件将要求每个导出的组件都存在，以便正确构建依赖项目。例如，一个项目可以定义组件“Runtime”和“Development”，共享库进入“Runtime”组件，静态库和头文件进入“Development”组件。导出集通常也是“开发”组件的一部分，但它会从“运行时”和“开发”组件中导出目标。因此，如果安装了"
" ``Development`` 组件，则需要安装 ``Runtime`` "
"组件，反之则不需要。如果在没有安装“运行时”组件的情况下安装了“开发”组件，则尝试链接它的依赖项目将出现构建错误。包管理器，例如 APT 和 "
"RPM，通常通过将“运行时”组件列为包元数据中“开发”组件的依赖项来处理此问题，确保在标头和 CMake 导出时始终安装库文件存在。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:849
msgid ""
"In addition to cmake language files, the ``EXPORT_ANDROID_MK`` mode may be"
" used to specify an export to the android ndk build system.  This mode "
"accepts the same options as the normal export mode.  The Android NDK "
"supports the use of prebuilt libraries, both static and shared. This "
"allows cmake to build the libraries of a project and make them available "
"to an ndk build system complete with transitive dependencies, include "
"flags and defines required to use the libraries."
msgstr ""
"除了 cmake 语言文件，``EXPORT_ANDROID_MK`` 模式可用于指定导出到 android ndk "
"构建系统。此模式接受与正常导出模式相同的选项。 Android NDK 支持使用预建库，包括静态库和共享库。这允许 cmake "
"构建项目的库，并使它们可用于具有传递依赖性的 ndk 构建系统，包括使用库所需的标志和定义。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:858
msgid "``CXX_MODULES_DIRECTORY``"
msgstr "``CXX_MODULES_DIRECTORY``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:864
msgid ""
"Specify a subdirectory to store C++ module information for targets in the "
"export set. This directory will be populated with files which add the "
"necessary target property information to the relevant targets. Note that "
"without this information, none of the C++ modules which are part of the "
"targets in the export set will support being imported in consuming "
"targets."
msgstr ""
"指定一个子目录来存储导出集中目标的 C++ "
"模块信息。该目录将填充文件，这些文件将必要的目标属性信息添加到相关目标。请注意，如果没有此信息，作为导出集中目标的一部分的 C++ "
"模块将不支持在使​​用目标中导入。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:870
msgid ""
"The ``EXPORT`` form is useful to help outside projects use targets built "
"and installed by the current project.  For example, the code"
msgstr "``EXPORT`` 表单有助于外部项目使用当前项目构建和安装的目标。例如，代码"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:879
msgid ""
"will install the executable ``myexe`` to ``<prefix>/bin`` and code to "
"import it in the file ``<prefix>/lib/myproj/myproj.cmake`` and "
"``<prefix>/share/ndk-modules/Android.mk``.  An outside project may load "
"this file with the include command and reference the ``myexe`` executable "
"from the installation tree using the imported target name ``mp_myexe`` as "
"if the target were built in its own tree."
msgstr ""
"将可执行文件 ``myexe`` 安装到 ``<prefix>/bin`` 并将代码导入到文件 "
"``<prefix>/lib/myproj/myproj.cmake`` 和 ``<prefix>/share /ndk-"
"modules/Android.mk``。外部项目可以使用 include "
"命令加载此文件，并使用导入的目标名称“mp_myexe”从安装树中引用“myexe”可执行文件，就好像目标是在自己的树中构建的一样。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:887
msgid ""
"This command supersedes the :command:`install_targets` command and the "
":prop_tgt:`PRE_INSTALL_SCRIPT` and :prop_tgt:`POST_INSTALL_SCRIPT` target "
"properties.  It also replaces the ``FILES`` forms of the "
":command:`install_files` and :command:`install_programs` commands. The "
"processing order of these install rules relative to those generated by "
":command:`install_targets`, :command:`install_files`, and "
":command:`install_programs` commands is not defined."
msgstr ""
"此命令取代 :command:`install_targets` 命令以及 :prop_tgt:`PRE_INSTALL_SCRIPT` 和 "
":prop_tgt:`POST_INSTALL_SCRIPT` 目标属性。它还替换了 :command:`install_files` 和 "
":command:`install_programs` 命令的 ``FILES`` 形式。这些安装规则相对于 "
":command:`install_targets`、 :command:`install_files` 和 "
":command:`install_programs` 命令生成的规则的处理顺序未定义。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:897
msgid "Installing Runtime Dependencies"
msgstr "安装运行时依赖"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:924
msgid ""
"Installs a runtime dependency set previously created by one or more "
"`install(TARGETS)`_ or `install(IMPORTED_RUNTIME_ARTIFACTS)`_ commands. "
"The dependencies of targets belonging to a runtime dependency set are "
"installed in the ``RUNTIME`` destination and component on DLL platforms, "
"and in the ``LIBRARY`` destination and component on non-DLL platforms. "
"macOS frameworks are installed in the ``FRAMEWORK`` destination and "
"component. Targets built within the build tree will never be installed as "
"runtime dependencies, nor will their own dependencies, unless the targets "
"themselves are installed with `install(TARGETS)`_."
msgstr ""
"安装先前由一个或多个`install(TARGETS)`_ 或`install(IMPORTED_RUNTIME_ARTIFACTS)`_ "
"命令创建的运行时依赖集。属于运行时依赖集的目标的依赖项在 DLL 平台上安装在“RUNTIME”目标和组件中，在非 DLL "
"平台上安装在“LIBRARY”目标和组件中。 macOS "
"框架安装在“FRAMEWORK”目标和组件中。在构建树中构建的目标将永远不会作为运行时依赖项安装，它们自己的依赖项也不会安装，除非目标本身是使用 "
"`install(TARGETS)`_ 安装的。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:934
msgid ""
"The generated install script calls "
":command:`file(GET_RUNTIME_DEPENDENCIES)` on the build-tree files to "
"calculate the runtime dependencies. The build-tree executable files are "
"passed as the ``EXECUTABLES`` argument, the build-tree shared libraries as"
" the ``LIBRARIES`` argument, and the build-tree modules as the ``MODULES``"
" argument. On macOS, if one of the executables is a "
":prop_tgt:`MACOSX_BUNDLE`, that executable is passed as the "
"``BUNDLE_EXECUTABLE`` argument. At most one such bundle executable may be "
"in the runtime dependency set on macOS. The :prop_tgt:`MACOSX_BUNDLE` "
"property has no effect on other platforms. Note that "
":command:`file(GET_RUNTIME_DEPENDENCIES)` only supports collecting the "
"runtime dependencies for Windows, Linux and macOS platforms, so "
"``install(RUNTIME_DEPENDENCY_SET)`` has the same limitation."
msgstr ""
"生成的安装脚本在构建树文件上调用 :command:`file(GET_RUNTIME_DEPENDENCIES)` "
"来计算运行时依赖性。构建树可执行文件作为 EXECUTABLES 参数传递，构建树共享库作为 LIBRARIES 参数传递，构建树模块作为 "
"MODULES 参数传递。在 macOS 上，如果其中一个可执行文件是 :prop_tgt:`MACOSX_BUNDLE`，则该可执行文件将作为 "
"``BUNDLE_EXECUTABLE`` 参数传递。至多一个这样的捆绑可执行文件可能在 macOS 上的运行时依赖项集中。 "
":prop_tgt:`MACOSX_BUNDLE` "
"属性对其他平台没有影响。请注意 :command:`file(GET_RUNTIME_DEPENDENCIES)` 仅支持收集 Windows、Linux 和 "
"macOS 平台的运行时依赖项，因此 ``install(RUNTIME_DEPENDENCY_SET)`` 具有相同的限制。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:947
msgid ""
"The following sub-arguments are forwarded through as the corresponding "
"arguments to :command:`file(GET_RUNTIME_DEPENDENCIES)` (for those that "
"provide a non-empty list of directories, regular expressions or files).  "
"They all support :manual:`generator expressions <cmake-generator-"
"expressions(7)>`."
msgstr ""
"以下子参数作为相应参数转发给 "
":command:`file(GET_RUNTIME_DEPENDENCIES)`（对于那些提供非空目录、正则表达式或文件列表的子参数）。它们都支持"
" :manual:`generator expressions <cmake-generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:961
msgid "Generated Installation Script"
msgstr "生成的安装脚本"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:965
msgid ""
"Use of this feature is not recommended. Please consider using the "
":option:`cmake --install` instead."
msgstr "不建议使用此功能。请考虑改用 :option:`cmake --install`。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:968
msgid ""
"The ``install()`` command generates a file, ``cmake_install.cmake``, "
"inside the build directory, which is used internally by the generated "
"install target and by CPack. You can also invoke this script manually with"
" :option:`cmake -P`. This script accepts several variables:"
msgstr ""
"``install()`` 命令在构建目录中生成一个文件 ``cmake_install.cmake``，生成的安装目标和 CPack "
"在内部使用该文件。您也可以使用 :option:`cmake -P` 手动调用此脚本。该脚本接受几个变量："

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:974
msgid ""
"Set this variable to install only a single CPack component as opposed to "
"all of them. For example, if you only want to install the ``Development`` "
"component, run ``cmake -DCOMPONENT=Development -P cmake_install.cmake``."
msgstr ""
"设置此变量以仅安装一个 CPack 组件，而不是安装所有组件。例如，如果您只想安装“开发”组件，请运行“cmake "
"-DCOMPONENT=Development -P cmake_install.cmake”。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:981
msgid "``BUILD_TYPE``"
msgstr "``BUILD_TYPE``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:979
msgid ""
"Set this variable to change the build type if you are using a multi-config"
" generator. For example, to install with the ``Debug`` configuration, run "
"``cmake -DBUILD_TYPE=Debug -P cmake_install.cmake``."
msgstr ""
"如果您使用的是多配置生成器，请设置此变量以更改构建类型。例如，要使用“Debug”配置进行安装，请运行“cmake "
"-DBUILD_TYPE=Debug -P cmake_install.cmake”。"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:985
msgid "``DESTDIR``"
msgstr "``DESTDIR``"

#: ../../cmake-prefix/src/cmake/Help/command/install.rst:984
msgid ""
"This is an environment variable rather than a CMake variable. It allows "
"you to change the installation prefix on UNIX systems. See "
":envvar:`DESTDIR` for details."
msgstr ""
"这是一个环境变量而不是 CMake 变量。它允许您更改 UNIX 系统上的安装前缀。有关详细信息，请参见:envvar:`DESTDIR`。"

#: ../../cmake-prefix/src/cmake/Help/command/install_files.rst:2
msgid "install_files"
msgstr "安装文件"

#: ../../cmake-prefix/src/cmake/Help/command/install_files.rst:6
msgid "Use the :command:`install(FILES)` command instead."
msgstr "请改用 :command:`install(FILES)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/install_files.rst:8
msgid ""
"This command has been superseded by the :command:`install` command.  It is"
" provided for compatibility with older CMake code.  The ``FILES`` form is "
"directly replaced by the ``FILES`` form of the :command:`install` command."
"  The regexp form can be expressed more clearly using the ``GLOB`` form of"
" the :command:`file` command."
msgstr ""
"此命令已被 :command:`install` 命令取代。提供它是为了与旧的 CMake 代码兼容。 ``FILES`` 形式直接替换为 "
":command:`install` 命令的 ``FILES`` 形式。使用 :command:`file` 命令的 ``GLOB`` "
"形式可以更清楚地表达正则表达式形式。"

#: ../../cmake-prefix/src/cmake/Help/command/install_files.rst:18
msgid ""
"Create rules to install the listed files with the given extension into the"
" given directory.  Only files existing in the current source tree or its "
"corresponding location in the binary tree may be listed.  If a file "
"specified already has an extension, that extension will be removed first."
"  This is useful for providing lists of source files such as foo.cxx when "
"you want the corresponding foo.h to be installed. A typical extension is "
"``.h``."
msgstr ""
"创建规则以将具有给定扩展名的列出文件安装到给定目录中。只能列出存在于当前源代码树或其在二叉树中相应位置的文件。如果指定的文件已经有扩展名，则该扩展名将首先被删除。当您想要安装相应的"
" foo.h 时，这对于提供源文件列表（例如 foo.cxx）很有用。典型的扩展名是 ``.h``。"

#: ../../cmake-prefix/src/cmake/Help/command/install_files.rst:30
msgid ""
"Any files in the current source directory that match the regular "
"expression will be installed."
msgstr "将安装当前源目录中与正则表达式匹配的任何文件。"

#: ../../cmake-prefix/src/cmake/Help/command/install_files.rst:37
msgid ""
"Any files listed after the ``FILES`` keyword will be installed explicitly "
"from the names given.  Full paths are allowed in this form."
msgstr "在 ``FILES`` 关键字之后列出的任何文件都将从给定的名称中明确安装。此表单中允许使用完整路径。"

#: ../../cmake-prefix/src/cmake/Help/command/install_files.rst:40
#: ../../cmake-prefix/src/cmake/Help/command/install_programs.rst:35
msgid ""
"The directory ``<dir>`` is relative to the installation prefix, which is "
"stored in the variable :variable:`CMAKE_INSTALL_PREFIX`."
msgstr "目录 ``<dir>`` 是相对于安装前缀的，它存储在变量 :variable:`CMAKE_INSTALL_PREFIX` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/install_programs.rst:2
msgid "install_programs"
msgstr "安装程序"

#: ../../cmake-prefix/src/cmake/Help/command/install_programs.rst:6
msgid "Use the :command:`install(PROGRAMS)` command instead."
msgstr "请改用 :command:`install(PROGRAMS)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/install_programs.rst:8
msgid ""
"This command has been superseded by the :command:`install` command.  It is"
" provided for compatibility with older CMake code.  The ``FILES`` form is "
"directly replaced by the ``PROGRAMS`` form of the :command:`install` "
"command.  The regexp form can be expressed more clearly using the ``GLOB``"
" form of the :command:`file` command."
msgstr ""
"此命令已被 :command:`install` 命令取代。提供它是为了与旧的 CMake 代码兼容。 ``FILES`` 形式直接被 "
":command:`install` 命令的 ``PROGRAMS`` 形式取代。使用 :command:`file` 命令的 ``GLOB`` "
"形式可以更清楚地表达正则表达式形式。"

#: ../../cmake-prefix/src/cmake/Help/command/install_programs.rst:19
msgid ""
"Create rules to install the listed programs into the given directory. Use "
"the ``FILES`` argument to guarantee that the file list version of the "
"command will be used even when there is only one argument."
msgstr "创建规则以将列出的程序安装到给定目录中。使用 ``FILES`` 参数保证即使只有一个参数也将使用命令的文件列表版本。"

#: ../../cmake-prefix/src/cmake/Help/command/install_programs.rst:27
msgid ""
"In the second form any program in the current source directory that "
"matches the regular expression will be installed."
msgstr "在第二种形式中，将安装当前源目录中与正则表达式匹配的任何程序。"

#: ../../cmake-prefix/src/cmake/Help/command/install_programs.rst:30
msgid ""
"This command is intended to install programs that are not built by cmake, "
"such as shell scripts.  See the ``TARGETS`` form of the :command:`install`"
" command to create installation rules for targets built by cmake."
msgstr ""
"此命令旨在安装不是由 cmake 构建的程序，例如 shell 脚本。请参阅 :command:`install` 命令的 ``TARGETS`` "
"形式，为 cmake 构建的目标创建安装规则。"

#: ../../cmake-prefix/src/cmake/Help/command/install_targets.rst:2
msgid "install_targets"
msgstr "安装目标"

#: ../../cmake-prefix/src/cmake/Help/command/install_targets.rst:6
msgid "Use the :command:`install(TARGETS)` command instead."
msgstr "请改用 :command:`install(TARGETS)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/install_targets.rst:8
msgid ""
"This command has been superseded by the :command:`install` command.  It is"
" provided for compatibility with older CMake code."
msgstr "此命令已被 :command:`install` 命令取代。提供它是为了与旧的 CMake 代码兼容。"

#: ../../cmake-prefix/src/cmake/Help/command/install_targets.rst:15
msgid ""
"Create rules to install the listed targets into the given directory. The "
"directory ``<dir>`` is relative to the installation prefix, which is "
"stored in the variable :variable:`CMAKE_INSTALL_PREFIX`.  If "
"``RUNTIME_DIRECTORY`` is specified, then on systems with special runtime "
"files (Windows DLL), the files will be copied to that directory."
msgstr ""
"创建规则以将列出的目标安装到给定目录中。目录 ``<dir>`` 是相对于安装前缀的，它存储在变量 "
":variable:`CMAKE_INSTALL_PREFIX` "
"中。如果指定了``RUNTIME_DIRECTORY``，那么在具有特殊运行时文件（Windows DLL）的系统上，文件将被复制到该目录。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:2
msgid "link_directories"
msgstr "链接目录"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:4
msgid "Add directories in which the linker will look for libraries."
msgstr "添加链接器将在其中查找库的目录。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:10
msgid ""
"Adds the paths in which the linker should search for libraries. Relative "
"paths given to this command are interpreted as relative to the current "
"source directory, see :policy:`CMP0015`."
msgstr "添加链接器应在其中搜索库的路径。提供给此命令的相对路径被解释为相对于当前源目录，请参阅 :policy:`CMP0015`。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:14
msgid "The command will apply only to targets created after it is called."
msgstr "该命令将仅适用于调用它后创建的目标。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:16
msgid ""
"The directories are added to the :prop_dir:`LINK_DIRECTORIES` directory "
"property for the current ``CMakeLists.txt`` file, converting relative "
"paths to absolute as needed.  See the :manual:`cmake-buildsystem(7)` "
"manual for more on defining buildsystem properties."
msgstr ""
"这些目录被添加到当前 CMakeLists.txt 文件的 LINK_DIRECTORIES "
"目录属性中，根据需要将相对路径转换为绝对路径。有关定义构建系统属性的更多信息，请参阅 :manual:`cmake-buildsystem(7)` "
"手册。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:22
msgid ""
"By default the directories specified are appended onto the current list of"
" directories.  This default behavior can be changed by setting "
":variable:`CMAKE_LINK_DIRECTORIES_BEFORE` to ``ON``.  By using ``AFTER`` "
"or ``BEFORE`` explicitly, you can select between appending and prepending,"
" independent of the default."
msgstr ""
"默认情况下，指定的目录附加到当前目录列表中。可以通过将 :variable:`CMAKE_LINK_DIRECTORIES_BEFORE` 设置为 "
"``ON`` 来更改此默认行为。通过显式使用 ``AFTER`` 或 ``BEFORE``，您可以独立于默认值在追加和前置之间进行选择。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:29
msgid ""
"Arguments to ``link_directories`` may use \"generator expressions\" with "
"the syntax \"$<...>\".  See the :manual:`cmake-generator-expressions(7)` "
"manual for available expressions."
msgstr ""
"``link_directories`` 的参数可以使用语法为“$<...>”的“生成器表达式”。请参阅 :manual:`cmake-"
"generator-expressions(7)` 手册了解可用的表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:36
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:42
msgid ""
"This command is rarely necessary and should be avoided where there are "
"other choices.  Prefer to pass full absolute paths to libraries where "
"possible, since this ensures the correct library will always be linked. "
"The :command:`find_library` command provides the full path, which can "
"generally be used directly in calls to :command:`target_link_libraries`. "
"Situations where a library search path may be needed include:"
msgstr ""
"此命令很少需要，在有其他选择的情况下应避免使用。尽可能将完整的绝对路径传递给库，因为这可确保始终链接正确的库。 "
":command:`find_library` "
"命令提供了完整路径，通常可以直接用于调用 :command:`target_link_libraries`。可能需要库搜索路径的情况包括："

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:43
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:49
msgid ""
"Project generators like Xcode where the user can switch target "
"architecture at build time, but a full path to a library cannot be used "
"because it only provides one architecture (i.e. it is not a universal "
"binary)."
msgstr ""
"像 Xcode 这样的项目生成器，用户可以在构建时切换目标架构，但不能使用库的完整路径，因为它只提供一种架构（即它不是通用二进制文件）。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:47
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:53
msgid ""
"Libraries may themselves have other private library dependencies that "
"expect to be found via ``RPATH`` mechanisms, but some linkers are not able"
" to fully decode those paths (e.g. due to the presence of things like "
"``$ORIGIN``)."
msgstr ""
"库本身可能有其他私有库依赖项，这些依赖项期望通过“RPATH”机制找到，但某些链接器无法完全解码这些路径（例如，由于存在“$ORIGIN”之类的东西）。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:52
msgid ""
"If a library search path must be provided, prefer to localize the effect "
"where possible by using the :command:`target_link_directories` command "
"rather than ``link_directories()``.  The target-specific command can also "
"control how the search directories propagate to other dependent targets."
msgstr ""
"如果必须提供库搜索路径，最好使用 target_link_directories 命令而不是 link_directories() "
"来尽可能地本地化效果。特定于目标的命令还可以控制搜索目录如何传播到其他相关目标。"

#: ../../cmake-prefix/src/cmake/Help/command/link_directories.rst:60
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:58
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:46
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:55
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:84
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:418
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:62
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:131
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:216
msgid ":command:`target_link_directories`"
msgstr ":command:`target_link_directories`"

#: ../../cmake-prefix/src/cmake/Help/command/link_libraries.rst:2
msgid "link_libraries"
msgstr "链接库"

#: ../../cmake-prefix/src/cmake/Help/command/link_libraries.rst:4
msgid "Link libraries to all targets added later."
msgstr "将库链接到以后添加的所有目标。"

#: ../../cmake-prefix/src/cmake/Help/command/link_libraries.rst:11
msgid ""
"Specify libraries or flags to use when linking any targets created later "
"in the current directory or below by commands such as "
":command:`add_executable` or :command:`add_library`.  See the "
":command:`target_link_libraries` command for meaning of arguments."
msgstr ""
"指定库或标志，以在链接稍后在当前目录中创建的任何目标时使用，或通过命令（例如:command:`add_executable` 或 "
":command:`add_library`。有关参数的含义，请参阅 :command:`target_link_libraries` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/link_libraries.rst:17
msgid ""
"The :command:`target_link_libraries` command should be preferred whenever "
"possible.  Library dependencies are chained automatically, so directory-"
"wide specification of link libraries is rarely needed."
msgstr ""
"应该尽可能首选 :command:`target_link_libraries` 命令。库依赖项是自动链接的，因此很少需要链接库的目录范围规范。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:2
msgid "list"
msgstr "列表"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:4
msgid "List operations."
msgstr "列出操作。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:39
msgid ""
"The list subcommands ``APPEND``, ``INSERT``, ``FILTER``, ``PREPEND``, "
"``POP_BACK``, ``POP_FRONT``, ``REMOVE_AT``, ``REMOVE_ITEM``, "
"``REMOVE_DUPLICATES``, ``REVERSE`` and ``SORT`` may create new values for "
"the list within the current CMake variable scope.  Similar to the "
":command:`set` command, the LIST command creates new variable values in "
"the current scope, even if the list itself is actually defined in a parent"
" scope.  To propagate the results of these operations upwards, use "
":command:`set` with ``PARENT_SCOPE``, :command:`set` with ``CACHE "
"INTERNAL``, or some other means of value propagation."
msgstr ""
"列表子命令``APPEND``、``INSERT``、``FILTER``、``PREPEND``、``POP_BACK``、``POP_FRONT``、``REMOVE_AT``、``REMOVE_ITEM``"
" 、``REMOVE_DUPLICATES``、``REVERSE`` 和 ``SORT`` 可能会在当前 CMake "
"变量范围内为列表创建新值。类似于 :command:`set` 命令，LIST "
"命令在当前作用域中创建新的变量值，即使列表本身实际上是在父作用域中定义的。要向上传播这些操作的结果，请使用 :command:`set` 和 "
"``PARENT_SCOPE``、 :command:`set` 和 ``CACHE INTERNAL`` 或其他一些值传播方式。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:51
msgid ""
"A list in cmake is a ``;`` separated group of strings.  To create a list "
"the set command can be used.  For example, ``set(var a b c d e)`` creates "
"a list with ``a;b;c;d;e``, and ``set(var \"a b c d e\")`` creates a string"
" or a list with one item in it.   (Note macro arguments are not variables,"
" and therefore cannot be used in LIST commands.)"
msgstr ""
"cmake 中的列表是一组由 ``;`` 分隔的字符串。要创建列表，可以使用 set 命令。例如，``set(var a b c d e)`` "
"创建一个包含 ``a;b;c;d;e`` 的列表，而 ``set(var \"a b c d e\")`` "
"创建一个字符串或包含一个的列表其中的项目。 （注意宏参数不是变量，因此不能在 LIST 命令中使用。）"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:59
msgid ""
"When specifying index values, if ``<element index>`` is 0 or greater, it "
"is indexed from the beginning of the list, with 0 representing the first "
"list element.  If ``<element index>`` is -1 or lesser, it is indexed from "
"the end of the list, with -1 representing the last list element. Be "
"careful when counting with negative indices: they do not start from 0.  -0"
" is equivalent to 0, the first list element."
msgstr ""
"指定索引值时，如果 ``<element index>`` 为 0 或更大，则从列表的开头开始索引，0 表示第一个列表元素。如果 "
"``<element index>`` 为 -1 或更小，则从列表末尾开始索引，-1 表示最后一个列表元素。使用负索引计数时要小心：它们不是从 0 "
"开始的。-0 等同于 0，第一个列表元素。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:75
msgid "Returns the list's length."
msgstr "返回列表的长度。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:83
msgid "Returns the list of elements specified by indices from the list."
msgstr "返回由列表中的索引指定的元素列表。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:93
msgid ""
"Returns a string joining all list's elements using the glue string. To "
"join multiple strings, which are not part of a list, use ``JOIN`` operator"
" from :command:`string` command."
msgstr ""
"返回使用粘合字符串连接所有列表元素的字符串。要连接不属于列表的多个字符串，请使用 :command:`string` 命令中的 ``JOIN`` "
"运算符。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:105
msgid ""
"Returns a sublist of the given list. If ``<length>`` is 0, an empty list "
"will be returned. If ``<length>`` is -1 or the list is smaller than "
"``<begin>+<length>`` then the remaining elements of the list starting at "
"``<begin>`` will be returned."
msgstr ""
"返回给定列表的子列表。如果 ``<length>`` 为 0，将返回一个空列表。如果 ``<length>`` 为 -1 或列表小于 "
"``<begin>+<length>`` 则列表中从 ``<begin>`` 开始的剩余元素将被返回。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:111
msgid "Search"
msgstr "搜索"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:119
msgid ""
"Returns the index of the element specified in the list or -1 if it wasn't "
"found."
msgstr "返回列表中指定元素的索引，如果未找到则返回 -1。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:131
msgid ""
"Appends elements to the list. If no variable named ``<list>`` exists in "
"the current scope its value is treated as empty and the elements are "
"appended to that empty list."
msgstr "将元素追加到列表中。如果当前作用域中不存在名为 ``<list>`` 的变量，则将其值视为空，并将元素附加到该空列表。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:143
msgid ""
"Includes or removes items from the list that match the mode's pattern. In "
"``REGEX`` mode, items will be matched against the given regular "
"expression."
msgstr "在列表中包含或删除与模式模式匹配的项目。在 ``REGEX`` 模式下，项目将与给定的正则表达式匹配。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:146
msgid ""
"For more information on regular expressions look under :ref:`string(REGEX)"
" <Regex Specification>`."
msgstr "有关正则表达式的更多信息，请参阅 :ref:`string(REGEX) <Regex Specification>`。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:155
msgid ""
"Inserts elements to the list to the specified index. It is an error to "
"specify an out-of-range index. Valid indexes are 0 to `N` where `N` is the"
" length of the list, inclusive. An empty list has length 0. If no variable"
" named ``<list>`` exists in the current scope its value is treated as "
"empty and the elements are inserted in that empty list."
msgstr ""
"将列表中的元素插入到指定索引。指定超出范围的索引是错误的。有效索引为 0 到 `N`，其中 `N` 是列表的长度，包括在内。空列表的长度为 "
"0。如果当前作用域中不存在名为 ``<list>`` 的变量，则将其值视为空，并将元素插入该空列表中。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:170
msgid ""
"If no variable name is given, removes exactly one element. Otherwise, with"
" `N` variable names provided, assign the last `N` elements' values to the "
"given variables and then remove the last `N` values from ``<list>``."
msgstr ""
"如果没有给出变量名，则只删除一个元素。否则，在提供“N”变量名称的情况下，将最后的“N”个元素的值分配给给定的变量，然后从“<列表>”中删除最后的“N”个值。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:183
msgid ""
"If no variable name is given, removes exactly one element. Otherwise, with"
" `N` variable names provided, assign the first `N` elements' values to the"
" given variables and then remove the first `N` values from ``<list>``."
msgstr ""
"如果没有给出变量名，则只删除一个元素。否则，在提供“N”变量名称的情况下，将前“N”个元素的值分配给给定变量，然后从“<列表>”中删除前“N”个值。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:196
msgid ""
"Insert elements to the 0th position in the list. If no variable named "
"``<list>`` exists in the current scope its value is treated as empty and "
"the elements are prepended to that empty list."
msgstr ""
"将元素插入列表中的第 0 个位置。如果当前作用域中不存在名为 ``<list>`` 的变量，则其值被视为空，并且元素被添加到该空列表之前。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:206
msgid "Removes all instances of the given items from the list."
msgstr "从列表中删除给定项目的所有实例。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:214
msgid "Removes items at given indices from the list."
msgstr "从列表中删除给定索引处的项目。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:222
msgid ""
"Removes duplicated items in the list. The relative order of items is "
"preserved, but if duplicates are encountered, only the first instance is "
"preserved."
msgstr "删除列表中的重复项目。保留项目的相对顺序，但如果遇到重复项，则仅保留第一个实例。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:234
msgid ""
"Transforms the list by applying an action to all or, by specifying a "
"``<SELECTOR>``, to the selected elements of the list, storing the result "
"in-place or in the specified output variable."
msgstr "通过将操作应用于所有列表或通过指定 <SELECTOR> 应用于列表的选定元素来转换列表，将结果存储在适当的位置或指定的输出变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:240
msgid ""
"The ``TRANSFORM`` sub-command does not change the number of elements in "
"the list. If a ``<SELECTOR>`` is specified, only some elements will be "
"changed, the other ones will remain the same as before the transformation."
msgstr ""
"``TRANSFORM`` 子命令不会改变列表中元素的数量。如果指定了 "
"``<SELECTOR>``，只有部分元素会被改变，其他的将与转换前保持不变。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:244
msgid ""
"``<ACTION>`` specifies the action to apply to the elements of the list. "
"The actions have exactly the same semantics as sub-commands of the "
":command:`string` command.  ``<ACTION>`` must be one of the following:"
msgstr ""
"``<ACTION>`` 指定要应用于列表元素的操作。这些操作与 :command:`string` 命令的子命令具有完全相同的语义。 "
"``<ACTION>`` 必须是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:248
msgid ""
"``APPEND``, ``PREPEND``: Append, prepend specified value to each element "
"of the list."
msgstr "``APPEND``, ``PREPEND``：追加，将指定值添加到列表的每个元素。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:255
msgid ""
"``TOUPPER``, ``TOLOWER``: Convert each element of the list to upper, lower"
" characters."
msgstr "``TOUPPER``, ``TOLOWER``: 将列表的每个元素转换为大、小字符。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:262
msgid ""
"``STRIP``: Remove leading and trailing spaces from each element of the "
"list."
msgstr "``STRIP``：从列表的每个元素中删除前导和尾随空格。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:269
msgid ""
"``GENEX_STRIP``: Strip any :manual:`generator expressions <cmake-"
"generator-expressions(7)>` from each element of the list."
msgstr ""
"``GENEX_STRIP``：从列表的每个元素中去除任何生成器表达式 <cmake-generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:277
msgid ""
"``REPLACE``: Match the regular expression as many times as possible and "
"substitute the replacement expression for the match for each element of "
"the list (Same semantic as ``REGEX REPLACE`` from :command:`string` "
"command)."
msgstr ""
"``REPLACE``：尽可能多次匹配正则表达式，并将替换表达式替换为列表中每个元素的匹配项（与 :command:`string` 命令中的 "
"``REGEX REPLACE`` 语义相同）。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:287
msgid ""
"``<SELECTOR>`` determines which elements of the list will be transformed. "
"Only one type of selector can be specified at a time.  When given, "
"``<SELECTOR>`` must be one of the following:"
msgstr ""
"``<SELECTOR>`` 确定列表中的哪些元素将被转换。一次只能指定一种类型的选择器。给定时，``<SELECTOR>`` 必须是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:291
msgid "``AT``: Specify a list of indexes."
msgstr "``AT``：指定索引列表。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:297
msgid ""
"``FOR``: Specify a range with, optionally, an increment used to iterate "
"over the range."
msgstr "``FOR``：指定一个范围，可选地，用于迭代该范围的增量。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:304
msgid ""
"``REGEX``: Specify a regular expression. Only elements matching the "
"regular expression will be transformed."
msgstr "``REGEX``：指定一个正则表达式。只有匹配正则表达式的元素才会被转换。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:313
msgid "Ordering"
msgstr "订购"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:321
msgid "Reverses the contents of the list in-place."
msgstr "就地反转列表的内容。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:329
msgid "Sorts the list in-place alphabetically."
msgstr "按字母顺序对列表进行就地排序。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:331
msgid "Added the ``COMPARE``, ``CASE``, and ``ORDER`` options."
msgstr "添加了 ``COMPARE``、``CASE`` 和 ``ORDER`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:334
msgid "Added the ``COMPARE NATURAL`` option."
msgstr "添加了“比较自然”选项。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:337
msgid ""
"Use the ``COMPARE`` keyword to select the comparison method for sorting. "
"The ``<compare>`` option should be one of:"
msgstr "使用 ``COMPARE`` 关键字选择排序的比较方法。 ``<compare>`` 选项应该是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:340
msgid ""
"``STRING``: Sorts a list of strings alphabetically.  This is the default "
"behavior if the ``COMPARE`` option is not given."
msgstr "``STRING``：按字母顺序对字符串列表进行排序。如果没有给出 ``COMPARE`` 选项，这是默认行为。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:342
msgid ""
"``FILE_BASENAME``: Sorts a list of pathnames of files by their basenames."
msgstr "``FILE_BASENAME``：按文件的基本名称对文件路径名列表进行排序。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:343
msgid ""
"``NATURAL``: Sorts a list of strings using natural order (see "
"``strverscmp(3)`` manual), i.e. such that contiguous digits are compared "
"as whole numbers. For example: the following list `10.0 1.1 2.1 8.0 2.0 "
"3.1` will be sorted as `1.1 2.0 2.1 3.1 8.0 10.0` if the ``NATURAL`` "
"comparison is selected where it will be sorted as `1.1 10.0 2.0 2.1 3.1 "
"8.0` with the ``STRING`` comparison."
msgstr ""
"``NATURAL``：使用自然顺序对字符串列表进行排序（参见 ``strverscmp(3)`` "
"手册），即将连续数字作为整数进行比较。例如：以下列表“10.0 1.1 2.1 8.0 2.0 3.1”将被排序为“1.1 2.0 2.1 3.1 "
"8.0 10.0”，如果选择“自然”比较，它将被排序为“1.1 10.0 2.0 2.1 3.1 8.0”与 ``STRING`` 比较。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:351
msgid ""
"Use the ``CASE`` keyword to select a case sensitive or case insensitive "
"sort mode.  The ``<case>`` option should be one of:"
msgstr "使用 ``CASE`` 关键字选择区分大小写或不区分大小写的排序模式。 ``<case>`` 选项应该是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:354
msgid ""
"``SENSITIVE``: List items are sorted in a case-sensitive manner.  This is "
"the default behavior if the ``CASE`` option is not given."
msgstr "``SENSITIVE``：列表项以区分大小写的方式排序。如果没有给出 ``CASE`` 选项，这是默认行为。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:356
msgid ""
"``INSENSITIVE``: List items are sorted case insensitively.  The order of "
"items which differ only by upper/lowercase is not specified."
msgstr "``INSENSITIVE``：列表项不区分大小写排序。未指定仅大写/小写不同的项目的顺序。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:359
msgid ""
"To control the sort order, the ``ORDER`` keyword can be given. The "
"``<order>`` option should be one of:"
msgstr "要控制排序顺序，可以给出 ``ORDER`` 关键字。 ``<order>`` 选项应该是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:362
msgid ""
"``ASCENDING``: Sorts the list in ascending order.  This is the default "
"behavior when the ``ORDER`` option is not given."
msgstr "``ASCENDING``：按升序对列表进行排序。这是未给出 ``ORDER`` 选项时的默认行为。"

#: ../../cmake-prefix/src/cmake/Help/command/list.rst:364
msgid "``DESCENDING``: Sorts the list in descending order."
msgstr "``DESCENDING``：按降序对列表进行排序。"

#: ../../cmake-prefix/src/cmake/Help/command/load_cache.rst:2
msgid "load_cache"
msgstr "加载缓存"

#: ../../cmake-prefix/src/cmake/Help/command/load_cache.rst:4
msgid "Load in the values from another project's CMake cache."
msgstr "从另一个项目的 CMake 缓存中加载值。"

#: ../../cmake-prefix/src/cmake/Help/command/load_cache.rst:10
msgid ""
"Reads the cache and store the requested entries in variables with their "
"name prefixed with the given prefix.  This only reads the values, and does"
" not create entries in the local project's cache."
msgstr "读取缓存并将请求的条目存储在名称以给定前缀为前缀的变量中。这只会读取值，不会在本地项目的缓存中创建条目。"

#: ../../cmake-prefix/src/cmake/Help/command/load_cache.rst:19
msgid ""
"Loads in the values from another cache and store them in the local "
"project's cache as internal entries.  This is useful for a project that "
"depends on another project built in a different tree.  ``EXCLUDE`` option "
"can be used to provide a list of entries to be excluded. "
"``INCLUDE_INTERNALS`` can be used to provide a list of internal entries to"
" be included.  Normally, no internal entries are brought in.  Use of this "
"form of the command is strongly discouraged, but it is provided for "
"backward compatibility."
msgstr ""
"从另一个缓存中加载值并将它们作为内部条目存储在本地项目的缓存中。这对于依赖于在不同树中构建的另一个项目的项目很有用。 ``EXCLUDE`` "
"选项可用于提供要排除的条目列表。 ``INCLUDE_INTERNALS`` "
"可用于提供要包含的内部条目列表。通常，不会引入任何内部条目。强烈建议不要使用这种形式的命令，但它是为了向后兼容而提供的。"

#: ../../cmake-prefix/src/cmake/Help/command/load_command.rst:2
msgid "load_command"
msgstr "加载命令"

#: ../../cmake-prefix/src/cmake/Help/command/load_command.rst:4
msgid "Disallowed since version 3.0.  See CMake Policy :policy:`CMP0031`."
msgstr "3.0 版后不允许。请参阅 CMake 政策:policy:`CMP0031`。"

#: ../../cmake-prefix/src/cmake/Help/command/load_command.rst:6
msgid "Load a command into a running CMake."
msgstr "将命令加载到正在运行的 CMake 中。"

#: ../../cmake-prefix/src/cmake/Help/command/load_command.rst:12
msgid ""
"The given locations are searched for a library whose name is "
"cmCOMMAND_NAME.  If found, it is loaded as a module and the command is "
"added to the set of available CMake commands.  Usually, "
":command:`try_compile` is used before this command to compile the module."
"  If the command is successfully loaded a variable named"
msgstr ""
"在给定位置搜索名称为 cmCOMMAND_NAME 的库。如果找到，它将作为模块加载，并将命令添加到可用的 CMake "
"命令集中。通常， :command:`try_compile` 用于此命令之前以编译模块。如果命令成功加载了一个名为"

#: ../../cmake-prefix/src/cmake/Help/command/load_command.rst:22
msgid ""
"will be set to the full path of the module that was loaded.  Otherwise the"
" variable will not be set."
msgstr "将被设置为已加载模块的完整路径。否则不会设置变量。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:2
msgid "macro"
msgstr "宏观"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:4
msgid "Start recording a macro for later invocation as a command"
msgstr "开始录制宏以供以后作为命令调用"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:12
msgid ""
"Defines a macro named ``<name>`` that takes arguments named ``<arg1>``, "
"... Commands listed after macro, but before the matching "
":command:`endmacro()`, are not executed until the macro is invoked."
msgstr ""
"定义一个名为 ``<name>`` 的宏，它接受名为 ``<arg1>`` 的参数，...在宏之后但在匹配的 endmacro() "
"之前列出的命令，直到宏才执行被调用。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:17
msgid ""
"Per legacy, the :command:`endmacro` command admits an optional ``<name>`` "
"argument. If used, it must be a verbatim repeat of the argument of the "
"opening ``macro`` command."
msgstr ""
"按照传统， :command:`endmacro` 命令接受一个可选的 ``<name>`` 参数。如果使用，它必须逐字重复开头的“宏”命令的参数。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:21
msgid ""
"See the :command:`cmake_policy()` command documentation for the behavior "
"of policies inside macros."
msgstr "请参阅 :command:`cmake_policy()` 命令文档以了解宏中策略的行为。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:24
msgid ""
"See the :ref:`Macro vs Function` section below for differences between "
"CMake macros and :command:`functions <function>`."
msgstr ""
"请参阅下面的 :ref:`Macro vs Function` 部分了解 CMake 宏和 :command:`functions "
"<function>` 之间的区别。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:30
msgid "The macro invocation is case-insensitive. A macro defined as"
msgstr "宏调用不区分大小写。宏定义为"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:47
msgid ""
"and so on. However, it is strongly recommended to stay with the case "
"chosen in the macro definition.  Typically macros use all-lowercase names."
msgstr "等等。但是，强烈建议保留在宏定义中选择的大小写。通常，宏使用全小写的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:51
msgid ""
"The :command:`cmake_language(CALL ...)` command can also be used to invoke"
" the macro."
msgstr ":command:`cmake_language(CALL ...)` 命令也可用于调用宏。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:58
msgid ""
"When a macro is invoked, the commands recorded in the macro are first "
"modified by replacing formal parameters (``${arg1}``, ...) with the "
"arguments passed, and then invoked as normal commands."
msgstr "当一个宏被调用时，记录在宏中的命令首先被修改，用传递的参数替换形式参数（``${arg1}``, ...），然后作为普通命令被调用。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:62
msgid ""
"In addition to referencing the formal parameters you can reference the "
"values ``${ARGC}`` which will be set to the number of arguments passed "
"into the function as well as ``${ARGV0}``, ``${ARGV1}``, ``${ARGV2}``, ..."
"  which will have the actual values of the arguments passed in. This "
"facilitates creating macros with optional arguments."
msgstr ""
"除了引用形式参数之外，您还可以引用值 ``${ARGC}``，它将被设置为传递给函数的参数数量以及``${ARGV0}``、``${ARGV1 "
"}``, ``${ARGV2}``, ... 将传入参数的实际值。这有助于创建带有可选参数的宏。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:68
msgid ""
"Furthermore, ``${ARGV}`` holds the list of all arguments given to the "
"macro and ``${ARGN}`` holds the list of arguments past the last expected "
"argument. Referencing to ``${ARGV#}`` arguments beyond ``${ARGC}`` have "
"undefined behavior. Checking that ``${ARGC}`` is greater than ``#`` is the"
" only way to ensure that ``${ARGV#}`` was passed to the function as an "
"extra argument."
msgstr ""
"此外，``${ARGV}`` 保存给宏的所有参数列表，``${ARGN}`` 保存最后一个预期参数之后的参数列表。引用``${ARGV#}`` "
"超出``${ARGC}`` 的参数有未定义的行为。检查 ``${ARGC}`` 是否大于 ``#`` 是确保 ``${ARGV#}`` "
"作为额外参数传递给函数的唯一方法。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:79
msgid "Macro vs Function"
msgstr "宏与函数"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:81
msgid ""
"The ``macro`` command is very similar to the :command:`function` command. "
"Nonetheless, there are a few important differences."
msgstr "``macro`` 命令与 :command:`function` 命令非常相似。尽管如此，还是有一些重要的区别。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:84
msgid ""
"In a function, ``ARGN``, ``ARGC``, ``ARGV`` and ``ARGV0``, ``ARGV1``, ... "
"are true variables in the usual CMake sense.  In a macro, they are not, "
"they are string replacements much like the C preprocessor would do with a "
"macro.  This has a number of consequences, as explained in the "
":ref:`Argument Caveats` section below."
msgstr ""
"在一个函数中，``ARGN``、``ARGC``、``ARGV`` 和 ``ARGV0``、``ARGV1`` ……在通常的 CMake "
"意义上是真正的变量。在宏中，它们不是，它们是字符串替换，就像 C 预处理器对宏所做的一样。这会产生许多后果，如下面的 :ref:`Argument "
"Caveats` 部分所述。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:90
msgid ""
"Another difference between macros and functions is the control flow. A "
"function is executed by transferring control from the calling statement to"
" the function body.  A macro is executed as if the macro body were pasted "
"in place of the calling statement.  This has the consequence that a "
":command:`return()` in a macro body does not just terminate execution of "
"the macro; rather, control is returned from the scope of the macro call.  "
"To avoid confusion, it is recommended to avoid :command:`return()` in "
"macros altogether."
msgstr ""
"宏和函数之间的另一个区别是控制流。通过将控制权从调用语句转移到函数体来执行函数。宏的执行就像宏主体被粘贴到调用语句的位置一样。这会导致宏主体中的 "
"return() "
"不仅会终止宏的执行，还会终止宏的执行；相反，控制是从宏调用的范围返回的。为避免混淆，建议在宏中完全避免使用 :command:`return()`。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:99
msgid ""
"Unlike a function, the :variable:`CMAKE_CURRENT_FUNCTION`, "
":variable:`CMAKE_CURRENT_FUNCTION_LIST_DIR`, "
":variable:`CMAKE_CURRENT_FUNCTION_LIST_FILE`, "
":variable:`CMAKE_CURRENT_FUNCTION_LIST_LINE` variables are not set for a "
"macro."
msgstr ""
"与函数不同，CMAKE_CURRENT_FUNCTION、CMAKE_CURRENT_FUNCTION_LIST_DIR、CMAKE_CURRENT_FUNCTION_LIST_FILE、CMAKE_CURRENT_FUNCTION_LIST_LINE"
" 变量不是为宏设置的。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:108
msgid "Argument Caveats"
msgstr "论证注意事项"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:110
msgid ""
"Since ``ARGN``, ``ARGC``, ``ARGV``, ``ARGV0`` etc. are not variables, you "
"will NOT be able to use commands like"
msgstr "由于 ``ARGN``、``ARGC``、``ARGV``、``ARGV0`` 等不是变量，您将无法使用像这样的命令"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:120
msgid ""
"In the first case, you can use ``if(${ARGV1})``.  In the second and third "
"case, the proper way to check if an optional variable was passed to the "
"macro is to use ``if(${ARGC} GREATER 2)``.  In the last case, you can use "
"``foreach(loop_var ${ARGN})`` but this will skip empty arguments.  If you "
"need to include them, you can use"
msgstr ""
"在第一种情况下，您可以使用 if(${ARGV1}) 。在第二种和第三种情况下，检查可选变量是否传递给宏的正确方法是使用“if(${ARGC} "
"GREATER 2)”。在最后一种情况下，您可以使用“foreach(loop_var "
"${ARGN})”，但这会跳过空参数。如果你需要包括它们，你可以使用"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:131
msgid ""
"Note that if you have a variable with the same name in the scope from "
"which the macro is called, using unreferenced names will use the existing "
"variable instead of the arguments. For example:"
msgstr "请注意，如果在调用宏的范围内有一个同名变量，则使用未引用的名称将使用现有变量而不是参数。例如："

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:149
msgid ""
"Will loop over ``a;b;c`` and not over ``x;y;z`` as one might have "
"expected. If you want true CMake variables and/or better CMake scope "
"control you should look at the function command."
msgstr ""
"将遍历 ``a;b;c`` 而不是像人们预期的那样遍历 ``x;y;z`` 。如果您想要真正的 CMake 变量和/或更好的 CMake "
"范围控制，您应该查看函数命令。"

#: ../../cmake-prefix/src/cmake/Help/command/macro.rst:157
msgid ":command:`endmacro`"
msgstr ":command:`endmacro`"

#: ../../cmake-prefix/src/cmake/Help/command/make_directory.rst:2
msgid "make_directory"
msgstr "制作目录"

#: ../../cmake-prefix/src/cmake/Help/command/make_directory.rst:6
msgid "Use the :command:`file(MAKE_DIRECTORY)` command instead."
msgstr "请改用 :command:`file(MAKE_DIRECTORY)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/make_directory.rst:12
msgid ""
"Creates the specified directory.  Full paths should be given.  Any parent "
"directories that do not exist will also be created.  Use with care."
msgstr "创建指定的目录。应给出完整路径。还将创建任何不存在的父目录。小心使用。"

#: ../../cmake-prefix/src/cmake/Help/command/mark_as_advanced.rst:2
msgid "mark_as_advanced"
msgstr "标记为高级"

#: ../../cmake-prefix/src/cmake/Help/command/mark_as_advanced.rst:4
msgid "Mark cmake cached variables as advanced."
msgstr "将 cmake 缓存变量标记为高级。"

#: ../../cmake-prefix/src/cmake/Help/command/mark_as_advanced.rst:10
msgid "Sets the advanced/non-advanced state of the named cached variables."
msgstr "设置命名缓存变量的高级/非高级状态。"

#: ../../cmake-prefix/src/cmake/Help/command/mark_as_advanced.rst:13
msgid ""
"An advanced variable will not be displayed in any of the cmake GUIs unless"
" the ``show advanced`` option is on. In script mode, the advanced/non-"
"advanced state has no effect."
msgstr "高级变量不会显示在任何 cmake GUI 中，除非“显示高级”选项打开。在脚本模式下，高级/非高级状态无效。"

#: ../../cmake-prefix/src/cmake/Help/command/mark_as_advanced.rst:17
msgid ""
"If the keyword ``CLEAR`` is given then advanced variables are changed back"
" to unadvanced. If the keyword ``FORCE`` is given then the variables are "
"made advanced. If neither ``FORCE`` nor ``CLEAR`` is specified, new values"
" will be marked as advanced, but if a variable already has an "
"advanced/non-advanced state, it will not be changed."
msgstr ""
"如果给出关键字“CLEAR”，则高级变量将变回非高级。如果给出了关键字“FORCE”，那么变量就会被提升。如果既没有指定 FORCE 也没有指定 "
"CLEAR ，新值将被标记为高级，但如果变量已经具有高级/非高级状态，则不会更改。"

#: ../../cmake-prefix/src/cmake/Help/command/mark_as_advanced.rst:26
msgid ""
"Variables passed to this command which are not already in the cache are "
"ignored. See policy :policy:`CMP0102`."
msgstr "传递给此命令但尚未在缓存中的变量将被忽略。请参阅政策:policy:`CMP0102`。"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:2
msgid "math"
msgstr "数学"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:4
msgid "Evaluate a mathematical expression."
msgstr "评估数学表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:10
msgid ""
"Evaluates a mathematical ``<expression>`` and sets ``<variable>`` to the "
"resulting value.  The result of the expression must be representable as a "
"64-bit signed integer."
msgstr "评估数学“<表达式>”并将“<变量>”设置为结果值。表达式的结果必须可表示为 64 位有符号整数。"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:14
msgid ""
"The mathematical expression must be given as a string (i.e. enclosed in "
"double quotation marks). An example is ``\"5 * (10 + 13)\"``. Supported "
"operators are ``+``, ``-``, ``*``, ``/``, ``%``, ``|``, ``&``, ``^``, "
"``~``, ``<<``, ``>>``, and ``(...)``; they have the same meaning as in C "
"code."
msgstr ""
"数学表达式必须作为字符串给出（即用双引号括起来）。一个例子是``\"5 * (10 + 13)\"``。支持的操作符有``+``, ``-``, "
"``*``, ``/``, ``%``, ``|``, ``&``, ``^`` "
"，``~``，``<<``，``>>``和``（...）``；它们与 C 代码中的含义相同。"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:20
msgid ""
"Hexadecimal numbers are recognized when prefixed with ``0x``, as in C "
"code."
msgstr "十六进制数在前缀为“0x”时被识别，就像在 C 代码中一样。"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:23
msgid ""
"The result is formatted according to the option ``OUTPUT_FORMAT``, where "
"``<format>`` is one of"
msgstr "结果根据选项 ``OUTPUT_FORMAT`` 进行格式化，其中 ``<format>`` 是其中之一"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:27
msgid "``HEXADECIMAL``"
msgstr "``十六进制``"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:28
msgid "Hexadecimal notation as in C code, i. e. starting with \"0x\"."
msgstr "C 代码中的十六进制表示法，i。 e.以“0x”开头。"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:30
msgid "``DECIMAL``"
msgstr "``十进制``"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:30
msgid ""
"Decimal notation. Which is also used if no ``OUTPUT_FORMAT`` option is "
"specified."
msgstr "十进制表示法。如果没有指定 ``OUTPUT_FORMAT`` 选项，也会使用它。"

#: ../../cmake-prefix/src/cmake/Help/command/math.rst:33
msgid "For example"
msgstr "例如"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:2
msgid "message"
msgstr "信息"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:4
msgid "Log a message."
msgstr "记录一条消息。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:21
msgid "General messages"
msgstr "一般信息"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:27
msgid ""
"Record the specified message text in the log.  If more than one message "
"string is given, they are concatenated into a single message with no "
"separator between the strings."
msgstr "在日志中记录指定的消息文本。如果给出了多个消息字符串，它们将连接成一条消息，字符串之间没有分隔符。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:31
msgid ""
"The optional ``<mode>`` keyword determines the type of message, which "
"influences the way the message is handled:"
msgstr "可选的 ``<mode>`` 关键字确定消息的类型，这会影响消息的处理方式："

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:38
msgid "``FATAL_ERROR``"
msgstr "``致命错误``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:35
msgid "CMake Error, stop processing and generation."
msgstr "CMake Error，停止处理和生成。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:37
msgid ""
"The :manual:`cmake(1)` executable will return a non-zero :ref:`exit code "
"<CMake Exit Code>`."
msgstr ""
":manual:`cmake(1)` 可执行文件将返回一个非零的 :ref:`exit code <CMake Exit Code>`。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:41
msgid "``SEND_ERROR``"
msgstr "``发送错误``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:41
msgid "CMake Error, continue processing, but skip generation."
msgstr "CMake 错误，继续处理，但跳过生成。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:44
msgid "``WARNING``"
msgstr "``警告``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:44
msgid "CMake Warning, continue processing."
msgstr "CMake 警告，继续处理。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:47
msgid "``AUTHOR_WARNING``"
msgstr "``AUTHOR_WARNING``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:47
msgid "CMake Warning (dev), continue processing."
msgstr "CMake Warning (dev)，继续处理。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:52
msgid "``DEPRECATION``"
msgstr "``弃用``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:50
msgid ""
"CMake Deprecation Error or Warning if variable "
":variable:`CMAKE_ERROR_DEPRECATED` or :variable:`CMAKE_WARN_DEPRECATED` is"
" enabled, respectively, else no message."
msgstr ""
"如果变量 :variable:`CMAKE_ERROR_DEPRECATED` 或 "
":variable:`CMAKE_WARN_DEPRECATED` 分别启用，则 CMake 弃用错误或警告，否则没有消息。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:55
msgid "(none) or ``NOTICE``"
msgstr "（无）或``注意``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:55
msgid "Important message printed to stderr to attract user's attention."
msgstr "打印到 stderr 以引起用户注意的重要消息。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:60
msgid "``STATUS``"
msgstr "``状态``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:58
msgid ""
"The main interesting messages that project users might be interested in. "
"Ideally these should be concise, no more than a single line, but still "
"informative."
msgstr "项目用户可能感兴趣的主要有趣消息。理想情况下，这些消息应该简明扼要，不超过一行，但仍能提供信息。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:66
msgid "``VERBOSE``"
msgstr "``冗长``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:63
msgid ""
"Detailed informational messages intended for project users.  These "
"messages should provide additional details that won't be of interest in "
"most cases, but which may be useful to those building the project when "
"they want deeper insight into what's happening."
msgstr ""
"针对项目用户的详细信息消息。这些消息应提供在大多数情况下不会引起人们兴趣的其他详细信息，但对于那些希望更深入地了解正在发生的事情的构建项目的人员来说，这些信息可能会有用。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:72
msgid "``DEBUG``"
msgstr "``调试``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:69
msgid ""
"Detailed informational messages intended for developers working on the "
"project itself as opposed to users who just want to build it.  These "
"messages will not typically be of interest to other users building the "
"project and will often be closely related to internal implementation "
"details."
msgstr ""
"详细的信息性消息适用于从事项目本身的开发人员，而不是只想构建项目的用户。这些消息通常不会引起构建项目的其他用户的兴趣，并且通常与内部实现细节密切相关。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:77
msgid "``TRACE``"
msgstr "``追踪``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:75
msgid ""
"Fine-grained messages with very low-level implementation details.  "
"Messages using this log level would normally only be temporary and would "
"expect to be removed before releasing the project, packaging up the files,"
" etc."
msgstr "具有非常低级实现细节的细粒度消息。使用此日志级别的消息通常只是临时的，预计会在发布项目、打包文件等之前被删除。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:79
msgid "Added the ``NOTICE``, ``VERBOSE``, ``DEBUG``, and ``TRACE`` levels."
msgstr "添加了 ``NOTICE``、``VERBOSE``、``DEBUG`` 和 ``TRACE`` 级别。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:82
msgid ""
"The CMake command-line tool displays ``STATUS`` to ``TRACE`` messages on "
"stdout with the message preceded by two hyphens and a space.  All other "
"message types are sent to stderr and are not prefixed with hyphens.  The "
":manual:`CMake GUI <cmake-gui(1)>` displays all messages in its log area. "
"The :manual:`curses interface <ccmake(1)>` shows ``STATUS`` to ``TRACE`` "
"messages one at a time on a status line and other messages in an "
"interactive pop-up box.  The :option:`--log-level <cmake --log-level>` "
"command-line option to each of these tools can be used to control which "
"messages will be shown."
msgstr ""
"CMake 命令行工具在标准输出上显示 ``STATUS`` 到 ``TRACE`` 消息，消息前面有两个连字符和一个空格。所有其他消息类型都发送到"
" stderr，并且不以连字符为前缀。 :manual:`CMake GUI <cmake-gui(1)>` 在其日志区域中显示所有消息。 "
":manual:`curses 接口 <ccmake(1)>` 在状态行上一次一条地显示 ``STATUS`` 到 ``TRACE`` "
"消息，并在交互式弹出框中显示其他消息。这些工具的 :option:`--log-level <cmake --log-level>` "
"命令行选项可用于控制将显示哪些消息。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:92
msgid ""
"To make a log level persist between CMake runs, the "
":variable:`CMAKE_MESSAGE_LOG_LEVEL` variable can be set instead. Note that"
" the command line option takes precedence over the cache variable."
msgstr ""
"要在 CMake 运行之间保持日志级别，可以改为设置 :variable:`CMAKE_MESSAGE_LOG_LEVEL` "
"变量。请注意，命令行选项优先于缓存变量。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:97
msgid ""
"Messages of log levels ``NOTICE`` and below will have each line preceded "
"by the content of the :variable:`CMAKE_MESSAGE_INDENT` variable (converted"
" to a single string by concatenating its list items).  For ``STATUS`` to "
"``TRACE`` messages, this indenting content will be inserted after the "
"hyphens."
msgstr ""
"日志级别 ``NOTICE`` 及以下的消息将在每一行前面加上 :variable:`CMAKE_MESSAGE_INDENT` "
"变量的内容（通过连接其列表项转换为单个字符串）。对于 ``STATUS`` 到 ``TRACE`` 消息，这个缩进内容将被插入到连字符之后。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:103
msgid ""
"Messages of log levels ``NOTICE`` and below can also have each line "
"preceded with context of the form ``[some.context.example]``.  The content"
" between the square brackets is obtained by converting the "
":variable:`CMAKE_MESSAGE_CONTEXT` list variable to a dot-separated string."
"  The message context will always appear before any indenting content but "
"after any automatically added leading hyphens. By default, message context"
" is not shown, it has to be explicitly enabled by giving the "
":option:`cmake --log-context` command-line option or by setting the "
":variable:`CMAKE_MESSAGE_CONTEXT_SHOW` variable to true.  See the "
":variable:`CMAKE_MESSAGE_CONTEXT` documentation for usage examples."
msgstr ""
"日志级别 ``NOTICE`` 及以下的消息也可以在每一行前面加上 ``[some.context.example]`` "
"形式的上下文。方括号之间的内容是通过将 :variable:`CMAKE_MESSAGE_CONTEXT` "
"列表变量转换为点分隔字符串获得的。消息上下文将始终出现在任何缩进内容之前，但出现在任何自动添加的前导连字符之后。默认情况下，不显示消息上下文，必须通过提供"
" :option:`cmake --log-context` 命令行选项或通过将 "
":variable:`CMAKE_MESSAGE_CONTEXT_SHOW` 变量设置为 true 来显式启用它。有关使用示例，请参阅 "
":variable:`CMAKE_MESSAGE_CONTEXT` 文档。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:115
msgid ""
"CMake Warning and Error message text displays using a simple markup "
"language.  Non-indented text is formatted in line-wrapped paragraphs "
"delimited by newlines.  Indented text is considered pre-formatted."
msgstr "CMake 警告和错误消息文本使用简单的标记语言显示。非缩进文本被格式化为由换行符分隔的换行段落。缩进文本被认为是预先格式化的。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:121
msgid "Reporting checks"
msgstr "报告检查"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:125
msgid ""
"A common pattern in CMake output is a message indicating the start of some"
" sort of check, followed by another message reporting the result of that "
"check. For example:"
msgstr "CMake 输出中的一个常见模式是一条消息指示某种检查的开始，然后是另一条消息报告该检查的结果。例如："

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:139
msgid ""
"This can be more robustly and conveniently expressed using the "
"``CHECK_...`` keyword form of the ``message()`` command:"
msgstr "这可以使用 ``message()`` 命令的 ``CHECK_...`` 关键字形式更稳健和方便地表达："

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:146
msgid "where ``<checkState>`` must be one of the following:"
msgstr "其中 ``<checkState>`` 必须是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:149
msgid "``CHECK_START``"
msgstr "``CHECK_START``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:149
msgid "Record a concise message about the check about to be performed."
msgstr "记录有关即将执行的检查的简明消息。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:152
msgid "``CHECK_PASS``"
msgstr "``检查通过``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:152
msgid "Record a successful result for a check."
msgstr "记录检查的成功结果。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:155
msgid "``CHECK_FAIL``"
msgstr "``CHECK_FAIL``"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:155
msgid "Record an unsuccessful result for a check."
msgstr "记录检查不成功的结果。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:157
msgid ""
"When recording a check result, the command repeats the message from the "
"most recently started check for which no result has yet been reported, "
"then some separator characters and then the message text provided after "
"the ``CHECK_PASS`` or ``CHECK_FAIL`` keyword.  Check messages are always "
"reported at ``STATUS`` log level."
msgstr ""
"记录检查结果时，该命令会重复最近开始的尚未报告结果的检查的消息，然后是一些分隔符，然后是“CHECK_PASS”或“CHECK_FAIL”关键字后提供的消息文本.检查消息总是在"
" ``STATUS`` 日志级别报告。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:163
msgid ""
"Checks may be nested and every ``CHECK_START`` should have exactly one "
"matching ``CHECK_PASS`` or ``CHECK_FAIL``. The "
":variable:`CMAKE_MESSAGE_INDENT` variable can also be used to add "
"indenting to nested checks if desired.  For example:"
msgstr ""
"检查可以嵌套，每个 ``CHECK_START`` 应该恰好有一个匹配的 ``CHECK_PASS`` 或 "
"``CHECK_FAIL``。如果需要，CMAKE_MESSAGE_INDENT 变量也可用于为嵌套检查添加缩进。例如："

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:190
msgid "Output from the above would appear something like the following::"
msgstr "上面的输出将如下所示："

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:200
msgid "Configure Log"
msgstr "配置日志"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:208
msgid ""
"Record a :ref:`configure-log message event <message configure-log event>` "
"with the specified ``<text>``.  By convention, if the text contains more "
"than one line, the first line should be a summary of the event."
msgstr ""
"使用指定的 ``<text>`` 记录 :ref:`configure-log 消息事件 <message configure-log "
"event>`。按照惯例，如果文本包含多行，第一行应该是事件的摘要。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:212
msgid ""
"This mode is intended to record the details of a system inspection check "
"or other one-time operation guarded by a cache entry, but that is not "
"performed using :command:`try_compile` or :command:`try_run`, which "
"automatically log their details.  Projects should avoid calling it every "
"time CMake runs.  For example:"
msgstr ""
"此模式旨在记录系统检查检查或其他由缓存条目保护的一次性操作的详细信息，但不会使用 :command:`try_compile` 或 "
":command:`try_run` 执行，它们会自动记录其详细信息.项目应避免在每次 CMake 运行时调用它。例如："

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:243
msgid ""
"If no project is currently being configured, such as in :ref:`cmake -P "
"<Script Processing Mode>` script mode, this command does nothing."
msgstr ""
"如果当前没有配置任何项目，例如在 :ref:`cmake -P <Script Processing Mode>` "
"脚本模式下，此命令不执行任何操作。"

#: ../../cmake-prefix/src/cmake/Help/command/message.rst:250
msgid ":command:`cmake_language(GET_MESSAGE_LOG_LEVEL)`"
msgstr ":command:`cmake_language（GET_MESSAGE_LOG_LEVEL）`"

#: ../../cmake-prefix/src/cmake/Help/command/option.rst:2
msgid "option"
msgstr "选项"

#: ../../cmake-prefix/src/cmake/Help/command/option.rst:4
msgid "Provide a boolean option that the user can optionally select."
msgstr "提供一个布尔值选项，用户可以选择该选项。"

#: ../../cmake-prefix/src/cmake/Help/command/option.rst:10
msgid ""
"If no initial ``<value>`` is provided, boolean ``OFF`` is the default "
"value. If ``<variable>`` is already set as a normal or cache variable, "
"then the command does nothing (see policy :policy:`CMP0077`)."
msgstr ""
"如果没有提供初始的 ``<value>``，则布尔值 ``OFF`` 是默认值。如果 ``<variable>`` "
"已经设置为普通变量或缓存变量，则该命令不执行任何操作（请参阅策略:policy:`CMP0077`）。"

#: ../../cmake-prefix/src/cmake/Help/command/option.rst:14
msgid ""
"For options that depend on the values of other options, see the module "
"help for :module:`CMakeDependentOption`."
msgstr "对于依赖于其他选项值的选项，请参阅 :module:`CMakeDependentOption` 的模块帮助。"

#: ../../cmake-prefix/src/cmake/Help/command/option.rst:17
msgid ""
"In CMake project mode, a boolean cache variable is created with the option"
" value. In CMake script mode, a boolean variable is set with the option "
"value."
msgstr "在 CMake 项目模式下，使用选项值创建布尔缓存变量。在 CMake 脚本模式下，布尔变量设置有选项值。"

#: ../../cmake-prefix/src/cmake/Help/command/output_required_files.rst:2
msgid "output_required_files"
msgstr "output_required_files"

#: ../../cmake-prefix/src/cmake/Help/command/output_required_files.rst:4
msgid "Disallowed since version 3.0.  See CMake Policy :policy:`CMP0032`."
msgstr "3.0 版后不允许。请参阅 CMake 政策:policy:`CMP0032`。"

#: ../../cmake-prefix/src/cmake/Help/command/output_required_files.rst:6
msgid "Approximate C preprocessor dependency scanning."
msgstr "近似 C 预处理器依赖扫描。"

#: ../../cmake-prefix/src/cmake/Help/command/output_required_files.rst:8
msgid ""
"This command exists only because ancient CMake versions provided it. CMake"
" handles preprocessor dependency scanning automatically using a more "
"advanced scanner."
msgstr "这个命令的存在只是因为古老的 CMake 版本提供了它。 CMake 使用更高级的扫描器自动处理预处理器依赖扫描。"

#: ../../cmake-prefix/src/cmake/Help/command/output_required_files.rst:16
msgid ""
"Outputs a list of all the source files that are required by the specified "
"``srcfile``.  This list is written into ``outputfile``.  This is similar "
"to writing out the dependencies for ``srcfile`` except that it jumps from "
"``.h`` files into ``.cxx``, ``.c`` and ``.cpp`` files if possible."
msgstr ""
"输出指定的 ``srcfile`` 所需的所有源文件的列表。这个列表被写入``outputfile``。这类似于写出 ``srcfile`` "
"的依赖关系，除了它会从 ``.h`` 文件跳转到 ``.cxx``、``.c`` 和 ``.cpp`` 文件（如果可能的话） ."

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:2
msgid "project"
msgstr "项目"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:4
msgid "Set the name of the project."
msgstr "设置项目的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:18
msgid ""
"Sets the name of the project, and stores it in the variable "
":variable:`PROJECT_NAME`. When called from the top-level "
"``CMakeLists.txt`` also stores the project name in the variable "
":variable:`CMAKE_PROJECT_NAME`."
msgstr ""
"设置项目名称，并将其存储在变量 :variable:`PROJECT_NAME` 中。当从顶级 ``CMakeLists.txt`` "
"调用时，还将项目名称存储在变量 :variable:`CMAKE_PROJECT_NAME` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:23
msgid "Also sets the variables:"
msgstr "还设置变量："

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:26
msgid ""
":variable:`PROJECT_SOURCE_DIR`, :variable:`<PROJECT-NAME>_SOURCE_DIR`"
msgstr ":variable:`PROJECT_SOURCE_DIR`， :variable:`<PROJECT-NAME>_SOURCE_DIR`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:26
msgid "Absolute path to the source directory for the project."
msgstr "项目源目录的绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:29
msgid ""
":variable:`PROJECT_BINARY_DIR`, :variable:`<PROJECT-NAME>_BINARY_DIR`"
msgstr ":variable:`PROJECT_BINARY_DIR`， :variable:`<PROJECT-NAME>_BINARY_DIR`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:29
msgid "Absolute path to the binary directory for the project."
msgstr "项目二进制目录的绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:34
msgid ""
":variable:`PROJECT_IS_TOP_LEVEL`, :variable:`<PROJECT-NAME>_IS_TOP_LEVEL`"
msgstr ":variable:`PROJECT_IS_TOP_LEVEL`， :variable:`<PROJECT-NAME>_IS_TOP_LEVEL`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:34
msgid "Boolean value indicating whether the project is top-level."
msgstr "指示项目是否为顶级的布尔值。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:36
msgid ""
"Further variables are set by the optional arguments described in the "
"following. If any of these arguments is not used, then the corresponding "
"variables are set to the empty string."
msgstr "其他变量由以下描述的可选参数设置。如果未使用这些参数中的任何一个，则相应的变量将设置为空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:41
msgid "Options"
msgstr "选项"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:67
msgid "``VERSION <version>``"
msgstr "``版本<版本>``"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:46
msgid ""
"Optional; may not be used unless policy :policy:`CMP0048` is set to "
"``NEW``."
msgstr "选修的;除非策略:policy:`CMP0048` 设置为 ``NEW``，否则不得使用。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:49
msgid ""
"Takes a ``<version>`` argument composed of non-negative integer "
"components, i.e. ``<major>[.<minor>[.<patch>[.<tweak>]]]``, and sets the "
"variables"
msgstr ""
"采用由非负整数分量组成的“<version>”参数，即“<major>[.<minor>[.<patch>[.<tweak>]]]”，并设置变量"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:53
msgid ":variable:`PROJECT_VERSION`, :variable:`<PROJECT-NAME>_VERSION`"
msgstr ":variable:`PROJECT_VERSION`， :variable:`<PROJECT-NAME>_VERSION`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:55
msgid ""
":variable:`PROJECT_VERSION_MAJOR`, :variable:`<PROJECT-"
"NAME>_VERSION_MAJOR`"
msgstr ":variable:`PROJECT_VERSION_MAJOR`， :variable:`<PROJECT-NAME>_VERSION_MAJOR`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:57
msgid ""
":variable:`PROJECT_VERSION_MINOR`, :variable:`<PROJECT-"
"NAME>_VERSION_MINOR`"
msgstr ":variable:`PROJECT_VERSION_MINOR`， :variable:`<PROJECT-NAME>_VERSION_MINOR`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:59
msgid ""
":variable:`PROJECT_VERSION_PATCH`, :variable:`<PROJECT-"
"NAME>_VERSION_PATCH`"
msgstr ":variable:`PROJECT_VERSION_PATCH`， :variable:`<PROJECT-NAME>_VERSION_PATCH`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:61
msgid ""
":variable:`PROJECT_VERSION_TWEAK`, :variable:`<PROJECT-"
"NAME>_VERSION_TWEAK`."
msgstr ":variable:`PROJECT_VERSION_TWEAK`， :variable:`<PROJECT-NAME>_VERSION_TWEAK`。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:64
msgid ""
"When the ``project()`` command is called from the top-level "
"``CMakeLists.txt``, then the version is also stored in the variable "
":variable:`CMAKE_PROJECT_VERSION`."
msgstr ""
"当从顶级 CMakeLists.txt 调用 project() 命令时，版本也存储在变量 CMAKE_PROJECT_VERSION 中。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:85
msgid "``DESCRIPTION <project-description-string>``"
msgstr "``DESCRIPTION <project-description-string>``"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:72
#: ../../cmake-prefix/src/cmake/Help/command/project.rst:90
msgid "Optional. Sets the variables"
msgstr "选修的。设置变量"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:75
msgid ""
":variable:`PROJECT_DESCRIPTION`, :variable:`<PROJECT-NAME>_DESCRIPTION`"
msgstr ":variable:`PROJECT_DESCRIPTION`， :variable:`<PROJECT-NAME>_DESCRIPTION`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:77
msgid ""
"to ``<project-description-string>``. It is recommended that this "
"description is a relatively short string, usually no more than a few "
"words."
msgstr "到``<project-description-string>``。建议这个描述是一个比较短的字符串，一般不要超过几个字。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:81
msgid ""
"When the ``project()`` command is called from the top-level "
"``CMakeLists.txt``, then the description is also stored in the variable "
":variable:`CMAKE_PROJECT_DESCRIPTION`."
msgstr ""
"当从顶级 CMakeLists.txt 调用 project() 命令时，描述也存储在变量 CMAKE_PROJECT_DESCRIPTION 中。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:84
msgid "Added the ``<PROJECT-NAME>_DESCRIPTION`` variable."
msgstr "添加了``<PROJECT-NAME>_DESCRIPTION`` 变量。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:98
msgid "``HOMEPAGE_URL <url-string>``"
msgstr "``HOMEPAGE_URL <url-string>``"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:93
msgid ""
":variable:`PROJECT_HOMEPAGE_URL`, :variable:`<PROJECT-NAME>_HOMEPAGE_URL`"
msgstr ":variable:`PROJECT_HOMEPAGE_URL`， :variable:`<PROJECT-NAME>_HOMEPAGE_URL`"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:95
msgid ""
"to ``<url-string>``, which should be the canonical home URL for the "
"project."
msgstr "到 ``<url-string>``，它应该是项目的规范主页 URL。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:97
msgid ""
"When the ``project()`` command is called from the top-level "
"``CMakeLists.txt``, then the URL also is stored in the variable "
":variable:`CMAKE_PROJECT_HOMEPAGE_URL`."
msgstr ""
"当从顶级 ``CMakeLists.txt`` 调用 ``project()`` 命令时，URL 也存储在变量 "
":variable:`CMAKE_PROJECT_HOMEPAGE_URL` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:104
msgid "``LANGUAGES <language-name>...``"
msgstr "``语言 <语言名称>...``"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:101
msgid ""
"Optional. Can also be specified without ``LANGUAGES`` keyword per the "
"first, short signature."
msgstr "选修的。也可以在没有 ``LANGUAGES`` 关键字的情况下指定第一个短签名。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:104
msgid "Selects which programming languages are needed to build the project."
msgstr "选择构建项目所需的编程语言。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:109
msgid ""
"The variables set through the ``VERSION``, ``DESCRIPTION`` and "
"``HOMEPAGE_URL`` options are intended for use as default values in package"
" metadata and documentation."
msgstr ""
"通过 ``VERSION``、``DESCRIPTION`` 和 ``HOMEPAGE_URL`` 选项设置的变量旨在用作包元数据和文档中的默认值。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:115
msgid "Code Injection"
msgstr "代码注入"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:117
msgid ""
"A number of variables can be defined by the user to specify files to "
"include at different points during the execution of the ``project()`` "
"command. The following outlines the steps performed during a ``project()``"
" call:"
msgstr ""
"用户可以定义许多变量，以指定在执行 ``project()`` 命令期间在不同点包含的文件。下面概述了在 ``project()`` "
"调用期间执行的步骤："

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:121
msgid ""
"For every ``project()`` call regardless of the project name, include the "
"file named by :variable:`CMAKE_PROJECT_INCLUDE_BEFORE`, if set."
msgstr ""
"对于每个 ``project()`` 调用，无论项目名称如何，都包含由 "
":variable:`CMAKE_PROJECT_INCLUDE_BEFORE` 命名的文件（如果已设置）。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:126
msgid ""
"If the ``project()`` command specifies ``<PROJECT-NAME>`` as its project "
"name, include the file named by :variable:`CMAKE_PROJECT_<PROJECT-"
"NAME>_INCLUDE_BEFORE`, if set."
msgstr ""
"如果 ``project()`` 命令指定 ``<PROJECT-NAME>`` 作为其项目名称，则包含由 "
":variable:`CMAKE_PROJECT_<PROJECT-NAME>_INCLUDE_BEFORE` 命名的文件（如果已设置）。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:131
msgid ""
"Set the various project-specific variables detailed in the `Synopsis`_ and"
" `Options`_ sections above."
msgstr "设置上面“概要”和“选项”部分中详述的各种项目特定变量。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:134
msgid "For the very first ``project()`` call only:"
msgstr "仅对于第一个 ``project()`` 调用："

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:136
msgid ""
"If :variable:`CMAKE_TOOLCHAIN_FILE` is set, read it at least once. It may "
"be read multiple times and it may also be read again when enabling "
"languages later (see below)."
msgstr ""
"如果设置了 "
":variable:`CMAKE_TOOLCHAIN_FILE`，请至少读取一次。它可能会被多次阅读，也可能在稍后启用语言时再次阅读（见下文）。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:140
msgid ""
"Set the variables describing the host and target platforms. Language-"
"specific variables might or might not be set at this point. On the first "
"run, the only language-specific variables that might be defined are those "
"a toolchain file may have set. On subsequent runs, language-specific "
"variables cached from a previous run may be set."
msgstr ""
"设置描述主机和目标平台的变量。此时可能会或可能不会设置特定于语言的变量。在第一次运行时，唯一可能定义的特定于语言的变量是工具链文件可能已设置的变量。在后续运行中，可以设置从上一次运行缓存的特定于语言的变量。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:146
msgid ""
"Include each file listed in :variable:`CMAKE_PROJECT_TOP_LEVEL_INCLUDES`, "
"if set. The variable is ignored by CMake thereafter."
msgstr ""
"包括 CMAKE_PROJECT_TOP_LEVEL_INCLUDES 中列出的每个文件（如果已设置）。此后，CMake 将忽略该变量。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:150
msgid ""
"Enable any languages specified in the call, or the default languages if "
"none were provided. The toolchain file may be re-read when enabling a "
"language for the first time."
msgstr "启用调用中指定的任何语言，如果未提供，则启用默认语言。首次启用语言时可能会重新读取工具链文件。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:154
msgid ""
"For every ``project()`` call regardless of the project name, include the "
"file named by :variable:`CMAKE_PROJECT_INCLUDE`, if set."
msgstr ""
"对于每个 ``project()`` 调用，无论项目名称如何，都包含由 CMAKE_PROJECT_INCLUDE 命名的文件（如果已设置）。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:159
msgid ""
"If the ``project()`` command specifies ``<PROJECT-NAME>`` as its project "
"name, include the file named by :variable:`CMAKE_PROJECT_<PROJECT-"
"NAME>_INCLUDE`, if set."
msgstr ""
"如果 ``project()`` 命令指定 ``<PROJECT-NAME>`` 作为其项目名称，则包含由 "
":variable:`CMAKE_PROJECT_<PROJECT-NAME>_INCLUDE` 命名的文件（如果已设置）。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:164
msgid "Usage"
msgstr "用法"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:166
msgid ""
"The top-level ``CMakeLists.txt`` file for a project must contain a "
"literal, direct call to the ``project()`` command; loading one through the"
" :command:`include` command is not sufficient.  If no such call exists, "
"CMake will issue a warning and pretend there is a ``project(Project)`` at "
"the top to enable the default languages (``C`` and ``CXX``)."
msgstr ""
"项目的顶级 CMakeLists.txt 文件必须包含对 project() 命令的直接调用；通过 :command:`include` "
"命令加载一个是不够的。如果不存在这样的调用，CMake 将发出警告并假装顶部有一个 ``project(Project)`` "
"以启用默认语言（``C`` 和 ``CXX``）。"

#: ../../cmake-prefix/src/cmake/Help/command/project.rst:174
msgid ""
"Call the ``project()`` command near the top of the top-level "
"``CMakeLists.txt``, but *after* calling :command:`cmake_minimum_required`."
" It is important to establish version and policy settings before invoking "
"other commands whose behavior they may affect and for this reason the "
"``project()`` command will issue a warning if this order is not kept. See "
"also policy :policy:`CMP0000`."
msgstr ""
"在顶级 CMakeLists.txt 的顶部附近调用 project() 命令，但*在*调用 "
":command:`cmake_minimum_required` "
"之后。在调用可能影响其行为的其他命令之前建立版本和策略设置很重要，因此，如果不遵守此命令，``project()`` "
"命令将发出警告。另请参阅政策:policy:`CMP0000`。"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_cpp.rst:2
msgid "qt_wrap_cpp"
msgstr "qt_wrap_cpp"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_cpp.rst:6
msgid ""
"This command was originally added to support Qt 3 before the "
":command:`add_custom_command()` command was sufficiently mature.  The "
":module:`FindQt4` module provides the ``qt4_wrap_cpp()`` macro, which "
"should be used instead for Qt 4 projects.  For projects using Qt 5 or "
"later, use the equivalent macro provided by Qt itself (e.g. Qt 5 provides "
"``qt5_wrap_cpp()``)."
msgstr ""
"在 :command:`add_custom_command()` 命令足够成熟之前，添加此命令最初是为了支持 Qt 3。 "
":module:`FindQt4` 模块提供了 ``qt4_wrap_cpp()`` 宏，应该用于 Qt 4 项目。对于使用 Qt 5 "
"或更高版本的项目，使用 Qt 本身提供的等效宏（例如 Qt 5 提供 ``qt5_wrap_cpp()``）。"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_cpp.rst:13
msgid "Manually create Qt Wrappers."
msgstr "手动创建 Qt Wrappers。"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_cpp.rst:19
msgid ""
"Produces moc files for all the .h files listed in the SourceLists.  The "
"moc files will be added to the library using the ``DestName`` source list."
msgstr "为 SourceLists 中列出的所有 .h 文件生成 moc 文件。 moc 文件将使用“DestName”源列表添加到库中。"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_cpp.rst:22
msgid ""
"Consider updating the project to use the :prop_tgt:`AUTOMOC` target "
"property instead for a more automated way of invoking the ``moc`` tool."
msgstr "考虑更新项目以使用 :prop_tgt:`AUTOMOC` 目标属性，而不是以更自动化的方式调用 ``moc`` 工具。"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_ui.rst:2
msgid "qt_wrap_ui"
msgstr "qt_wrap_ui"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_ui.rst:6
msgid ""
"This command was originally added to support Qt 3 before the "
":command:`add_custom_command()` command was sufficiently mature.  The "
":module:`FindQt4` module provides the ``qt4_wrap_ui()`` macro, which "
"should be used instead for Qt 4 projects.  For projects using Qt 5 or "
"later, use the equivalent macro provided by Qt itself (e.g. Qt 5 provides "
"``qt5_wrap_ui()``)."
msgstr ""
"在 :command:`add_custom_command()` 命令足够成熟之前，添加此命令最初是为了支持 Qt 3。 "
":module:`FindQt4` 模块提供了 ``qt4_wrap_ui()`` 宏，它应该用于 Qt 4 项目。对于使用 Qt 5 "
"或更高版本的项目，请使用 Qt 本身提供的等效宏（例如 Qt 5 提供 ``qt5_wrap_ui()``）。"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_ui.rst:13
msgid "Manually create Qt user interfaces Wrappers."
msgstr "手动创建 Qt 用户界面包装器。"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_ui.rst:20
msgid ""
"Produces .h and .cxx files for all the .ui files listed in the "
"``SourceLists``.  The .h files will be added to the library using the "
"``HeadersDestNamesource`` list.  The .cxx files will be added to the "
"library using the ``SourcesDestNamesource`` list."
msgstr ""
"为“SourceLists”中列出的所有 .ui 文件生成 .h 和 .cxx 文件。 .h "
"文件将使用“HeadersDestNamesource”列表添加到库中。 .cxx "
"文件将使用“SourcesDestNamesource”列表添加到库中。"

#: ../../cmake-prefix/src/cmake/Help/command/qt_wrap_ui.rst:25
msgid ""
"Consider updating the project to use the :prop_tgt:`AUTOUIC` target "
"property instead for a more automated way of invoking the ``uic`` tool."
msgstr "考虑更新项目以使用 :prop_tgt:`AUTOUIC` 目标属性来代替以更自动化的方式调用 ``uic`` 工具。"

#: ../../cmake-prefix/src/cmake/Help/command/remove.rst:2
msgid "remove"
msgstr "消除"

#: ../../cmake-prefix/src/cmake/Help/command/remove.rst:6
msgid "Use the :command:`list(REMOVE_ITEM)` command instead."
msgstr "请改用 :command:`list(REMOVE_ITEM)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/remove.rst:12
msgid ""
"Removes ``VALUE`` from the variable ``VAR``.  This is typically used to "
"remove entries from a vector (e.g.  semicolon separated list).  ``VALUE`` "
"is expanded."
msgstr "从变量“VAR”中删除“VALUE”。这通常用于从向量中删除条目（例如，分号分隔的列表）。 ``VALUE`` 已展开。"

#: ../../cmake-prefix/src/cmake/Help/command/remove_definitions.rst:2
msgid "remove_definitions"
msgstr "删除定义"

#: ../../cmake-prefix/src/cmake/Help/command/remove_definitions.rst:4
msgid "Remove -D define flags added by :command:`add_definitions`."
msgstr "删除由 add_definitions 添加的 -D 定义标志。"

#: ../../cmake-prefix/src/cmake/Help/command/remove_definitions.rst:10
msgid ""
"Removes flags (added by :command:`add_definitions`) from the compiler "
"command line for sources in the current directory and below."
msgstr "从当前目录及以下目录中的源代码的编译器命令行中删除标志（由 :command:`add_definitions` 添加）。"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:2
msgid "return"
msgstr "返回"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:4
msgid "Return from a file, directory or function."
msgstr "从文件、目录或函数返回。"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:10
msgid ""
"When this command is encountered in an included file (via "
":command:`include` or :command:`find_package`), it causes processing of "
"the current file to stop and control is returned to the including file.  "
"If it is encountered in a file which is not included by another file, e.g."
" a ``CMakeLists.txt``, deferred calls scheduled by "
":command:`cmake_language(DEFER)` are invoked and control is returned to "
"the parent directory if there is one."
msgstr ""
"当在包含文件中遇到此命令时（通过 :command:`include` 或 "
":command:`find_package`），它会导致当前文件的处理停止并将控制权返回到包含文件。如果在另一个文件未包含的文件中遇到它，例如一个"
" ``CMakeLists.txt``，调用由 cmake_language(DEFER) 调度的延迟调用，如果有的话，控制返回到父目录。"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:17
msgid ""
"If ``return()`` is called in a function, control is returned to the caller"
" of that function.  Note that a :command:`macro`, unlike a "
":command:`function`, is expanded in place and therefore cannot handle "
"``return()``."
msgstr ""
"如果在函数中调用 ``return()``，控制权将返回给该函数的调用者。请注意，与 :command:`function` "
"不同， :command:`macro` 是就地展开的，因此无法处理 ``return()``。"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:21
msgid ""
"Policy :policy:`CMP0140` controls the behavior regarding the arguments of "
"the command.  All arguments are ignored unless that policy is set to "
"``NEW``."
msgstr "策略 :policy:`CMP0140` 控制有关命令参数的行为。除非该策略设置为“NEW”，否则所有参数都将被忽略。"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:27
msgid ""
"This option sets or unsets the specified variables in the parent directory"
" or function caller scope. This is equivalent to "
":command:`set(PARENT_SCOPE)` or :command:`unset(PARENT_SCOPE)` commands, "
"except for the way it interacts with the :command:`block` command, as "
"described below."
msgstr ""
"此选项设置或取消设置父目录或函数调用者范围中的指定变量。这等同于 :command:`set(PARENT_SCOPE)` 或 "
":command:`unset(PARENT_SCOPE)` 命令，除了它与 :command:`block` 命令交互的方式，如下所述。"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:32
msgid ""
"The ``PROPAGATE`` option can be very useful in conjunction with the "
":command:`block` command.  A ``return`` will propagate the specified "
"variables through any enclosing block scopes created by the "
":command:`block` commands.  Inside a function, this ensures the variables "
"are propagated to the function's caller, regardless of any blocks within "
"the function.  If not inside a function, it ensures the variables are "
"propagated to the parent file or directory scope. For example:"
msgstr ""
"``PROPAGATE`` 选项与 :command:`block` 命令结合使用非常有用。 ``return`` 将通过 "
":command:`block` "
"命令创建的任何封闭块作用域传播指定的变量。在函数内部，这确保变量被传播到函数的调用者，而不管函数中的任何块。如果不在函数内部，它确保变量传播到父文件或目录范围。例如："

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:40
msgid "CMakeLists.txt"
msgstr "CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:55
msgid "subDir/CMakeLists.txt"
msgstr "子目录/CMakeLists.txt"

#: ../../cmake-prefix/src/cmake/Help/command/return.rst:91
msgid ":command:`block`"
msgstr ":command:`块`"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:2
msgid "separate_arguments"
msgstr "单独的参数"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:4
msgid "Parse command-line arguments into a semicolon-separated list."
msgstr "将命令行参数解析为以分号分隔的列表。"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:10
msgid ""
"Parses a space-separated string ``<args>`` into a list of items, and "
"stores this list in semicolon-separated standard form in ``<variable>``."
msgstr "将以空格分隔的字符串“<args>”解析为项目列表，并将此列表以分号分隔的标准形式存储在“<variable>”中。"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:13
msgid ""
"This function is intended for parsing command-line arguments. The entire "
"command line must be passed as one string in the argument ``<args>``."
msgstr "此函数用于解析命令行参数。整个命令行必须作为参数“<args>”中的一个字符串传递。"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:17
msgid ""
"The exact parsing rules depend on the operating system. They are specified"
" by the ``<mode>`` argument which must be one of the following keywords:"
msgstr "确切的解析规则取决于操作系统。它们由 ``<mode>`` 参数指定，该参数必须是以下关键字之一："

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:25
msgid "``UNIX_COMMAND``"
msgstr "``UNIX_COMMAND``"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:22
msgid ""
"Arguments are separated by unquoted whitespace. Both single-quote and "
"double-quote pairs are respected. A backslash escapes the next literal "
"character (``\\\"`` is ``\"``); there are no special escapes (``\\n`` is "
"just ``n``)."
msgstr ""
"参数由未加引号的空格分隔。单引号和双引号对都受到尊重。反斜杠转义下一个文字字符（``\\\"`` 是 "
"``\"``）；没有特殊的转义符（``\\n`` 只是 ``n``）。"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:32
msgid "``WINDOWS_COMMAND``"
msgstr "``WINDOWS_COMMAND``"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:28
msgid ""
"A Windows command-line is parsed using the same syntax the runtime library"
" uses to construct argv at startup.  It separates arguments by whitespace "
"that is not double-quoted. Backslashes are literal unless they precede "
"double-quotes.  See the MSDN article `Parsing C Command-Line Arguments`_ "
"for details."
msgstr ""
"使用运行时库在启动时用于构造 argv 的相同语法来解析 Windows "
"命令行。它用没有双引号的空格分隔参数。反斜杠是文字，除非它们在双引号之前。有关详细信息，请参阅 MSDN 文章“解析 C 命令行参数”。"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:38
msgid "``NATIVE_COMMAND``"
msgstr "``NATIVE_COMMAND``"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:37
msgid ""
"Proceeds as in ``WINDOWS_COMMAND`` mode if the host system is Windows. "
"Otherwise proceeds as in ``UNIX_COMMAND`` mode."
msgstr ""
"如果主机系统是 Windows，则按照“WINDOWS_COMMAND”模式进行。否则按照 ``UNIX_COMMAND`` 模式进行。"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:58
msgid "``PROGRAM``"
msgstr "``程序``"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:43
msgid ""
"The first item in ``<args>`` is assumed to be an executable and will be "
"searched in the system search path or left as a full path. If not found, "
"``<variable>`` will be empty. Otherwise, ``<variable>`` is a list of 2 "
"elements:"
msgstr ""
"``<args>`` 中的第一项被假定为可执行文件，并将在系统搜索路径中搜索或保留为完整路径。如果没有找到，``<variable>`` "
"将为空。否则，``<variable>`` 是 2 个元素的列表："

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:48
msgid "Absolute path of the program"
msgstr "程序的绝对路径"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:49
msgid "Any command-line arguments present in ``<args>`` as a string"
msgstr "``<args>`` 中作为字符串存在的任何命令行参数"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:57
msgid "First element of the list: ``/path/to/cc``"
msgstr "列表的第一个元素：``/path/to/cc``"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:58
msgid "Second element of the list: ``\" -c main.c\"``"
msgstr "列表的第二个元素：``\" -c main.c\"``"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:70
msgid "``SEPARATE_ARGS``"
msgstr "``SEPARATE_ARGS``"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:61
msgid ""
"When this sub-option of ``PROGRAM`` option is specified, command-line "
"arguments will be split as well and stored in ``<variable>``."
msgstr "当指定 ``PROGRAM`` 选项的这个子选项时，命令行参数也将被拆分并存储在 ``<variable>`` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:70
msgid "The contents of ``out`` will be: ``/path/to/cc;-c;main.c``"
msgstr "``out`` 的内容将是：``/path/to/cc;-c;main.c``"

#: ../../cmake-prefix/src/cmake/Help/command/separate_arguments.rst:78
msgid ""
"Convert the value of ``<var>`` to a semi-colon separated list.  All spaces"
" are replaced with ';'.  This helps with generating command lines."
msgstr "将 ``<var>`` 的值转换为以分号分隔的列表。所有空格都替换为“;”。这有助于生成命令行。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:2
msgid "set"
msgstr "放"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:4
msgid ""
"Set a normal, cache, or environment variable to a given value. See the "
":ref:`cmake-language(7) variables <CMake Language Variables>` "
"documentation for the scopes and interaction of normal variables and cache"
" entries."
msgstr ""
"将普通、缓存或环境变量设置为给定值。请参阅 :ref:`cmake-language(7) variables <CMake Language "
"Variables>` 文档了解普通变量和缓存条目的范围和交互。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:9
msgid ""
"Signatures of this command that specify a ``<value>...`` placeholder "
"expect zero or more arguments.  Multiple arguments will be joined as a "
":ref:`semicolon-separated list <CMake Language Lists>` to form the actual "
"variable value to be set.  Zero arguments will cause normal variables to "
"be unset.  See the :command:`unset` command to unset variables explicitly."
msgstr ""
"此命令的签名指定一个 ``<value>...`` 占位符期望零个或多个参数。多个参数将作为分号分隔的列表 <CMake Language "
"Lists> 连接起来，以形成要设置的实际变量值。零参数将导致普通变量被取消设置。请参阅 :command:`unset` 命令显式取消设置变量。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:16
msgid "Set Normal Variable"
msgstr "设置普通变量"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:22
msgid ""
"Sets the given ``<variable>`` in the current function or directory scope."
msgstr "在当前函数或目录范围内设置给定的``<variable>``。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:24
msgid ""
"If the ``PARENT_SCOPE`` option is given the variable will be set in the "
"scope above the current scope.  Each new directory or :command:`function` "
"command creates a new scope.  A scope can also be created with the "
":command:`block` command. This command will set the value of a variable "
"into the parent directory, calling function or encompassing scope "
"(whichever is applicable to the case at hand). The previous state of the "
"variable's value stays the same in the current scope (e.g., if it was "
"undefined before, it is still undefined and if it had a value, it is still"
" that value)."
msgstr ""
"如果给出了 ``PARENT_SCOPE`` 选项，变量将被设置在当前范围之上的范围内。每个新目录或 :command:`function` "
"命令都会创建一个新范围。也可以使用 :command:`block` "
"命令创建作用域。此命令会将变量的值设置到父目录、调用函数或包含范围（以适用于手头的情况为准）。变量值的先前状态在当前范围内保持不变（例如，如果它之前未定义，它仍然是未定义的，如果它有一个值，它仍然是那个值）。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:33
msgid ""
"The :command:`block(PROPAGATE)` and :command:`return(PROPAGATE)` commands "
"can be used as an alternate method to the :command:`set(PARENT_SCOPE)` and"
" :command:`unset(PARENT_SCOPE)` commands to update the parent scope."
msgstr ""
":command:`block(PROPAGATE)` 和 :command:`return(PROPAGATE)` 命令可以用作 "
":command:`set(PARENT_SCOPE)` 和 :command:`unset(PARENT_SCOPE)` "
"命令的替代方法更新父作用域。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:38
msgid "Set Cache Entry"
msgstr "设置缓存条目"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:44
msgid ""
"Sets the given cache ``<variable>`` (cache entry).  Since cache entries "
"are meant to provide user-settable values this does not overwrite existing"
" cache entries by default.  Use the ``FORCE`` option to overwrite existing"
" entries."
msgstr ""
"设置给定的缓存``<variable>``（缓存条目）。由于缓存条目旨在提供用户可设置的值，因此默认情况下这不会覆盖现有的缓存条目。使用“FORCE”选项覆盖现有条目。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:49
msgid "The ``<type>`` must be specified as one of:"
msgstr "``<type>`` 必须指定为以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:52
msgid "``BOOL``"
msgstr "``布尔``"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:52
msgid "Boolean ``ON/OFF`` value.  :manual:`cmake-gui(1)` offers a checkbox."
msgstr "布尔“开/关”值。 :manual:`cmake-gui(1)` 提供了一个复选框。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:55
msgid "``FILEPATH``"
msgstr "``文件路径``"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:55
msgid ""
"Path to a file on disk.  :manual:`cmake-gui(1)` offers a file dialog."
msgstr "磁盘上文件的路径。 :manual:`cmake-gui(1)` 提供了一个文件对话框。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:58
msgid ""
"Path to a directory on disk.  :manual:`cmake-gui(1)` offers a file dialog."
msgstr "磁盘上目录的路径。 :manual:`cmake-gui(1)` 提供了一个文件对话框。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:63
msgid "``STRING``"
msgstr "``字符串``"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:61
msgid ""
"A line of text.  :manual:`cmake-gui(1)` offers a text field or a drop-down"
" selection if the :prop_cache:`STRINGS` cache entry property is set."
msgstr ""
"一行文字。 :manual:`cmake-gui(1)` 如果设置了 :prop_cache:`STRINGS` "
"缓存条目属性，则提供文本字段或下拉选择。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:68
msgid "``INTERNAL``"
msgstr "``内部``"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:66
msgid ""
"A line of text.  :manual:`cmake-gui(1)` does not show internal entries. "
"They may be used to store variables persistently across runs. Use of this "
"type implies ``FORCE``."
msgstr ""
"一行文字。 :manual:`cmake-gui(1)` 不显示内部条目。它们可用于跨运行持久存储变量。使用这种类型意味着“FORCE”。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:70
msgid ""
"The ``<docstring>`` must be specified as a line of text providing a quick "
"summary of the option for presentation to :manual:`cmake-gui(1)` users."
msgstr "``<docstring>`` 必须指定为一行文本，提供选项的快速摘要以呈现给 :manual:`cmake-gui(1)` 用户。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:74
msgid ""
"If the cache entry does not exist prior to the call or the ``FORCE`` "
"option is given then the cache entry will be set to the given value."
msgstr "如果在调用之前缓存条目不存在或者给出了“FORCE”选项，那么缓存条目将被设置为给定的值。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:79
msgid ""
"The content of the cache variable will not be directly accessible if a "
"normal variable of the same name already exists (see :ref:`rules of "
"variable evaluation <CMake Language Variables>`). If policy "
":policy:`CMP0126` is set to ``OLD``, any normal variable binding in the "
"current scope will be removed."
msgstr ""
"如果已存在同名的普通变量，则无法直接访问缓存变量的内容（请参阅 :ref:`变量评估规则 <CMake 语言变量>`）。如果 "
"policy:policy:`CMP0126` 设置为 ``OLD``，则当前范围内的任何正常变量绑定都将被删除。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:84
msgid ""
"It is possible for the cache entry to exist prior to the call but have no "
"type set if it was created on the :manual:`cmake(1)` command line by a "
"user through the :option:`-D\\<var\\>=\\<value\\> <cmake -D>` option "
"without specifying a type.  In this case the ``set`` command will add the "
"type.  Furthermore, if the ``<type>`` is ``PATH`` or ``FILEPATH`` and the "
"``<value>`` provided on the command line is a relative path, then the "
"``set`` command will treat the path as relative to the current working "
"directory and convert it to an absolute path."
msgstr ""
"缓存条目可能在调用之前存在但没有设置类型，如果它是由用户通过 :option:`-D\\<var\\ 在 :manual:`cmake(1)` "
"命令行创建的>=\\<value\\> <cmake -D>` 选项而不指定类型。在这种情况下，``set`` 命令将添加类型。此外，如果 "
"``<type>`` 是 ``PATH`` 或 ``FILEPATH`` 并且命令行上提供的 ``<value>`` 是相对路径，则 ``set``"
" 命令会将路径视为相对于当前工作目录并将其转换为绝对路径。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:94
msgid "Set Environment Variable"
msgstr "设置环境变量"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:100
msgid ""
"Sets an :manual:`Environment Variable <cmake-env-variables(7)>` to the "
"given value. Subsequent calls of ``$ENV{<variable>}`` will return this new"
" value."
msgstr ""
"将 :manual:`环境变量 <cmake-env-variables(7)>` 设置为给定值。 ``$ENV{<variable>}`` "
"的后续调用将返回这个新值。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:104
#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:39
msgid ""
"This command affects only the current CMake process, not the process from "
"which CMake was called, nor the system environment at large, nor the "
"environment of subsequent build or test processes."
msgstr "此命令仅影响当前 CMake 进程，不影响调用 CMake 的进程，也不影响整个系统环境，也不影响后续构建或测试过程的环境。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:108
msgid ""
"If no argument is given after ``ENV{<variable>}`` or if ``<value>`` is an "
"empty string, then this command will clear any existing value of the "
"environment variable."
msgstr ""
"如果在 ``ENV{<variable>}`` 之后没有给出参数或者如果 ``<value>`` "
"是一个空字符串，那么这个命令将清除环境变量的任何现有值。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:112
msgid ""
"Arguments after ``<value>`` are ignored. If extra arguments are found, "
"then an author warning is issued."
msgstr "``<value>`` 之后的参数将被忽略。如果发现额外的参数，则会发出作者警告。"

#: ../../cmake-prefix/src/cmake/Help/command/set.rst:118
msgid ":command:`unset`"
msgstr ":command:`取消设置`"

#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:2
msgid "set_directory_properties"
msgstr "设置目录属性"

#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:4
msgid "Set properties of the current directory and subdirectories."
msgstr "设置当前目录和子目录的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:10
msgid ""
"Sets properties of the current directory and its subdirectories in key-"
"value pairs."
msgstr "在键值对中设置当前目录及其子目录的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:12
msgid "See also the :command:`set_property(DIRECTORY)` command."
msgstr "另请参阅 :command:`set_property(DIRECTORY)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:14
msgid ""
"See :ref:`Directory Properties` for the list of properties known to CMake "
"and their individual documentation for the behavior of each property."
msgstr "请参阅 :ref:`Directory Properties` 以获取 CMake 已知的属性列表及其针对每个属性的行为的单独文档。"

#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:21
msgid ":command:`get_directory_property`"
msgstr ":command:`get_directory_property`"

#: ../../cmake-prefix/src/cmake/Help/command/set_directory_properties.rst:22
#: ../../cmake-prefix/src/cmake/Help/command/set_target_properties.rst:23
#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:22
msgid "the more general :command:`set_property` command"
msgstr "更通用的 :command:`set_property` 命令"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:2
msgid "set_property"
msgstr "设置属性"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:4
msgid "Set a named property in a given scope."
msgstr "在给定范围内设置命名属性。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:20
msgid "Sets one property on zero or more objects of a scope."
msgstr "在范围的零个或多个对象上设置一个属性。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:22
msgid ""
"The first argument determines the scope in which the property is set. It "
"must be one of the following:"
msgstr "第一个参数确定设置属性的范围。它必须是以下之一："

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:29
msgid ""
"Scope defaults to the current directory but other directories (already "
"processed by CMake) may be named by full or relative path. Relative paths "
"are treated as relative to the current source directory. See also the "
":command:`set_directory_properties` command."
msgstr ""
"范围默认为当前目录，但其他目录（已由 CMake 处理）可以按完整路径或相对路径命名。相对路径被视为相对于当前源目录。另请参阅 "
":command:`set_directory_properties` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:38
msgid ""
"Scope may name zero or more existing targets. See also the "
":command:`set_target_properties` command."
msgstr "范围可以命名零个或多个现有目标。另请参阅 :command:`set_target_properties` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:42
msgid ""
"Scope may name zero or more source files.  By default, source file "
"properties are only visible to targets added in the same directory "
"(``CMakeLists.txt``)."
msgstr "范围可以命名零个或多个源文件。默认情况下，源文件属性仅对添加到同一目录中的目标可见（``CMakeLists.txt``）。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:45
msgid ""
"Visibility can be set in other directory scopes using one or both of the "
"following sub-options:"
msgstr "可以使用以下一个或两个子选项在其他目录范围内设置可见性："

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:57
#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:27
msgid "``DIRECTORY <dirs>...``"
msgstr "``目录 <dirs>...``"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:50
msgid ""
"The source file property will be set in each of the ``<dirs>`` "
"directories' scopes.  CMake must already know about each of these "
"directories, either by having added them through a call to "
":command:`add_subdirectory` or it being the top level source directory. "
"Relative paths are treated as relative to the current source directory."
msgstr ""
"源文件属性将在每个 ``<dirs>`` 目录范围内设置。 CMake 必须已经知道这些目录中的每一个，或者通过调用 "
"add_subdirectory 添加它们，或者它是顶级源目录。相对路径被视为相对于当前源目录。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:56
msgid "``<dirs>`` may reference a binary directory."
msgstr "``<dirs>`` 可以引用一个二进制目录。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:61
#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:32
msgid "``TARGET_DIRECTORY <targets>...``"
msgstr "``TARGET_DIRECTORY <目标>...``"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:60
msgid ""
"The source file property will be set in each of the directory scopes where"
" any of the specified ``<targets>`` were created (the ``<targets>`` must "
"therefore already exist)."
msgstr "源文件属性将在创建任何指定的 ``<targets>`` 的每个目录范围内设置（因此 ``<targets>`` 必须已经存在）。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:64
msgid "See also the :command:`set_source_files_properties` command."
msgstr "另请参阅 :command:`set_source_files_properties` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:69
msgid ""
"Scope may name zero or more installed file paths. These are made available"
" to CPack to influence deployment."
msgstr "Scope 可以指定零个或多个已安装的文件路径。这些可用于 CPack 以影响部署。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:72
msgid ""
"Both the property key and value may use generator expressions. Specific "
"properties may apply to installed files and/or directories."
msgstr "属性键和值都可以使用生成器表达式。特定属性可能适用于已安装的文件和/或目录。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:75
msgid ""
"Path components have to be separated by forward slashes, must be "
"normalized and are case sensitive."
msgstr "路径组件必须用正斜杠分隔，必须规范化并且区分大小写。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:78
msgid ""
"To reference the installation prefix itself with a relative path use "
"``.``."
msgstr "要使用相对路径引用安装前缀本身，请使用 ``.``。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:80
msgid ""
"Currently installed file properties are only defined for the WIX generator"
" where the given paths are relative to the installation prefix."
msgstr "当前安装的文件属性仅为 WIX 生成器定义，其中给定路径与安装前缀相关。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:85
msgid ""
"Scope may name zero or more existing tests. See also the "
":command:`set_tests_properties` command."
msgstr "Scope 可以命名零个或多个现有测试。另请参阅 :command:`set_tests_properties` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:88
#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:13
msgid ""
"Test property values may be specified using :manual:`generator expressions"
" <cmake-generator-expressions(7)>` for tests created by the "
":command:`add_test(NAME)` signature."
msgstr ""
"对于由 add_test(NAME) 签名创建的测试，可以使用 generator expressions <cmake-generator-"
"expressions(7)> 指定测试属性值。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:93
msgid "Scope must name zero or more cache existing entries."
msgstr "范围必须命名零个或多个缓存现有条目。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:95
msgid ""
"The required ``PROPERTY`` option is immediately followed by the name of "
"the property to set.  Remaining arguments are used to compose the property"
" value in the form of a semicolon-separated list."
msgstr "所需的 ``PROPERTY`` 选项紧跟在要设置的属性的名称之后。其余参数用于以分号分隔列表的形式组成属性值。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:99
msgid ""
"If the ``APPEND`` option is given the list is appended to any existing "
"property value (except that empty values are ignored and not appended). If"
" the ``APPEND_STRING`` option is given the string is appended to any "
"existing property value as string, i.e. it results in a longer string and "
"not a list of strings.  When using ``APPEND`` or ``APPEND_STRING`` with a "
"property defined to support ``INHERITED`` behavior (see "
":command:`define_property`), no inheriting occurs when finding the initial"
" value to append to.  If the property is not already directly set in the "
"nominated scope, the command will behave as though ``APPEND`` or "
"``APPEND_STRING`` had not been given."
msgstr ""
"如果给出 ``APPEND`` 选项，列表将附加到任何现有的属性值（除了忽略和不附加空值）。如果给出 ``APPEND_STRING`` "
"选项，字符串将作为字符串附加到任何现有属性值，即它会产生更长的字符串而不是字符串列表。当使用 ``APPEND`` 或 "
"``APPEND_STRING`` 以及定义为支持 ``INHERITED`` "
"行为的属性时（请参阅:command:`define_property`），在找到要附加到的初始值时不会发生继承。如果该属性尚未在指定范围内直接设置，则该命令的行为就好像没有给出"
" ``APPEND`` 或 ``APPEND_STRING`` 一样。"

#: ../../cmake-prefix/src/cmake/Help/command/set_property.rst:120
msgid ""
"The :manual:`cmake-properties(7)` manual for a list of properties in each "
"scope."
msgstr "每个范围内的属性列表的 :manual:`cmake-properties(7)` 手册。"

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:2
msgid "set_source_files_properties"
msgstr "设置源文件属性"

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:4
msgid "Source files can have properties that affect how they are built."
msgstr "源文件可以具有影响它们构建方式的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:14
msgid ""
"Sets properties associated with source files using a key/value paired "
"list."
msgstr "使用键/值配对列表设置与源文件关联的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:17
msgid ""
"By default, source file properties are only visible to targets added in "
"the same directory (``CMakeLists.txt``).  Visibility can be set in other "
"directory scopes using one or both of the following options:"
msgstr ""
"默认情况下，源文件属性仅对添加到同一目录中的目标可见（``CMakeLists.txt``）。可以使用以下一个或两个选项在其他目录范围内设置可见性："

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:23
msgid ""
"The source file properties will be set in each of the ``<dirs>`` "
"directories' scopes.  CMake must already know about each of these source "
"directories, either by having added them through a call to "
":command:`add_subdirectory` or it being the top level source directory. "
"Relative paths are treated as relative to the current source directory."
msgstr ""
"源文件属性将在每个 ``<dirs>`` 目录范围内设置。 CMake 必须已经知道这些源目录中的每一个，或者通过调用 "
":command:`add_subdirectory` 添加它们，或者它是顶级源目录。相对路径被视为相对于当前源目录。"

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:30
msgid ""
"The source file properties will be set in each of the directory scopes "
"where any of the specified ``<targets>`` were created (the ``<targets>`` "
"must therefore already exist)."
msgstr "源文件属性将在创建任何指定的 ``<targets>`` 的每个目录范围内设置（因此 ``<targets>`` 必须已经存在）。"

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:34
msgid ""
"Use :command:`get_source_file_property` to get property values. See also "
"the :command:`set_property(SOURCE)` command."
msgstr ""
"使用 :command:`get_source_file_property` 获取属性值。另请参阅 "
":command:`set_property(SOURCE)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:46
msgid ":command:`get_source_file_property`"
msgstr ":command:`get_source_file_property`"

#: ../../cmake-prefix/src/cmake/Help/command/set_source_files_properties.rst:47
msgid ""
":ref:`Source File Properties` for the list of properties known to CMake"
msgstr ":ref:`Source File Properties` 获取 CMake 已知的属性列表"

#: ../../cmake-prefix/src/cmake/Help/command/set_target_properties.rst:2
msgid "set_target_properties"
msgstr "设置目标属性"

#: ../../cmake-prefix/src/cmake/Help/command/set_target_properties.rst:4
msgid "Targets can have properties that affect how they are built."
msgstr "目标可以具有影响其构建方式的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/set_target_properties.rst:12
msgid ""
"Sets properties on targets.  The syntax for the command is to list all the"
" targets you want to change, and then provide the values you want to set "
"next.  You can use any prop value pair you want and extract it later with "
"the :command:`get_property` or :command:`get_target_property` command."
msgstr ""
"设置目标的属性。该命令的语法是列出您要更改的所有目标，然后提供您接下来要设置的值。您可以使用任何您想要的 prop 值对，稍后使用 "
":command:`get_property` 或 :command:`get_target_property` 命令提取它。"

#: ../../cmake-prefix/src/cmake/Help/command/set_target_properties.rst:22
msgid ":command:`get_target_property`"
msgstr ":command:`get_target_property`"

#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:2
msgid "set_tests_properties"
msgstr "设置测试属性"

#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:4
msgid "Set a property of the tests."
msgstr "设置测试的属性。"

#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:10
msgid ""
"Sets a property for the tests.  If the test is not found, CMake will "
"report an error."
msgstr "设置测试的属性。如果没有找到测试，CMake 会报错。"

#: ../../cmake-prefix/src/cmake/Help/command/set_tests_properties.rst:20
msgid ":command:`add_test`"
msgstr ":command:`add_test`"

#: ../../cmake-prefix/src/cmake/Help/command/site_name.rst:2
msgid "site_name"
msgstr "站点名称"

#: ../../cmake-prefix/src/cmake/Help/command/site_name.rst:4
msgid "Set the given variable to the name of the computer."
msgstr "将给定变量设置为计算机的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/site_name.rst:10
msgid ""
"On UNIX-like platforms, if the variable ``HOSTNAME`` is set, its value "
"will be executed as a command expected to print out the host name, much "
"like the ``hostname`` command-line tool."
msgstr ""
"在类 UNIX 平台上，如果设置了变量 ``HOSTNAME``，它的值将作为预期打印出主机名的命令执行，很像 ``hostname`` "
"命令行工具。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:2
msgid "source_group"
msgstr "来源组"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:4
msgid ""
"Define a grouping for source files in IDE project generation. There are "
"two different signatures to create source groups."
msgstr "在 IDE 项目生成中为源文件定义一个分组。有两种不同的签名来创建源组。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:12
msgid ""
"Defines a group into which sources will be placed in project files. This "
"is intended to set up file tabs in Visual Studio. The group is scoped in "
"the directory where the command is called, and applies to sources in "
"targets created in that directory."
msgstr ""
"定义一个组，源将被放置在项目文件中。这是为了在 Visual Studio "
"中设置文件选项卡。该组的范围在调用命令的目录中，并适用于在该目录中创建的目标中的源。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:26
msgid "``TREE``"
msgstr "``树``"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:22
msgid ""
"CMake will automatically detect, from ``<src>`` files paths, source groups"
" it needs to create, to keep structure of source groups analogically to "
"the actual files and directories structure in the project. Paths of "
"``<src>`` files will be cut to be relative to ``<root>``. The command "
"fails if the paths within ``src`` do not start with ``root``."
msgstr ""
"CMake 会自动从 ``<src>`` 文件路径中检测它需要创建的源组，以保持源组的结构类似于项目中的实际文件和目录结构。 ``<src>`` "
"文件的路径将被剪切为相对于 ``<root>``。如果 ``src`` 中的路径不以 ``root`` 开头，则命令失败。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:32
msgid "``PREFIX``"
msgstr "``前缀``"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:31
msgid ""
"Source group and files located directly in ``<root>`` path, will be placed"
" in ``<prefix>`` source groups."
msgstr "直接位于``<root>`` 路径中的源组和文件将放置在``<prefix>`` 源组中。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:37
msgid "``FILES``"
msgstr "``文件``"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:35
msgid ""
"Any source file specified explicitly will be placed in group ``<name>``.  "
"Relative paths are interpreted with respect to the current source "
"directory."
msgstr "任何明确指定的源文件都将放在组“<名称>”中。相对路径根据当前源目录进行解释。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:41
msgid "``REGULAR_EXPRESSION``"
msgstr "``REGULAR_EXPRESSION``"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:40
msgid ""
"Any source file whose name matches the regular expression will be placed "
"in group ``<name>``."
msgstr "名称与正则表达式匹配的任何源文件都将放置在组“<名称>”中。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:43
msgid ""
"If a source file matches multiple groups, the *last* group that explicitly"
" lists the file with ``FILES`` will be favored, if any. If no group "
"explicitly lists the file, the *last* group whose regular expression "
"matches the file will be favored."
msgstr ""
"如果一个源文件匹配多个组，则将优先使用明确列出带有“文件”的文件的*最后一个*组（如果有的话）。如果没有组明确列出该文件，则将优先使用其正则表达式与该文件匹配的"
" *last* 组。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:48
msgid ""
"The ``<name>`` of the group and ``<prefix>`` argument may contain forward "
"slashes or backslashes to specify subgroups.  Backslashes need to be "
"escaped appropriately:"
msgstr "组的 ``<name>`` 和 ``<prefix>`` 参数可以包含正斜杠或反斜杠来指定子组。反斜杠需要适当转义："

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:58
msgid "Allow using forward slashes (``/``) to specify subgroups."
msgstr "允许使用正斜杠 (``/``) 来指定子组。"

#: ../../cmake-prefix/src/cmake/Help/command/source_group.rst:61
msgid "For backwards compatibility, the short-hand signature"
msgstr "为了向后兼容，简写签名"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:2
msgid "string"
msgstr "细绳"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:4
msgid "String operations."
msgstr "字符串操作。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:60
msgid "Search and Replace"
msgstr "搜索和替换"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:63
msgid "Search and Replace With Plain Strings"
msgstr "搜索并替换为纯字符串"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:71
msgid ""
"Return the position where the given ``<substring>`` was found in the "
"supplied ``<string>``.  If the ``REVERSE`` flag was used, the command will"
" search for the position of the last occurrence of the specified "
"``<substring>``.  If the ``<substring>`` is not found, a position of -1 is"
" returned."
msgstr ""
"返回在提供的 ``<string>`` 中找到给定 ``<substring>`` 的位置。如果使用了 ``REVERSE`` "
"标志，该命令将搜索指定的 ``<substring>`` 最后一次出现的位置。如果未找到 ``<substring>``，则返回位置 -1。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:77
msgid ""
"The ``string(FIND)`` subcommand treats all strings as ASCII-only "
"characters. The index stored in ``<output_variable>`` will also be counted"
" in bytes, so strings containing multi-byte characters may lead to "
"unexpected results."
msgstr ""
"``string(FIND)`` 子命令将所有字符串视为纯 ASCII 字符。 ``<output_variable>`` "
"中存储的索引也将以字节计算，因此包含多字节字符的字符串可能会导致意外结果。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:89
msgid ""
"Replace all occurrences of ``<match_string>`` in the ``<input>`` with "
"``<replace_string>`` and store the result in the ``<output_variable>``."
msgstr ""
"将 ``<input>`` 中所有出现的 ``<match_string>`` 替换为 ``<replace_string>`` 并将结果存储在 "
"``<output_variable>`` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:93
msgid "Search and Replace With Regular Expressions"
msgstr "搜索并替换为正则表达式"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:102
msgid ""
"Match the ``<regular_expression>`` once and store the match in the "
"``<output_variable>``. All ``<input>`` arguments are concatenated before "
"matching. Regular expressions are specified in the subsection just below."
msgstr ""
"匹配 ``<regular_expression>`` 一次并将匹配存储在 ``<output_variable>`` "
"中。所有``<input>``参数在匹配之前被连接起来。正则表达式在下面的小节中指定。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:114
msgid ""
"Match the ``<regular_expression>`` as many times as possible and store the"
" matches in the ``<output_variable>`` as a list. All ``<input>`` arguments"
" are concatenated before matching."
msgstr ""
"尽可能多次匹配``<regular_expression>``并将匹配项作为列表存储在``<output_variable>``中。所有``<input>``参数在匹配之前被连接起来。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:126
msgid ""
"Match the ``<regular_expression>`` as many times as possible and "
"substitute the ``<replacement_expression>`` for the match in the output. "
"All ``<input>`` arguments are concatenated before matching."
msgstr ""
"尽可能多次匹配 ``<regular_expression>`` 并用 ``<replacement_expression>`` "
"替换输出中的匹配项。所有``<input>``参数在匹配之前被连接起来。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:130
msgid ""
"The ``<replacement_expression>`` may refer to parenthesis-delimited "
"subexpressions of the match using ``\\1``, ``\\2``, ..., ``\\9``.  Note "
"that two backslashes (``\\\\1``) are required in CMake code to get a "
"backslash through argument parsing."
msgstr ""
"``<replacement_expression>`` 可以使用 ``\\1``, ``\\2``, ..., ``\\9`` "
"引用匹配的括号分隔的子表达式。请注意，CMake 代码中需要两个反斜杠（``\\\\1``）才能通过参数解析获得反斜杠。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:138
msgid "Regex Specification"
msgstr "正则表达式规范"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:140
msgid ""
"The following characters have special meaning in regular expressions:"
msgstr "以下字符在正则表达式中具有特殊含义："

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:142
msgid "``^``"
msgstr "``^``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:143
msgid "Matches at beginning of input"
msgstr "在输入的开头匹配"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:144
msgid "``$``"
msgstr "``$``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:145
msgid "Matches at end of input"
msgstr "输入结束匹配"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:146
msgid "``.``"
msgstr "``.``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:147
msgid "Matches any single character"
msgstr "匹配任何单个字符"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:151
msgid "``\\<char>``"
msgstr "``\\<字符>``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:149
msgid ""
"Matches the single character specified by ``<char>``.  Use this to match "
"special regex characters, e.g. ``\\.`` for a literal ``.`` or ``\\\\`` for"
" a literal backslash ``\\``.  Escaping a non-special character is "
"unnecessary but allowed, e.g. ``\\a`` matches ``a``."
msgstr ""
"匹配由 ``<char>`` 指定的单个字符。使用它来匹配特殊的正则表达式字符，例如``\\.`` 用于文字 ``.`` 或 `\\\\`` "
"用于文字反斜杠 ``\\``。转义非特殊字符是不必要的，但允许，例如``\\a`` 匹配 ``a``。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:153
msgid "``[ ]``"
msgstr "``[]``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:154
msgid "Matches any character(s) inside the brackets"
msgstr "匹配括号内的任何字符"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:155
msgid "``[^ ]``"
msgstr "``[^]``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:156
msgid "Matches any character(s) not inside the brackets"
msgstr "匹配任何不在括号内的字符"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:161
msgid "``-``"
msgstr "``-``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:158
msgid ""
"Inside brackets, specifies an inclusive range between characters on either"
" side e.g. ``[a-f]`` is ``[abcdef]`` To match a literal ``-`` using "
"brackets, make it the first or the last character e.g. ``[+*/-]`` matches "
"basic mathematical operators."
msgstr ""
"在方括号内，指定两边字符之间的包含范围，例如``[a-f]`` 是 ``[abcdef]`` 要使用方括号匹配文字 "
"``-``，请将其作为第一个或最后一个字符，例如``[+*/-]`` 匹配基本的数学运算符。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:163
msgid "``*``"
msgstr "``*``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:164
msgid "Matches preceding pattern zero or more times"
msgstr "匹配前面的模式零次或多次"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:165
msgid "``+``"
msgstr "``+``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:166
msgid "Matches preceding pattern one or more times"
msgstr "匹配前面的模式一次或多次"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:167
msgid "``?``"
msgstr "``？``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:168
msgid "Matches preceding pattern zero or once only"
msgstr "匹配前面的模式零次或一次"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:169
msgid "``|``"
msgstr "``|``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:170
msgid "Matches a pattern on either side of the ``|``"
msgstr "匹配``|``两侧的模式"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:178
msgid "``()``"
msgstr "``（）``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:172
msgid ""
"Saves a matched subexpression, which can be referenced in the ``REGEX "
"REPLACE`` operation."
msgstr "保存匹配的子表达式，可以在 ``REGEX REPLACE`` 操作中引用。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:175
msgid ""
"All regular expression-related commands, including e.g. "
":command:`if(MATCHES)`, save subgroup matches in the variables "
":variable:`CMAKE_MATCH_<n>` for ``<n>`` 0..9."
msgstr ""
"所有与正则表达式相关的命令，包括例如 :command:`if(MATCHES)`，将子组匹配保存在变量中:variable:`CMAKE_MATCH_<n>`"
" for ``<n>`` 0..9。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:180
msgid ""
"``*``, ``+`` and ``?`` have higher precedence than concatenation.  ``|`` "
"has lower precedence than concatenation.  This means that the regular "
"expression ``^ab+d$`` matches ``abbd`` but not ``ababd``, and the regular "
"expression ``^(ab|cd)$`` matches ``ab`` but not ``abd``."
msgstr ""
"``*``、``+`` 和 ``?`` 的优先级高于串联。 ``|`` 的优先级低于串联。这意味着正则表达式 ``^ab+d$`` 匹配 "
"``abbd`` 但不匹配 ``ababd``，而正则表达式 ``^(ab|cd)$`` 匹配 ``ab``但不是``abd``。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:185
msgid ""
"CMake language :ref:`Escape Sequences` such as ``\\t``, ``\\r``, ``\\n``, "
"and ``\\\\`` may be used to construct literal tabs, carriage returns, "
"newlines, and backslashes (respectively) to pass in a regex.  For example:"
msgstr ""
"CMake 语言 :ref:`Escape Sequences` 例如 `\\t``、``\\r``、``\\n`` 和 ``\\\\`` "
"可用于构造文字制表符、回车符、换行符和反斜杠（分别）以传递正则表达式。例如："

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:189
msgid ""
"The quoted argument ``\"[ \\t\\r\\n]\"`` specifies a regex that matches "
"any single whitespace character."
msgstr "引用的参数 ``\"[ \\t\\r\\n]\" `` 指定匹配任何单个空白字符的正则表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:191
msgid ""
"The quoted argument ``\"[/\\\\]\"`` specifies a regex that matches a "
"single forward slash ``/`` or backslash ``\\``."
msgstr "引用的参数``\"[/\\\\]\"`` 指定匹配单个正斜杠``/`` 或反斜杠``\\`` 的正则表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:193
msgid ""
"The quoted argument ``\"[A-Za-z0-9_]\"`` specifies a regex that matches "
"any single \"word\" character in the C locale."
msgstr "引用的参数``\"[A-Za-z0-9_]\"`` 指定一个匹配 C 语言环境中任何单个“单词”字符的正则表达式。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:195
msgid ""
"The quoted argument ``\"\\\\(\\\\a\\\\+b\\\\)\"`` specifies a regex that "
"matches the exact string ``(a+b)``.  Each ``\\\\`` is parsed in a quoted "
"argument as just ``\\``, so the regex itself is actually "
"``\\(\\a\\+\\b\\)``.  This can alternatively be specified in a "
":ref:`bracket argument` without having to escape the backslashes, e.g. "
"``[[\\(\\a\\+\\b\\)]]``."
msgstr ""
"引用的参数 ``\"\\\\(\\\\a\\\\+b\\\\)\"`` 指定一个正则表达式来匹配精确的字符串 ``(a+b)``。每个 "
"``\\\\`` 在引用参数中被解析为 ``\\``，因此正则表达式本身实际上是 ``\\(\\a\\+\\b\\)``。这也可以在 "
":ref:`bracket argument` 中指定，而不必转义反斜杠，例如``[[\\(\\a\\+\\b\\)]]``。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:202
msgid "Manipulation"
msgstr "操纵"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:212
msgid "Append all the ``<input>`` arguments to the string."
msgstr "将所有 ``<input>`` 参数附加到字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:222
msgid "Prepend all the ``<input>`` arguments to the string."
msgstr "将所有 ``<input>`` 参数添加到字符串中。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:230
msgid ""
"Concatenate all the ``<input>`` arguments together and store the result in"
" the named ``<output_variable>``."
msgstr "将所有“<input>”参数连接在一起并将结果存储在命名的“<output_variable>”中。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:241
msgid ""
"Join all the ``<input>`` arguments together using the ``<glue>`` string "
"and store the result in the named ``<output_variable>``."
msgstr ""
"使用 ``<glue>`` 字符串将所有 ``<input>`` 参数连接在一起，并将结果存储在命名的 ``<output_variable>`` "
"中。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:244
msgid ""
"To join a list's elements, prefer to use the ``JOIN`` operator from the "
":command:`list` command.  This allows for the elements to have special "
"characters like ``;`` in them."
msgstr ""
"要连接列表的元素，最好使用 :command:`list` 命令中的 ``JOIN`` 运算符。这允许元素中包含特殊字符，如 ``;``。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:254
msgid "Convert ``<string>`` to lower characters."
msgstr "将 ``<string>`` 转换为小写字符。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:262
msgid "Convert ``<string>`` to upper characters."
msgstr "将 ``<string>`` 转换为大写字符。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:270
msgid ""
"Store in an ``<output_variable>`` a given string's length in bytes. Note "
"that this means if ``<string>`` contains multi-byte characters, the result"
" stored in ``<output_variable>`` will *not* be the number of characters."
msgstr ""
"将给定字符串的长度（以字节为单位）存储在“<output_variable>”中。请注意，这意味着如果 ``<string>`` "
"包含多字节字符，则存储在 ``<output_variable>`` 中的结果*不是*字符数。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:280
msgid ""
"Store in an ``<output_variable>`` a substring of a given ``<string>``.  If"
" ``<length>`` is ``-1`` the remainder of the string starting at "
"``<begin>`` will be returned."
msgstr ""
"在 ``<output_variable>`` 中存储给定 ``<string>`` 的子字符串。如果 ``<length>`` 为 "
"``-1``，则将返回从 ``<begin>`` 开始的字符串的其余部分。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:284
msgid ""
"If ``<string>`` is shorter than ``<length>`` then the end of the string is"
" used instead.  Previous versions of CMake reported an error in this case."
msgstr "如果 ``<string>`` 比 ``<length>`` 短，则使用字符串的结尾。以前版本的 CMake 在这种情况下会报错。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:288
msgid ""
"Both ``<begin>`` and ``<length>`` are counted in bytes, so care must be "
"exercised if ``<string>`` could contain multi-byte characters."
msgstr ""
"``<begin>`` 和 ``<length>`` 都以字节计算，因此如果 ``<string>`` 可能包含多字节字符，则必须小心。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:297
msgid ""
"Store in an ``<output_variable>`` a substring of a given ``<string>`` with"
" leading and trailing spaces removed."
msgstr "在 ``<output_variable>`` 中存储给定 ``<string>`` 的子字符串，删除前导和尾随空格。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:308
msgid ""
"Strip any :manual:`generator expressions <cmake-generator-expressions(7)>`"
" from the input ``<string>`` and store the result in the "
"``<output_variable>``."
msgstr ""
"从输入 ``<string>`` 中去除任何 :manual:`generator expressions <cmake-generator-"
"expressions(7)>` 并将结果存储在 ``<output_variable>`` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:319
msgid ""
"Produce the output string as the input ``<string>`` repeated ``<count>`` "
"times."
msgstr "将输出字符串作为输入``<string>`` 重复``<count>`` 次。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:322
msgid "Comparison"
msgstr "比较"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:335
msgid ""
"Compare the strings and store true or false in the ``<output_variable>``."
msgstr "比较字符串并将 true 或 false 存储在 ``<output_variable>`` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:337
msgid "Added the ``LESS_EQUAL`` and ``GREATER_EQUAL`` options."
msgstr "添加了 ``LESS_EQUAL`` 和 ``GREATER_EQUAL`` 选项。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:351
msgid ""
"Compute a cryptographic hash of the ``<input>`` string. The supported "
"``<HASH>`` algorithm names are:"
msgstr "计算 ``<input>`` 字符串的加密散列。支持的``<HASH>`` 算法名称是："

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:354
msgid "``MD5``"
msgstr "``MD5``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:355
msgid "Message-Digest Algorithm 5, RFC 1321."
msgstr "消息摘要算法 5，RFC 1321。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:356
msgid "``SHA1``"
msgstr "``SHA1``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:357
msgid "US Secure Hash Algorithm 1, RFC 3174."
msgstr "美国安全哈希算法 1，RFC 3174。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:358
msgid "``SHA224``"
msgstr "``SHA224``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:359
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:361
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:363
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:365
msgid "US Secure Hash Algorithms, RFC 4634."
msgstr "美国安全哈希算法，RFC 4634。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:360
msgid "``SHA256``"
msgstr "``SHA256``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:362
msgid "``SHA384``"
msgstr "``SHA384``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:364
msgid "``SHA512``"
msgstr "``SHA512``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:366
msgid "``SHA3_224``"
msgstr "``SHA3_224``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:367
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:369
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:371
#: ../../cmake-prefix/src/cmake/Help/command/string.rst:373
msgid "Keccak SHA-3."
msgstr "Keccak SHA-3。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:368
msgid "``SHA3_256``"
msgstr "``SHA3_256``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:370
msgid "``SHA3_384``"
msgstr "``SHA3_384``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:373
msgid "``SHA3_512``"
msgstr "``SHA3_512``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:375
msgid "Added the ``SHA3_*`` hash algorithms."
msgstr "添加了``SHA3_*`` 哈希算法。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:387
msgid "Convert all numbers into corresponding ASCII characters."
msgstr "将所有数字转换成相应的 ASCII 字符。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:397
msgid ""
"Convert each byte in the input ``<string>`` to its hexadecimal "
"representation and store the concatenated hex digits in the "
"``<output_variable>``. Letters in the output (``a`` through ``f``) are in "
"lowercase."
msgstr ""
"将输入“<string>”中的每个字节转换为其十六进制表示形式，并将连接的十六进制数字存储在“<output_variable>”中。输出中的字母（``a``"
" 到 ``f``）是小写的。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:408
msgid ""
"Transform a ``<string>`` like :command:`configure_file` transforms a file."
msgstr "转换一个 ``<string>`` 就像 :command:`configure_file` 转换一个文件。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:416
msgid ""
"Convert each non-alphanumeric character in the input ``<string>`` to an "
"underscore and store the result in the ``<output_variable>``.  If the "
"first character of the ``<string>`` is a digit, an underscore will also be"
" prepended to the result."
msgstr ""
"将输入“<string>”中的每个非字母数字字符转换为下划线，并将结果存储在“<output_variable>”中。如果 ``<string>``"
" 的第一个字符是数字，下划线也将添加到结果前面。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:428
msgid ""
"Return a random string of given ``<length>`` consisting of characters from"
" the given ``<alphabet>``.  Default length is 5 characters and default "
"alphabet is all numbers and upper and lower case letters. If an integer "
"``RANDOM_SEED`` is given, its value will be used to seed the random number"
" generator."
msgstr ""
"返回给定 ``<length>`` 的随机字符串，由给定 ``<alphabet>`` 中的字符组成。默认长度为 5 "
"个字符，默认字母表为所有数字和大小写字母。如果给出一个整数``RANDOM_SEED``，它的值将用于随机数生成器的种子。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:440
msgid ""
"Write a string representation of the current date and/or time to the "
"``<output_variable>``."
msgstr "将当前日期和/或时间的字符串表示写入``<output_variable>``。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:443
msgid ""
"If the command is unable to obtain a timestamp, the ``<output_variable>`` "
"will be set to the empty string ``\"\"``."
msgstr "如果命令无法获取时间戳，``<output_variable>`` 将被设置为空字符串``\"\"``。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:446
msgid ""
"The optional ``UTC`` flag requests the current date/time representation to"
" be in Coordinated Universal Time (UTC) rather than local time."
msgstr "可选的“UTC”标志要求当前日期/时间表示采用协调世界时 (UTC) 而不是本地时间。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:449
msgid ""
"The optional ``<format_string>`` may contain the following format "
"specifiers:"
msgstr "可选的 ``<format_string>`` 可能包含以下格式说明符："

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:455
#, python-format
msgid "``%%``"
msgstr "``%%``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:455
msgid "A literal percent sign (%)."
msgstr "文字百分号 (%)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:458
#, python-format
msgid "``%d``"
msgstr "``%d``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:458
msgid "The day of the current month (01-31)."
msgstr "当月的第几天 (01-31)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:461
msgid "``%H``"
msgstr "``%H``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:461
msgid "The hour on a 24-hour clock (00-23)."
msgstr "24 小时制的小时 (00-23)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:464
msgid "``%I``"
msgstr "``%我``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:464
msgid "The hour on a 12-hour clock (01-12)."
msgstr "12 小时制的小时 (01-12)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:467
msgid "``%j``"
msgstr "``%j``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:467
msgid "The day of the current year (001-366)."
msgstr "本年度的第几天 (001-366)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:470
msgid "``%m``"
msgstr "``%m``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:470
msgid "The month of the current year (01-12)."
msgstr "当前年份的月份 (01-12)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:475
msgid "``%b``"
msgstr "``%b``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:475
msgid "Abbreviated month name (e.g. Oct)."
msgstr "缩写的月份名称（例如 Oct）。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:480
msgid "``%B``"
msgstr "``%B``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:480
msgid "Full month name (e.g. October)."
msgstr "完整的月份名称（例如十月）。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:483
msgid "``%M``"
msgstr "``%M``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:483
msgid "The minute of the current hour (00-59)."
msgstr "当前小时的分钟 (00-59)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:488
#, python-format
msgid "``%s``"
msgstr "``%s``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:488
msgid "Seconds since midnight (UTC) 1-Jan-1970 (UNIX time)."
msgstr "自 1970 年 1 月 1 日午夜 (UTC) 以来的秒数（UNIX 时间）。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:491
msgid "``%S``"
msgstr "``%S``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:491
msgid ""
"The second of the current minute.  60 represents a leap second. (00-60)"
msgstr "当前分钟的秒数。 60代表闰秒。 (00-60)"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:496
#, python-format
msgid "``%f``"
msgstr "``%f``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:496
msgid "The microsecond of the current second (000000-999999)."
msgstr "当前秒的微秒 (000000-999999)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:499
msgid "``%U``"
msgstr "``%U``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:499
msgid "The week number of the current year (00-53)."
msgstr "当前年份的周数 (00-53)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:504
msgid "``%V``"
msgstr "``%V``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:504
msgid "The ISO 8601 week number of the current year (01-53)."
msgstr "当前年份的 ISO 8601 周数 (01-53)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:507
msgid "``%w``"
msgstr "``%w``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:507
msgid "The day of the current week. 0 is Sunday. (0-6)"
msgstr "当前星期几。 0 是星期天。 (0-6)"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:512
msgid "``%a``"
msgstr "``%a``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:512
msgid "Abbreviated weekday name (e.g. Fri)."
msgstr "缩写的工作日名称（例如 Fri）。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:517
msgid "``%A``"
msgstr "``%A``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:517
msgid "Full weekday name (e.g. Friday)."
msgstr "完整的工作日名称（例如星期五）。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:520
msgid "``%y``"
msgstr "``%y``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:520
msgid "The last two digits of the current year (00-99)."
msgstr "当前年份的最后两位数 (00-99)。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:523
msgid "``%Y``"
msgstr "``%Y``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:523
msgid "The current year."
msgstr "本年度。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:529
msgid "``%z``"
msgstr "``%z``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:528
msgid ""
"The offset of the time zone from UTC, in hours and minutes, with format "
"``+hhmm`` or ``-hhmm``."
msgstr "时区与 UTC 的偏移量，以小时和分钟为单位，格式为“+hhmm”或“-hhmm”。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:534
msgid "``%Z``"
msgstr "``%Z``"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:534
msgid "The time zone name."
msgstr "时区名称。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:536
msgid ""
"Unknown format specifiers will be ignored and copied to the output as-is."
msgstr "未知的格式说明符将被忽略并按原样复制到输出中。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:539
msgid "If no explicit ``<format_string>`` is given, it will default to:"
msgstr "如果没有给出明确的``<format_string>``，它将默认为："

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:546
msgid ""
"If the ``SOURCE_DATE_EPOCH`` environment variable is set, its value will "
"be used instead of the current time. See https://reproducible-"
"builds.org/specs/source-date-epoch/ for details."
msgstr ""
"如果设置了 ``SOURCE_DATE_EPOCH`` 环境变量，将使用它的值而不是当前时间。有关详细信息，请参阅 "
"https://reproducible-builds.org/specs/source-date-epoch/。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:560
msgid ""
"Create a universally unique identifier (aka GUID) as per RFC4122 based on "
"the hash of the combined values of ``<namespace>`` (which itself has to be"
" a valid UUID) and ``<name>``. The hash algorithm can be either ``MD5`` "
"(Version 3 UUID) or ``SHA1`` (Version 5 UUID). A UUID has the format "
"``xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`` where each ``x`` represents a "
"lower case hexadecimal character. Where required, an uppercase "
"representation can be requested with the optional ``UPPER`` flag."
msgstr ""
"根据 RFC4122，根据 ``<namespace>``（它本身必须是有效的 UUID）和 ``<name>`` "
"的组合值的散列创建一个通用唯一标识符（又名 GUID）。哈希算法可以是“MD5”（第 3 版 UUID）或“SHA1”（第 5 版 UUID）。 "
"UUID 的格式为“xxxxxxxx-xxxx-xxxx-xxxx-"
"xxxxxxxxxxxx”，其中每个“x”代表一个小写十六进制字符。如果需要，可以使用可选的“UPPER”标志请求大写表示。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:573
msgid "JSON"
msgstr "JSON"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:577
msgid "Functionality for querying a JSON string."
msgstr "查询 JSON 字符串的功能。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:580
msgid ""
"In each of the following JSON-related subcommands, if the optional "
"``ERROR_VARIABLE`` argument is given, errors will be reported in ``<error-"
"variable>`` and the ``<out-var>`` will be set to "
"``<member|index>-[<member|index>...]-NOTFOUND`` with the path elements up "
"to the point where the error occurred, or just ``NOTFOUND`` if there is no"
" relevant path.  If an error occurs but the ``ERROR_VARIABLE`` option is "
"not present, a fatal error message is generated.  If no error occurs, the "
"``<error-variable>`` will be set to ``NOTFOUND``."
msgstr ""
"在以下每个与 JSON 相关的子命令中，如果提供了可选的 ``ERROR_VARIABLE`` 参数，将在 ``<error-variable>``"
" 中报告错误，并设置 ``<out-var>``到 ``<member|index>-[<member|index>...]-NOTFOUND`` "
"到错误发生点的路径元素，或者如果没有相关路径则只是 "
"``NOTFOUND``。如果发生错误但不存在“ERROR_VARIABLE”选项，则会生成致命错误消息。如果没有错误发生，``<error-"
"variable>`` 将被设置为``NOTFOUND``。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:595
msgid ""
"Get an element from ``<json-string>`` at the location given by the list of"
" ``<member|index>`` arguments. Array and object elements will be returned "
"as a JSON string. Boolean elements will be returned as ``ON`` or ``OFF``. "
"Null elements will be returned as an empty string. Number and string types"
" will be returned as strings."
msgstr ""
"在由 ``<member|index>`` 参数列表给定的位置从 ``<json-string>`` 获取一个元素。数组和对象元素将作为 JSON "
"字符串返回。布尔元素将返回为 ``ON`` 或 ``OFF``。 Null 元素将作为空字符串返回。数字和字符串类型将作为字符串返回。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:608
msgid ""
"Get the type of an element in ``<json-string>`` at the location given by "
"the list of ``<member|index>`` arguments. The ``<out-var>`` will be set to"
" one of ``NULL``, ``NUMBER``, ``STRING``, ``BOOLEAN``, ``ARRAY``, or "
"``OBJECT``."
msgstr ""
"在 ``<member|index>`` 参数列表给定的位置获取 ``<json-string>`` 中元素的类型。 ``<out-var>`` "
"将被设置为 ``NULL``、``NUMBER``、``STRING``、``BOOLEAN``、``ARRAY`` 或 ``OBJECT "
"之一``。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:620
msgid ""
"Get the name of the ``<index>``-th member in ``<json-string>`` at the "
"location given by the list of ``<member|index>`` arguments. Requires an "
"element of object type."
msgstr ""
"在 ``<member|index>`` 参数列表给定的位置获取 ``<json-string>`` 中第 ``<index>`` "
"成员的名称。需要对象类型的元素。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:630
msgid ""
"Get the length of an element in ``<json-string>`` at the location given by"
" the list of ``<member|index>`` arguments. Requires an element of array or"
" object type."
msgstr ""
"在 ``<member|index>`` 参数列表给定的位置获取 ``<json-string>`` 中元素的长度。需要数组或对象类型的元素。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:640
msgid ""
"Remove an element from ``<json-string>`` at the location given by the list"
" of ``<member|index>`` arguments. The JSON string without the removed "
"element will be stored in ``<out-var>``."
msgstr ""
"在 ``<member|index>`` 参数列表给定的位置从 ``<json-string>`` 中删除一个元素。没有删除元素的 JSON "
"字符串将存储在 ``<out-var>`` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:650
msgid ""
"Set an element in ``<json-string>`` at the location given by the list of "
"``<member|index>`` arguments to ``<value>``. The contents of ``<value>`` "
"should be valid JSON."
msgstr ""
"在 ``<member|index>`` 参数列表给定的位置处将 ``<json-string>`` 中的元素设置为 ``<value>``。 "
"``<value>`` 的内容应该是有效的 JSON。"

#: ../../cmake-prefix/src/cmake/Help/command/string.rst:660
msgid ""
"Compare the two JSON objects given by ``<json-string1>`` and ``<json-"
"string2>`` for equality.  The contents of ``<json-string1>`` and ``<json-"
"string2>`` should be valid JSON.  The ``<out-var>`` will be set to a true "
"value if the JSON objects are considered equal, or a false value "
"otherwise."
msgstr ""
"比较 ``<json-string1>`` 和 ``<json-string2>`` 给出的两个 JSON 对象是否相等。 ``<json-"
"string1>`` 和``<json-string2>`` 的内容应该是有效的 JSON。如果 JSON 对象被认为相等，则 ``<out-"
"var>`` 将设置为真值，否则设置为假值。"

#: ../../cmake-prefix/src/cmake/Help/command/subdir_depends.rst:2
msgid "subdir_depends"
msgstr "子目录依赖"

#: ../../cmake-prefix/src/cmake/Help/command/subdir_depends.rst:4
msgid "Disallowed since version 3.0.  See CMake Policy :policy:`CMP0029`."
msgstr "3.0 版后不允许。请参阅 CMake 政策:policy:`CMP0029`。"

#: ../../cmake-prefix/src/cmake/Help/command/subdir_depends.rst:6
msgid "Does nothing."
msgstr "什么也没做。"

#: ../../cmake-prefix/src/cmake/Help/command/subdir_depends.rst:12
msgid ""
"Does not do anything.  This command used to help projects order parallel "
"builds correctly.  This functionality is now automatic."
msgstr "什么都不做。此命令用于帮助项目正确排序并行构建。此功能现在是自动的。"

#: ../../cmake-prefix/src/cmake/Help/command/subdirs.rst:2
msgid "subdirs"
msgstr "子目录"

#: ../../cmake-prefix/src/cmake/Help/command/subdirs.rst:6
msgid "Use the :command:`add_subdirectory` command instead."
msgstr "请改用 :command:`add_subdirectory` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/subdirs.rst:8
msgid "Add a list of subdirectories to the build."
msgstr "将子目录列表添加到构建中。"

#: ../../cmake-prefix/src/cmake/Help/command/subdirs.rst:15
msgid ""
"Add a list of subdirectories to the build.  The "
":command:`add_subdirectory` command should be used instead of ``subdirs`` "
"although ``subdirs`` will still work.  This will cause any CMakeLists.txt "
"files in the sub directories to be processed by CMake.  Any directories "
"after the ``PREORDER`` flag are traversed first by makefile builds, the "
"``PREORDER`` flag has no effect on IDE projects.  Any directories after "
"the ``EXCLUDE_FROM_ALL`` marker will not be included in the top level "
"makefile or project file.  This is useful for having CMake create "
"makefiles or projects for a set of examples in a project.  You would want "
"CMake to generate makefiles or project files for all the examples at the "
"same time, but you would not want them to show up in the top level project"
" or be built each time make is run from the top."
msgstr ""
"将子目录列表添加到构建中。应该使用 :command:`add_subdirectory` 命令代替 ``subdirs`` 尽管 "
"``subdirs`` 仍然有效。这将导致 CMake 处理子目录中的所有 CMakeLists.txt 文件。 ``PREORDER`` "
"标志之后的任何目录首先由 makefile 构建遍历，``PREORDER`` 标志对 IDE 项目没有影响。 "
"``EXCLUDE_FROM_ALL`` 标记之后的任何目录都不会包含在顶级 makefile 或项目文件中。这对于让 CMake "
"为项目中的一组示例创建 makefile 或项目很有用。您可能希望 CMake 同时为所有示例生成 makefile "
"或项目文件，但您不希望它们出现在顶级项目中或每次从顶部运行 make 时都构建它们。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:2
msgid "target_compile_definitions"
msgstr "目标编译定义"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:4
msgid "Add compile definitions to a target."
msgstr "将编译定义添加到目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:12
msgid ""
"Specifies compile definitions to use when compiling a given ``<target>``."
"  The named ``<target>`` must have been created by a command such as "
":command:`add_executable` or :command:`add_library` and must not be an "
":ref:`ALIAS target <Alias Targets>`."
msgstr ""
"指定编译给定的 ``<target>`` 时要使用的编译定义。命名的 ``<target>`` 必须由命令创建，例如 "
":command:`add_executable` 或 :command:`add_library` 并且不能是 :ref:`ALIAS "
"target <Alias Targets>`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:17
msgid ""
"The ``INTERFACE``, ``PUBLIC`` and ``PRIVATE`` keywords are required to "
"specify the :ref:`scope <Target Usage Requirements>` of the following "
"arguments. ``PRIVATE`` and ``PUBLIC`` items will populate the "
":prop_tgt:`COMPILE_DEFINITIONS` property of ``<target>``. ``PUBLIC`` and "
"``INTERFACE`` items will populate the "
":prop_tgt:`INTERFACE_COMPILE_DEFINITIONS` property of ``<target>``. The "
"following arguments specify compile definitions.  Repeated calls for the "
"same ``<target>`` append items in the order called."
msgstr ""
"需要 ``INTERFACE``、``PUBLIC`` 和 ``PRIVATE`` 关键字来指定以下参数的范围 <Target Usage "
"Requirements>`。 ``PRIVATE`` 和 ``PUBLIC`` 项将填充 ``<target>`` 的 "
":prop_tgt:`COMPILE_DEFINITIONS` 属性。 ``PUBLIC`` 和 ``INTERFACE`` 项将填充 "
"``<target>`` 的 :prop_tgt:`INTERFACE_COMPILE_DEFINITIONS` "
"属性。以下参数指定编译定义。重复调用相同的 ``<target>`` 按调用的顺序追加项目。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:25
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:26
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:33
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:27
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:38
msgid ""
"Allow setting ``INTERFACE`` items on :ref:`IMPORTED targets <Imported "
"Targets>`."
msgstr "允许在 :ref:`IMPORTED 目标 <Imported Targets> 上设置 ``INTERFACE`` 项目。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:31
msgid ""
"Any leading ``-D`` on an item will be removed.  Empty items are ignored. "
"For example, the following are all equivalent:"
msgstr "项目上任何前导的 ``-D`` 都将被删除。空项将被忽略。例如，以下都是等价的："

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:41
msgid "Definitions may optionally have values:"
msgstr "定义可以有选择地具有值："

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:47
msgid ""
"Note that many compilers treat ``-DFOO`` as equivalent to ``-DFOO=1``, but"
" other tools may not recognize this in all circumstances (e.g. "
"IntelliSense)."
msgstr ""
"请注意，许多编译器将“-DFOO”视为等同于“-DFOO=1”，但其他工具可能无法在所有情况下识别这一点（例如 IntelliSense）。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:53
msgid ":command:`add_compile_definitions`"
msgstr ":command:`add_compile_definitions`"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:54
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:53
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:81
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:63
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:415
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:58
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:127
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:212
msgid ":command:`target_compile_features`"
msgstr ":command:`target_compile_features`"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:55
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:43
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:82
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:64
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:416
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:59
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:128
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:213
msgid ":command:`target_compile_options`"
msgstr ":command:`target_compile_options`"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:60
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:48
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:57
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:86
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:68
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:420
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:63
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:218
msgid ":command:`target_precompile_headers`"
msgstr ":command:`target_precompile_headers`"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_definitions.rst:61
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:49
#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:58
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:87
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:69
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:421
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:64
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:133
msgid ":command:`target_sources`"
msgstr ":command:`target_sources`"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:2
msgid "target_compile_features"
msgstr "target_compile_features"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:6
msgid "Add expected compiler features to a target."
msgstr "将预期的编译器功能添加到目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:12
msgid ""
"Specifies compiler features required when compiling a given target.  If "
"the feature is not listed in the :variable:`CMAKE_C_COMPILE_FEATURES`, "
":variable:`CMAKE_CUDA_COMPILE_FEATURES`, or "
":variable:`CMAKE_CXX_COMPILE_FEATURES` variables, then an error will be "
"reported by CMake.  If the use of the feature requires an additional "
"compiler flag, such as ``-std=gnu++11``, the flag will be added "
"automatically."
msgstr ""
"指定编译给定目标时所需的编译器功能。如果该功能未在 "
"CMAKE_C_COMPILE_FEATURES、CMAKE_CUDA_COMPILE_FEATURES 或 "
"CMAKE_CXX_COMPILE_FEATURES 变量中列出，则 CMake "
"将报告错误。如果使用该功能需要额外的编译器标志，例如“-std=gnu++11”，该标志将自动添加。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:19
msgid ""
"The ``INTERFACE``, ``PUBLIC`` and ``PRIVATE`` keywords are required to "
"specify the scope of the features.  ``PRIVATE`` and ``PUBLIC`` items will "
"populate the :prop_tgt:`COMPILE_FEATURES` property of ``<target>``. "
"``PUBLIC`` and ``INTERFACE`` items will populate the "
":prop_tgt:`INTERFACE_COMPILE_FEATURES` property of ``<target>``. Repeated "
"calls for the same ``<target>`` append items."
msgstr ""
"需要“INTERFACE”、“PUBLIC”和“PRIVATE”关键字来指定功能的范围。 ``PRIVATE`` 和 ``PUBLIC`` 项将填充"
" ``<target>`` 的 :prop_tgt:`COMPILE_FEATURES` 属性。 ``PUBLIC`` 和 "
"``INTERFACE`` 项将填充 ``<target>`` 的 :prop_tgt:`INTERFACE_COMPILE_FEATURES` "
"属性。重复调用相同的 ``<target>`` 附加项。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:29
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:19
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:15
msgid ""
"The named ``<target>`` must have been created by a command such as "
":command:`add_executable` or :command:`add_library` and must not be an "
":ref:`ALIAS target <Alias Targets>`."
msgstr ""
"命名的 ``<target>`` 必须由命令创建，例如 :command:`add_executable` 或 "
":command:`add_library` 并且不能是 :ref:`ALIAS target <Alias Targets>`。"

#: ../../cmake-prefix/src/cmake/Help/command/GENEX_NOTE.txt:1
msgid "for more on defining buildsystem properties."
msgstr "有关定义构建系统属性的更多信息。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_features.rst:42
#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:80
#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:62
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:414
#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:57
#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:126
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:211
msgid ":command:`target_compile_definitions`"
msgstr ":command:`target_compile_definitions`"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:2
msgid "target_compile_options"
msgstr "目标编译选项"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:4
msgid "Add compile options to a target."
msgstr "向目标添加编译选项。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:12
msgid ""
"Adds options to the :prop_tgt:`COMPILE_OPTIONS` or "
":prop_tgt:`INTERFACE_COMPILE_OPTIONS` target properties. These options are"
" used when compiling the given ``<target>``, which must have been created "
"by a command such as :command:`add_executable` or :command:`add_library` "
"and must not be an :ref:`ALIAS target <Alias Targets>`."
msgstr ""
"添加选项到 :prop_tgt:`COMPILE_OPTIONS` 或 :prop_tgt:`INTERFACE_COMPILE_OPTIONS` "
"目标属性。这些选项在编译给定的 ``<target>`` 时使用，它们必须由诸如 :command:`add_executable` 或 "
":command:`add_library` 之类的命令创建，并且不能是 :ref:`ALIAS 目标<别名目标>`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:21
msgid ""
"If ``BEFORE`` is specified, the content will be prepended to the property "
"instead of being appended.  See policy :policy:`CMP0101` which affects "
"whether ``BEFORE`` will be ignored in certain cases."
msgstr ""
"如果指定了 "
"``BEFORE``，则内容将被添加到属性中而不是附加到属性中。请参阅政策:policy:`CMP0101`，它会影响在某些情况下是否会忽略``BEFORE``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:25
msgid ""
"The ``INTERFACE``, ``PUBLIC`` and ``PRIVATE`` keywords are required to "
"specify the :ref:`scope <Target Usage Requirements>` of the following "
"arguments. ``PRIVATE`` and ``PUBLIC`` items will populate the "
":prop_tgt:`COMPILE_OPTIONS` property of ``<target>``.  ``PUBLIC`` and "
"``INTERFACE`` items will populate the "
":prop_tgt:`INTERFACE_COMPILE_OPTIONS` property of ``<target>``. The "
"following arguments specify compile options.  Repeated calls for the same "
"``<target>`` append items in the order called."
msgstr ""
"需要 ``INTERFACE``、``PUBLIC`` 和 ``PRIVATE`` 关键字来指定以下参数的范围 <Target Usage "
"Requirements>`。 ``PRIVATE`` 和 ``PUBLIC`` 项将填充 ``<target>`` 的 "
":prop_tgt:`COMPILE_OPTIONS` 属性。 ``PUBLIC`` 和 ``INTERFACE`` 项将填充 "
"``<target>`` 的 :prop_tgt:`INTERFACE_COMPILE_OPTIONS` 属性。以下参数指定编译选项。重复调用相同的"
" ``<target>`` 按调用的顺序追加项目。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:44
msgid ""
"This command can be used to add any options. However, for adding "
"preprocessor definitions and include directories it is recommended to use "
"the more specific commands :command:`target_compile_definitions` and "
":command:`target_include_directories`."
msgstr ""
"此命令可用于添加任何选项。但是，为了添加预处理器定义和包含目录，建议使用更具体的命令:command:`target_compile_definitions`"
" 和:command:`target_include_directories`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:49
msgid ""
"For directory-wide settings, there is the command "
":command:`add_compile_options`."
msgstr "对于目录范围的设置，有命令:command:`add_compile_options`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_compile_options.rst:51
msgid ""
"For file-specific settings, there is the source file property "
":prop_sf:`COMPILE_OPTIONS`."
msgstr "对于特定于文件的设置，有源文件属性 :prop_sf:`COMPILE_OPTIONS`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:2
msgid "target_include_directories"
msgstr "target_include_directories"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:4
msgid "Add include directories to a target."
msgstr "将包含目录添加到目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:12
msgid ""
"Specifies include directories to use when compiling a given target. The "
"named ``<target>`` must have been created by a command such as "
":command:`add_executable` or :command:`add_library` and must not be an "
":ref:`ALIAS target <Alias Targets>`."
msgstr ""
"指定编译给定目标时要使用的包含目录。命名的 ``<target>`` 必须由命令创建，例如 :command:`add_executable` 或 "
":command:`add_library` 并且不能是 :ref:`ALIAS target <Alias Targets>`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:17
msgid ""
"By using ``AFTER`` or ``BEFORE`` explicitly, you can select between "
"appending and prepending, independent of the default."
msgstr "通过显式使用 ``AFTER`` 或 ``BEFORE``，您可以独立于默认值在追加和前置之间进行选择。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:20
msgid ""
"The ``INTERFACE``, ``PUBLIC`` and ``PRIVATE`` keywords are required to "
"specify the :ref:`scope <Target Usage Requirements>` of the following "
"arguments. ``PRIVATE`` and ``PUBLIC`` items will populate the "
":prop_tgt:`INCLUDE_DIRECTORIES` property of ``<target>``. ``PUBLIC`` and "
"``INTERFACE`` items will populate the "
":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` property of ``<target>``. The "
"following arguments specify include directories."
msgstr ""
"需要 ``INTERFACE``、``PUBLIC`` 和 ``PRIVATE`` 关键字来指定以下参数的范围 <Target Usage "
"Requirements>`。 ``PRIVATE`` 和 ``PUBLIC`` 项将填充 ``<target>`` 的 "
":prop_tgt:`INCLUDE_DIRECTORIES` 属性。 ``PUBLIC`` 和 ``INTERFACE`` 项将填充 "
"``<target>`` 的 :prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES` 属性。以下参数指定包含目录。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:30
#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:33
msgid ""
"Repeated calls for the same ``<target>`` append items in the order called."
msgstr "重复调用相同的 ``<target>`` 按调用的顺序追加项目。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:32
msgid ""
"If ``SYSTEM`` is specified, the compiler will be told the directories are "
"meant as system include directories on some platforms.  This may have "
"effects such as suppressing warnings or skipping the contained headers in "
"dependency calculations (see compiler documentation). Additionally, system"
" include directories are searched after normal include directories "
"regardless of the order specified."
msgstr ""
"如果指定了“SYSTEM”，编译器将被告知这些目录在某些平台上是系统包含目录。这可能会产生诸如抑制警告或跳过依赖项计算中包含的标头等效果（请参阅编译器文档）。此外，无论指定的顺序如何，都会在正常包含目录之后搜索系统包含目录。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:39
msgid ""
"If ``SYSTEM`` is used together with ``PUBLIC`` or ``INTERFACE``, the "
":prop_tgt:`INTERFACE_SYSTEM_INCLUDE_DIRECTORIES` target property will be "
"populated with the specified directories."
msgstr ""
"如果``SYSTEM`` 与``PUBLIC`` 或``INTERFACE`` "
"一起使用， :prop_tgt:`INTERFACE_SYSTEM_INCLUDE_DIRECTORIES` 目标属性将填充指定的目录。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:46
msgid ""
"Specified include directories may be absolute paths or relative paths. A "
"relative path will be interpreted as relative to the current source "
"directory (i.e. :variable:`CMAKE_CURRENT_SOURCE_DIR`) and converted to an "
"absolute path before storing it in the associated target property. If the "
"path starts with a generator expression, it will always be assumed to be "
"an absolute path (with one exception noted below) and will be used "
"unmodified."
msgstr ""
"指定的包含目录可以是绝对路径也可以是相对路径。相对路径将被解释为相对于当前源目录（即 :variable:`CMAKE_CURRENT_SOURCE_DIR`）并在将其存储在关联的目标属性之前转换为绝对路径。如果路径以生成器表达式开头，它将始终被假定为绝对路径（下面提到的一个例外）并且将不加修改地使用。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:54
msgid ""
"Include directories usage requirements commonly differ between the build-"
"tree and the install-tree.  The :genex:`BUILD_INTERFACE` and "
":genex:`INSTALL_INTERFACE` generator expressions can be used to describe "
"separate usage requirements based on the usage location.  Relative paths "
"are allowed within the :genex:`INSTALL_INTERFACE` expression and are "
"interpreted as relative to the installation prefix.  Relative paths should"
" not be used in :genex:`BUILD_INTERFACE` expressions because they will not"
" be converted to absolute.  For example:"
msgstr ""
"包含目录的使用要求通常在构建树和安装树之间有所不同。 :genex:`BUILD_INTERFACE` 和 "
":genex:`INSTALL_INTERFACE` 生成器表达式可用于根据使用位置描述单独的使用要求。 "
":genex:`INSTALL_INTERFACE` 表达式中允许使用相对路径，并被解释为相对于安装前缀。相对路径不应在 "
"BUILD_INTERFACE 表达式中使用，因为它们不会被转换为绝对路径。例如："

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:71
#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:406
msgid "Creating Relocatable Packages"
msgstr "创建可重定位包"

#: ../../cmake-prefix/src/cmake/Help/include/INTERFACE_INCLUDE_DIRECTORIES_WARNING.txt:2
msgid ""
"Note that it is not advisable to populate the :genex:`INSTALL_INTERFACE` "
"of the |INTERFACE_PROPERTY_LINK| of a target with absolute paths to the "
"include directories of dependencies.  That would hard-code into installed "
"packages the include directory paths for dependencies **as found on the "
"machine the package was made on**."
msgstr ""
"请注意，不建议填充 |INTERFACE_PROPERTY_LINK| 的 "
":genex:`INSTALL_INTERFACE`具有到依赖项包含目录的绝对路径的目标。这会将硬编码到已安装的包中，包括依赖项的目录路径**在创建包的机器上**。"

#: ../../cmake-prefix/src/cmake/Help/include/INTERFACE_INCLUDE_DIRECTORIES_WARNING.txt:8
msgid ""
"The :genex:`INSTALL_INTERFACE` of the |INTERFACE_PROPERTY_LINK| is only "
"suitable for specifying the required include directories for headers "
"provided with the target itself, not those provided by the transitive "
"dependencies listed in its :prop_tgt:`INTERFACE_LINK_LIBRARIES` target "
"property.  Those dependencies should themselves be targets that specify "
"their own header locations in |INTERFACE_PROPERTY_LINK|."
msgstr ""
"|INTERFACE_PROPERTY_LINK| 的 "
":genex:`INSTALL_INTERFACE`仅适用于为目标本身提供的标头指定所需的包含目录，而不适用于其 "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` 目标属性中列出的传递依赖项提供的目录。这些依赖项本身应该是在 "
"|INTERFACE_PROPERTY_LINK| 中指定自己的标头位置的目标。"

#: ../../cmake-prefix/src/cmake/Help/include/INTERFACE_INCLUDE_DIRECTORIES_WARNING.txt:15
#: ../../cmake-prefix/src/cmake/Help/include/INTERFACE_LINK_LIBRARIES_WARNING.txt:7
msgid ""
"See the :ref:`Creating Relocatable Packages` section of the "
":manual:`cmake-packages(7)` manual for discussion of additional care that "
"must be taken when specifying usage requirements while creating packages "
"for redistribution."
msgstr ""
"请参阅 :ref:`cmake-packages(7)` 手册的 :ref:`Creating Relocatable Packages` "
"部分，讨论在创建用于重新分发的包时指定使用要求时必须注意的额外注意事项。"

#: ../../cmake-prefix/src/cmake/Help/command/target_include_directories.rst:79
msgid ":command:`include_directories`"
msgstr ":command:`include_directories`"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:2
msgid "target_link_directories"
msgstr "目标链接目录"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:6
msgid "Add link directories to a target."
msgstr "将链接目录添加到目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:14
msgid ""
"Specifies the paths in which the linker should search for libraries when "
"linking a given target.  Each item can be an absolute or relative path, "
"with the latter being interpreted as relative to the current source "
"directory.  These items will be added to the link command."
msgstr ""
"指定链接器在链接给定目标时应在其中搜索库的路径。每个项目可以是绝对路径或相对路径，后者被解释为相对于当前源目录。这些项目将被添加到链接命令中。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:23
msgid ""
"The ``INTERFACE``, ``PUBLIC`` and ``PRIVATE`` keywords are required to "
"specify the :ref:`scope <Target Usage Requirements>` of the items that "
"follow them. ``PRIVATE`` and ``PUBLIC`` items will populate the "
":prop_tgt:`LINK_DIRECTORIES` property of ``<target>``.  ``PUBLIC`` and "
"``INTERFACE`` items will populate the "
":prop_tgt:`INTERFACE_LINK_DIRECTORIES` property of ``<target>`` "
"(:ref:`IMPORTED targets <Imported Targets>` only support ``INTERFACE`` "
"items). Each item specifies a link directory and will be converted to an "
"absolute path if necessary before adding it to the relevant property.  "
"Repeated calls for the same ``<target>`` append items in the order called."
msgstr ""
"需要 ``INTERFACE``、``PUBLIC`` 和 ``PRIVATE`` 关键字来指定它们后面的项目的 :ref:`scope "
"<Target Usage Requirements>`。 ``PRIVATE`` 和 ``PUBLIC`` 项将填充 ``<target>`` "
"的 :prop_tgt:`LINK_DIRECTORIES` 属性。 ``PUBLIC`` 和 ``INTERFACE`` 项将填充 "
"``<target>`` 的 :prop_tgt:`INTERFACE_LINK_DIRECTORIES` 属性（ :ref:`IMPORTED 目标"
" <Imported Targets>` 仅支持 ``INTERFACE`` "
"项).每个项目指定一个链接目录，并在将其添加到相关属性之前根据需要将其转换为绝对路径。重复调用相同的 ``<target>`` "
"按调用的顺序追加项目。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:34
msgid ""
"If ``BEFORE`` is specified, the content will be prepended to the relevant "
"property instead of being appended."
msgstr "如果指定了 ``BEFORE``，内容将被添加到相关属性之前，而不是被追加。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_directories.rst:61
msgid ":command:`link_directories`"
msgstr ":command:`link_directories`"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:2
msgid "target_link_libraries"
msgstr "目标链接库"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:8
msgid ""
"Specify libraries or flags to use when linking a given target and/or its "
"dependents.  :ref:`Usage requirements <Target Usage Requirements>` from "
"linked library targets will be propagated.  Usage requirements of a "
"target's dependencies affect compilation of its own sources."
msgstr ""
"指定链接给定目标和/或其依赖项时要使用的库或标志。 :ref:`使用要求 <Target Usage Requirements>` "
"来自链接库目标将被传播。目标依赖项的使用要求会影响其自身源代码的编译。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:14
msgid "Overview"
msgstr "概述"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:16
msgid ""
"This command has several signatures as detailed in subsections below. All "
"of them have the general form"
msgstr "此命令有几个签名，详见以下小节。它们都有一般形式"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:23
msgid ""
"The named ``<target>`` must have been created by a command such as "
":command:`add_executable` or :command:`add_library` and must not be an "
":ref:`ALIAS target <Alias Targets>`.  If policy :policy:`CMP0079` is not "
"set to ``NEW`` then the target must have been created in the current "
"directory.  Repeated calls for the same ``<target>`` append items in the "
"order called."
msgstr ""
"命名的 ``<target>`` 必须由命令创建，例如 :command:`add_executable` 或 "
":command:`add_library` 并且不能是 :ref:`ALIAS target <Alias Targets>`。如果 "
"policy:policy:`CMP0079` 未设置为 ``NEW`` 则目标必须已在当前目录中创建。重复调用相同的 ``<target>`` "
"按调用的顺序追加项目。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:30
msgid ""
"The ``<target>`` doesn't have to be defined in the same directory as the "
"``target_link_libraries`` call."
msgstr "``<target>`` 不必在与``target_link_libraries`` 调用相同的目录中定义。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:34
msgid "Each ``<item>`` may be:"
msgstr "每个 ``<item>`` 可能是："

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:36
msgid ""
"**A library target name**: The generated link line will have the full path"
" to the linkable library file associated with the target. The buildsystem "
"will have a dependency to re-link ``<target>`` if the library file "
"changes."
msgstr ""
"**库目标名称**：生成的链接行将具有与目标关联的可链接库文件的完整路径。如果库文件发生变化，构建系统将依赖于重新链接 ``<target>``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:41
msgid ""
"The named target must be created by :command:`add_library` within the "
"project or as an :ref:`IMPORTED library <Imported Targets>`. If it is "
"created within the project an ordering dependency will automatically be "
"added in the build system to make sure the named library target is up-to-"
"date before the ``<target>`` links."
msgstr ""
"命名目标必须由项目中的 :command:`add_library` 创建或作为 :ref:`IMPORTED 库 <Imported "
"Targets>` 创建。如果它是在项目中创建的，则会在构建系统中自动添加一个排序依赖项，以确保命名的库目标在 ``<target>`` "
"链接之前是最新的。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:47
msgid ""
"If an imported library has the :prop_tgt:`IMPORTED_NO_SONAME` target "
"property set, CMake may ask the linker to search for the library instead "
"of using the full path (e.g. ``/usr/lib/libfoo.so`` becomes ``-lfoo``)."
msgstr ""
"如果导入的库设置了 :prop_tgt:`IMPORTED_NO_SONAME` 目标属性，CMake "
"可能会要求链接器搜索库而不是使用完整路径（例如，``/usr/lib/libfoo.so`` 变为 ``- lfoo``）。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:52
msgid ""
"The full path to the target's artifact will be quoted/escaped for the "
"shell automatically."
msgstr "目标工件的完整路径将自动为 shell 引用/转义。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:55
msgid ""
"**A full path to a library file**: The generated link line will normally "
"preserve the full path to the file. The buildsystem will have a dependency"
" to re-link ``<target>`` if the library file changes."
msgstr ""
"**库文件的完整路径**：生成的链接行通常会保留文件的完整路径。如果库文件发生变化，构建系统将依赖于重新链接 ``<target>``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:59
msgid ""
"There are some cases where CMake may ask the linker to search for the "
"library (e.g. ``/usr/lib/libfoo.so`` becomes ``-lfoo``), such as when a "
"shared library is detected to have no ``SONAME`` field. See policy "
":policy:`CMP0060` for discussion of another case."
msgstr ""
"在某些情况下，CMake 可能会要求链接器搜索库（例如，``/usr/lib/libfoo.so`` 变为 "
"``-lfoo``），例如当检测到共享库没有 ` `SONAME`` 字段。有关另一个案例的讨论，请参阅政策:policy:`CMP0060`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:64
msgid ""
"If the library file is in a macOS framework, the ``Headers`` directory of "
"the framework will also be processed as a :ref:`usage requirement <Target "
"Usage Requirements>`.  This has the same effect as passing the framework "
"directory as an include directory."
msgstr ""
"如果库文件在 macOS 框架中，框架的 ``Headers`` 目录也会被处理为 :ref:`usage requirement <Target "
"Usage Requirements>`。这与将框架目录作为包含目录传递具有相同的效果。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:69
msgid ""
"On :ref:`Visual Studio Generators` for VS 2010 and above, library files "
"ending in ``.targets`` will be treated as MSBuild targets files and "
"imported into generated project files.  This is not supported by other "
"generators."
msgstr ""
"在 VS 2010 及更高版本的 Visual Studio Generators 上，以 .targets 结尾的库文件将被视为 MSBuild "
"目标文件并导入到生成的项目文件中。其他生成器不支持此功能。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:75
msgid ""
"The full path to the library file will be quoted/escaped for the shell "
"automatically."
msgstr "库文件的完整路径将自动为 shell 引用/转义。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:78
msgid ""
"**A plain library name**: The generated link line will ask the linker to "
"search for the library (e.g. ``foo`` becomes ``-lfoo`` or ``foo.lib``)."
msgstr "**普通库名称**：生成的链接行将要求链接器搜索库（例如，``foo`` 变为 ``-lfoo`` 或 ``foo.lib``）。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:81
msgid ""
"The library name/flag is treated as a command-line string fragment and "
"will be used with no extra quoting or escaping."
msgstr "库名称/标志被视为命令行字符串片段，将在没有额外引号或转义的情况下使用。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:84
msgid ""
"**A link flag**: Item names starting with ``-``, but not ``-l`` or "
"``-framework``, are treated as linker flags.  Note that such flags will be"
" treated like any other library link item for purposes of transitive "
"dependencies, so they are generally safe to specify only as private link "
"items that will not propagate to dependents."
msgstr ""
"**链接标志**：以“-”开头但不是“-l”或“-framework”的项目名称被视为链接器标志。请注意，出于传递依赖性的目的，此类标志将像任何其他库链接项一样对待，因此通常可以安全地将它们指定为不会传播到依赖项的私有链接项。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:90
msgid ""
"Link flags specified here are inserted into the link command in the same "
"place as the link libraries. This might not be correct, depending on the "
"linker. Use the :prop_tgt:`LINK_OPTIONS` target property or "
":command:`target_link_options` command to add link flags explicitly. The "
"flags will then be placed at the toolchain-defined flag position in the "
"link command."
msgstr ""
"此处指定的链接标志被插入到链接命令中与链接库相同的位置。这可能不正确，具体取决于链接器。使用 :prop_tgt:`LINK_OPTIONS` "
"目标属性或 :command:`target_link_options` "
"命令显式添加链接标志。然后，这些标志将被放置在链接命令中工具链定义的标志位置。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:97
msgid ""
":prop_tgt:`LINK_OPTIONS` target property and "
":command:`target_link_options` command.  For earlier versions of CMake, "
"use :prop_tgt:`LINK_FLAGS` property instead."
msgstr ""
":prop_tgt:`LINK_OPTIONS` 目标属性和 :command:`target_link_options` 命令。对于早期版本的 "
"CMake，请改用 :prop_tgt:`LINK_FLAGS` 属性。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:102
msgid ""
"The link flag is treated as a command-line string fragment and will be "
"used with no extra quoting or escaping."
msgstr "链接标志被视为命令行字符串片段，将在没有额外引号或转义的情况下使用。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:105
msgid ""
"**A generator expression**: A ``$<...>`` :manual:`generator expression "
"<cmake-generator-expressions(7)>` may evaluate to any of the above items "
"or to a :ref:`semicolon-separated list <CMake Language Lists>` of them. If"
" the ``...`` contains any ``;`` characters, e.g. after evaluation of a "
"``${list}`` variable, be sure to use an explicitly quoted argument "
"``\"$<...>\"`` so that this command receives it as a single ``<item>``."
msgstr ""
"**生成器表达式**：``$<...>`` :manual:`generator expression <cmake-generator-"
"expressions(7)>` 可以计算为上述任何项目或 :ref: `以分号分隔的列表 <CMake Language Lists>` "
"其中的。如果 ``...`` 包含任何 ``;`` 字符，例如在对 ``${list}`` 变量求值后，一定要使用显式引用的参数 "
"``\"$<...>\"`` 以便此命令将其作为单个 ``<item>`` 接收."

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:113
msgid ""
"Additionally, a generator expression may be used as a fragment of any of "
"the above items, e.g. ``foo$<1:_d>``."
msgstr "此外，生成器表达式可以用作上述任何项目的片段，例如``foo$<1:_d>``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:116
msgid ""
"Note that generator expressions will not be used in OLD handling of policy"
" :policy:`CMP0003` or policy :policy:`CMP0004`."
msgstr "请注意，生成器表达式不会用于政策的旧处理:policy:`CMP0003` 或政策:policy:`CMP0004`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:119
msgid ""
"A ``debug``, ``optimized``, or ``general`` keyword immediately followed by"
" another ``<item>``.  The item following such a keyword will be used only "
"for the corresponding build configuration.  The ``debug`` keyword "
"corresponds to the ``Debug`` configuration (or to configurations named in "
"the :prop_gbl:`DEBUG_CONFIGURATIONS` global property if it is set). The "
"``optimized`` keyword corresponds to all other configurations.  The "
"``general`` keyword corresponds to all configurations, and is purely "
"optional.  Higher granularity may be achieved for per-configuration rules "
"by creating and linking to :ref:`IMPORTED library targets <Imported "
"Targets>`. These keywords are interpreted immediately by this command and "
"therefore have no special meaning when produced by a generator expression."
msgstr ""
"``debug``、``optimized`` 或 ``general`` 关键字紧跟另一个 "
"``<item>``。这样的关键字后面的项目将仅用于相应的构建配置。 ``debug`` 关键字对应于 ``Debug`` 配置（或在 "
":prop_gbl:`DEBUG_CONFIGURATIONS` 全局属性中命名的配置，如果已设置）。 ``optimized`` "
"关键字对应于所有其他配置。 ``general`` 关键字对应所有配置，纯属可选。通过创建并链接到 :ref:`IMPORTED library "
"targets <Imported "
"Targets>`，可以为每个配置规则实现更高的粒度。这些关键字由该命令立即解释，因此在由生成器表达式生成时没有特殊含义。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:132
msgid ""
"Items containing ``::``, such as ``Foo::Bar``, are assumed to be "
":ref:`IMPORTED <Imported Targets>` or :ref:`ALIAS <Alias Targets>` library"
" target names and will cause an error if no such target exists. See policy"
" :policy:`CMP0028`."
msgstr ""
"包含 ``::`` 的项目，例如 ``Foo::Bar``，被假定为 :ref:`IMPORTED <Imported Targets>` 或 "
":ref:`ALIAS <Alias Targets>` 库目标名称并将如果不存在这样的目标，则会导致错误。请参阅政策:policy:`CMP0028`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:141
msgid "Libraries for a Target and/or its Dependents"
msgstr "目标和/或其从属的库"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:149
msgid ""
"The ``PUBLIC``, ``PRIVATE`` and ``INTERFACE`` :ref:`scope <Target Usage "
"Requirements>` keywords can be used to specify both the link dependencies "
"and the link interface in one command."
msgstr ""
"``PUBLIC``、``PRIVATE`` 和 ``INTERFACE`` :ref:`scope <Target Usage "
"Requirements>` 关键字可用于在一个命令中指定链接依赖项和链接接口。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:153
msgid ""
"Libraries and targets following ``PUBLIC`` are linked to, and are made "
"part of the link interface.  Libraries and targets following ``PRIVATE`` "
"are linked to, but are not made part of the link interface.  Libraries "
"following ``INTERFACE`` are appended to the link interface and are not "
"used for linking ``<target>``."
msgstr ""
"``PUBLIC`` 之后的库和目标被链接到，并成为链接接口的一部分。 ``PRIVATE`` 之后的库和目标被链接到，但不是链接接口的一部分。 "
"``INTERFACE`` 之后的库附加到链接接口，不用于链接``<target>``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:160
msgid "Libraries for both a Target and its Dependents"
msgstr "目标及其从属的库"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:166
msgid ""
"Library dependencies are transitive by default with this signature. When "
"this target is linked into another target then the libraries linked to "
"this target will appear on the link line for the other target too.  This "
"transitive \"link interface\" is stored in the "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` target property and may be overridden"
" by setting the property directly.  When :policy:`CMP0022` is not set to "
"``NEW``, transitive linking is built in but may be overridden by the "
":prop_tgt:`LINK_INTERFACE_LIBRARIES` property.  Calls to other signatures "
"of this command may set the property making any libraries linked "
"exclusively by this signature private."
msgstr ""
"默认情况下，库依赖项使用此签名是可传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的链接行上。这个可传递的“链接接口”存储在"
" :prop_tgt:`INTERFACE_LINK_LIBRARIES` 目标属性中，可以通过直接设置该属性来覆盖。当 CMP0022 未设置为 "
"NEW 时，传递链接是内置的，但可能会被 LINK_INTERFACE_LIBRARIES "
"属性覆盖。调用此命令的其他签名可能会设置属性，使任何由此签名专门链接的库成为私有的。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:178
msgid "Libraries for a Target and/or its Dependents (Legacy)"
msgstr "目标和/或其依赖项的库（旧版）"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:186
msgid ""
"The ``LINK_PUBLIC`` and ``LINK_PRIVATE`` modes can be used to specify both"
" the link dependencies and the link interface in one command."
msgstr "``LINK_PUBLIC`` 和 ``LINK_PRIVATE`` 模式可用于在一个命令中指定链接依赖项和链接接口。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:189
msgid ""
"This signature is for compatibility only.  Prefer the ``PUBLIC`` or "
"``PRIVATE`` keywords instead."
msgstr "此签名仅用于兼容性。更喜欢 ``PUBLIC`` 或 ``PRIVATE`` 关键字。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:192
msgid ""
"Libraries and targets following ``LINK_PUBLIC`` are linked to, and are "
"made part of the :prop_tgt:`INTERFACE_LINK_LIBRARIES`.  If policy "
":policy:`CMP0022` is not ``NEW``, they are also made part of the "
":prop_tgt:`LINK_INTERFACE_LIBRARIES`.  Libraries and targets following "
"``LINK_PRIVATE`` are linked to, but are not made part of the "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` (or "
":prop_tgt:`LINK_INTERFACE_LIBRARIES`)."
msgstr ""
"``LINK_PUBLIC`` 之后的库和目标链接到 :prop_tgt:`INTERFACE_LINK_LIBRARIES` "
"并成为其一部分。如果策略:policy:`CMP0022` 不是 ``NEW``，它们也会成为 "
":prop_tgt:`LINK_INTERFACE_LIBRARIES` 的一部分。 ``LINK_PRIVATE`` 之后的库和目标链接到 "
":prop_tgt:`INTERFACE_LINK_LIBRARIES`（或 "
":prop_tgt:`LINK_INTERFACE_LIBRARIES`），但不是其一部分。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:200
msgid "Libraries for Dependents Only (Legacy)"
msgstr "仅供家属使用的图书馆（旧版）"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:206
msgid ""
"The ``LINK_INTERFACE_LIBRARIES`` mode appends the libraries to the "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` target property instead of using them"
" for linking.  If policy :policy:`CMP0022` is not ``NEW``, then this mode "
"also appends libraries to the :prop_tgt:`LINK_INTERFACE_LIBRARIES` and its"
" per-configuration equivalent."
msgstr ""
"``LINK_INTERFACE_LIBRARIES`` 模式将库附加到 :prop_tgt:`INTERFACE_LINK_LIBRARIES` "
"目标属性，而不是使用它们进行链接。如果策略:policy:`CMP0022` "
"不是``NEW``，那么此模式还将库附加到:prop_tgt:`LINK_INTERFACE_LIBRARIES` 及其每个配置的等效项。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:212
msgid ""
"This signature is for compatibility only.  Prefer the ``INTERFACE`` mode "
"instead."
msgstr "此签名仅用于兼容性。更喜欢 ``INTERFACE`` 模式。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:215
msgid ""
"Libraries specified as ``debug`` are wrapped in a generator expression to "
"correspond to debug builds.  If policy :policy:`CMP0022` is not ``NEW``, "
"the libraries are also appended to the "
":prop_tgt:`LINK_INTERFACE_LIBRARIES_DEBUG "
"<LINK_INTERFACE_LIBRARIES_<CONFIG>>` property (or to the properties "
"corresponding to configurations listed in the "
":prop_gbl:`DEBUG_CONFIGURATIONS` global property if it is set). Libraries "
"specified as ``optimized`` are appended to the "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` property.  If policy "
":policy:`CMP0022` is not ``NEW``, they are also appended to the "
":prop_tgt:`LINK_INTERFACE_LIBRARIES` property.  Libraries specified as "
"``general`` (or without any keyword) are treated as if specified for both "
"``debug`` and ``optimized``."
msgstr ""
"指定为“调试”的库被包装在生成器表达式中以对应于调试版本。如果策略:policy:`CMP0022` 不是 "
"``NEW``，库也会附加到:prop_tgt:`LINK_INTERFACE_LIBRARIES_DEBUG "
"<LINK_INTERFACE_LIBRARIES_<CONFIG>>` 属性（或与 :prop_gbl 中列出的配置相对应的属性： "
"`DEBUG_CONFIGURATIONS` 全局属性（如果已设置）。指定为“优化”的库附加到 "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` 属性。如果策略 CMP0022 不是 NEW，它们也会附加到 "
"LINK_INTERFACE_LIBRARIES "
"属性。指定为“general”（或没有任何关键字）的库被视为同时指定了“debug”和“optimized”。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:229
msgid "Linking Object Libraries"
msgstr "链接对象库"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:233
msgid ""
":ref:`Object Libraries` may be used as the ``<target>`` (first) argument "
"of ``target_link_libraries`` to specify dependencies of their sources on "
"other libraries.  For example, the code"
msgstr ""
":ref:`Object Libraries` 可以用作``target_link_libraries`` "
"的``<target>``（第一个）参数来指定它们的源对其他库的依赖性。例如，代码"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:246
msgid ""
"compiles ``obj.c`` with ``-DA -DOBJ`` and establishes usage requirements "
"for ``obj`` that propagate to its dependents."
msgstr "使用“-DA -DOBJ”编译“obj.c”，并为传播到其依赖项的“obj”建立使用要求。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:249
msgid ""
"Normal libraries and executables may link to :ref:`Object Libraries` to "
"get their objects and usage requirements.  Continuing the above example, "
"the code"
msgstr "普通库和可执行文件可以链接到 :ref:`Object Libraries` 以获取它们的对象和使用要求。继续上面的例子，代码"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:258
msgid ""
"compiles ``b.c`` with ``-DA -DOBJ``, creates shared library ``B`` with "
"object files from ``b.c`` and ``obj.c``, and links ``B`` to ``A``. "
"Furthermore, the code"
msgstr ""
"使用“-DA -DOBJ”编译“b.c”，使用来自“b.c”和“obj.c”的目标文件创建共享库“B”，并将“B”链接到``一个``。此外，代码"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:267
msgid ""
"compiles ``main.c`` with ``-DA -DOBJ`` and links executable ``main`` to "
"``B`` and ``A``.  The object library's usage requirements are propagated "
"transitively through ``B``, but its object files are not."
msgstr ""
"使用“-DA "
"-DOBJ”编译“main.c”并将可执行文件“main”链接到“B”和“A”。对象库的使用要求通过“B”传递传递，但它的对象文件不是。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:271
msgid ""
":ref:`Object Libraries` may \"link\" to other object libraries to get "
"usage requirements, but since they do not have a link step nothing is done"
" with their object files.  Continuing from the above example, the code:"
msgstr ""
":ref:`Object Libraries` "
"可能会“链接”到其他对象库以获得使用要求，但由于它们没有链接步骤，因此不会对它们的对象文件执行任何操作。继续上面的例子，代码："

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:284
msgid ""
"compiles ``obj2.c`` with ``-DA -DOBJ``, creates executable ``main2`` with "
"object files from ``main2.c`` and ``obj2.c``, and links ``main2`` to "
"``A``."
msgstr ""
"使用“-DA "
"-DOBJ”编译“obj2.c”，使用“main2.c”和“obj2.c”中的目标文件创建可执行文件“main2”，并链接“main2” `` 到 "
"``A``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:288
msgid ""
"In other words, when :ref:`Object Libraries` appear in a target's "
":prop_tgt:`INTERFACE_LINK_LIBRARIES` property they will be treated as "
":ref:`Interface Libraries`, but when they appear in a target's "
":prop_tgt:`LINK_LIBRARIES` property their object files will be included in"
" the link too."
msgstr ""
"换句话说，当 :ref:`Object Libraries` 出现在目标的 :prop_tgt:`INTERFACE_LINK_LIBRARIES`"
" 属性中时，它们将被视为 :ref:`Interface Libraries`，但当它们出现在目标的 "
":prop_tgt:`LINK_LIBRARIES` 属性中时他们的目标文件也将包含在链接中。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:297
msgid "Linking Object Libraries via ``$<TARGET_OBJECTS>``"
msgstr "通过``$<TARGET_OBJECTS>``链接对象库"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:301
msgid ""
"The object files associated with an object library may be referenced by "
"the :genex:`$<TARGET_OBJECTS>` generator expression.  Such object files "
"are placed on the link line *before* all libraries, regardless of their "
"relative order.  Additionally, an ordering dependency will be added to the"
" build system to make sure the object library is up-to-date before the "
"dependent target links.  For example, the code"
msgstr ""
"与对象库关联的对象文件可以由 :genex:`$<TARGET_OBJECTS>` "
"生成器表达式引用。这些目标文件放在所有库*之前*的链接行上，不管它们的相对顺序如何。此外，将向构建系统添加一个排序依赖项，以确保对象库在依赖目标链接之前是最新的。例如，代码"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:316
msgid ""
"links executable ``main3`` with object files from ``main3.c`` and "
"``obj3.c`` followed by the ``a3`` and ``b3`` libraries. ``main3.c`` is "
"*not* compiled with usage requirements from ``obj3``, such as ``-DOBJ3``."
msgstr ""
"将可执行文件“main3”与“main3.c”和“obj3.c”中的目标文件链接起来，然后是“a3”和“b3”库。 ``main3.c`` "
"*未*根据 ``obj3`` 的使用要求进行编译，例如 ``-DOBJ3``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:321
msgid ""
"This approach can be used to achieve transitive inclusion of object files "
"in link lines as usage requirements.  Continuing the above example, the "
"code"
msgstr "这种方法可用于实现目标文件在链接行中的传递包含作为使用要求。继续上面的例子，代码"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:330
msgid ""
"creates an interface library ``iface_obj3`` that forwards the ``obj3`` "
"usage requirements and adds the ``obj3`` object files to dependents' link "
"lines.  The code"
msgstr "创建一个接口库 ``iface_obj3`` 转发 ``obj3`` 使用要求，并将 ``obj3`` 对象文件添加到从属链接行。代码"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:339
msgid ""
"compiles ``use_obj3.c`` with ``-DOBJ3`` and links executable ``use_obj3`` "
"with object files from ``use_obj3.c`` and ``obj3.c``."
msgstr ""
"使用“-DOBJ3”编译“use_obj3.c”，并将可执行文件“use_obj3”与“use_obj3.c”和“obj3.c”中的目标文件链接起来。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:342
msgid ""
"This also works transitively through a static library.  Since a static "
"library does not link, it does not consume the object files from object "
"libraries referenced this way.  Instead, the object files become "
"transitive link dependencies of the static library. Continuing the above "
"example, the code"
msgstr ""
"这也可以通过静态库传递。由于静态库不链接，因此它不会使用以这种方式引用的对象库中的对象文件。相反，目标文件成为静态库的传递链接依赖项。继续上面的例子，代码"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:356
msgid ""
"compiles ``static3.c`` with ``-DOBJ3`` and creates ``libstatic3.a`` using "
"only its own object file.  ``use_static3.c`` is compiled *without* "
"``-DOBJ3`` because the usage requirement is not transitive through the "
"private dependency of ``static3``.  However, the link dependencies of "
"``static3`` are propagated, including the ``iface_obj3`` reference to "
"``$<TARGET_OBJECTS:obj3>``.  The ``use_static3`` executable is created "
"with object files from ``use_static3.c`` and ``obj3.c``, and linked to "
"library ``libstatic3.a``."
msgstr ""
"使用“-DOBJ3”编译“static3.c”并仅使用它自己的目标文件创建“libstatic3.a”。 ``use_static3.c`` "
"编译*没有* ``-DOBJ3`` 因为使用要求不能通过 ``static3`` 的私有依赖传递。然而，``static3`` "
"的链接依赖项被传播，包括``iface_obj3`` 对``$<TARGET_OBJECTS:obj3>`` 的引用。 "
"``use_static3`` 可执行文件是使用来自``use_static3.c`` 和``obj3.c`` "
"的目标文件创建的，并链接到库``libstatic3.a``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:365
msgid ""
"When using this approach, it is the project's responsibility to avoid "
"linking multiple dependent binaries to ``iface_obj3``, because they will "
"all get the ``obj3`` object files on their link lines."
msgstr "使用这种方法时，项目有责任避免将多个依赖二进制文件链接到“iface_obj3”，因为它们都将在其链接行上获得“obj3”目标文件。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:371
msgid ""
"Referencing :genex:`$<TARGET_OBJECTS>` in ``target_link_libraries`` calls "
"worked in versions of CMake prior to 3.21 for some cases, but was not "
"fully supported:"
msgstr ""
"在 ``target_link_libraries`` 调用中引用 :genex:`$<TARGET_OBJECTS>` 在某些情况下可以在 "
"3.21 之前的 CMake 版本中工作，但不完全支持："

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:375
msgid "It did not place the object files before libraries on link lines."
msgstr "它没有将目标文件放在链接行上的库之前。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:376
msgid "It did not add an ordering dependency on the object library."
msgstr "它没有添加对对象库的排序依赖。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:377
msgid "It did not work in Xcode with multiple architectures."
msgstr "它在具有多种架构的 Xcode 中不起作用。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:380
msgid "Cyclic Dependencies of Static Libraries"
msgstr "静态库的循环依赖"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:382
msgid ""
"The library dependency graph is normally acyclic (a DAG), but in the case "
"of mutually-dependent ``STATIC`` libraries CMake allows the graph to "
"contain cycles (strongly connected components).  When another target links"
" to one of the libraries, CMake repeats the entire connected component. "
"For example, the code"
msgstr ""
"库依赖图通常是非循环的（DAG），但在相互依赖的“STATIC”库的情况下，CMake "
"允许该图包含循环（强连接组件）。当另一个目标链接到其中一个库时，CMake 会重复整个连接的组件。例如，代码"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_libraries.rst:397
msgid ""
"links ``main`` to ``A B A B``.  While one repetition is usually "
"sufficient, pathological object file and symbol arrangements can require "
"more.  One may handle such cases by using the "
":prop_tgt:`LINK_INTERFACE_MULTIPLICITY` target property or by manually "
"repeating the component in the last ``target_link_libraries`` call. "
"However, if two archives are really so interdependent they should probably"
" be combined into a single archive, perhaps by using :ref:`Object "
"Libraries`."
msgstr ""
"将 ``main`` 链接到 ``A B A B``。虽然一次重复通常就足够了，但病理对象文件和符号排列可能需要更多。可以通过使用 "
"LINK_INTERFACE_MULTIPLICITY 目标属性或通过在最后一个 ``target_link_libraries`` "
"调用中手动重复组件来处理这种情况。但是，如果两个存档真的如此相互依赖，那么它们应该合并成一个存档，也许可以使用 :ref:`Object "
"Libraries`。"

#: ../../cmake-prefix/src/cmake/Help/include/INTERFACE_LINK_LIBRARIES_WARNING.txt:2
msgid ""
"Note that it is not advisable to populate the |INTERFACE_PROPERTY_LINK| of"
" a target with absolute paths to dependencies. That would hard-code into "
"installed packages the library file paths for dependencies **as found on "
"the machine the package was made on**."
msgstr ""
"请注意，不建议填充 |INTERFACE_PROPERTY_LINK|具有依赖项绝对路径的目标。这会将依赖项的库文件路径硬编码到已安装的包中 ** "
"在制作包的机器上找到 ** 。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:2
msgid "target_link_options"
msgstr "目标链接选项"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:6
msgid ""
"Add options to the link step for an executable, shared library or module "
"library target."
msgstr "向可执行文件、共享库或模块库目标的链接步骤添加选项。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:31
msgid ""
"If ``BEFORE`` is specified, the content will be prepended to the property "
"instead of being appended."
msgstr "如果指定了 ``BEFORE``，则内容将被添加到属性中而不是附加到属性中。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:34
msgid ""
"The ``INTERFACE``, ``PUBLIC`` and ``PRIVATE`` keywords are required to "
"specify the :ref:`scope <Target Usage Requirements>` of the following "
"arguments. ``PRIVATE`` and ``PUBLIC`` items will populate the "
":prop_tgt:`LINK_OPTIONS` property of ``<target>``.  ``PUBLIC`` and "
"``INTERFACE`` items will populate the :prop_tgt:`INTERFACE_LINK_OPTIONS` "
"property of ``<target>``. The following arguments specify link options.  "
"Repeated calls for the same ``<target>`` append items in the order called."
msgstr ""
"需要 ``INTERFACE``、``PUBLIC`` 和 ``PRIVATE`` 关键字来指定以下参数的范围 <Target Usage "
"Requirements>`。 ``PRIVATE`` 和 ``PUBLIC`` 项将填充 ``<target>`` "
"的 :prop_tgt:`LINK_OPTIONS` 属性。 ``PUBLIC`` 和 ``INTERFACE`` 项将填充 ``<target>``"
" 的 :prop_tgt:`INTERFACE_LINK_OPTIONS` 属性。以下参数指定链接选项。重复调用相同的 ``<target>`` "
"按调用的顺序追加项目。"

#: ../../cmake-prefix/src/cmake/Help/command/target_link_options.rst:43
msgid ""
":ref:`IMPORTED targets <Imported Targets>` only support ``INTERFACE`` "
"items."
msgstr ":ref:`IMPORTED 目标 <Imported Targets>` 仅支持 ``INTERFACE`` 项。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:2
msgid "target_precompile_headers"
msgstr "target_precompile_headers"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:6
msgid "Add a list of header files to precompile."
msgstr "添加要预编译的头文件列表。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:8
msgid ""
"Precompiling header files can speed up compilation by creating a partially"
" processed version of some header files, and then using that version "
"during compilations rather than repeatedly parsing the original headers."
msgstr "预编译头文件可以通过创建一些头文件的部分处理版本，然后在编译期间使用该版本而不是重复解析原始头文件来加快编译速度。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:13
msgid "Main Form"
msgstr "主窗体"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:21
msgid ""
"The command adds header files to the :prop_tgt:`PRECOMPILE_HEADERS` and/or"
" :prop_tgt:`INTERFACE_PRECOMPILE_HEADERS` target properties of "
"``<target>``. The named ``<target>`` must have been created by a command "
"such as :command:`add_executable` or :command:`add_library` and must not "
"be an :ref:`ALIAS target <Alias Targets>`."
msgstr ""
"该命令将头文件添加到 `<target>`` 的 :prop_tgt:`PRECOMPILE_HEADERS` 和/或 "
":prop_tgt:`INTERFACE_PRECOMPILE_HEADERS` 目标属性。命名的 ``<target>`` 必须由命令创建，例如 "
":command:`add_executable` 或 :command:`add_library` 并且不能是 :ref:`ALIAS "
"target <Alias Targets>`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:27
msgid ""
"The ``INTERFACE``, ``PUBLIC`` and ``PRIVATE`` keywords are required to "
"specify the :ref:`scope <Target Usage Requirements>` of the following "
"arguments. ``PRIVATE`` and ``PUBLIC`` items will populate the "
":prop_tgt:`PRECOMPILE_HEADERS` property of ``<target>``.  ``PUBLIC`` and "
"``INTERFACE`` items will populate the "
":prop_tgt:`INTERFACE_PRECOMPILE_HEADERS` property of ``<target>`` "
"(:ref:`IMPORTED targets <Imported Targets>` only support ``INTERFACE`` "
"items). Repeated calls for the same ``<target>`` will append items in the "
"order called."
msgstr ""
"需要 ``INTERFACE``、``PUBLIC`` 和 ``PRIVATE`` 关键字来指定以下参数的范围 <Target Usage "
"Requirements>`。 ``PRIVATE`` 和 ``PUBLIC`` 项将填充 ``<target>`` 的 "
":prop_tgt:`PRECOMPILE_HEADERS` 属性。 ``PUBLIC`` 和 ``INTERFACE`` 项将填充 "
"``<target>`` 的 :prop_tgt:`INTERFACE_PRECOMPILE_HEADERS` 属性（ :ref:`IMPORTED "
"目标 <Imported Targets>` 仅支持 ``INTERFACE`` 项).重复调用相同的 ``<target>`` "
"将按照调用的顺序追加项目。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:35
msgid ""
"Projects should generally avoid using ``PUBLIC`` or ``INTERFACE`` for "
"targets that will be :ref:`exported <install(EXPORT)>`, or they should at "
"least use the :genex:`$<BUILD_INTERFACE:...>` generator expression to "
"prevent precompile headers from appearing in an installed exported target."
"  Consumers of a target should typically be in control of what precompile "
"headers they use, not have precompile headers forced on them by the "
"targets being consumed (since precompile headers are not typically usage "
"requirements).  A notable exception to this is where an :ref:`interface "
"library <Interface Libraries>` is created to define a commonly used set of"
" precompile headers in one place and then other targets link to that "
"interface library privately.  In this case, the interface library exists "
"specifically to propagate the precompile headers to its consumers and the "
"consumer is effectively still in control, since it decides whether to link"
" to the interface library or not."
msgstr ""
"项目通常应避免使用 ``PUBLIC`` 或 ``INTERFACE`` 用于要导出的目标 <install(EXPORT)>`，或者它们至少应使用"
" :genex:`$<BUILD_INTERFACE:。 ..>` "
"生成器表达式，以防止预编译标头出现在已安装的导出目标中。目标的消费者通常应该控制他们使用的预编译头，而不是被消费的目标强加给他们的预编译头（因为预编译头通常不是使用要求）。一个值得注意的例外是:ref:`接口库"
" <Interface Libraries>` "
"被创建以在一个地方定义一组常用的预编译标头，然后其他目标私下链接到该接口库。在这种情况下，接口库的存在专门用于将预编译标头传播给它的消费者，并且消费者实际上仍然处于控制之中，因为它决定是否链接到接口库。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:49
msgid ""
"The list of header files is used to generate a header file named "
"``cmake_pch.h|xx`` which is used to generate the precompiled header file "
"(``.pch``, ``.gch``, ``.pchi``) artifact.  The ``cmake_pch.h|xx`` header "
"file will be force included (``-include`` for GCC, ``/FI`` for MSVC) to "
"all source files, so sources do not need to have ``#include \"pch.h\"``."
msgstr ""
"头文件列表用于生成名为``cmake_pch.h|xx``的头文件，该头文件用于生成预编译头文件（``.pch``，``.gch``，``.pchi"
" ``) 神器。 ``cmake_pch.h|xx`` 头文件将被强制包含（对于 GCC 为``-include``，对于 MSVC "
"为``/FI``）到所有源文件中，因此源不需要``#包括“pch.h”``。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:55
msgid ""
"Header file names specified with angle brackets (e.g. ``<unordered_map>``)"
" or explicit double quotes (escaped for the :manual:`cmake-language(7)`, "
"e.g. ``[[\"other_header.h\"]]``) will be treated as is, and include "
"directories must be available for the compiler to find them.  Other header"
" file names (e.g. ``project_header.h``) are interpreted as being relative "
"to the current source directory (e.g. "
":variable:`CMAKE_CURRENT_SOURCE_DIR`) and will be included by absolute "
"path.  For example:"
msgstr ""
"用尖括号（例如 ``<unordered_map>``）或显式双引号（为 :manual:`cmake-language(7)` 转义，例如 "
"``[[\"other_header.h\"]]` 指定的头文件名`) 将按原样处理，并且包含目录必须可供编译器找到它们。其他头文件名（例如 "
"``project_header.h``）被解释为相对于当前源目录（例如 "
":variable:`CMAKE_CURRENT_SOURCE_DIR`）并将包含在绝对路径中。例如："

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:94
msgid "Reusing Precompile Headers"
msgstr "重用预编译标头"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:96
msgid ""
"The command also supports a second signature which can be used to specify "
"that one target re-uses a precompiled header file artifact from another "
"target instead of generating its own:"
msgstr "该命令还支持第二个签名，可用于指定一个目标重新使用来自另一个目标的预编译头文件工件，而不是生成自己的："

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:104
msgid ""
"This form sets the :prop_tgt:`PRECOMPILE_HEADERS_REUSE_FROM` property to "
"``<other_target>`` and adds a dependency such that ``<target>`` will "
"depend on ``<other_target>``.  CMake will halt with an error if the "
":prop_tgt:`PRECOMPILE_HEADERS` property of ``<target>`` is already set "
"when the ``REUSE_FROM`` form is used."
msgstr ""
"这种形式将 :prop_tgt:`PRECOMPILE_HEADERS_REUSE_FROM` 属性设置为 ``<other_target>`` "
"并添加一个依赖项，使得 ``<target>`` 将依赖于 ``<other_target>``。如果在使用 ``REUSE_FROM`` "
"形式时已经设置了 ``<target>`` 的 :prop_tgt:`PRECOMPILE_HEADERS` 属性，CMake 将因错误而停止。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:112
msgid ""
"The ``REUSE_FROM`` form requires the same set of compiler options, "
"compiler flags and compiler definitions for both ``<target>`` and "
"``<other_target>``.  Some compilers (e.g. GCC) may issue a warning if the "
"precompiled header file cannot be used (``-Winvalid-pch``)."
msgstr ""
"``REUSE_FROM`` 形式需要为 ``<target>`` 和 ``<other_target>`` "
"设置相同的编译器选项、编译器标志和编译器定义。如果无法使用预编译头文件 (``-Winvalid-pch``)，某些编译器（例如 "
"GCC）可能会发出警告。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:120
msgid ""
"To disable precompile headers for specific targets, see the "
":prop_tgt:`DISABLE_PRECOMPILE_HEADERS` target property."
msgstr "要禁用特定目标的预编译标头，请参阅 :prop_tgt:`DISABLE_PRECOMPILE_HEADERS` 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/command/target_precompile_headers.rst:123
msgid ""
"To prevent precompile headers from being used when compiling a specific "
"source file, see the :prop_sf:`SKIP_PRECOMPILE_HEADERS` source file "
"property."
msgstr "要防止在编译特定源文件时使用预编译标头，请参阅 :prop_sf:`SKIP_PRECOMPILE_HEADERS` 源文件属性。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:2
msgid "target_sources"
msgstr "目标源"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:6
msgid "Add sources to a target."
msgstr "将源添加到目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:14
msgid ""
"Specifies sources to use when building a target and/or its dependents. The"
" named ``<target>`` must have been created by a command such as "
":command:`add_executable` or :command:`add_library` or "
":command:`add_custom_target` and must not be an :ref:`ALIAS target <Alias "
"Targets>`.  The ``<items>`` may use :manual:`generator expressions <cmake-"
"generator-expressions(7)>`."
msgstr ""
"指定在构建目标和/或其依赖项时要使用的源。命名的 ``<target>`` 必须由命令创建，例如 :command:`add_executable`"
" 或 :command:`add_library` 或 :command:`add_custom_target` 并且不能是 :ref:`ALIAS"
" 目标 <别名目标>`。 ``<items>`` 可以使用 :manual:`generator expressions <cmake-"
"generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:21
msgid "``<target>`` can be a custom target."
msgstr "``<target>`` 可以是自定义目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:24
msgid ""
"The ``INTERFACE``, ``PUBLIC`` and ``PRIVATE`` keywords are required to "
"specify the :ref:`scope <Target Usage Requirements>` of the source file "
"paths (``<items>``) that follow them.  ``PRIVATE`` and ``PUBLIC`` items "
"will populate the :prop_tgt:`SOURCES` property of ``<target>``, which are "
"used when building the target itself. ``PUBLIC`` and ``INTERFACE`` items "
"will populate the :prop_tgt:`INTERFACE_SOURCES` property of ``<target>``, "
"which are used when building dependents.  A target created by "
":command:`add_custom_target` can only have ``PRIVATE`` scope."
msgstr ""
"需要``INTERFACE``、``PUBLIC`` 和``PRIVATE`` "
"关键字来指定源文件路径（``<items>``）的 :ref:`scope <Target Usage Requirements>`跟着他们。 "
"``PRIVATE`` 和 ``PUBLIC`` 项将填充 ``<target>`` 的 :prop_tgt:`SOURCES` "
"属性，它们在构建目标本身时使用。 ``PUBLIC`` 和 ``INTERFACE`` 项将填充 ``<target>`` 的 "
":prop_tgt:`INTERFACE_SOURCES` 属性，在构建依赖项时使用。由 :command:`add_custom_target` "
"创建的目标只能有 ``PRIVATE`` 作用域。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:35
msgid "Allow exporting targets with :prop_tgt:`INTERFACE_SOURCES`."
msgstr "允许使用 :prop_tgt:`INTERFACE_SOURCES` 导出目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:42
msgid ""
"Relative source file paths are interpreted as being relative to the "
"current source directory (i.e. :variable:`CMAKE_CURRENT_SOURCE_DIR`). See "
"policy :policy:`CMP0076`."
msgstr ""
"相对源文件路径被解释为相对于当前源目录（即 :variable:`CMAKE_CURRENT_SOURCE_DIR`）。请参阅政策:policy:`CMP0076`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:47
msgid ""
"A path that begins with a generator expression is left unmodified. When a "
"target's :prop_tgt:`SOURCE_DIR` property differs from "
":variable:`CMAKE_CURRENT_SOURCE_DIR`, use absolute paths in generator "
"expressions to ensure the sources are correctly assigned to the target."
msgstr ""
"以生成器表达式开头的路径保持不变。当目标的 :prop_tgt:`SOURCE_DIR` 属性不同于 "
":variable:`CMAKE_CURRENT_SOURCE_DIR` 时，在生成器表达式中使用绝对路径以确保将源正确分配给目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:64
msgid "File Sets"
msgstr "文件集"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:75
msgid ""
"Adds a file set to a target, or adds files to an existing file set. "
"Targets have zero or more named file sets. Each file set has a name, a "
"type, a scope of ``INTERFACE``, ``PUBLIC``, or ``PRIVATE``, one or more "
"base directories, and files within those directories. The acceptable types"
" include:"
msgstr ""
"将文件集添加到目标，或将文件添加到现有文件集。目标具有零个或多个命名文件集。每个文件集都有一个名称、一种类型、“INTERFACE”、“PUBLIC”或“PRIVATE”的范围、一个或多个基本目录以及这些目录中的文件。可接受的类型包括："

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:80
msgid "``HEADERS``"
msgstr "``标题``"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:82
msgid "Sources intended to be used via a language's ``#include`` mechanism."
msgstr "旨在通过语言的“#include”机制使用的源代码。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:84
msgid "``CXX_MODULES``"
msgstr "``CXX_MODULES``"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:90
msgid ""
"Sources which contain C++ interface module or partition units (i.e., those"
" using the ``export`` keyword). This file set type may not have an "
"``INTERFACE`` scope except on ``IMPORTED`` targets."
msgstr ""
"包含 C++ 接口模块或分区单元的源代码（即使用 ``export`` 关键字的源代码）。此文件集类型可能没有 ``INTERFACE`` "
"范围，除了``IMPORTED`` 目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:94
msgid "``CXX_MODULE_HEADER_UNITS``"
msgstr "``CXX_MODULE_HEADER_UNITS``"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:100
msgid ""
"C++ header sources which may be imported by other C++ source code. This "
"file set type may not have an ``INTERFACE`` scope except on ``IMPORTED`` "
"targets."
msgstr ""
"可以由其他 C++ 源代码导入的 C++ 标头源。此文件集类型可能没有 ``INTERFACE`` 范围，除了``IMPORTED`` 目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:103
msgid ""
"The optional default file sets are named after their type. The target may "
"not be a custom target or :prop_tgt:`FRAMEWORK` target."
msgstr "可选的默认文件集以其类型命名。目标可能不是自定义目标或 :prop_tgt:`FRAMEWORK` 目标。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:106
msgid ""
"Files in a ``PRIVATE`` or ``PUBLIC`` file set are marked as source files "
"for the purposes of IDE integration. Additionally, files in ``HEADERS`` "
"file sets have their :prop_sf:`HEADER_FILE_ONLY` property set to ``TRUE``."
" Files in an ``INTERFACE`` or ``PUBLIC`` file set can be installed with "
"the :command:`install(TARGETS)` command, and exported with the "
":command:`install(EXPORT)` and :command:`export` commands."
msgstr ""
"出于 IDE 集成的目的，``PRIVATE`` 或 ``PUBLIC`` 文件集中的文件被标记为源文件。此外，``HEADERS`` "
"文件集中的文件的 :prop_sf:`HEADER_FILE_ONLY` 属性设置为 ``TRUE``。 ``INTERFACE`` 或 "
"``PUBLIC`` 文件集中的文件可以使用 :command:`install(TARGETS)` 命令安装，并使用 "
":command:`install(EXPORT)` 和 :command:` 导出导出命令。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:113
msgid ""
"Each ``target_sources(FILE_SET)`` entry starts with ``INTERFACE``, "
"``PUBLIC``, or ``PRIVATE`` and accepts the following arguments:"
msgstr ""
"每个“target_sources(FILE_SET)”条目都以“INTERFACE”、“PUBLIC”或“PRIVATE”开头，并接受以下参数："

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:118
msgid ""
"The name of the file set to create or add to. It must contain only "
"letters, numbers and underscores. Names starting with a capital letter are"
" reserved for built-in file sets predefined by CMake. The only predefined "
"set names are those matching the acceptable types. All other set names "
"must not start with a capital letter or underscore."
msgstr ""
"要创建或添加到的文件集的名称。它只能包含字母、数字和下划线。以大写字母开头的名称是为 CMake "
"预定义的内置文件集保留的。唯一的预定义集名称是那些匹配可接受类型的名称。所有其他集名称不得以大写字母或下划线开头。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:125
msgid "``TYPE <type>``"
msgstr "``类型<类型>``"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:127
msgid ""
"Every file set is associated with a particular type of file. Only types "
"specified above may be used and it is an error to specify anything else. "
"As a special case, if the name of the file set is one of the types, the "
"type does not need to be specified and the ``TYPE <type>`` arguments can "
"be omitted. For all other file set names, ``TYPE`` is required."
msgstr ""
"每个文件集都与特定类型的文件相关联。只能使用上面指定的类型，指定任何其他类型都是错误的。作为一种特殊情况，如果文件集的名称是其中一种类型，则不需要指定类型，并且可以省略"
" TYPE <type> 参数。对于所有其他文件集名称，“TYPE”是必需的。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:133
msgid "``BASE_DIRS <dirs>...``"
msgstr "``BASE_DIRS <目录>...``"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:135
msgid ""
"An optional list of base directories of the file set. Any relative path is"
" treated as relative to the current source directory (i.e. "
":variable:`CMAKE_CURRENT_SOURCE_DIR`). If no ``BASE_DIRS`` are specified "
"when the file set is first created, the value of "
":variable:`CMAKE_CURRENT_SOURCE_DIR` is added. This argument supports "
":manual:`generator expressions <cmake-generator-expressions(7)>`."
msgstr ""
"文件集的基本目录的可选列表。任何相对路径都被视为相对于当前源目录（即 :variable:`CMAKE_CURRENT_SOURCE_DIR`）。如果在首次创建文件集时未指定"
" ``BASE_DIRS``，则添加 :variable:`CMAKE_CURRENT_SOURCE_DIR` 的值。此参数支持 "
":manual:`generator expressions <cmake-generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:142
msgid ""
"No two base directories for a file set may be sub-directories of each "
"other. This requirement must be met across all base directories added to a"
" file set, not just those within a single call to ``target_sources()``."
msgstr ""
"一个文件集的两个基目录不能互为子目录。必须在添加到文件集的所有基本目录中满足此要求，而不仅仅是对“target_sources()”的单个调用中的那些。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:146
msgid "``FILES <files>...``"
msgstr "``FILES <文件>...``"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:148
msgid ""
"An optional list of files to add to the file set. Each file must be in one"
" of the base directories, or a subdirectory of one of the base "
"directories. This argument supports :manual:`generator expressions <cmake-"
"generator-expressions(7)>`."
msgstr ""
"要添加到文件集中的可选文件列表。每个文件必须位于基本目录之一或基本目录之一的子目录中。此参数支持 :manual:`generator "
"expressions <cmake-generator-expressions(7)>`。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:153
msgid ""
"If relative paths are specified, they are considered relative to "
":variable:`CMAKE_CURRENT_SOURCE_DIR` at the time ``target_sources()`` is "
"called. An exception to this is a path starting with ``$<``. Such paths "
"are treated as relative to the target's source directory after evaluation "
"of generator expressions."
msgstr ""
"如果指定了相对路径，则在调用 target_sources() 时，它们被认为是相对于 CMAKE_CURRENT_SOURCE_DIR "
"的。一个例外是以 ``$<`` 开头的路径。在对生成器表达式求值后，此类路径被视为相对于目标的源目录。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:159
msgid ""
"The following target properties are set by ``target_sources(FILE_SET)``, "
"but they should not generally be manipulated directly:"
msgstr "以下目标属性由“target_sources(FILE_SET)”设置，但通常不应直接操作它们："

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:162
msgid "For file sets of type ``HEADERS``:"
msgstr "对于类型为“HEADERS”的文件集："

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:164
msgid ":prop_tgt:`HEADER_SETS`"
msgstr ":prop_tgt:`HEADER_SETS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:165
msgid ":prop_tgt:`INTERFACE_HEADER_SETS`"
msgstr ":prop_tgt:`INTERFACE_HEADER_SETS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:166
msgid ":prop_tgt:`HEADER_SET`"
msgstr ":prop_tgt:`HEADER_SET`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:167
msgid ":prop_tgt:`HEADER_SET_<NAME>`"
msgstr ":prop_tgt:`HEADER_SET_<NAME>`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:168
msgid ":prop_tgt:`HEADER_DIRS`"
msgstr ":prop_tgt:`HEADER_DIRS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:169
msgid ":prop_tgt:`HEADER_DIRS_<NAME>`"
msgstr ":prop_tgt:`HEADER_DIRS_<NAME>`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:171
msgid "For file sets of type ``CXX_MODULES``:"
msgstr "对于类型为“CXX_MODULES”的文件集："

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:173
msgid ":prop_tgt:`CXX_MODULE_SETS`"
msgstr ":prop_tgt:`CXX_MODULE_SETS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:174
msgid ":prop_tgt:`INTERFACE_CXX_MODULE_SETS`"
msgstr ":prop_tgt:`INTERFACE_CXX_MODULE_SETS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:175
msgid ":prop_tgt:`CXX_MODULE_SET`"
msgstr ":prop_tgt:`CXX_MODULE_SET`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:176
msgid ":prop_tgt:`CXX_MODULE_SET_<NAME>`"
msgstr ":prop_tgt:`CXX_MODULE_SET_<NAME>`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:177
msgid ":prop_tgt:`CXX_MODULE_DIRS`"
msgstr ":prop_tgt:`CXX_MODULE_DIRS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:178
msgid ":prop_tgt:`CXX_MODULE_DIRS_<NAME>`"
msgstr ":prop_tgt:`CXX_MODULE_DIRS_<名称>`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:180
msgid "For file sets of type ``CXX_MODULE_HEADER_UNITS``:"
msgstr "对于类型为“CXX_MODULE_HEADER_UNITS”的文件集："

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:182
msgid ":prop_tgt:`CXX_MODULE_HEADER_UNIT_SETS`"
msgstr ":prop_tgt:`CXX_MODULE_HEADER_UNIT_SETS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:183
msgid ":prop_tgt:`INTERFACE_CXX_MODULE_HEADER_UNIT_SETS`"
msgstr ":prop_tgt:`INTERFACE_CXX_MODULE_HEADER_UNIT_SETS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:184
msgid ":prop_tgt:`CXX_MODULE_HEADER_UNIT_SET`"
msgstr ":prop_tgt:`CXX_MODULE_HEADER_UNIT_SET`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:185
msgid ":prop_tgt:`CXX_MODULE_HEADER_UNIT_SET_<NAME>`"
msgstr ":prop_tgt:`CXX_MODULE_HEADER_UNIT_SET_<NAME>`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:186
msgid ":prop_tgt:`CXX_MODULE_HEADER_UNIT_DIRS`"
msgstr ":prop_tgt:`CXX_MODULE_HEADER_UNIT_DIRS`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:187
msgid ":prop_tgt:`CXX_MODULE_HEADER_UNIT_DIRS_<NAME>`"
msgstr ":prop_tgt:`CXX_MODULE_HEADER_UNIT_DIRS_<NAME>`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:189
msgid ""
"Target properties related to include directories are also modified by "
"``target_sources(FILE_SET)`` as follows:"
msgstr "与包含目录相关的目标属性也由 ``target_sources(FILE_SET)`` 修改如下："

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:192
msgid ":prop_tgt:`INCLUDE_DIRECTORIES`"
msgstr ":prop_tgt:`INCLUDE_DIRECTORIES`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:194
msgid ""
"If the ``TYPE`` is ``HEADERS`` or ``CXX_MODULE_HEADER_UNITS``, and the "
"scope of the file set is ``PRIVATE`` or ``PUBLIC``, all of the "
"``BASE_DIRS`` of the file set are wrapped in :genex:`$<BUILD_INTERFACE>` "
"and appended to this property."
msgstr ""
"如果 ``TYPE`` 是 ``HEADERS`` 或 ``CXX_MODULE_HEADER_UNITS``，并且文件集的范围是 "
"``PRIVATE`` 或 ``PUBLIC``，则所有的 ``BASE_DIRS``文件集包装在 "
":genex:`$<BUILD_INTERFACE>` 中并附加到此属性。"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:199
msgid ":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES`"
msgstr ":prop_tgt:`INTERFACE_INCLUDE_DIRECTORIES`"

#: ../../cmake-prefix/src/cmake/Help/command/target_sources.rst:201
msgid ""
"If the ``TYPE`` is ``HEADERS`` or ``CXX_MODULE_HEADER_UNITS``, and the "
"scope of the file set is ``INTERFACE`` or ``PUBLIC``, all of the "
"``BASE_DIRS`` of the file set are wrapped in :genex:`$<BUILD_INTERFACE>` "
"and appended to this property."
msgstr ""
"如果 ``TYPE`` 是 ``HEADERS`` 或 ``CXX_MODULE_HEADER_UNITS``，并且文件集的范围是 "
"``INTERFACE`` 或 ``PUBLIC``，则所有的 ``BASE_DIRS``文件集包装在 "
":genex:`$<BUILD_INTERFACE>` 中并附加到此属性。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:2
msgid "try_compile"
msgstr "尝试编译"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:8
msgid "Try building some code."
msgstr "尝试构建一些代码。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:13
msgid "Try Compiling Whole Projects"
msgstr "尝试编译整个项目"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:29
msgid ""
"Try building a project.  Build success returns ``TRUE`` and build failure "
"returns ``FALSE`` in ``<compileResultVar>``."
msgstr "尝试构建一个项目。构建成功返回“TRUE”，构建失败在“<compileResultVar>”中返回“FALSE”。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:32
msgid ""
"In this form, ``<srcdir>`` should contain a complete CMake project with a "
"``CMakeLists.txt`` file and all sources.  The ``<bindir>`` and "
"``<srcdir>`` will not be deleted after this command is run.  Specify "
"``<targetName>`` to build a specific target instead of the ``all`` or "
"``ALL_BUILD`` target.  See below for the meaning of other options."
msgstr ""
"在这种形式中，``<srcdir>`` 应该包含一个完整的 CMake 项目，其中包含一个 ``CMakeLists.txt`` 文件和所有源代码。"
" ``<bindir>`` 和 ``<srcdir>`` 运行该命令后不会被删除。指定 ``<targetName>`` 以构建特定目标而不是 "
"``all`` 或 ``ALL_BUILD`` 目标。其他选项的含义见下文。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:38
msgid ""
"CMake variables describing platform settings, and those listed by the "
":variable:`CMAKE_TRY_COMPILE_PLATFORM_VARIABLES` variable, are propagated "
"into the project's build configuration.  See policy :policy:`CMP0137`. "
"Previously this was only done by the :ref:`source file <Try Compiling "
"Source Files>` signature."
msgstr ""
"描述平台设置的 CMake 变量，以及由 :variable:`CMAKE_TRY_COMPILE_PLATFORM_VARIABLES` "
"变量列出的变量，被传播到项目的构建配置中。请参阅政策:policy:`CMP0137`。以前这只能通过 :ref:`source file <Try "
"Compiling Source Files>` 签名来完成。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:45
msgid ""
"This command records a :ref:`configure-log try_compile event <try_compile "
"configure-log event>` if the ``NO_LOG`` option is not specified."
msgstr ""
"如果未指定 ``NO_LOG`` 选项，此命令会记录 :ref:`configure-log try_compile 事件 <try_compile"
" configure-log event>`。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:50
#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:120
#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:58
msgid ""
"This command supports an alternate signature for CMake older than 3.25. "
"The signature above is recommended for clarity."
msgstr "此命令支持 CMake 3.25 之前的备用签名。为清楚起见，建议使用上面的签名。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:63
msgid "Try Compiling Source Files"
msgstr "尝试编译源文件"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:88
msgid ""
"Try building an executable or static library from one or more source files"
" (which one is determined by the :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE`"
" variable). Build success returns ``TRUE`` and build failure returns "
"``FALSE`` in ``<compileResultVar>``."
msgstr ""
"尝试从一个或多个源文件（哪个由 CMAKE_TRY_COMPILE_TARGET_TYPE "
"变量确定）构建可执行文件或静态库。构建成功返回“TRUE”，构建失败在“<compileResultVar>”中返回“FALSE”。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:93
msgid ""
"In this form, one or more source files must be provided. Additionally, one"
" of ``SOURCES`` and/or ``SOURCE_FROM_*`` must precede other keywords."
msgstr ""
"在这种形式中，必须提供一个或多个源文件。此外，``SOURCES`` 和/或 ``SOURCE_FROM_*`` 之一必须位于其他关键字之前。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:96
msgid ""
"If :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` is unset or is set to "
"``EXECUTABLE``, the sources must include a definition for ``main`` and "
"CMake will create a ``CMakeLists.txt`` file to build the source(s) as an "
"executable. If :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` is set to "
"``STATIC_LIBRARY``, a static library will be built instead and no "
"definition for ``main`` is required.  For an executable, the generated "
"``CMakeLists.txt`` file would contain something like the following:"
msgstr ""
"如果 :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` 未设置或设置为 "
"``EXECUTABLE``，源代码必须包含 ``main`` 的定义，CMake 将创建一个 ``CMakeLists.txt`` "
"文件来构建源代码) 作为可执行文件。如果 :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` 设置为 "
"``STATIC_LIBRARY``，则将构建一个静态库，而不需要为 ``main`` "
"定义。对于可执行文件，生成的“CMakeLists.txt”文件将包含如下内容："

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:113
msgid ""
"CMake automatically generates, for each ``try_compile`` operation, a "
"unique directory under ``${CMAKE_BINARY_DIR}/CMakeFiles/CMakeScratch`` "
"with an unspecified name.  These directories are cleaned automatically "
"unless :option:`--debug-trycompile <cmake --debug-trycompile>` is passed "
"to :program:`cmake`. Such directories from previous runs are also "
"unconditionally cleaned at the beginning of any :program:`cmake` "
"execution."
msgstr ""
"CMake 会自动为每个 ``try_compile`` 操作在 "
"``${CMAKE_BINARY_DIR}/CMakeFiles/CMakeScratch`` "
"下生成一个未指定名称的唯一目录。这些目录会自动清理，除非 :option:`--debug-trycompile <cmake --debug-"
"trycompile>` 被传递给 :program:`cmake`。以前运行的此类目录也会在任何 :program:`cmake` "
"执行开始时无条件清理。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:137
msgid ""
"In this version, ``try_compile`` will use ``<bindir>/CMakeFiles/CMakeTmp``"
" for its operation, and all such files will be cleaned automatically. For "
"debugging, :option:`--debug-trycompile <cmake --debug-trycompile>` can be "
"passed to :program:`cmake` to avoid this clean.  However, multiple "
"sequential ``try_compile`` operations, if given the same ``<bindir>``, "
"will reuse this single output directory, such that you can only debug one "
"such ``try_compile`` call at a time.  Use of the newer signature is "
"recommended to simplify debugging of multiple ``try_compile`` operations."
msgstr ""
"在此版本中，``try_compile`` 将使用``<bindir>/CMakeFiles/CMakeTmp`` "
"进行操作，所有此类文件将自动清理。对于调试，可以将 :option:`--debug-trycompile <cmake --debug-"
"trycompile>` 传递给 :program:`cmake` 以避免这种清理。但是，如果给定相同的 ``<bindir>``，多个连续的 "
"``try_compile`` 操作将重用这个单一的输出目录，这样您一次只能调试一个这样的 ``try_compile`` "
"调用。建议使用较新的签名以简化多个“try_compile”操作的调试。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:153
msgid "``CMAKE_FLAGS <flags>...``"
msgstr "``CMAKE_FLAGS <标志>...``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:149
msgid ""
"Specify flags of the form :option:`-DVAR:TYPE=VALUE <cmake -D>` to be "
"passed to the :manual:`cmake(1)` command-line used to drive the test "
"build. The above example shows how values for variables "
"``INCLUDE_DIRECTORIES``, ``LINK_DIRECTORIES``, and ``LINK_LIBRARIES`` are "
"used."
msgstr ""
"指定形式的标志:option:`-DVAR:TYPE=VALUE <cmake -D>` 传递给用于驱动测试构建的 cmake(1) "
"命令行。上面的示例显示了如何使用变量“INCLUDE_DIRECTORIES”、“LINK_DIRECTORIES”和“LINK_LIBRARIES”的值。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:157
msgid "``COMPILE_DEFINITIONS <defs>...``"
msgstr "``COMPILE_DEFINITIONS <defs>...``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:156
msgid ""
"Specify ``-Ddefinition`` arguments to pass to :command:`add_definitions` "
"in the generated test project."
msgstr "在生成的测试项目中指定要传递给 add_definitions 的 ``-Ddefinition`` 参数。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:160
msgid "``COPY_FILE <fileName>``"
msgstr "``COPY_FILE <文件名>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:160
msgid ""
"Copy the built executable or static library to the given ``<fileName>``."
msgstr "将构建的可执行文件或静态库复制到给定的 ``<fileName>``。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:164
msgid "``COPY_FILE_ERROR <var>``"
msgstr "``COPY_FILE_ERROR <var>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:163
msgid ""
"Use after ``COPY_FILE`` to capture into variable ``<var>`` any error "
"message encountered while trying to copy the file."
msgstr "在 ``COPY_FILE`` 之后使用将尝试复制文件时遇到的任何错误消息捕获到变量 ``<var>`` 中。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:172
msgid "``LINK_LIBRARIES <libs>...``"
msgstr "``LINK_LIBRARIES <库>...``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:167
msgid ""
"Specify libraries to be linked in the generated project. The list of "
"libraries may refer to system libraries and to :ref:`Imported Targets "
"<Imported Targets>` from the calling project."
msgstr ""
"在生成的项目中指定要链接的库。库列表可以引用系统库和来自调用项目的 :ref:`Imported Targets <Imported "
"Targets>`。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:171
msgid ""
"If this option is specified, any ``-DLINK_LIBRARIES=...`` value given to "
"the ``CMAKE_FLAGS`` option will be ignored."
msgstr "如果指定了此选项，则将忽略任何赋予“CMAKE_FLAGS”选项的“-DLINK_LIBRARIES=...”值。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:179
msgid "``LINK_OPTIONS <options>...``"
msgstr "``LINK_OPTIONS <选项>...``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:177
msgid ""
"Specify link step options to pass to :command:`target_link_options` or to "
"set the :prop_tgt:`STATIC_LIBRARY_OPTIONS` target property in the "
"generated project, depending on the "
":variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` variable."
msgstr ""
"指定链接步骤选项以传递给 :command:`target_link_options` "
"或在生成的项目中设置 :prop_tgt:`STATIC_LIBRARY_OPTIONS` "
"目标属性，具体取决于 :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` 变量。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:185
msgid "``LOG_DESCRIPTION <text>``"
msgstr "``LOG_DESCRIPTION <文本>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:184
msgid ""
"Specify a non-empty text description of the purpose of the check. This is "
"recorded in the :manual:`cmake-configure-log(7)` entry."
msgstr "指定检查目的的非空文本描述。这记录在 :manual:`cmake-configure-log(7)` 条目中。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:190
msgid ""
"The result will be stored in a normal variable rather than a cache entry."
msgstr "结果将存储在普通变量中而不是缓存条目中。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:192
msgid ""
"The result variable is normally cached so that a simple pattern can be "
"used to avoid repeating the test on subsequent executions of CMake:"
msgstr "结果变量通常被缓存，以便可以使用一个简单的模式来避免在后续的 CMake 执行中重复测试："

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:203
msgid ""
"If the guard variable and result variable are not the same (for example, "
"if the test is part of a larger inspection), ``NO_CACHE`` may be useful to"
" avoid leaking the intermediate result variable into the cache."
msgstr "如果保护变量和结果变量不相同（例如，如果测试是更大检查的一部分），``NO_CACHE`` 可能有助于避免将中间结果变量泄漏到缓存中。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:210
msgid "``NO_LOG``"
msgstr "``NO_LOG``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:210
msgid ""
"Do not record a :manual:`cmake-configure-log(7)` entry for this call."
msgstr "不要为此调用记录 :manual:`cmake-configure-log(7)` 条目。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:213
#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:89
msgid "``OUTPUT_VARIABLE <var>``"
msgstr "``OUTPUT_VARIABLE <变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:213
msgid "Store the output from the build process in the given variable."
msgstr "将构建过程的输出存储在给定变量中。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:223
msgid "``SOURCE_FROM_CONTENT <name> <content>``"
msgstr "``SOURCE_FROM_CONTENT <名称> <内容>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:218
msgid ""
"Write ``<content>`` to a file named ``<name>`` in the operation directory."
" This can be used to bypass the need to separately write a source file "
"when the contents of the file are dynamically specified. The specified "
"``<name>`` is not allowed to contain path components."
msgstr ""
"将 ``<content>`` 写入操作目录中名为 ``<name>`` "
"的文件。这可用于在动态指定文件内容时绕过单独编写源文件的需要。指定的``<name>`` 不允许包含路径组件。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:223
msgid "``SOURCE_FROM_CONTENT`` may be specified multiple times."
msgstr "``SOURCE_FROM_CONTENT`` 可以指定多次。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:233
msgid "``SOURCE_FROM_FILE <name> <path>``"
msgstr "``SOURCE_FROM_FILE <名称> <路径>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:228
msgid ""
"Copy ``<path>`` to a file named ``<name>`` in the operation directory. "
"This can be used to consolidate files into the operation directory, which "
"may be useful if a source which already exists (i.e. as a stand-alone file"
" in a project's source repository) needs to refer to other file(s) created"
" by ``SOURCE_FROM_*``. (Otherwise, ``SOURCES`` is usually more "
"convenient.) The specified ``<name>`` is not allowed to contain path "
"components."
msgstr ""
"将 ``<path>`` 复制到操作目录中名为 ``<name>`` "
"的文件。这可用于将文件合并到操作目录中，如果已经存在的源（即作为项目源存储库中的独立文件）需要引用由 ``SOURCE_FROM_ "
"创建的其他文件，这可能很有用*``。 （否则，``SOURCES`` 通常更方便。）指定的 ``<name>`` 不允许包含路径组件。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:245
msgid "``SOURCE_FROM_VAR <name> <var>``"
msgstr "``SOURCE_FROM_VAR <名称> <变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:238
msgid ""
"Write the contents of ``<var>`` to a file named ``<name>`` in the "
"operation directory. This is the same as ``SOURCE_FROM_CONTENT``, but "
"takes the contents from the specified CMake variable, rather than "
"directly, which may be useful when passing arguments through a function "
"which wraps ``try_compile``. The specified ``<name>`` is not allowed to "
"contain path components."
msgstr ""
"将 ``<var>`` 的内容写入操作目录中名为 ``<name>`` 的文件。这与 ``SOURCE_FROM_CONTENT`` "
"相同，但不是直接从指定的 CMake 变量中获取内容，这在通过包装 ``try_compile`` "
"的函数传递参数时可能很有用。指定的``<name>`` 不允许包含路径组件。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:245
msgid "``SOURCE_FROM_VAR`` may be specified multiple times."
msgstr "``SOURCE_FROM_VAR`` 可以指定多次。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:252
msgid "``<LANG>_STANDARD <std>``"
msgstr "``<LANG>_STANDARD <std>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:250
msgid ""
"Specify the :prop_tgt:`C_STANDARD`, :prop_tgt:`CXX_STANDARD`, "
":prop_tgt:`OBJC_STANDARD`, :prop_tgt:`OBJCXX_STANDARD`, or "
":prop_tgt:`CUDA_STANDARD` target property of the generated project."
msgstr ""
"指定生成项目的 C_STANDARD、CXX_STANDARD、OBJC_STANDARD、OBJCXX_STANDARD 或 "
"CUDA_STANDARD 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:260
msgid "``<LANG>_STANDARD_REQUIRED <bool>``"
msgstr "``<LANG>_STANDARD_REQUIRED <bool>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:257
msgid ""
"Specify the :prop_tgt:`C_STANDARD_REQUIRED`, "
":prop_tgt:`CXX_STANDARD_REQUIRED`, :prop_tgt:`OBJC_STANDARD_REQUIRED`, "
":prop_tgt:`OBJCXX_STANDARD_REQUIRED`,or :prop_tgt:`CUDA_STANDARD_REQUIRED`"
" target property of the generated project."
msgstr ""
"指定生成项目的 "
"C_STANDARD_REQUIRED、CXX_STANDARD_REQUIRED、OBJC_STANDARD_REQUIRED、OBJCXX_STANDARD_REQUIRED"
" 或 CUDA_STANDARD_REQUIRED 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:267
msgid "``<LANG>_EXTENSIONS <bool>``"
msgstr "``<LANG>_EXTENSIONS <bool>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:265
msgid ""
"Specify the :prop_tgt:`C_EXTENSIONS`, :prop_tgt:`CXX_EXTENSIONS`, "
":prop_tgt:`OBJC_EXTENSIONS`, :prop_tgt:`OBJCXX_EXTENSIONS`, or "
":prop_tgt:`CUDA_EXTENSIONS` target property of the generated project."
msgstr ""
"指定生成的项目的 C_EXTENSIONS、CXX_EXTENSIONS、OBJC_EXTENSIONS、OBJCXX_EXTENSIONS 或 "
"CUDA_EXTENSIONS 目标属性。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:270
#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:115
msgid "Other Behavior Settings"
msgstr "其他行为设置"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:272
msgid ""
"If set, the following variables are passed in to the generated try_compile"
" CMakeLists.txt to initialize compile target properties with default "
"values:"
msgstr "如果设置，以下变量将传递到生成的 try_compile CMakeLists.txt 以使用默认值初始化编译目标属性："

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:277
msgid ":variable:`CMAKE_CUDA_RUNTIME_LIBRARY`"
msgstr ":variable:`CMAKE_CUDA_RUNTIME_LIBRARY`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:278
msgid ":variable:`CMAKE_ENABLE_EXPORTS`"
msgstr ":variable:`CMAKE_ENABLE_EXPORTS`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:279
msgid ":variable:`CMAKE_LINK_SEARCH_START_STATIC`"
msgstr ":variable:`CMAKE_LINK_SEARCH_START_STATIC`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:280
msgid ":variable:`CMAKE_LINK_SEARCH_END_STATIC`"
msgstr ":variable:`CMAKE_LINK_SEARCH_END_STATIC`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:281
msgid ":variable:`CMAKE_MSVC_RUNTIME_LIBRARY`"
msgstr ":variable:`CMAKE_MSVC_RUNTIME_LIBRARY`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:282
msgid ":variable:`CMAKE_POSITION_INDEPENDENT_CODE`"
msgstr ":variable:`CMAKE_POSITION_INDEPENDENT_CODE`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:283
msgid ":variable:`CMAKE_WATCOM_RUNTIME_LIBRARY`"
msgstr ":variable:`CMAKE_WATCOM_RUNTIME_LIBRARY`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:285
msgid ""
"If :policy:`CMP0056` is set to ``NEW``, then "
":variable:`CMAKE_EXE_LINKER_FLAGS` is passed in as well."
msgstr "如果 CMP0056 设置为 NEW，那么 CMAKE_EXE_LINKER_FLAGS 也会传入。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:288
msgid ""
"If :policy:`CMP0083` is set to ``NEW``, then in order to obtain correct "
"behavior at link time, the ``check_pie_supported()`` command from the "
":module:`CheckPIESupported` module must be called before using the "
"``try_compile`` command."
msgstr ""
"如果 CMP0083 设置为 NEW，那么为了在链接时获得正确的行为，必须在使用前调用 CheckPIESupported 模块中的 "
"check_pie_supported() 命令``try_compile`` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:294
msgid ""
"The current settings of :policy:`CMP0065` and :policy:`CMP0083` are "
"propagated through to the generated test project."
msgstr ":policy:`CMP0065` 和 :policy:`CMP0083` 的当前设置会传播到生成的测试项目。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:297
#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:117
msgid ""
"Set variable :variable:`CMAKE_TRY_COMPILE_CONFIGURATION` to choose a build"
" configuration:"
msgstr "设置变量 :variable:`CMAKE_TRY_COMPILE_CONFIGURATION` 以选择构建配置："

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:300
#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:120
msgid ""
"For multi-config generators, this selects which configuration to build."
msgstr "对于多配置生成器，这会选择要构建的配置。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:302
#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:122
msgid ""
"For single-config generators, this sets :variable:`CMAKE_BUILD_TYPE` in "
"the test project."
msgstr "对于单配置生成器，这会在测试项目中设置 :variable:`CMAKE_BUILD_TYPE`。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:305
msgid ""
"Set the :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` variable to specify the "
"type of target used for the source file signature."
msgstr "设置 :variable:`CMAKE_TRY_COMPILE_TARGET_TYPE` 变量以指定用于源文件签名的目标类型。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:309
msgid ""
"Set the :variable:`CMAKE_TRY_COMPILE_PLATFORM_VARIABLES` variable to "
"specify variables that must be propagated into the test project.  This "
"variable is meant for use only in toolchain files and is only honored by "
"the ``try_compile()`` command for the source files form, not when given a "
"whole project."
msgstr ""
"设置 :variable:`CMAKE_TRY_COMPILE_PLATFORM_VARIABLES` "
"变量以指定必须传播到测试项目中的变量。此变量仅用于工具链文件，并且仅在源文件形式的 ``try_compile()`` "
"命令中使用，而不是在给定整个项目时使用。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:316
msgid ""
"If :policy:`CMP0067` is set to ``NEW``, or any of the ``<LANG>_STANDARD``,"
" ``<LANG>_STANDARD_REQUIRED``, or ``<LANG>_EXTENSIONS`` options are used, "
"then the language standard variables are honored:"
msgstr ""
"如果 :policy:`CMP0067` "
"设置为``NEW``，或者使用``<LANG>_STANDARD``、``<LANG>_STANDARD_REQUIRED`` "
"或``<LANG>_EXTENSIONS`` 选项中的任何一个, 然后语言标准变量被尊重："

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:321
msgid ":variable:`CMAKE_C_STANDARD`"
msgstr ":variable:`CMAKE_C_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:322
msgid ":variable:`CMAKE_C_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_C_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:323
msgid ":variable:`CMAKE_C_EXTENSIONS`"
msgstr ":variable:`CMAKE_C_EXTENSIONS`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:324
msgid ":variable:`CMAKE_CXX_STANDARD`"
msgstr ":variable:`CMAKE_CXX_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:325
msgid ":variable:`CMAKE_CXX_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_CXX_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:326
msgid ":variable:`CMAKE_CXX_EXTENSIONS`"
msgstr ":variable:`CMAKE_CXX_EXTENSIONS`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:327
msgid ":variable:`CMAKE_OBJC_STANDARD`"
msgstr ":variable:`CMAKE_OBJC_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:328
msgid ":variable:`CMAKE_OBJC_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_OBJC_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:329
msgid ":variable:`CMAKE_OBJC_EXTENSIONS`"
msgstr ":variable:`CMAKE_OBJC_EXTENSIONS`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:330
msgid ":variable:`CMAKE_OBJCXX_STANDARD`"
msgstr ":variable:`CMAKE_OBJCXX_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:331
msgid ":variable:`CMAKE_OBJCXX_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_OBJCXX_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:332
msgid ":variable:`CMAKE_OBJCXX_EXTENSIONS`"
msgstr ":variable:`CMAKE_OBJCXX_EXTENSIONS`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:333
msgid ":variable:`CMAKE_CUDA_STANDARD`"
msgstr ":variable:`CMAKE_CUDA_STANDARD`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:334
msgid ":variable:`CMAKE_CUDA_STANDARD_REQUIRED`"
msgstr ":variable:`CMAKE_CUDA_STANDARD_REQUIRED`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:335
msgid ":variable:`CMAKE_CUDA_EXTENSIONS`"
msgstr ":variable:`CMAKE_CUDA_EXTENSIONS`"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:337
msgid ""
"Their values are used to set the corresponding target properties in the "
"generated project (unless overridden by an explicit option)."
msgstr "它们的值用于在生成的项目中设置相应的目标属性（除非被显式选项覆盖）。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:340
msgid ""
"For the :generator:`Green Hills MULTI` generator, the GHS toolset and "
"target system customization cache variables are also propagated into the "
"test project."
msgstr "对于 :generator:`Green Hills MULTI` 生成器，GHS 工具集和目标系统自定义缓存变量也传播到测试项目中。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:345
msgid ""
"The :variable:`CMAKE_TRY_COMPILE_NO_PLATFORM_VARIABLES` variable may be "
"set to disable passing platform variables into the test project."
msgstr ""
":variable:`CMAKE_TRY_COMPILE_NO_PLATFORM_VARIABLES` "
"变量可以设置为禁止将平台变量传递到测试项目中。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:349
msgid ""
"If :policy:`CMP0141` is set to ``NEW``, one can use "
":variable:`CMAKE_MSVC_DEBUG_INFORMATION_FORMAT` to specify the MSVC debug "
"information format."
msgstr ""
"如果 CMP0141 设置为 NEW，可以使用 CMAKE_MSVC_DEBUG_INFORMATION_FORMAT 指定 MSVC "
"调试信息格式。"

#: ../../cmake-prefix/src/cmake/Help/command/try_compile.rst:357
msgid ":command:`try_run`"
msgstr ":command:`try_run`"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:2
msgid "try_run"
msgstr "试运行"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:8
msgid "Try compiling and then running some code."
msgstr "尝试编译然后运行一些代码。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:11
msgid "Try Compiling and Running Source Files"
msgstr "尝试编译和运行源文件"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:41
msgid ""
"Try building an executable from one or more source files.  Build success "
"returns ``TRUE`` and build failure returns ``FALSE`` in "
"``<compileResultVar>``. If the build succeeds, this runs the executable "
"and stores the exit code in ``<runResultVar>``.  If the executable was "
"built, but failed to run, then ``<runResultVar>`` will be set to "
"``FAILED_TO_RUN``.  See command :command:`try_compile` for documentation "
"of options common to both commands, and for information on how the test "
"project is constructed to build the source file."
msgstr ""
"尝试从一个或多个源文件构建可执行文件。构建成功返回“TRUE”，构建失败在“<compileResultVar>”中返回“FALSE”。如果构建成功，这将运行可执行文件并将退出代码存储在“<runResultVar>”中。如果可执行文件已构建，但未能运行，则“<runResultVar>”将设置为“FAILED_TO_RUN”。请参阅命令"
" :command:`try_compile` 以获取这两个命令共有的选项的文档，以及有关如何构建测试项目以构建源文件的信息。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:50
msgid ""
"One or more source files must be provided. Additionally, one of "
"``SOURCES`` and/or ``SOURCE_FROM_*`` must precede other keywords."
msgstr "必须提供一个或多个源文件。此外，``SOURCES`` 和/或 ``SOURCE_FROM_*`` 之一必须位于其他关键字之前。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:53
msgid ""
"This command records a :ref:`configure-log try_run event <try_run "
"configure-log event>` if the ``NO_LOG`` option is not specified."
msgstr ""
"如果未指定 ``NO_LOG`` 选项，此命令会记录 :ref:`configure-log try_run 事件 <try_run "
"configure-log event>`。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:80
msgid "The options specific to ``try_run`` are:"
msgstr "``try_run`` 特有的选项是："

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:83
msgid "``COMPILE_OUTPUT_VARIABLE <var>``"
msgstr "``COMPILE_OUTPUT_VARIABLE <var>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:83
msgid "Report the compile step build output in a given variable."
msgstr "在给定变量中报告编译步骤构建输出。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:86
msgid ""
"Report the compile build output and the output from running the executable"
" in the given variable.  This option exists for legacy reasons and is only"
" supported by the old ``try_run`` signature. Prefer "
"``COMPILE_OUTPUT_VARIABLE`` and ``RUN_OUTPUT_VARIABLE`` instead."
msgstr ""
"报告编译构建输出和在给定变量中运行可执行文件的输出。此选项的存在是出于遗留原因，并且仅受旧的 ``try_run`` "
"签名支持。更喜欢``COMPILE_OUTPUT_VARIABLE``和``RUN_OUTPUT_VARIABLE``。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:92
msgid "``RUN_OUTPUT_VARIABLE <var>``"
msgstr "``RUN_OUTPUT_VARIABLE <var>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:92
msgid "Report the output from running the executable in a given variable."
msgstr "报告在给定变量中运行可执行文件的输出。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:97
msgid "``RUN_OUTPUT_STDOUT_VARIABLE <var>``"
msgstr "``RUN_OUTPUT_STDOUT_VARIABLE <var>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:97
msgid ""
"Report the output of stdout from running the executable in a given "
"variable."
msgstr "报告在给定变量中运行可执行文件的 stdout 输出。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:102
msgid "``RUN_OUTPUT_STDERR_VARIABLE <var>``"
msgstr "``RUN_OUTPUT_STDERR_VARIABLE <var>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:102
msgid ""
"Report the output of stderr from running the executable in a given "
"variable."
msgstr "报告在给定变量中运行可执行文件的 stderr 输出。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:109
msgid "``WORKING_DIRECTORY <var>``"
msgstr "``WORKING_DIRECTORY <var>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:107
msgid ""
"Run the executable in the given directory. If no ``WORKING_DIRECTORY`` is "
"specified, the executable will run in ``<bindir>`` or the current build "
"directory."
msgstr "在给定目录中运行可执行文件。如果未指定“WORKING_DIRECTORY”，可执行文件将在“<bindir>”或当前构建目录中运行。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:112
msgid "``ARGS <args>...``"
msgstr "``ARGS <args>...``"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:112
msgid "Additional arguments to pass to the executable when running it."
msgstr "运行时传递给可执行文件的附加参数。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:126
msgid "Behavior when Cross Compiling"
msgstr "交叉编译时的行为"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:128
msgid ""
"Use ``CMAKE_CROSSCOMPILING_EMULATOR`` when running cross-compiled "
"binaries."
msgstr "在运行交叉编译的二进制文件时使用 ``CMAKE_CROSSCOMPILING_EMULATOR``。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:131
msgid ""
"When cross compiling, the executable compiled in the first step usually "
"cannot be run on the build host.  The ``try_run`` command checks the "
":variable:`CMAKE_CROSSCOMPILING` variable to detect whether CMake is in "
"cross-compiling mode.  If that is the case, it will still try to compile "
"the executable, but it will not try to run the executable unless the "
":variable:`CMAKE_CROSSCOMPILING_EMULATOR` variable is set.  Instead it "
"will create cache variables which must be filled by the user or by "
"presetting them in some CMake script file to the values the executable "
"would have produced if it had been run on its actual target platform. "
"These cache entries are:"
msgstr ""
"交叉编译时，第一步编译出的可执行文件通常无法在构建主机上运行。 ``try_run`` 命令检查 "
":variable:`CMAKE_CROSSCOMPILING` 变量以检测 CMake "
"是否处于交叉编译模式。如果是这种情况，它仍会尝试编译可执行文件，但不会尝试运行可执行文件，除非设置了 "
":variable:`CMAKE_CROSSCOMPILING_EMULATOR` "
"变量。相反，它将创建缓存变量，这些变量必须由用户填充，或者通过在某些 CMake "
"脚本文件中将它们预设为可执行文件在其实际目标平台上运行时会产生的值。这些缓存条目是："

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:143
msgid "``<runResultVar>``"
msgstr "``<runResultVar>``"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:143
msgid "Exit code if the executable were to be run on the target platform."
msgstr "如果可执行文件要在目标平台上运行，则退出代码。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:148
msgid "``<runResultVar>__TRYRUN_OUTPUT``"
msgstr "``<runResultVar>__TRYRUN_OUTPUT``"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:146
msgid ""
"Output from stdout and stderr if the executable were to be run on the "
"target platform.  This is created only if the ``RUN_OUTPUT_VARIABLE`` or "
"``OUTPUT_VARIABLE`` option was used."
msgstr ""
"如果可执行文件要在目标平台上运行，则从 stdout 和 stderr "
"输出。仅当使用“RUN_OUTPUT_VARIABLE”或“OUTPUT_VARIABLE”选项时才会创建。"

#: ../../cmake-prefix/src/cmake/Help/command/try_run.rst:150
msgid ""
"In order to make cross compiling your project easier, use ``try_run`` only"
" if really required.  If you use ``try_run``, use the "
"``RUN_OUTPUT_STDOUT_VARIABLE``, ``RUN_OUTPUT_STDERR_VARIABLE``, "
"``RUN_OUTPUT_VARIABLE`` or ``OUTPUT_VARIABLE`` options only if really "
"required.  Using them will require that when cross-compiling, the cache "
"variables will have to be set manually to the output of the executable. "
"You can also \"guard\" the calls to ``try_run`` with an :command:`if` "
"block checking the :variable:`CMAKE_CROSSCOMPILING` variable and provide "
"an easy-to-preset alternative for this case."
msgstr ""
"为了使您的项目更容易交叉编译，请仅在确实需要时才使用 ``try_run``。如果您使用 ``try_run``，请仅在确实需要时使用 "
"``RUN_OUTPUT_STDOUT_VARIABLE``、``RUN_OUTPUT_STDERR_VARIABLE``、``RUN_OUTPUT_VARIABLE``"
" 或 ``OUTPUT_VARIABLE`` 选项。使用它们需要在交叉编译时，必须手动将缓存变量设置为可执行文件的输出。您还可以使用 "
":command:`if` 块“保护”对 `try_run`` 的调用，检查 :variable:`CMAKE_CROSSCOMPILING` "
"变量，并为这种情况提供易于预设的替代方案。"

#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:2
msgid "unset"
msgstr "取消设置"

#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:4
msgid "Unset a variable, cache variable, or environment variable."
msgstr "取消设置变量、缓存变量或环境变量。"

#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:7
msgid "Unset Normal Variable or Cache Entry"
msgstr "取消设置普通变量或缓存条目"

#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:13
msgid ""
"Removes a normal variable from the current scope, causing it to become "
"undefined.  If ``CACHE`` is present, then a cache variable is removed "
"instead of a normal variable.  Note that when evaluating :ref:`Variable "
"References` of the form ``${VAR}``, CMake first searches for a normal "
"variable with that name.  If no such normal variable exists, CMake will "
"then search for a cache entry with that name.  Because of this unsetting a"
" normal variable can expose a cache variable that was previously hidden.  "
"To force a variable reference of the form ``${VAR}`` to return an empty "
"string, use ``set(<variable> \"\")``, which clears the normal variable but"
" leaves it defined."
msgstr ""
"从当前作用域中移除一个普通变量，使其变为未定义。如果存在“CACHE”，则会删除缓存变量而不是普通变量。请注意，在计算 ``${VAR}`` "
"形式的 :ref:`Variable References` 时，CMake 首先搜索具有该名称的普通变量。如果不存在这样的普通变量，CMake "
"将搜索具有该名称的缓存条目。由于这种取消设置，普通变量可以暴露以前隐藏的缓存变量。要强制 ``${VAR}`` 形式的变量引用返回空字符串，请使用 "
"``set(<variable> \"\")``，它会清除普通变量但保留其定义。"

#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:24
msgid ""
"If ``PARENT_SCOPE`` is present then the variable is removed from the scope"
" above the current scope.  See the same option in the :command:`set` "
"command for further details."
msgstr ""
"如果存在 ``PARENT_SCOPE``，则该变量将从当前范围之上的范围中删除。有关详细信息，请参阅 :command:`set` "
"命令中的相同选项。"

#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:29
msgid "Unset Environment Variable"
msgstr "取消设置环境变量"

#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:35
msgid ""
"Removes ``<variable>`` from the currently available :manual:`Environment "
"Variables <cmake-env-variables(7)>`. Subsequent calls of "
"``$ENV{<variable>}`` will return the empty string."
msgstr ""
"从当前可用的 :manual:`Environment Variables <cmake-env-variables(7)>` "
"中删除``<variable>``。 ``$ENV{<variable>}`` 的后续调用将返回空字符串。"

#: ../../cmake-prefix/src/cmake/Help/command/unset.rst:46
msgid ":command:`set`"
msgstr ":command:`设置`"

#: ../../cmake-prefix/src/cmake/Help/command/use_mangled_mesa.rst:2
msgid "use_mangled_mesa"
msgstr "使用_mangled_mesa"

#: ../../cmake-prefix/src/cmake/Help/command/use_mangled_mesa.rst:4
msgid "Disallowed since version 3.0.  See CMake Policy :policy:`CMP0030`."
msgstr "3.0 版后不允许。请参阅 CMake 政策:policy:`CMP0030`。"

#: ../../cmake-prefix/src/cmake/Help/command/use_mangled_mesa.rst:6
msgid "Copy mesa headers for use in combination with system GL."
msgstr "复制台面标头以与系统 GL 结合使用。"

#: ../../cmake-prefix/src/cmake/Help/command/use_mangled_mesa.rst:12
msgid ""
"The path to mesa includes, should contain ``gl_mangle.h``.  The mesa "
"headers are copied to the specified output directory.  This allows mangled"
" mesa headers to override other GL headers by being added to the include "
"directory path earlier."
msgstr ""
"mesa 的路径包括，应该包含 ``gl_mangle.h``。台面标头被复制到指定的输出目录。这允许损坏的 mesa "
"标头通过更早地添加到包含目录路径来覆盖其他 GL 标头。"

#: ../../cmake-prefix/src/cmake/Help/command/utility_source.rst:2
msgid "utility_source"
msgstr "实用程序源"

#: ../../cmake-prefix/src/cmake/Help/command/utility_source.rst:4
msgid "Disallowed since version 3.0.  See CMake Policy :policy:`CMP0034`."
msgstr "3.0 版后不允许。请参阅 CMake 政策:policy:`CMP0034`。"

#: ../../cmake-prefix/src/cmake/Help/command/utility_source.rst:6
msgid "Specify the source tree of a third-party utility."
msgstr "指定第三方实用程序的源代码树。"

#: ../../cmake-prefix/src/cmake/Help/command/utility_source.rst:13
msgid ""
"When a third-party utility's source is included in the distribution, this "
"command specifies its location and name.  The cache entry will not be set "
"unless the ``path_to_source`` and all listed files exist.  It is assumed "
"that the source tree of the utility will have been built before it is "
"needed."
msgstr ""
"当第三方实用程序的源包含在分发中时，此命令指定其位置和名称。除非 ``path_to_source`` "
"和所有列出的文件都存在，否则不会设置缓存条目。假定实用程序的源代码树在需要之前已经构建。"

#: ../../cmake-prefix/src/cmake/Help/command/utility_source.rst:19
msgid ""
"When cross compiling CMake will print a warning if a ``utility_source()`` "
"command is executed, because in many cases it is used to build an "
"executable which is executed later on.  This doesn't work when cross "
"compiling, since the executable can run only on their target platform. So "
"in this case the cache entry has to be adjusted manually so it points to "
"an executable which is runnable on the build host."
msgstr ""
"交叉编译时，如果执行 ``utility_source()`` 命令，CMake "
"将打印警告，因为在许多情况下，它用于构建稍后执行的可执行文件。这在交叉编译时不起作用，因为可执行文件只能在其目标平台上运行。所以在这种情况下，必须手动调整缓存条目，使其指向可在构建主机上运行的可执行文件。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_requires.rst:2
msgid "variable_requires"
msgstr "变量要求"

#: ../../cmake-prefix/src/cmake/Help/command/variable_requires.rst:4
msgid "Disallowed since version 3.0.  See CMake Policy :policy:`CMP0035`."
msgstr "3.0 版后不允许。请参阅 CMake 政策:policy:`CMP0035`。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_requires.rst:6
msgid "Use the :command:`if` command instead."
msgstr "请改用 :command:`if` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_requires.rst:8
msgid "Assert satisfaction of an option's required variables."
msgstr "断言满足选项的必需变量。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_requires.rst:16
msgid ""
"The first argument (``TEST_VARIABLE``) is the name of the variable to be "
"tested, if that variable is false nothing else is done.  If "
"``TEST_VARIABLE`` is true, then the next argument (``RESULT_VARIABLE``) is"
" a variable that is set to true if all the required variables are set. The"
" rest of the arguments are variables that must be true or not set to "
"``NOTFOUND`` to avoid an error.  If any are not true, an error is "
"reported."
msgstr ""
"第一个参数（``TEST_VARIABLE``）是要测试的变量的名称，如果该变量为 false，则什么都不做。如果 "
"``TEST_VARIABLE`` 为真，则下一个参数 (``RESULT_VARIABLE``) "
"是一个变量，如果设置了所有必需的变量，该变量将设置为 "
"true。其余参数是必须为真或不设置为“NOTFOUND”以避免错误的变量。如果有任何不正确，则报告错误。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:2
msgid "variable_watch"
msgstr "变量_手表"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:4
msgid "Watch the CMake variable for change."
msgstr "观察 CMake 变量的变化。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:10
msgid ""
"If the specified ``<variable>`` changes and no ``<command>`` is given, a "
"message will be printed to inform about the change."
msgstr "如果指定的 ``<variable>`` 发生变化并且没有给出 ``<command>``，将打印一条消息以通知更改。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:13
msgid ""
"If ``<command>`` is given, this command will be executed instead. The "
"command will receive the following arguments: ``COMMAND(<variable> "
"<access> <value> <current_list_file> <stack>)``"
msgstr ""
"如果给出了``<command>``，则将执行此命令。该命令将接收以下参数：``COMMAND(<variable> <access> "
"<value> <current_list_file> <stack>)``"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:18
msgid "``<variable>``"
msgstr "``<变量>``"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:18
msgid "Name of the variable being accessed."
msgstr "正在访问的变量的名称。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:25
msgid "``<access>``"
msgstr "``<访问>``"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:21
msgid ""
"One of ``READ_ACCESS``, ``UNKNOWN_READ_ACCESS``, ``MODIFIED_ACCESS``, "
"``UNKNOWN_MODIFIED_ACCESS``, or ``REMOVED_ACCESS``.  The ``UNKNOWN_`` "
"values are only used when the variable has never been set.  Once set, they"
" are never used again during the same CMake run, even if the variable is "
"later unset."
msgstr ""
"``READ_ACCESS``、``UNKNOWN_READ_ACCESS``、``MODIFIED_ACCESS``、``UNKNOWN_MODIFIED_ACCESS``"
" 或 ``REMOVED_ACCESS`` 之一。 ``UNKNOWN_`` 值仅在从未设置变量时使用。一旦设置，它们就不会在同一次 CMake "
"运行期间再次使用，即使稍后取消设置变量也是如此。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:29
msgid "``<value>``"
msgstr "``<值>``"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:28
msgid ""
"The value of the variable.  On a modification, this is the new (modified) "
"value of the variable.  On removal, the value is empty."
msgstr "变量的值。在修改时，这是变量的新（修改）值。删除时，该值为空。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:32
msgid "``<current_list_file>``"
msgstr "``<current_list_file>``"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:32
msgid "Full path to the file doing the access."
msgstr "进行访问的文件的完整路径。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:37
msgid "``<stack>``"
msgstr "``<堆栈>``"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:35
msgid ""
"List of absolute paths of all files currently on the stack of file "
"inclusion, with the bottom-most file first and the currently processed "
"file (that is, ``current_list_file``) last."
msgstr "当前在文件包含堆栈中的所有文件的绝对路径列表，最底部的文件在前，当前处理的文件（即“current_list_file”）在后。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:39
msgid ""
"Note that for some accesses such as :command:`list(APPEND)`, the watcher "
"is executed twice, first with a read access and then with a write one. "
"Also note that an :command:`if(DEFINED)` query on the variable does not "
"register as an access and the watcher is not executed."
msgstr ""
"请注意，对于某些访问，例如 :command:`list(APPEND)`，观察程序会执行两次，第一次是读访问，然后是写访问。另请注意，对变量的 "
":command:`if(DEFINED)` 查询不会注册为访问，也不会执行观察程序。"

#: ../../cmake-prefix/src/cmake/Help/command/variable_watch.rst:44
msgid ""
"Only non-cache variables can be watched using this command.  Access to "
"cache variables is never watched.  However, the existence of a cache "
"variable ``var`` causes accesses to the non-cache variable ``var`` to not "
"use the ``UNKNOWN_`` prefix, even if a non-cache variable ``var`` has "
"never existed."
msgstr ""
"使用此命令只能监视非缓存变量。从不监视对缓存变量的访问。然而，缓存变量“var”的存在导致访问非缓存变量“var”时不使用“UNKNOWN_”前缀，即使非缓存变量“var”具有从未存在过。"

#: ../../cmake-prefix/src/cmake/Help/command/while.rst:2
msgid "while"
msgstr "尽管"

#: ../../cmake-prefix/src/cmake/Help/command/while.rst:4
msgid "Evaluate a group of commands while a condition is true"
msgstr "在条件为真时评估一组命令"

#: ../../cmake-prefix/src/cmake/Help/command/while.rst:12
msgid ""
"All commands between while and the matching :command:`endwhile` are "
"recorded without being invoked.  Once the :command:`endwhile` is "
"evaluated, the recorded list of commands is invoked as long as the "
"``<condition>`` is true."
msgstr ""
"while 和匹配的 :command:`endwhile` 之间的所有命令都被记录下来而不被调用。一旦 :command:`endwhile` "
"被求值，只要 ``<condition>`` 为真，就会调用记录的命令列表。"

#: ../../cmake-prefix/src/cmake/Help/command/while.rst:16
msgid ""
"The ``<condition>`` has the same syntax and is evaluated using the same "
"logic as described at length for the :command:`if` command."
msgstr "``<condition>`` 具有相同的语法，并使用与 :command:`if` 命令详细描述的相同逻辑进行评估。"

#: ../../cmake-prefix/src/cmake/Help/command/while.rst:22
msgid ""
"Per legacy, the :command:`endwhile` command admits an optional "
"``<condition>`` argument. If used, it must be a verbatim repeat of the "
"argument of the opening ``while`` command."
msgstr ""
"按照传统， :command:`endwhile` 命令接受一个可选的 ``<condition>`` "
"参数。如果使用，它必须逐字重复开头的“while”命令的参数。"

#: ../../cmake-prefix/src/cmake/Help/command/while.rst:32
msgid ":command:`foreach`"
msgstr ":command:`foreach`"

#: ../../cmake-prefix/src/cmake/Help/command/while.rst:33
msgid ":command:`endwhile`"
msgstr ":command:`结束`"

#: ../../cmake-prefix/src/cmake/Help/command/write_file.rst:2
msgid "write_file"
msgstr "写文件"

#: ../../cmake-prefix/src/cmake/Help/command/write_file.rst:6
msgid "Use the :command:`file(WRITE)` command instead."
msgstr "请改用 :command:`file(WRITE)` 命令。"

#: ../../cmake-prefix/src/cmake/Help/command/write_file.rst:12
msgid ""
"The first argument is the file name, the rest of the arguments are "
"messages to write.  If the argument ``APPEND`` is specified, then the "
"message will be appended."
msgstr "第一个参数是文件名，其余参数是要写入的消息。如果指定了参数“APPEND”，那么消息将被附加。"

#: ../../cmake-prefix/src/cmake/Help/command/write_file.rst:16
msgid ""
"NOTE 1: :command:`file(WRITE)`  and :command:`file(APPEND)`  do exactly "
"the same as this one but add some more functionality."
msgstr ""
"注意 1: :command:`file(WRITE)` 和 :command:`file(APPEND)` 与这个完全一样，但增加了一些功能。"

#: ../../cmake-prefix/src/cmake/Help/command/write_file.rst:19
msgid ""
"NOTE 2: When using ``write_file`` the produced file cannot be used as an "
"input to CMake (CONFIGURE_FILE, source file ...) because it will lead to "
"an infinite loop.  Use :command:`configure_file` if you want to generate "
"input files to CMake."
msgstr ""
"注意 2：当使用 ``write_file`` 时，生成的文件不能用作 CMake "
"的输入（CONFIGURE_FILE，源文件...），因为它会导致无限循环。如果你想为 CMake 生成输入文件，请使用 "
":command:`configure_file`。"
